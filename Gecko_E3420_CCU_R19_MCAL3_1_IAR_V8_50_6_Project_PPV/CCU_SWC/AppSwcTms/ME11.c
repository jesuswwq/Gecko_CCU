/*
 * File: ME11.c
 *
 * Code generated for Simulink model 'ME11'.
 *
 * Model version                  : 1.2188
 * Simulink Coder version         : 9.8 (R2022b) 13-May-2022
 * C/C++ source code generated on : Tue Oct  8 16:29:54 2024
 *
 * Target selection: autosar.tlc
 * Embedded hardware selection: NXP->Cortex-M4
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include "ME11.h"
#include "rtwtypes.h"
#include <math.h>
#include "ME11_ABI.h"
#include "Rte_Type.h"
#include "ME11_types.h"
#include "TMS_MonitorData.h"
#include "TMS_CalibrationData.h"
#include "Dem_Cfg.h"
#include "zero_crossing_types.h"

/* Named constants for Chart: '<S497>/OverDuty1' */
#define ME11_IN_Clear                  ((uint8)1U)
#define ME11_IN_Fault                  ((uint8)1U)
#define ME11_IN_HVOff                  ((uint8)1U)
#define ME11_IN_HVOn                   ((uint8)2U)
#define ME11_IN_NO_ACTIVE_CHILD        ((uint8)0U)
#define ME11_IN_Normal                 ((uint8)2U)
#define ME11_IN_wait                   ((uint8)3U)
#define ME11_IN_wait1                  ((uint8)4U)

/* Named constants for Chart: '<S526>/Flg3Cal' */
#define ME11_IN_Default                ((uint8)1U)
#define ME11_IN_Flg3                   ((uint8)2U)

/* Named constants for Chart: '<S572>/PwrOn' */
#define ME11_IN_Off                    ((uint8)1U)
#define ME11_IN_On                     ((uint8)2U)

/* Named constants for Chart: '<S642>/Chart' */
#define ME11_IN_Default_f              ((uint8)1U)
#define ME11_IN_wait1_e                ((uint8)3U)
#define ME11_IN_wait_n                 ((uint8)2U)

/* Named constants for Chart: '<S943>/ Abnormal_Over_temperatura_via _software_monitoring' */
#define ME11_IN_Default_c              ((uint8)1U)
#define ME11_IN_Err                    ((uint8)2U)
#define ME11_IN_wait1_m                ((uint8)4U)
#define ME11_IN_wait_p                 ((uint8)3U)

/* Named constants for Chart: '<S943>/External_Com_Fault' */
#define ME11_IN_Default_d              ((uint8)1U)
#define ME11_IN_Err_b                  ((uint8)2U)
#define ME11_IN_wait1_d                ((uint8)4U)
#define ME11_IN_wait_o                 ((uint8)3U)

/* Named constants for Chart: '<S1022>/AcPMPFaultJudge' */
#define ME11_IN_Fault_a                ((uint8)1U)
#define ME11_IN_Normal_f               ((uint8)2U)
#define ME11_IN_wait_g                 ((uint8)3U)

/* Named constants for Chart: '<S1093>/Judge' */
#define ME11_IN_Init                   ((uint8)1U)
#define ME11_IN_MaxErr                 ((uint8)1U)
#define ME11_IN_MaxJudge               ((uint8)2U)
#define ME11_IN_MinErr                 ((uint8)3U)
#define ME11_IN_MinJudge               ((uint8)4U)
#define ME11_IN_NO_ACTIVE_CHILD_g      ((uint8)0U)
#define ME11_IN_judge                  ((uint8)2U)
#define ME11_IN_wait_h                 ((uint8)3U)

/* Named constants for Chart: '<S1223>/Delay' */
#define ME11_IN_Off_e                  ((uint8)1U)
#define ME11_IN_On_l                   ((uint8)2U)
#define ME11_IN_Wait                   ((uint8)3U)

/* Named constants for Chart: '<S1333>/Delay' */
#define ME11_IN_False                  ((uint8)1U)
#define ME11_IN_True                   ((uint8)2U)
#define ME11_IN_Wait_g                 ((uint8)3U)

/* Named constants for Chart: '<S1320>/Chart' */
#define ME11_IN_Off_h                  ((uint8)1U)
#define ME11_IN_On_k                   ((uint8)2U)

/* Named constants for Chart: '<S1574>/Chart' */
#define ME11_IN_False_n                ((uint8)1U)
#define ME11_IN_True_j                 ((uint8)2U)
#define ME11_IN_Wait_h                 ((uint8)3U)

/* Named constants for Chart: '<S1325>/Chart' */
#define ME11_IN_Off_n                  ((uint8)1U)
#define ME11_IN_On_d                   ((uint8)2U)

/* Named constants for Chart: '<S1231>/Delay' */
#define ME11_IN_Off_p                  ((uint8)1U)
#define ME11_IN_On_i                   ((uint8)2U)
#define ME11_IN_Wait_j                 ((uint8)3U)

/* Named constants for Chart: '<S1232>/Judge' */
#define ME11_IN_ALLInner               ((uint8)1U)
#define ME11_IN_ALLOut                 ((uint8)2U)
#define ME11_IN_Default_e              ((uint8)3U)
#define ME11_IN_Fault1                 ((uint8)5U)
#define ME11_IN_Fault_j                ((uint8)4U)
#define ME11_IN_InRec_Stuck            ((uint8)6U)
#define ME11_IN_Init_n                 ((uint8)1U)
#define ME11_IN_InnerRec               ((uint8)7U)
#define ME11_IN_Judge                  ((uint8)2U)
#define ME11_IN_OutRec                 ((uint8)8U)
#define ME11_IN_OutRec_Stuck           ((uint8)9U)
#define ME11_IN_wait_j                 ((uint8)3U)

/* Named constants for Chart: '<S1233>/Judge' */
#define ME11_IN_ALLCool                ((uint8)1U)
#define ME11_IN_AllWarm                ((uint8)2U)
#define ME11_IN_Cool                   ((uint8)3U)
#define ME11_IN_Default_d2             ((uint8)4U)
#define ME11_IN_Fault1_c               ((uint8)6U)
#define ME11_IN_Fault_d                ((uint8)5U)
#define ME11_IN_InMix_Stuck            ((uint8)7U)
#define ME11_IN_OutMix_Stuck           ((uint8)8U)
#define ME11_IN_Warm                   ((uint8)9U)

/* Named constants for Chart: '<S1234>/Judge' */
#define ME11_IN_ALLDefrost             ((uint8)1U)
#define ME11_IN_ALLFace                ((uint8)2U)
#define ME11_IN_Defrost                ((uint8)4U)
#define ME11_IN_Defrost_Stuck          ((uint8)5U)
#define ME11_IN_Face                   ((uint8)6U)
#define ME11_IN_Face_Stuck             ((uint8)7U)
#define ME11_IN_Fault1_b               ((uint8)9U)
#define ME11_IN_Fault_l                ((uint8)8U)

/* Named constants for Chart: '<S33>/Cal_RunTime_20ms' */
#define ME11_IN_Counter_Cal            ((uint8)1U)
#define ME11_IN_Counter_Init           ((uint8)2U)

/* Named constants for Chart: '<S59>/PWM2FANLEVEL' */
#define ME11_IN_Fan_0                  ((uint8)1U)
#define ME11_IN_Fan_01                 ((uint8)2U)
#define ME11_IN_Fan_02                 ((uint8)3U)
#define ME11_IN_Fan_03                 ((uint8)4U)
#define ME11_IN_Fan_04                 ((uint8)5U)
#define ME11_IN_Fan_05                 ((uint8)6U)
#define ME11_IN_Fan_06                 ((uint8)7U)
#define ME11_IN_Fan_07                 ((uint8)8U)
#define ME11_IN_Fan_08                 ((uint8)9U)
#define ME11_IN_NO_ACTIVE_CHILD_gl     ((uint8)0U)

/* Named constants for Chart: '<S50>/BlowerChangeCheck' */
#define ME11_IN_Limit                  ((uint8)1U)
#define ME11_IN_Mode                   ((uint8)2U)
#define ME11_IN_Modehaschanged         ((uint8)3U)

/* Named constants for Chart: '<S80>/AutoBlowerMode' */
#define ME11_ColdStart                 ((uint8)1U)
#define ME11_HotStart                  ((uint8)2U)
#define ME11_IN_BlowerModeLim          ((uint8)1U)
#define ME11_IN_BlowerModeLockFloor    ((uint8)2U)
#define ME11_IN_BlowerModeLockFloor1   ((uint8)3U)
#define ME11_IN_BlowerNormal           ((uint8)4U)
#define ME11_IN_Face_Floor             ((uint8)2U)
#define ME11_IN_Face_c                 ((uint8)1U)
#define ME11_IN_Floor                  ((uint8)3U)
#define ME11_LittleCold                ((uint8)3U)
#define ME11_NormalStart               ((uint8)0U)

/* Named constants for Chart: '<S127>/Recirc_AQS' */
#define ME11_IN_ACCtl_tiAQSHi_cnt      ((uint8)1U)
#define ME11_IN_ACCtl_tiAQSHi_cntClear ((uint8)2U)
#define ME11_IN_ACCtl_tiAQSLo_cnt      ((uint8)1U)
#define ME11_IN_ACCtl_tiAQSLo_cntClear ((uint8)2U)
#define ME11_IN_Initi                  ((uint8)1U)
#define ME11_IN_Recirc_AQS             ((uint8)2U)

/* Named constants for Chart: '<S39>/AirConditionStartState' */
#define ME11_IN_BlowerFanWorkTimeAdd   ((uint8)1U)
#define ME11_IN_BlowerFanWorkTimeKeep  ((uint8)2U)
#define ME11_IN_BlowerFan_Off          ((uint8)1U)
#define ME11_IN_BlowerFan_On           ((uint8)2U)
#define ME11_IN_Cold_Air_Protection    ((uint8)1U)
#define ME11_IN_Hot_Air_Protection     ((uint8)2U)
#define ME11_IN_IGN_OFF                ((uint8)1U)
#define ME11_IN_IGN_ON                 ((uint8)2U)
#define ME11_IN_Normal_LittleCold      ((uint8)3U)
#define ME11_IN_Normal_Op              ((uint8)4U)

/* Named constants for Chart: '<S210>/TempRampBaseTimeAndStep' */
#define ME11_IN_DecreaseTemp           ((uint8)1U)
#define ME11_IN_Delay                  ((uint8)1U)
#define ME11_IN_Delaychecked           ((uint8)2U)
#define ME11_IN_DontChange             ((uint8)2U)
#define ME11_IN_IncreaseTemp           ((uint8)3U)

/* Named constants for Chart: '<S178>/EvaCooledCheck' */
#define ME11_IN_Eva_Stop               ((uint8)1U)
#define ME11_IN_Eva_Stoping            ((uint8)2U)
#define ME11_IN_Eva_cooling            ((uint8)3U)

/* Named constants for Chart: '<S179>/PTCHeatedCheck' */
#define ME11_IN_PTC_Heating            ((uint8)1U)
#define ME11_IN_PTC_Stop               ((uint8)2U)
#define ME11_IN_PTC_Stoping            ((uint8)3U)

/* Named constants for Chart: '<S4>/stExhaustFunCheck' */
#define ME11_IN_Exhaust_Check          ((uint8)1U)
#define ME11_IN_Exhaust_OFF            ((uint8)2U)
#define ME11_IN_Exhaust_ON             ((uint8)1U)
#define ME11_IN_Exhaust_intl           ((uint8)2U)

/* Named constants for Chart: '<S462>/delay' */
#define ME11_IN_Off_a                  ((uint8)1U)
#define ME11_IN_On_li                  ((uint8)2U)
#define ME11_IN_Wait_c                 ((uint8)3U)

/* Named constants for Chart: '<S497>/OverDuty' */
#define ME11_IN_Clear_d                ((uint8)1U)
#define ME11_IN_Fault_ax               ((uint8)1U)
#define ME11_IN_HVOff_o                ((uint8)1U)
#define ME11_IN_HVOn_o                 ((uint8)2U)
#define ME11_IN_Normal_k               ((uint8)2U)
#define ME11_IN_wait1_o                ((uint8)4U)
#define ME11_IN_wait_k                 ((uint8)3U)

/* Named constants for Chart: '<S449>/Flg3Cal' */
#define ME11_IN_Default_k              ((uint8)1U)
#define ME11_IN_Fault_b                ((uint8)2U)

/* Named constants for Chart: '<S503>/Chart' */
#define ME11_IN_Normal_m               ((uint8)1U)
#define ME11_IN_Stop                   ((uint8)2U)
#define ME11_IN_Stop1                  ((uint8)3U)
#define ME11_IN_wait_f                 ((uint8)4U)

/* Named constants for Chart: '<S529>/Flg3Cal' */
#define ME11_IN_Flg2                   ((uint8)1U)
#define ME11_IN_Flg3_n                 ((uint8)2U)
#define ME11_IN_wait_2                 ((uint8)3U)

/* Named constants for Chart: '<S531>/Flg3Cal' */
#define ME11_IN_Flg1                   ((uint8)1U)
#define ME11_IN_Flg2_j                 ((uint8)2U)
#define ME11_IN_Flg3_p                 ((uint8)3U)
#define ME11_IN_wait_2_i               ((uint8)4U)
#define ME11_IN_wait_3                 ((uint8)5U)

/* Named constants for Chart: '<S546>/Judge' */
#define ME11_IN_ChgBatCool             ((uint8)1U)
#define ME11_IN_ChgDCool               ((uint8)2U)
#define ME11_IN_NmlBatCool             ((uint8)3U)
#define ME11_IN_NmlBatCool1            ((uint8)4U)
#define ME11_IN_NmlBatCool2            ((uint8)5U)
#define ME11_IN_NmlDCoolHVS            ((uint8)6U)
#define ME11_IN_NmlDCoolLVS            ((uint8)7U)

/* Named constants for Chart: '<S455>/ActSpdDelay' */
#define ME11_IN_Init_i                 ((uint8)1U)
#define ME11_IN_protect                ((uint8)2U)

/* Named constants for Chart: '<S455>/HPrsPro' */
#define ME11_IN_Forbit                 ((uint8)2U)
#define ME11_IN_Lmt                    ((uint8)3U)

/* Named constants for Chart: '<S456>/FFCal' */
#define ME11_IN_CloseCtl               ((uint8)1U)
#define ME11_IN_DelayOpen              ((uint8)2U)
#define ME11_IN_OpenCtl                ((uint8)3U)
#define ME11_IN_RelayOpen              ((uint8)4U)

/* Named constants for Chart: '<S457>/Chart' */
#define ME11_IN_forbit                 ((uint8)2U)
#define ME11_IN_limit                  ((uint8)3U)

/* Named constants for Chart: '<S661>/Delay' */
#define ME11_IN_StepUp                 ((uint8)2U)

/* Named constants for Chart: '<S677>/FFCal' */
#define ME11_IN_CloseCtrl              ((uint8)1U)
#define ME11_IN_OpenCtrl               ((uint8)2U)

/* Named constants for Chart: '<S683>/EvapTemperature' */
#define ME11_IN_CalClsSpd              ((uint8)1U)
#define ME11_IN_CloseVavle             ((uint8)2U)
#define ME11_IN_Default_o              ((uint8)3U)
#define ME11_IN_OpenCtrl_l             ((uint8)4U)
#define ME11_IN_Wait1                  ((uint8)6U)
#define ME11_IN_Wait_b                 ((uint8)5U)
#define ME11_IN_wait_oc                ((uint8)7U)

/* Named constants for Chart: '<S919>/Delay' */
#define ME11_IN_wait_Off               ((uint8)3U)
#define ME11_IN_wait_On                ((uint8)4U)

/* Named constants for Chart: '<S943>/Over_Current_Fault' */
#define ME11_IN_Err_e                  ((uint8)2U)

/* Named constants for Chart: '<S947>/PowerOffDelay' */
#define ME11_IN_Act                    ((uint8)1U)
#define ME11_IN_Dec                    ((uint8)1U)
#define ME11_IN_Init_o                 ((uint8)2U)
#define ME11_IN_wait_pz                ((uint8)2U)

/* Named constants for Chart: '<S1023>/CoolStopDelayPMP' */
#define ME11_IN_OFF                    ((uint8)1U)
#define ME11_IN_ON                     ((uint8)2U)

/* Named constants for Chart: '<S1095>/median' */
#define ME11_IN_GetData                ((uint8)1U)
#define ME11_IN_Middle                 ((uint8)2U)
#define ME11_IN_init                   ((uint8)3U)

/* Named constants for Chart: '<S1105>/ccpCtrl' */
#define ME11_IN_Add                    ((uint8)1U)
#define ME11_IN_Continue               ((uint8)1U)
#define ME11_IN_Dec_d                  ((uint8)2U)
#define ME11_IN_Init_nt                ((uint8)3U)
#define ME11_IN_Max                    ((uint8)1U)
#define ME11_IN_Min                    ((uint8)2U)
#define ME11_IN_Normal_i               ((uint8)3U)
#define ME11_IN_NvmRead                ((uint8)4U)
#define ME11_IN_One                    ((uint8)2U)
#define ME11_IN_Two                    ((uint8)2U)

/* Named constants for Chart: '<S1117>/CCPCtrl' */
#define ME11_IN_Max_d                  ((uint8)2U)
#define ME11_IN_Min_b                  ((uint8)3U)
#define ME11_IN_Normal_l               ((uint8)4U)
#define ME11_IN_One_l                  ((uint8)1U)
#define ME11_IN_Two_h                  ((uint8)1U)

/* Named constants for Chart: '<S1117>/ModeSet' */
#define ME11_IN_Defrost_Foot           ((uint8)2U)
#define ME11_IN_Defrost_a              ((uint8)1U)
#define ME11_IN_Face_Foot              ((uint8)4U)
#define ME11_IN_Face_l                 ((uint8)3U)
#define ME11_IN_Foot                   ((uint8)5U)

/* Named constants for Chart: '<S1119>/SetTemp' */
#define ME11_IN_AddT                   ((uint8)1U)
#define ME11_IN_Chg_Off                ((uint8)1U)
#define ME11_IN_Chg_On                 ((uint8)2U)
#define ME11_IN_DecT                   ((uint8)2U)
#define ME11_IN_Nml                    ((uint8)4U)
#define ME11_IN_Nml_Init               ((uint8)3U)
#define ME11_IN_Set                    ((uint8)4U)
#define ME11_event_AddKey              (0)
#define ME11_event_DecKey              (1)

/* Named constants for Chart: '<S1167>/Chart' */
#define ME11_IN_After                  ((uint8)1U)
#define ME11_IN_Enter                  ((uint8)2U)
#define ME11_IN_Exit                   ((uint8)3U)
#define ME11_IN_Init_h                 ((uint8)4U)
#define ME11_IN_wait_b                 ((uint8)5U)

/* Named constants for Chart: '<S1169>/DealWith' */
#define ME11_IN_Off_l                  ((uint8)2U)
#define ME11_IN_On_kf                  ((uint8)3U)

/* Named constants for Chart: '<S1170>/Chart' */
#define ME11_IN_Active                 ((uint8)1U)
#define ME11_IN_Default_c4             ((uint8)2U)
#define ME11_IN_Max_n                  ((uint8)4U)

/* Named constants for Chart: '<S30>/Cal_RunTime' */
#define ME11_IN_Counter_Cal_f          ((uint8)1U)
#define ME11_IN_Counter_Init_f         ((uint8)2U)

/* Named constants for Chart: '<S30>/CoBatCharg' */
#define ME11_IN_BTMS_Default           ((uint8)1U)
#define ME11_IN_BTMS_NormalThermal     ((uint8)2U)
#define ME11_IN_BTMS_QuickChargeThermal ((uint8)3U)
#define ME11_IN_BTMS_SlowChargeThermal ((uint8)4U)

/* Named constants for Chart: '<S30>/RDCWorkStates' */
#define ME11_IN_CoAC_stAfterRun        ((uint8)1U)
#define ME11_IN_CoAC_stChargeWakeUp    ((uint8)1U)
#define ME11_IN_CoAC_stInit            ((uint8)2U)
#define ME11_IN_CoAC_stNativeWakeUp    ((uint8)2U)
#define ME11_IN_CoAC_stNormal          ((uint8)3U)
#define ME11_IN_CoAC_stOTA             ((uint8)4U)
#define ME11_IN_CoAC_stRemoteWakeUp    ((uint8)3U)
#define ME11_IN_CoAC_stStop            ((uint8)5U)

/* Named constants for Chart: '<S30>/T15SwtCheck' */
#define ME11_IN_T15_OFF                ((uint8)1U)
#define ME11_IN_T15_ON                 ((uint8)2U)

/* Named constants for Chart: '<S30>/TMSStatus' */
#define ME11_IN_ACchg                  ((uint8)1U)
#define ME11_IN_DCchg                  ((uint8)2U)
#define ME11_IN_Dischg                 ((uint8)4U)
#define ME11_IN_LowVoltage             ((uint8)5U)
#define ME11_IN_PTReady                ((uint8)6U)

/* Named constants for Chart: '<S1319>/CloseOfTemp' */
#define ME11_IN_Close                  ((uint8)1U)
#define ME11_IN_Open                   ((uint8)2U)

/* Named constants for Chart: '<S1311>/Modejudge' */
#define ME11_IN_Balance                ((uint8)1U)
#define ME11_IN_Cool_o                 ((uint8)2U)
#define ME11_IN_HStr                   ((uint8)3U)
#define ME11_IN_Heat                   ((uint8)4U)
#define ME11_IN_LTR                    ((uint8)5U)
#define ME11_IN_MotorHeatBat           ((uint8)6U)
#define ME11_IN_Off_nh                 ((uint8)7U)

/* Named constants for Chart: '<S1311>/OTS_WaterMode' */
#define ME11_IN_HStr_m                 ((uint8)2U)
#define ME11_IN_LTR_n                  ((uint8)3U)
#define ME11_IN_MotLTRAndBat           ((uint8)4U)
#define ME11_IN_MotLTRAndBatCool       ((uint8)5U)

/* Named constants for Chart: '<S1312>/CabinMode' */
#define ME11_IN_MD1                    ((uint8)1U)
#define ME11_IN_MD2                    ((uint8)2U)
#define ME11_IN_MD3                    ((uint8)3U)
#define ME11_IN_MD4                    ((uint8)4U)
#define ME11_IN_MD5                    ((uint8)1U)
#define ME11_IN_Standby                ((uint8)2U)
#define ME11_IN_Work                   ((uint8)3U)

/* Named constants for Chart: '<S1683>/KeepStandby' */
#define ME11_IN_Wait_o                 ((uint8)2U)

/* Named constants for Chart: '<S1316>/RefModes' */
#define ME11_IN_ExhDef                 ((uint8)1U)
#define ME11_IN_Nml_d                  ((uint8)2U)
#ifndef PORTABLE_WORDSIZES
#ifndef UCHAR_MAX
#include <limits.h>
#endif

#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )
#error Code was generated for compiler with different sized uchar/char. \
Consider adjusting Test hardware word size settings on the \
Hardware Implementation pane to match your compiler word sizes as \
defined in limits.h of the compiler. Alternatively, you can \
select the Test hardware is the same as production hardware option and \
select the Enable portable word sizes option on the Code Generation > \
Verification pane for ERT based targets, which will disable the \
preprocessor word size checks.
#endif

#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )
#error Code was generated for compiler with different sized ushort/short. \
Consider adjusting Test hardware word size settings on the \
Hardware Implementation pane to match your compiler word sizes as \
defined in limits.h of the compiler. Alternatively, you can \
select the Test hardware is the same as production hardware option and \
select the Enable portable word sizes option on the Code Generation > \
Verification pane for ERT based targets, which will disable the \
preprocessor word size checks.
#endif

#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )
#error Code was generated for compiler with different sized uint/int. \
Consider adjusting Test hardware word size settings on the \
Hardware Implementation pane to match your compiler word sizes as \
defined in limits.h of the compiler. Alternatively, you can \
select the Test hardware is the same as production hardware option and \
select the Enable portable word sizes option on the Code Generation > \
Verification pane for ERT based targets, which will disable the \
preprocessor word size checks.
#endif

#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )
#error Code was generated for compiler with different sized ulong/long. \
Consider adjusting Test hardware word size settings on the \
Hardware Implementation pane to match your compiler word sizes as \
defined in limits.h of the compiler. Alternatively, you can \
select the Test hardware is the same as production hardware option and \
select the Enable portable word sizes option on the Code Generation > \
Verification pane for ERT based targets, which will disable the \
preprocessor word size checks.
#endif

#if ( ULLONG_MAX != (0xFFFFFFFFFFFFFFFFULL) ) || ( LLONG_MAX != (0x7FFFFFFFFFFFFFFFLL) )
#error Code was generated for compiler with different sized typeStr. \
Consider adjusting Test hardware word size settings on the \
Hardware Implementation pane to match your compiler word sizes as \
defined in limits.h of the compiler. Alternatively, you can \
select the Test hardware is the same as production hardware option and \
select the Enable portable word sizes option on the Code Generation > \
Verification pane for ERT based targets, which will disable the \
preprocessor word size checks.
#endif
#endif                                 /* PORTABLE_WORDSIZES */

ARID_DEF_ME11_TMSIODriverFunc_T ME11_TMSIODriverFunc_ARID_DEF;
ARID_DEF_ME11_TMSADCSampleFunc_T ME11_TMSADCSampleFunc_ARID_DEF;

/* Exported block states */
float32 GLB_ESC_VehicleSpeed;          /* '<Root>/GLB_ESC_VehicleSpeed' */
uint8 GLB_CoAC_stwork;                 /* '<Root>/CoAC_stwork' */
boolean GLB_CoAC_stColdStart;          /* '<Root>/CoAC_stColdStart' */
boolean GLB_ESC_VehicleSpeedValid;     /* '<Root>/GLB_ESC_VehicleSpeedValid' */

/* Constant parameters (default storage) */
const ConstP_ME11_T ME11_ConstP = {
  /* Expression: single([1.5 2.5 4.5 8 12])
   * Referenced by: '<S331>/1-D Lookup Table'
   */
  { 1.5F, 2.5F, 4.5F, 8.0F, 12.0F },

  /* Expression: single([-1 0 1.5 3 5])
   * Referenced by: '<S331>/1-D Lookup Table'
   */
  { -1.0F, 0.0F, 1.5F, 3.0F, 5.0F },

  /* Expression: single([0.5 4.5])
   * Referenced by: '<S1234>/Rte_TMSPositions_ModeMotor'
   */
  { 0.5F, 4.5F },

  /* Pooled Parameter (Expression: )
   * Referenced by:
   *   '<S181>/cal_ACDrDVTSolarCor_MAP'
   *   '<S182>/cal_ACPsDVTSolarCor_MAP'
   *   '<S56>/cal_ACFanSpdSolarCorByEnv_MAP'
   *   '<S56>/cal_ACFanSpdSolarCor_MAP'
   */
  { 14U, 14U },

  /* Pooled Parameter (Expression: )
   * Referenced by:
   *   '<S179>/cal_SetPtcDesTempMax_MAP'
   *   '<S545>/cal_COMPATNoiseSpdLmt_MAP'
   *   '<S94>/cal_ACPTCPwrPreSetByEnv_MAP'
   *   '<S185>/cal_ACDVTPreSetByEnv_MAP'
   *   '<S187>/cal_DvtDesLmtByCabinTDiff_MAP'
   */
  { 9U, 9U },

  /* Pooled Parameter (Expression: )
   * Referenced by:
   *   '<S275>/cal_DrEvaDesValPIDLL_MAP'
   *   '<S276>/cal_PsEvaDesValPIDLL_MAP'
   */
  { 3U, 6U },

  /* Computed Parameter: cal_ACDVTPreSetSolarCor_MAP_maxIndex
   * Referenced by: '<S185>/cal_ACDVTPreSetSolarCor_MAP'
   */
  { 7U, 7U },

  /* Pooled Parameter (Expression: )
   * Referenced by:
   *   '<S582>/cal_PTCAuxHeatPwrLmt_MAP'
   *   '<S587>/cal_CtrlFPTCAuxHeatPwrLmt_MAP'
   *   '<S185>/cal_ACDVTPreSetSolarCorByVx_MAP'
   *   '<S282>/cal_EvapDesTempEnvCor_MAP'
   *   '<S307>/cal_EvapDesTempPsEnvCor_MAP'
   *   '<S341>/cal_ACPTCDesEnvCor_MAP'
   *   '<S363>/cal_ACPTCPsDesEnvCor_MAP'
   */
  { 5U, 5U },

  /* Pooled Parameter (Expression: )
   * Referenced by:
   *   '<S185>/cal_ACCabinPreSetByEnvECO_MAP'
   *   '<S185>/cal_ACCabinPreSetByEnv_MAP'
   */
  { 11U, 11U },

  /* Pooled Parameter (Expression: )
   * Referenced by:
   *   '<S182>/cal_ACPsDVTSetCorByEnv_MAP'
   *   '<S185>/cal_CabinDesTempSolarCorECO_MAP'
   *   '<S185>/cal_CabinDesTempSolarCor_MAP'
   */
  { 13U, 13U },

  /* Computed Parameter: cal_ECOEvaDesValLL_MAP_maxIndex
   * Referenced by: '<S178>/cal_ECOEvaDesValLL_MAP'
   */
  { 5U, 6U },

  /* Pooled Parameter (Expression: )
   * Referenced by:
   *   '<S915>/cal_CoolFanCtrl_MAP'
   *   '<S918>/cal_HeatFanCtrl_MAP'
   */
  { 3U, 12U },

  /* Computed Parameter: cal_ACCMCtrlA2FF_MAP_maxIndex
   * Referenced by: '<S582>/cal_ACCMCtrlA2FF_MAP '
   */
  { 5U, 4U },

  /* Expression: uint8([0 100])
   * Referenced by: '<S1234>/Rte_TMSPositions_ModeMotor'
   */
  { 0U, 100U },

  /* Pooled Parameter (Expression: )
   * Referenced by:
   *   '<S1033>/Constant'
   *   '<S466>/Constant'
   */
  { 4U, 5U, 6U, 7U, 8U },

  /* Computed Parameter: Constant_Value_dw
   * Referenced by: '<S517>/Constant'
   */
  { 4U, 5U, 6U, 7U, 8U, 14U },

  /* Computed Parameter: Constant_Value_dn
   * Referenced by: '<S636>/Constant'
   */
  { 1U, 3U, 7U, 8U, 14U },

  /* Computed Parameter: Constant_Value_ig
   * Referenced by: '<S737>/Constant'
   */
  { 1U, 3U, 7U, 8U, 9U, 14U },

  /* Computed Parameter: Constant_Value_l2
   * Referenced by: '<S928>/Constant'
   */
  { 4U, 6U, 7U, 8U, 14U }
};

/* PublicStructure Variables for Internal Data */
ARID_DEF_ME11_T ME11_ARID_DEF;
uint16 look2_iflftu16Dfdf_binlca(float32 u0, float32 u1, const float32 bp0[],
  const float32 bp1[], const uint16 table[], const uint32 maxIndex[], uint32
  stride);
uint32 binsearch_u32f(float32 u, const float32 bp[], uint32 startIndex, uint32
                      maxIndex);
uint32 plook_u32u8_binckan(uint8 u, const uint8 bp[], uint32 maxIndex);
uint32 binsearch_u32u8(uint8 u, const uint8 bp[], uint32 startIndex, uint32
  maxIndex);
sint16 look1_iu16lu64n48ts16Ds32_binlcas(uint16 u0, const uint16 bp0[], const
  sint16 table[], uint32 maxIndex);
float32 look1_iflf_binlca(float32 u0, const float32 bp0[], const float32 table[],
  uint32 maxIndex);
uint16 look1_iflftu16Df_binlca(float32 u0, const float32 bp0[], const uint16
  table[], uint32 maxIndex);
uint8 look1_iflftu8Df_binlca(float32 u0, const float32 bp0[], const uint8 table[],
  uint32 maxIndex);
float32 look2_iu16flftf_binlca(uint16 u0, float32 u1, const uint16 bp0[], const
  float32 bp1[], const float32 table[], const uint32 maxIndex[], uint32 stride);
float32 look2_iflf_binlca(float32 u0, float32 u1, const float32 bp0[], const
  float32 bp1[], const float32 table[], const uint32 maxIndex[], uint32 stride);
float32 look1_iu8lftf_binlca(uint8 u0, const uint8 bp0[], const float32 table[],
  uint32 maxIndex);
float32 look2_ifu8lftf_binlca(float32 u0, uint8 u1, const float32 bp0[], const
  uint8 bp1[], const float32 table[], const uint32 maxIndex[], uint32 stride);
uint8 look2_iflftu8Dfdf_binlca(float32 u0, float32 u1, const float32 bp0[],
  const float32 bp1[], const uint8 table[], const uint32 maxIndex[], uint32
  stride);
float32 look2_ifbfu8lf_binlca(float32 u0, float32 u1, const float32 bp0[], const
  uint8 bp1[], const float32 table[], const uint32 maxIndex[], uint32 stride);
uint8 look1_iu8lu64n56_binlcase(uint8 u0, const uint8 bp0[], const uint8 table[],
  uint32 maxIndex);
float32 look2_iu8flftf_binlca(uint8 u0, float32 u1, const uint8 bp0[], const
  float32 bp1[], const float32 table[], const uint32 maxIndex[], uint32 stride);
float32 look1_iu8bflftf_binlca(uint8 u0, const float32 bp0[], const float32
  table[], uint32 maxIndex);
float32 look1_iu16bflftf_binlca(uint16 u0, const float32 bp0[], const float32
  table[], uint32 maxIndex);
float32 look1_iu16lftf_binlca(uint16 u0, const uint16 bp0[], const float32
  table[], uint32 maxIndex);
uint32 plook_u32f_bincka(float32 u, const float32 bp[], uint32 maxIndex);
uint32 plook_u32f_binckan(float32 u, const float32 bp[], uint32 maxIndex);
extern void ME11_ManualMode(boolean rtu_Enable, BlowerModes
  rtu_ACCtl_BlowerModeManual, BlowerModes *rty_ACCtl_stBlowerMode);
extern void ME11_P_NEG(boolean rtu_Enable, float32 rtu_Dvt, float32 rtu_IWinNeg,
  float32 rtu_IkiNeg, float32 rtu_Ki, float32 *rty_P_NEG);
extern void ME11_P_POS(boolean rtu_Enable, float32 rtu_Dvt, float32 rtu_IWinPos,
  float32 rtu_IKiPos, float32 rtu_Ki, float32 *rty_P_Pos);
extern void ME11_deadzone_Init(boolean *rty_flag);
extern void ME11_deadzone(float32 rtu_u, float32 rtu_Deadzone, boolean *rty_flag);
extern void ME11_PI_Controller(boolean rtu_Enable, boolean rtu_Dvt_POSFlag,
  float32 rtu_PI_feedforward, float32 rtu_P_Cor, float32 rtu_I_Sum, float32
  rtu_PI_CorMax, float32 rtu_PI_CorMin, float32 *rty_PI_Cor, uint8
  *rty_IFreezFlag);
extern void ME11_PI_Controller1(boolean rtu_Enable, float32 rtu_PI_Defult,
  float32 *rty_PI_Cor, uint8 *rty_IFreezFlag);
extern void ME11_P_NEG_h(boolean rtu_Enable, float32 rtu_Dvt, float32
  rtu_pWinNeg, float32 rtu_pkpNeg, float32 rtu_pKp, float32 *rty_Out1);
extern void ME11_P_POS_c(boolean rtu_Enable, float32 rtu_Dvt, float32
  rtu_pWinPos, float32 rtu_pKpPos, float32 rtu_pKp, float32 *rty_Out1);
extern void ME11_PTC_PID_Init(void);
extern uint16 ME11_PTC_PID(float32 rtu_ACCtl_tSetPointPTC, float32 rtu_AC_tAcPTC,
  boolean rtu_ACCtl_stCabinHeatingEnable, boolean rtu_AC_AcPTCTempSensorFalied,
  float32 rtu_GlbDa_tEnv, ARID_DEF_PTC_PID_ME11_T *ME11__ARID_DEF_arg);
extern void ME11_ACCtlRecForPTCDvt(boolean *rty_ACCtl_stRecOut, uint8
  *rty_ACCtl_rIntakeDoor);
extern void ME11_deadzone_a_Init(boolean *rty_flag);
extern void ME11_deadzone_h(float32 rtu_u, float64 rtu_Deadzone, boolean
  *rty_flag);
extern void ME11_OverDuty1_Init(float64 *rty_Sts, float64 *rty_ClearFlt);
extern void ME11_OverDuty1(uint8 rtu_PWRCtl_eTMSStatus, boolean rtu_FaultFlg,
  float64 *rty_Sts, float64 *rty_ClearFlt, ARID_DEF_OverDuty1_ME11_T
  *ME11__ARID_DEF_arg);
extern void ME11_Flg3Cal_Init(boolean *rty_ACTCtl_eCOMPFlg3Cal);
extern void ME11_Flg3Cal(float32 rtu_HPFlg3, boolean *rty_ACTCtl_eCOMPFlg3Cal,
  ARID_DEF_Flg3Cal_ME11_T *ME11__ARID_DEF_arg);
extern void ME11_PwrOn_Init(boolean *rty_flg);
extern void ME11_PwrOn(boolean *rty_flg, ARID_DEF_PwrOn_ME11_T
  *ME11__ARID_DEF_arg);
extern void ME11_deadzone_p_Init(boolean *rty_flag);
extern void ME11_deadzone_h1(float32 rtu_u, float32 rtu_Deadzone, boolean
  *rty_flag);
extern void ME11_Descending_filter_Init(ARID_DEF_Descending_filter_ME11_T
  *ME11__ARID_DEF_arg);
extern void ME11_Descending_filter(boolean rtu_Enable, float32 rtu_Add, float32
  rtu_Dec, float32 rtu_Speed, float32 rtu_COMP_EcompActSpd, float32 *rty_Y,
  ARID_DEF_Descending_filter_ME11_T *ME11__ARID_DEF_arg);
extern void ME11_Chart_Init(boolean *rty_Flag);
extern void ME11_Chart(boolean rtu_Condition, uint16 rtu_Timer, boolean
  *rty_Flag, ARID_DEF_Chart_ME11_T *ME11__ARID_DEF_arg);
extern void ME11_Abnormal_Over_temperatura_via_software_monitoring_Init(boolean *
  rty_ErrSts);
extern void ME11_Abnormal_Over_temperatura_via_software_monitoring(boolean
  rtu_Flg, boolean *rty_ErrSts,
  ARID_DEF_Abnormal_Over_temperatura_via_software_monitoring_ME11_T
  *ME11__ARID_DEF_arg);
extern void ME11_External_Com_Fault_Init(boolean *rty_ErrSts);
extern void ME11_External_Com_Fault(boolean rtu_Flg, boolean *rty_ErrSts,
  ARID_DEF_External_Com_Fault_ME11_T *ME11__ARID_DEF_arg);
extern void ME11_AcPMPFaultJudge_Init(boolean *rty_ACTCtl_bAcPMPFaultFlg);
extern void ME11_AcPMPFaultJudge(boolean rtu_AcPMPFaultFlg, boolean
  *rty_ACTCtl_bAcPMPFaultFlg, ARID_DEF_AcPMPFaultJudge_ME11_T
  *ME11__ARID_DEF_arg);
extern void ME11_Judge_Init(uint8 *rty_SenSts);
extern void ME11_Judge(boolean rtu_MaxFlg, boolean rtu_MinFlg, uint8 rtu_timer,
  uint8 *rty_SenSts, ARID_DEF_Judge_ME11_T *ME11__ARID_DEF_arg);
extern void ME11_Delay_Init(boolean *rty_C);
extern void ME11_Delay(boolean rtu_A, boolean *rty_C, ARID_DEF_Delay_ME11_T
  *ME11__ARID_DEF_arg);
extern void ME11_Delay_j_Init(boolean *rty_B);
extern void ME11_Delay_m(boolean rtu_A, boolean *rty_B, ARID_DEF_Delay_ME11_e_T *
  ME11__ARID_DEF_arg);
extern void ME11_Chart_c_Init(boolean *rty_SOMCtl_bBatLTRFlg);
extern void ME11_Chart_i(boolean rtu_A, boolean rtu_B, boolean
  *rty_SOMCtl_bBatLTRFlg, ARID_DEF_Chart_ME11_e_T *ME11__ARID_DEF_arg);
extern void ME11_Chart_k_Init(boolean *rty_B);
extern void ME11_Chart_l(boolean rtu_A, boolean *rty_B, ARID_DEF_Chart_ME11_n_T *
  ME11__ARID_DEF_arg);
extern void ME11_Chart_e_Init(boolean *rty_SOMCtl_bBatHeatB3tB1Flg);
extern void ME11_Chart_n(boolean rtu_A, boolean rtu_B, boolean
  *rty_SOMCtl_bBatHeatB3tB1Flg, ARID_DEF_Chart_ME11_ng_T *ME11__ARID_DEF_arg);
extern void ME11_TMSIODriverFunc_Init(void);
extern void ME11_TMSIODriverFunc_Update(void);
extern void ME11_TMSIODriverFunc(void);
extern void ME11_TMSADCSampleFunc_Init(void);
extern void ME11_TMSADCSampleFunc(void);

/* Forward declaration for local functions */
void ME11_enter_internal_ThermalCoordinate(void);
void ME11_enter_internal_Sts(uint8 *PWRCtl_eTMSStatus_a);
void ME11_Cal(const boolean *FixPtRelationalOperator);
void ME11_enter_internal_Mode(void);
void ME11_sart(float64 v1, float64 v2, float64 *a, float64 *b);
void ME11_enter_internal_Choice(const uint8 *SOMCtl_eRefModes_b);
uint16 look2_iflftu16Dfdf_binlca(float32 u0, float32 u1, const float32 bp0[],
  const float32 bp1[], const uint16 table[], const uint32 maxIndex[], uint32
  stride)
{
  float32 fractions[2];
  float32 frac;
  uint32 bpIndices[2];
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint16 y;
  uint16 yL_0d0;

  /* Column-major Lookup 2-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex[0U]]) {
    /* Binary Search */
    bpIdx = maxIndex[0U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[0U];
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);
  } else {
    iLeft = maxIndex[0U];
    frac = 0.0F;
  }

  fractions[0U] = frac;
  bpIndices[0U] = iLeft;

  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u1 <= bp1[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u1 < bp1[maxIndex[1U]]) {
    /* Binary Search */
    bpIdx = maxIndex[1U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[1U];
    while (iRght - iLeft > 1U) {
      if (u1 < bp1[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u1 - bp1[iLeft]) / (bp1[iLeft + 1U] - bp1[iLeft]);
  } else {
    iLeft = maxIndex[1U];
    frac = 0.0F;
  }

  /* Column-major Interpolation 2-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  bpIdx = iLeft * stride + bpIndices[0U];
  if (bpIndices[0U] == maxIndex[0U]) {
    y = table[bpIdx];
  } else {
    yL_0d0 = table[bpIdx];
    y = (uint16)((uint32)(uint16)(((float32)table[bpIdx + 1U] - (float32)yL_0d0)
      * fractions[0U]) + yL_0d0);
  }

  if (iLeft == maxIndex[1U]) {
  } else {
    bpIdx += stride;
    if (bpIndices[0U] == maxIndex[0U]) {
      yL_0d0 = table[bpIdx];
    } else {
      yL_0d0 = table[bpIdx];
      yL_0d0 = (uint16)((uint32)(uint16)(((float32)table[bpIdx + 1U] - (float32)
        yL_0d0) * fractions[0U]) + yL_0d0);
    }

    y = (uint16)((uint32)(uint16)(((float32)yL_0d0 - (float32)y) * frac) + y);
  }

  return y;
}

uint32 binsearch_u32f(float32 u, const float32 bp[], uint32 startIndex, uint32
                      maxIndex)
{
  uint32 bpIdx;
  uint32 bpIndex;
  uint32 iRght;

  /* Binary Search */
  bpIdx = startIndex;
  bpIndex = 0U;
  iRght = maxIndex;
  while (iRght - bpIndex > 1U) {
    if (u < bp[bpIdx]) {
      iRght = bpIdx;
    } else {
      bpIndex = bpIdx;
    }

    bpIdx = (iRght + bpIndex) >> 1U;
  }

  return bpIndex;
}

uint32 plook_u32u8_binckan(uint8 u, const uint8 bp[], uint32 maxIndex)
{
  uint32 bpIndex;

  /* Prelookup - Index only
     Index Search method: 'binary'
     Interpolation method: 'Use nearest'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u <= bp[0U]) {
    bpIndex = 0U;
  } else if (u < bp[maxIndex]) {
    bpIndex = binsearch_u32u8(u, bp, maxIndex >> 1U, maxIndex);
    if ((bpIndex < maxIndex) && ((uint8)((uint32)bp[bpIndex + 1U] - u) <= (uint8)
         ((uint32)u - bp[bpIndex]))) {
      bpIndex++;
    }
  } else {
    bpIndex = maxIndex;
  }

  return bpIndex;
}

uint32 binsearch_u32u8(uint8 u, const uint8 bp[], uint32 startIndex, uint32
  maxIndex)
{
  uint32 bpIdx;
  uint32 bpIndex;
  uint32 iRght;

  /* Binary Search */
  bpIdx = startIndex;
  bpIndex = 0U;
  iRght = maxIndex;
  while (iRght - bpIndex > 1U) {
    if (u < bp[bpIdx]) {
      iRght = bpIdx;
    } else {
      bpIndex = bpIdx;
    }

    bpIdx = (iRght + bpIndex) >> 1U;
  }

  return bpIndex;
}

sint16 look1_iu16lu64n48ts16Ds32_binlcas(uint16 u0, const uint16 bp0[], const
  sint16 table[], uint32 maxIndex)
{
  uint64 frac;
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  sint16 y;
  sint16 yL_0d0;
  uint16 bpLeftVar;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
     Rounding mode: 'simplest'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
     Rounding mode: 'simplest'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0ULL;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = maxIndex >> 1U;
    iLeft = 0U;
    iRght = maxIndex;
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    bpLeftVar = bp0[iLeft];
    frac = ((uint64)(uint16)((uint32)u0 - bpLeftVar) << 48) / (uint16)((uint32)
      bp0[iLeft + 1U] - bpLeftVar);
  } else {
    iLeft = maxIndex;
    frac = 0ULL;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Rounding mode: 'simplest'
     Overflow mode: 'wrapping'
   */
  if (iLeft == maxIndex) {
    y = table[iLeft];
  } else {
    yL_0d0 = table[iLeft];
    y = (sint16)((sint16)(((table[iLeft + 1U] - yL_0d0) * (sint64)frac) >> 48) +
                 yL_0d0);
  }

  return y;
}

float32 look1_iflf_binlca(float32 u0, const float32 bp0[], const float32 table[],
  uint32 maxIndex)
{
  float32 frac;
  float32 y;
  float32 yL_0d0;
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = maxIndex >> 1U;
    iLeft = 0U;
    iRght = maxIndex;
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);
  } else {
    iLeft = maxIndex;
    frac = 0.0F;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  if (iLeft == maxIndex) {
    y = table[iLeft];
  } else {
    yL_0d0 = table[iLeft];
    y = (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;
  }

  return y;
}

uint16 look1_iflftu16Df_binlca(float32 u0, const float32 bp0[], const uint16
  table[], uint32 maxIndex)
{
  float32 frac;
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint16 y;
  uint16 yL_0d0;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = maxIndex >> 1U;
    iLeft = 0U;
    iRght = maxIndex;
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);
  } else {
    iLeft = maxIndex;
    frac = 0.0F;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  if (iLeft == maxIndex) {
    y = table[iLeft];
  } else {
    yL_0d0 = table[iLeft];
    y = (uint16)((uint32)(uint16)(((float32)table[iLeft + 1U] - (float32)yL_0d0)
      * frac) + yL_0d0);
  }

  return y;
}

uint8 look1_iflftu8Df_binlca(float32 u0, const float32 bp0[], const uint8 table[],
  uint32 maxIndex)
{
  float32 frac;
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint8 y;
  uint8 yL_0d0;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = maxIndex >> 1U;
    iLeft = 0U;
    iRght = maxIndex;
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);
  } else {
    iLeft = maxIndex;
    frac = 0.0F;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  if (iLeft == maxIndex) {
    y = table[iLeft];
  } else {
    yL_0d0 = table[iLeft];
    y = (uint8)((uint32)(uint8)(((float32)table[iLeft + 1U] - (float32)yL_0d0) *
      frac) + yL_0d0);
  }

  return y;
}

float32 look2_iu16flftf_binlca(uint16 u0, float32 u1, const uint16 bp0[], const
  float32 bp1[], const float32 table[], const uint32 maxIndex[], uint32 stride)
{
  float32 fractions[2];
  float32 frac;
  float32 y;
  float32 yL_0d0;
  uint32 bpIndices[2];
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint16 bpLeftVar;

  /* Column-major Lookup 2-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex[0U]]) {
    /* Binary Search */
    bpIdx = maxIndex[0U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[0U];
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    bpLeftVar = bp0[iLeft];
    frac = (float32)(uint16)((uint32)u0 - bpLeftVar) / (float32)(uint16)((uint32)
      bp0[iLeft + 1U] - bpLeftVar);
  } else {
    iLeft = maxIndex[0U];
    frac = 0.0F;
  }

  fractions[0U] = frac;
  bpIndices[0U] = iLeft;

  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u1 <= bp1[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u1 < bp1[maxIndex[1U]]) {
    /* Binary Search */
    bpIdx = maxIndex[1U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[1U];
    while (iRght - iLeft > 1U) {
      if (u1 < bp1[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u1 - bp1[iLeft]) / (bp1[iLeft + 1U] - bp1[iLeft]);
  } else {
    iLeft = maxIndex[1U];
    frac = 0.0F;
  }

  /* Column-major Interpolation 2-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  bpIdx = iLeft * stride + bpIndices[0U];
  if (bpIndices[0U] == maxIndex[0U]) {
    y = table[bpIdx];
  } else {
    yL_0d0 = table[bpIdx];
    y = (table[bpIdx + 1U] - yL_0d0) * fractions[0U] + yL_0d0;
  }

  if (iLeft == maxIndex[1U]) {
  } else {
    bpIdx += stride;
    if (bpIndices[0U] == maxIndex[0U]) {
      yL_0d0 = table[bpIdx];
    } else {
      yL_0d0 = table[bpIdx];
      yL_0d0 += (table[bpIdx + 1U] - yL_0d0) * fractions[0U];
    }

    y += (yL_0d0 - y) * frac;
  }

  return y;
}

float32 look2_iflf_binlca(float32 u0, float32 u1, const float32 bp0[], const
  float32 bp1[], const float32 table[], const uint32 maxIndex[], uint32 stride)
{
  float32 fractions[2];
  float32 frac;
  float32 y;
  float32 yL_0d0;
  uint32 bpIndices[2];
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;

  /* Column-major Lookup 2-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex[0U]]) {
    /* Binary Search */
    bpIdx = maxIndex[0U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[0U];
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);
  } else {
    iLeft = maxIndex[0U];
    frac = 0.0F;
  }

  fractions[0U] = frac;
  bpIndices[0U] = iLeft;

  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u1 <= bp1[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u1 < bp1[maxIndex[1U]]) {
    /* Binary Search */
    bpIdx = maxIndex[1U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[1U];
    while (iRght - iLeft > 1U) {
      if (u1 < bp1[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u1 - bp1[iLeft]) / (bp1[iLeft + 1U] - bp1[iLeft]);
  } else {
    iLeft = maxIndex[1U];
    frac = 0.0F;
  }

  /* Column-major Interpolation 2-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  bpIdx = iLeft * stride + bpIndices[0U];
  if (bpIndices[0U] == maxIndex[0U]) {
    y = table[bpIdx];
  } else {
    yL_0d0 = table[bpIdx];
    y = (table[bpIdx + 1U] - yL_0d0) * fractions[0U] + yL_0d0;
  }

  if (iLeft == maxIndex[1U]) {
  } else {
    bpIdx += stride;
    if (bpIndices[0U] == maxIndex[0U]) {
      yL_0d0 = table[bpIdx];
    } else {
      yL_0d0 = table[bpIdx];
      yL_0d0 += (table[bpIdx + 1U] - yL_0d0) * fractions[0U];
    }

    y += (yL_0d0 - y) * frac;
  }

  return y;
}

float32 look1_iu8lftf_binlca(uint8 u0, const uint8 bp0[], const float32 table[],
  uint32 maxIndex)
{
  float32 frac;
  float32 y;
  float32 yL_0d0;
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint8 bpLeftVar;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = maxIndex >> 1U;
    iLeft = 0U;
    iRght = maxIndex;
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    bpLeftVar = bp0[iLeft];
    frac = (float32)(uint8)((uint32)u0 - bpLeftVar) / (float32)(uint8)((uint32)
      bp0[iLeft + 1U] - bpLeftVar);
  } else {
    iLeft = maxIndex;
    frac = 0.0F;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  if (iLeft == maxIndex) {
    y = table[iLeft];
  } else {
    yL_0d0 = table[iLeft];
    y = (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;
  }

  return y;
}

float32 look2_ifu8lftf_binlca(float32 u0, uint8 u1, const float32 bp0[], const
  uint8 bp1[], const float32 table[], const uint32 maxIndex[], uint32 stride)
{
  float32 fractions[2];
  float32 frac;
  float32 y;
  float32 yL_0d0;
  uint32 bpIndices[2];
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint8 bpLeftVar;

  /* Column-major Lookup 2-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex[0U]]) {
    /* Binary Search */
    bpIdx = maxIndex[0U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[0U];
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);
  } else {
    iLeft = maxIndex[0U];
    frac = 0.0F;
  }

  fractions[0U] = frac;
  bpIndices[0U] = iLeft;

  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u1 <= bp1[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u1 < bp1[maxIndex[1U]]) {
    /* Binary Search */
    bpIdx = maxIndex[1U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[1U];
    while (iRght - iLeft > 1U) {
      if (u1 < bp1[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    bpLeftVar = bp1[iLeft];
    frac = (float32)(uint8)((uint32)u1 - bpLeftVar) / (float32)(uint8)((uint32)
      bp1[iLeft + 1U] - bpLeftVar);
  } else {
    iLeft = maxIndex[1U];
    frac = 0.0F;
  }

  /* Column-major Interpolation 2-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  bpIdx = iLeft * stride + bpIndices[0U];
  if (bpIndices[0U] == maxIndex[0U]) {
    y = table[bpIdx];
  } else {
    yL_0d0 = table[bpIdx];
    y = (table[bpIdx + 1U] - yL_0d0) * fractions[0U] + yL_0d0;
  }

  if (iLeft == maxIndex[1U]) {
  } else {
    bpIdx += stride;
    if (bpIndices[0U] == maxIndex[0U]) {
      yL_0d0 = table[bpIdx];
    } else {
      yL_0d0 = table[bpIdx];
      yL_0d0 += (table[bpIdx + 1U] - yL_0d0) * fractions[0U];
    }

    y += (yL_0d0 - y) * frac;
  }

  return y;
}

uint8 look2_iflftu8Dfdf_binlca(float32 u0, float32 u1, const float32 bp0[],
  const float32 bp1[], const uint8 table[], const uint32 maxIndex[], uint32
  stride)
{
  float32 fractions[2];
  float32 frac;
  uint32 bpIndices[2];
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint8 y;
  uint8 yL_0d0;

  /* Column-major Lookup 2-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex[0U]]) {
    /* Binary Search */
    bpIdx = maxIndex[0U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[0U];
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);
  } else {
    iLeft = maxIndex[0U];
    frac = 0.0F;
  }

  fractions[0U] = frac;
  bpIndices[0U] = iLeft;

  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u1 <= bp1[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u1 < bp1[maxIndex[1U]]) {
    /* Binary Search */
    bpIdx = maxIndex[1U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[1U];
    while (iRght - iLeft > 1U) {
      if (u1 < bp1[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u1 - bp1[iLeft]) / (bp1[iLeft + 1U] - bp1[iLeft]);
  } else {
    iLeft = maxIndex[1U];
    frac = 0.0F;
  }

  /* Column-major Interpolation 2-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  bpIdx = iLeft * stride + bpIndices[0U];
  if (bpIndices[0U] == maxIndex[0U]) {
    y = table[bpIdx];
  } else {
    yL_0d0 = table[bpIdx];
    y = (uint8)((uint32)(uint8)(((float32)table[bpIdx + 1U] - (float32)yL_0d0) *
      fractions[0U]) + yL_0d0);
  }

  if (iLeft == maxIndex[1U]) {
  } else {
    bpIdx += stride;
    if (bpIndices[0U] == maxIndex[0U]) {
      yL_0d0 = table[bpIdx];
    } else {
      yL_0d0 = table[bpIdx];
      yL_0d0 = (uint8)((uint32)(uint8)(((float32)table[bpIdx + 1U] - (float32)
        yL_0d0) * fractions[0U]) + yL_0d0);
    }

    y = (uint8)((uint32)(uint8)(((float32)yL_0d0 - (float32)y) * frac) + y);
  }

  return y;
}

float32 look2_ifbfu8lf_binlca(float32 u0, float32 u1, const float32 bp0[], const
  uint8 bp1[], const float32 table[], const uint32 maxIndex[], uint32 stride)
{
  float32 fractions[2];
  float32 frac;
  float32 y;
  float32 yL_0d0;
  uint32 bpIndices[2];
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint8 uCast;

  /* Column-major Lookup 2-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex[0U]]) {
    /* Binary Search */
    bpIdx = maxIndex[0U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[0U];
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);
  } else {
    iLeft = maxIndex[0U];
    frac = 0.0F;
  }

  fractions[0U] = frac;
  bpIndices[0U] = iLeft;

  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u1 < 256.0F) {
    if (u1 >= 0.0F) {
      uCast = (uint8)u1;
    } else {
      uCast = 0U;
    }
  } else {
    uCast = MAX_uint8_T;
  }

  if (u1 < bp1[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u1 < bp1[maxIndex[1U]]) {
    /* Binary Search */
    bpIdx = maxIndex[1U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[1U];
    while (iRght - iLeft > 1U) {
      if (uCast < bp1[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u1 - (float32)bp1[iLeft]) / (float32)(uint8)((uint32)bp1[iLeft + 1U]
      - bp1[iLeft]);
  } else {
    iLeft = maxIndex[1U];
    frac = 0.0F;
  }

  /* Column-major Interpolation 2-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  bpIdx = iLeft * stride + bpIndices[0U];
  if (bpIndices[0U] == maxIndex[0U]) {
    y = table[bpIdx];
  } else {
    yL_0d0 = table[bpIdx];
    y = (table[bpIdx + 1U] - yL_0d0) * fractions[0U] + yL_0d0;
  }

  if (iLeft == maxIndex[1U]) {
  } else {
    bpIdx += stride;
    if (bpIndices[0U] == maxIndex[0U]) {
      yL_0d0 = table[bpIdx];
    } else {
      yL_0d0 = table[bpIdx];
      yL_0d0 += (table[bpIdx + 1U] - yL_0d0) * fractions[0U];
    }

    y += (yL_0d0 - y) * frac;
  }

  return y;
}

uint8 look1_iu8lu64n56_binlcase(uint8 u0, const uint8 bp0[], const uint8 table[],
  uint32 maxIndex)
{
  uint64 frac;
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint8 bpLeftVar;
  uint8 y;
  uint8 yL_0d0;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
     Rounding mode: 'simplest'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
     Rounding mode: 'simplest'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0ULL;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = maxIndex >> 1U;
    iLeft = 0U;
    iRght = maxIndex;
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    bpLeftVar = bp0[iLeft];
    frac = ((uint64)(uint8)((uint32)u0 - bpLeftVar) << 56) / (uint8)((uint32)
      bp0[iLeft + 1U] - bpLeftVar);
  } else {
    iLeft = maxIndex;
    frac = 0ULL;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Rounding mode: 'simplest'
     Overflow mode: 'wrapping'
   */
  if (iLeft == maxIndex) {
    y = table[iLeft];
  } else {
    bpLeftVar = table[iLeft + 1U];
    yL_0d0 = table[iLeft];
    if (bpLeftVar >= yL_0d0) {
      y = (uint8)((uint32)(uint8)(((uint8)((uint32)bpLeftVar - yL_0d0) * frac) >>
        56) + yL_0d0);
    } else {
      y = (uint8)((uint32)yL_0d0 - (uint8)(((uint8)((uint32)yL_0d0 - bpLeftVar) *
        frac) >> 56));
    }
  }

  return y;
}

float32 look2_iu8flftf_binlca(uint8 u0, float32 u1, const uint8 bp0[], const
  float32 bp1[], const float32 table[], const uint32 maxIndex[], uint32 stride)
{
  float32 fractions[2];
  float32 frac;
  float32 y;
  float32 yL_0d0;
  uint32 bpIndices[2];
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint8 bpLeftVar;

  /* Column-major Lookup 2-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex[0U]]) {
    /* Binary Search */
    bpIdx = maxIndex[0U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[0U];
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    bpLeftVar = bp0[iLeft];
    frac = (float32)(uint8)((uint32)u0 - bpLeftVar) / (float32)(uint8)((uint32)
      bp0[iLeft + 1U] - bpLeftVar);
  } else {
    iLeft = maxIndex[0U];
    frac = 0.0F;
  }

  fractions[0U] = frac;
  bpIndices[0U] = iLeft;

  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u1 <= bp1[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u1 < bp1[maxIndex[1U]]) {
    /* Binary Search */
    bpIdx = maxIndex[1U] >> 1U;
    iLeft = 0U;
    iRght = maxIndex[1U];
    while (iRght - iLeft > 1U) {
      if (u1 < bp1[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = (u1 - bp1[iLeft]) / (bp1[iLeft + 1U] - bp1[iLeft]);
  } else {
    iLeft = maxIndex[1U];
    frac = 0.0F;
  }

  /* Column-major Interpolation 2-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  bpIdx = iLeft * stride + bpIndices[0U];
  if (bpIndices[0U] == maxIndex[0U]) {
    y = table[bpIdx];
  } else {
    yL_0d0 = table[bpIdx];
    y = (table[bpIdx + 1U] - yL_0d0) * fractions[0U] + yL_0d0;
  }

  if (iLeft == maxIndex[1U]) {
  } else {
    bpIdx += stride;
    if (bpIndices[0U] == maxIndex[0U]) {
      yL_0d0 = table[bpIdx];
    } else {
      yL_0d0 = table[bpIdx];
      yL_0d0 += (table[bpIdx + 1U] - yL_0d0) * fractions[0U];
    }

    y += (yL_0d0 - y) * frac;
  }

  return y;
}

float32 look1_iu8bflftf_binlca(uint8 u0, const float32 bp0[], const float32
  table[], uint32 maxIndex)
{
  float32 frac;
  float32 y;
  float32 yL_0d0;
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 < bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = maxIndex >> 1U;
    iLeft = 0U;
    iRght = maxIndex;
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = ((float32)u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);
  } else {
    iLeft = maxIndex;
    frac = 0.0F;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  if (iLeft == maxIndex) {
    y = table[iLeft];
  } else {
    yL_0d0 = table[iLeft];
    y = (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;
  }

  return y;
}

float32 look1_iu16bflftf_binlca(uint16 u0, const float32 bp0[], const float32
  table[], uint32 maxIndex)
{
  float32 frac;
  float32 y;
  float32 yL_0d0;
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 < bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = maxIndex >> 1U;
    iLeft = 0U;
    iRght = maxIndex;
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    frac = ((float32)u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);
  } else {
    iLeft = maxIndex;
    frac = 0.0F;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  if (iLeft == maxIndex) {
    y = table[iLeft];
  } else {
    yL_0d0 = table[iLeft];
    y = (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;
  }

  return y;
}

float32 look1_iu16lftf_binlca(uint16 u0, const uint16 bp0[], const float32
  table[], uint32 maxIndex)
{
  float32 frac;
  float32 y;
  float32 yL_0d0;
  uint32 bpIdx;
  uint32 iLeft;
  uint32 iRght;
  uint16 bpLeftVar;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = maxIndex >> 1U;
    iLeft = 0U;
    iRght = maxIndex;
    while (iRght - iLeft > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (iRght + iLeft) >> 1U;
    }

    bpLeftVar = bp0[iLeft];
    frac = (float32)(uint16)((uint32)u0 - bpLeftVar) / (float32)(uint16)((uint32)
      bp0[iLeft + 1U] - bpLeftVar);
  } else {
    iLeft = maxIndex;
    frac = 0.0F;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'wrapping'
   */
  if (iLeft == maxIndex) {
    y = table[iLeft];
  } else {
    yL_0d0 = table[iLeft];
    y = (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;
  }

  return y;
}

uint32 plook_u32f_bincka(float32 u, const float32 bp[], uint32 maxIndex)
{
  uint32 bpIndex;

  /* Prelookup - Index only
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u <= bp[0U]) {
    bpIndex = 0U;
  } else if (u < bp[maxIndex]) {
    bpIndex = binsearch_u32f(u, bp, maxIndex >> 1U, maxIndex);
  } else {
    bpIndex = maxIndex;
  }

  return bpIndex;
}

uint32 plook_u32f_binckan(float32 u, const float32 bp[], uint32 maxIndex)
{
  uint32 bpIndex;

  /* Prelookup - Index only
     Index Search method: 'binary'
     Interpolation method: 'Use nearest'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u <= bp[0U]) {
    bpIndex = 0U;
  } else if (u < bp[maxIndex]) {
    bpIndex = binsearch_u32f(u, bp, maxIndex >> 1U, maxIndex);
    if ((bpIndex < maxIndex) && (bp[bpIndex + 1U] - u <= u - bp[bpIndex])) {
      bpIndex++;
    }
  } else {
    bpIndex = maxIndex;
  }

  return bpIndex;
}

/*
 * Output and update for enable system:
 *    '<S76>/ManualMode'
 *    '<S43>/BlowerControlShutOff'
 */
void ME11_ManualMode(boolean rtu_Enable, BlowerModes rtu_ACCtl_BlowerModeManual,
                     BlowerModes *rty_ACCtl_stBlowerMode)
{
  /* Outputs for Enabled SubSystem: '<S76>/ManualMode' incorporates:
   *  EnablePort: '<S79>/Enable'
   */
  if (rtu_Enable) {
    /* SignalConversion generated from: '<S79>/ACCtl_BlowerModeManual' */
    *rty_ACCtl_stBlowerMode = rtu_ACCtl_BlowerModeManual;
  }

  /* End of Outputs for SubSystem: '<S76>/ManualMode' */
}

/*
 * Output and update for enable system:
 *    '<S105>/P_NEG'
 *    '<S192>/P_NEG'
 *    '<S235>/P_NEG'
 *    '<S254>/P_NEG'
 *    '<S289>/P_NEG'
 *    '<S315>/P_NEG'
 *    '<S348>/P_NEG'
 *    '<S370>/P_NEG'
 *    '<S400>/P_NEG'
 *    '<S424>/P_NEG'
 *    ...
 */
void ME11_P_NEG(boolean rtu_Enable, float32 rtu_Dvt, float32 rtu_IWinNeg,
                float32 rtu_IkiNeg, float32 rtu_Ki, float32 *rty_P_NEG)
{
  /* Outputs for Enabled SubSystem: '<S105>/P_NEG' incorporates:
   *  EnablePort: '<S111>/Enable'
   */
  if (rtu_Enable) {
    /* Switch: '<S111>/Switch' incorporates:
     *  Product: '<S111>/Product1'
     *  Product: '<S111>/Product2'
     *  RelationalOperator: '<S111>/Relational Operator'
     */
    if (rtu_Dvt > rtu_IWinNeg) {
      *rty_P_NEG = rtu_IkiNeg * rtu_Dvt;
    } else {
      *rty_P_NEG = rtu_Ki * rtu_Dvt;
    }

    /* End of Switch: '<S111>/Switch' */
  }

  /* End of Outputs for SubSystem: '<S105>/P_NEG' */
}

/*
 * Output and update for enable system:
 *    '<S105>/P_POS'
 *    '<S192>/P_POS'
 *    '<S235>/P_POS'
 *    '<S254>/P_POS'
 *    '<S289>/P_POS'
 *    '<S315>/P_POS'
 *    '<S348>/P_POS'
 *    '<S370>/P_POS'
 *    '<S400>/P_POS'
 *    '<S424>/P_POS'
 *    ...
 */
void ME11_P_POS(boolean rtu_Enable, float32 rtu_Dvt, float32 rtu_IWinPos,
                float32 rtu_IKiPos, float32 rtu_Ki, float32 *rty_P_Pos)
{
  /* Outputs for Enabled SubSystem: '<S105>/P_POS' incorporates:
   *  EnablePort: '<S112>/Enable'
   */
  if (rtu_Enable) {
    /* Switch: '<S112>/Switch' incorporates:
     *  Product: '<S112>/Product2'
     *  Product: '<S112>/Product3'
     *  RelationalOperator: '<S112>/Relational Operator'
     */
    if (rtu_Dvt > rtu_IWinPos) {
      *rty_P_Pos = rtu_IKiPos * rtu_Dvt;
    } else {
      *rty_P_Pos = rtu_Ki * rtu_Dvt;
    }

    /* End of Switch: '<S112>/Switch' */
  }

  /* End of Outputs for SubSystem: '<S105>/P_POS' */
}

/*
 * System initialize for atomic system:
 *    '<S102>/deadzone'
 *    '<S189>/deadzone'
 *    '<S285>/deadzone'
 *    '<S311>/deadzone'
 */
void ME11_deadzone_Init(boolean *rty_flag)
{
  *rty_flag = false;
}

/*
 * Output and update for atomic system:
 *    '<S102>/deadzone'
 *    '<S189>/deadzone'
 *    '<S285>/deadzone'
 *    '<S311>/deadzone'
 */
void ME11_deadzone(float32 rtu_u, float32 rtu_Deadzone, boolean *rty_flag)
{
  /* Chart: '<S102>/deadzone' */
  *rty_flag = ((float32)fabs(rtu_u) < rtu_Deadzone);
}

/*
 * Output and update for enable system:
 *    '<S103>/PI_Controller'
 *    '<S190>/PI_Controller'
 *    '<S233>/PI_Controller'
 *    '<S252>/PI_Controller'
 *    '<S286>/PI_Controller'
 *    '<S312>/PI_Controller'
 *    '<S346>/PI_Controller'
 *    '<S368>/PI_Controller'
 *    '<S398>/PI_Controller'
 *    '<S422>/PI_Controller'
 *    ...
 */
void ME11_PI_Controller(boolean rtu_Enable, boolean rtu_Dvt_POSFlag, float32
  rtu_PI_feedforward, float32 rtu_P_Cor, float32 rtu_I_Sum, float32
  rtu_PI_CorMax, float32 rtu_PI_CorMin, float32 *rty_PI_Cor, uint8
  *rty_IFreezFlag)
{
  float32 rtb_Switch_gx;

  /* Outputs for Enabled SubSystem: '<S103>/PI_Controller' incorporates:
   *  EnablePort: '<S114>/Enable'
   */
  if (rtu_Enable) {
    /* Switch: '<S114>/Switch' incorporates:
     *  RelationalOperator: '<S114>/Relational Operator'
     *  Switch: '<S114>/Switch1'
     */
    if (rtu_Dvt_POSFlag) {
      /* Switch: '<S114>/Switch' incorporates:
       *  Sum: '<S114>/Sum2'
       *  Sum: '<S114>/Sum3'
       */
      rtb_Switch_gx = (rtu_PI_feedforward + rtu_P_Cor) + rtu_I_Sum;
    } else {
      if (rtu_P_Cor < rtu_PI_feedforward) {
        /* Switch: '<S114>/Switch1' incorporates:
         *  Sum: '<S114>/Sum4'
         */
        rtb_Switch_gx = rtu_PI_feedforward - rtu_P_Cor;
      } else {
        /* Switch: '<S114>/Switch1' incorporates:
         *  Constant: '<S114>/Constant'
         */
        rtb_Switch_gx = 0.0F;
      }

      /* Switch: '<S114>/Switch' incorporates:
       *  Sum: '<S114>/Sum1'
       *  Switch: '<S114>/Switch1'
       */
      rtb_Switch_gx += rtu_I_Sum;
    }

    /* End of Switch: '<S114>/Switch' */

    /* Switch: '<S116>/Switch2' incorporates:
     *  RelationalOperator: '<S116>/LowerRelop1'
     *  RelationalOperator: '<S116>/UpperRelop'
     *  Switch: '<S116>/Switch'
     */
    if (rtb_Switch_gx > rtu_PI_CorMax) {
      /* Switch: '<S116>/Switch2' */
      rtb_Switch_gx = rtu_PI_CorMax;
    } else if (rtb_Switch_gx < rtu_PI_CorMin) {
      /* Switch: '<S116>/Switch' incorporates:
       *  Switch: '<S116>/Switch2'
       */
      rtb_Switch_gx = rtu_PI_CorMin;
    }

    /* End of Switch: '<S116>/Switch2' */

    /* SignalConversion generated from: '<S114>/PI_Cor' */
    *rty_PI_Cor = rtb_Switch_gx;

    /* Sum: '<S117>/Add' incorporates:
     *  Gain: '<S117>/Gain'
     *  RelationalOperator: '<S117>/Relational Operator'
     *  RelationalOperator: '<S117>/Relational Operator1'
     */
    *rty_IFreezFlag = (uint8)((uint32)((rtb_Switch_gx <= rtu_PI_CorMin) << 1) +
      (uint32)(rtu_PI_CorMax <= rtb_Switch_gx));
  }

  /* End of Outputs for SubSystem: '<S103>/PI_Controller' */
}

/*
 * Output and update for enable system:
 *    '<S103>/PI_Controller1'
 *    '<S190>/PI_Controller1'
 *    '<S233>/PI_Controller1'
 *    '<S252>/PI_Controller1'
 *    '<S286>/PI_Controller1'
 *    '<S312>/PI_Controller1'
 *    '<S346>/PI_Controller1'
 *    '<S368>/PI_Controller1'
 *    '<S398>/PI_Controller1'
 *    '<S422>/PI_Controller1'
 *    ...
 */
void ME11_PI_Controller1(boolean rtu_Enable, float32 rtu_PI_Defult, float32
  *rty_PI_Cor, uint8 *rty_IFreezFlag)
{
  /* Outputs for Enabled SubSystem: '<S103>/PI_Controller1' incorporates:
   *  EnablePort: '<S115>/Enable'
   */
  if (rtu_Enable) {
    /* SignalConversion generated from: '<S115>/PI_Defult' */
    *rty_PI_Cor = rtu_PI_Defult;

    /* SignalConversion generated from: '<S115>/IFreezFlag' incorporates:
     *  Constant: '<S115>/Constant1'
     */
    *rty_IFreezFlag = 3U;
  }

  /* End of Outputs for SubSystem: '<S103>/PI_Controller1' */
}

/*
 * Output and update for enable system:
 *    '<S104>/P_NEG'
 *    '<S191>/P_NEG'
 *    '<S234>/P_NEG'
 *    '<S253>/P_NEG'
 *    '<S288>/P_NEG'
 *    '<S313>/P_NEG'
 *    '<S347>/P_NEG'
 *    '<S369>/P_NEG'
 *    '<S399>/P_NEG'
 *    '<S423>/P_NEG'
 *    ...
 */
void ME11_P_NEG_h(boolean rtu_Enable, float32 rtu_Dvt, float32 rtu_pWinNeg,
                  float32 rtu_pkpNeg, float32 rtu_pKp, float32 *rty_Out1)
{
  float32 tmp;
  float32 tmp_0;

  /* Outputs for Enabled SubSystem: '<S104>/P_NEG' incorporates:
   *  EnablePort: '<S118>/Enable'
   */
  if (rtu_Enable) {
    /* Switch: '<S118>/Switch' incorporates:
     *  Constant: '<S118>/Constant'
     *  RelationalOperator: '<S118>/Relational Operator'
     *  Sum: '<S118>/Sum'
     */
    if (rtu_Dvt > rtu_pWinNeg) {
      tmp = rtu_Dvt - rtu_pWinNeg;
    } else {
      tmp = 0.0F;
    }

    /* Switch: '<S118>/Switch1' incorporates:
     *  Product: '<S118>/Product2'
     *  Product: '<S118>/Product3'
     *  RelationalOperator: '<S118>/Relational Operator1'
     */
    if (rtu_Dvt <= rtu_pWinNeg) {
      tmp_0 = rtu_pKp * rtu_Dvt;
    } else {
      tmp_0 = rtu_pWinNeg * rtu_pKp;
    }

    /* Sum: '<S118>/Sum1' incorporates:
     *  Product: '<S118>/Product1'
     *  Switch: '<S118>/Switch'
     *  Switch: '<S118>/Switch1'
     */
    *rty_Out1 = rtu_pkpNeg * tmp + tmp_0;
  }

  /* End of Outputs for SubSystem: '<S104>/P_NEG' */
}

/*
 * Output and update for enable system:
 *    '<S104>/P_POS'
 *    '<S191>/P_POS'
 *    '<S234>/P_POS'
 *    '<S253>/P_POS'
 *    '<S288>/P_POS'
 *    '<S313>/P_POS'
 *    '<S347>/P_POS'
 *    '<S369>/P_POS'
 *    '<S399>/P_POS'
 *    '<S423>/P_POS'
 *    ...
 */
void ME11_P_POS_c(boolean rtu_Enable, float32 rtu_Dvt, float32 rtu_pWinPos,
                  float32 rtu_pKpPos, float32 rtu_pKp, float32 *rty_Out1)
{
  float32 tmp;
  float32 tmp_0;

  /* Outputs for Enabled SubSystem: '<S104>/P_POS' incorporates:
   *  EnablePort: '<S119>/Enable'
   */
  if (rtu_Enable) {
    /* Switch: '<S119>/Switch1' incorporates:
     *  Product: '<S119>/Product1'
     *  Product: '<S119>/Product2'
     *  RelationalOperator: '<S119>/Relational Operator1'
     */
    if (rtu_Dvt <= rtu_pWinPos) {
      tmp = rtu_pKp * rtu_Dvt;
    } else {
      tmp = rtu_pWinPos * rtu_pKp;
    }

    /* Switch: '<S119>/Switch' incorporates:
     *  Constant: '<S119>/Constant'
     *  RelationalOperator: '<S119>/Relational Operator'
     *  Sum: '<S119>/Sum2'
     */
    if (rtu_Dvt > rtu_pWinPos) {
      tmp_0 = rtu_Dvt - rtu_pWinPos;
    } else {
      tmp_0 = 0.0F;
    }

    /* Sum: '<S119>/Sum1' incorporates:
     *  Product: '<S119>/Product'
     *  Switch: '<S119>/Switch'
     *  Switch: '<S119>/Switch1'
     */
    *rty_Out1 = rtu_pKpPos * tmp_0 + tmp;
  }

  /* End of Outputs for SubSystem: '<S104>/P_POS' */
}

/* System initialize for atomic system: '<S45>/PTC_PID' */
void ME11_PTC_PID_Init(void)
{
  /* local block i/o variables */
  boolean rtb_flag_i;

  /* SystemInitialize for Chart: '<S102>/deadzone' */
  ME11_deadzone_Init(&rtb_flag_i);
}

/* Output and update for atomic system: '<S45>/PTC_PID' */
uint16 ME11_PTC_PID(float32 rtu_ACCtl_tSetPointPTC, float32 rtu_AC_tAcPTC,
                    boolean rtu_ACCtl_stCabinHeatingEnable, boolean
                    rtu_AC_AcPTCTempSensorFalied, float32 rtu_GlbDa_tEnv,
                    ARID_DEF_PTC_PID_ME11_T *ME11__ARID_DEF_arg)
{
  /* local block i/o variables */
  boolean rtb_flag_i;
  uint16 rty_ACCtl_pwrHeatingReq_0;
  float32 rtb_PI_Cor_aw;
  uint8 rtb_IFreezFlag_mt;
  boolean rtb_LogicalOperator_k0;

  /* Lookup_n-D: '<S94>/cal_ACPTCPwrPreSetByEnv_MAP' */
  ACCtl_pwrHeatingFeed = look2_iflftu16Dfdf_binlca(rtu_ACCtl_tSetPointPTC,
    rtu_GlbDa_tEnv, (const float32 *)&cal_ACPTCPwrPreSetByEnv_2X[0], (const
    float32 *)&cal_ACPTCPwrPreSetByEnv_2Y[0], (const uint16 *)
    &cal_ACPTCPwrPreSetByEnv_MAP[0], ME11_ConstP.pooled36, 10U);

  /* Logic: '<S94>/Logical Operator' incorporates:
   *  Logic: '<S94>/Logical Operator1'
   */
  rtb_LogicalOperator_k0 = ((!rtu_AC_AcPTCTempSensorFalied) &&
    rtu_ACCtl_stCabinHeatingEnable);

  /* Outputs for Enabled SubSystem: '<S103>/PI_Controller1' */
  /* Logic: '<S103>/Logical Operator' incorporates:
   *  Constant: '<S94>/Constant1'
   */
  ME11_PI_Controller1(!rtb_LogicalOperator_k0, 0.0F, &rtb_PI_Cor_aw,
                      &rtb_IFreezFlag_mt);

  /* End of Outputs for SubSystem: '<S103>/PI_Controller1' */

  /* RelationalOperator: '<S102>/Relational Operator' */
  ACCtl_tErrACPTCPosFlag = (rtu_ACCtl_tSetPointPTC >= rtu_AC_tAcPTC);

  /* Sum: '<S102>/Sum' */
  ACCtl_tErrACPTC = rtu_ACCtl_tSetPointPTC - rtu_AC_tAcPTC;

  /* Chart: '<S102>/deadzone' incorporates:
   *  Constant: '<S94>/Constant'
   */
  ME11_deadzone(ACCtl_tErrACPTC, 0.5F, &rtb_flag_i);

  /* Switch: '<S102>/Switch1' incorporates:
   *  Switch: '<S102>/Switch'
   */
  if (rtb_flag_i) {
    /* Switch: '<S102>/Switch1' incorporates:
     *  Constant: '<S102>/Constant'
     */
    ACCtl_tErrACPTC = 0.0F;
  } else if (!ACCtl_tErrACPTCPosFlag) {
    /* Switch: '<S102>/Switch1' incorporates:
     *  Sum: '<S102>/Sum1'
     *  Switch: '<S102>/Switch'
     */
    ACCtl_tErrACPTC = rtu_AC_tAcPTC - rtu_ACCtl_tSetPointPTC;
  }

  /* End of Switch: '<S102>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S104>/P_NEG' */
  /* Logic: '<S104>/Logical Operator' incorporates:
   *  Constant: '<S94>/Kp'
   *  Constant: '<S94>/Kp1'
   *  Constant: '<S94>/Kp4'
   */
  ME11_P_NEG_h(!ACCtl_tErrACPTCPosFlag, ACCtl_tErrACPTC,
               cal_PtcPwrDesValPID_pWinNeg, cal_PtcPwrDesValPID_KpNeg,
               cal_PtcPwrDesValPID_Kp, (float32 *)&ACCtl_pwrHeatingPCor);

  /* End of Outputs for SubSystem: '<S104>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S104>/P_POS' */
  /* Constant: '<S94>/Kp3' incorporates:
   *  Constant: '<S94>/Kp'
   *  Constant: '<S94>/Kp2'
   */
  ME11_P_POS_c(ACCtl_tErrACPTCPosFlag, ACCtl_tErrACPTC,
               cal_PtcPwrDesValPID_pWinPos, cal_PtcPwrDesValPID_KpPos,
               cal_PtcPwrDesValPID_Kp, (float32 *)&ACCtl_pwrHeatingPCor);

  /* End of Outputs for SubSystem: '<S104>/P_POS' */

  /* Outputs for Enabled SubSystem: '<S105>/P_NEG' */
  /* Logic: '<S105>/Logical Operator' incorporates:
   *  Constant: '<S94>/Constant6'
   *  Constant: '<S94>/Kp7'
   *  Constant: '<S94>/Kp9'
   */
  ME11_P_NEG(!ACCtl_tErrACPTCPosFlag, ACCtl_tErrACPTC,
             cal_PtcPwrDesValPIDDeadBandNeg, cal_PtcPwrDesValPID_KiNeg,
             cal_PtcPwrDesValPID_Ki, (float32 *)&ACCtl_pwrHeatingICor);

  /* End of Outputs for SubSystem: '<S105>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S105>/P_POS' */
  /* Constant: '<S94>/Constant7' incorporates:
   *  Constant: '<S94>/Kp10'
   *  Constant: '<S94>/Kp7'
   */
  ME11_P_POS(ACCtl_tErrACPTCPosFlag, ACCtl_tErrACPTC,
             cal_PtcPwrDesValPIDDeadBandPos, cal_PtcPwrDesValPID_KiPos,
             cal_PtcPwrDesValPID_Ki, (float32 *)&ACCtl_pwrHeatingICor);

  /* End of Outputs for SubSystem: '<S105>/P_POS' */

  /* Switch: '<S101>/Switch1' */
  if (rtb_LogicalOperator_k0) {
    /* MultiPortSwitch: '<S105>/Multiport Switch' incorporates:
     *  Delay: '<S105>/Delay'
     */
    switch (ME11__ARID_DEF_arg->Delay_DSTATE_l) {
     case 0:
      /* Switch: '<S109>/Switch' */
      if (ACCtl_tErrACPTCPosFlag) {
        /* Switch: '<S106>/Switch2' incorporates:
         *  Delay: '<S101>/Delay'
         *  Sum: '<S109>/Add'
         *  Switch: '<S109>/Switch'
         */
        ACCtl_pwrHeatingISum = ACCtl_pwrHeatingISum + ACCtl_pwrHeatingICor;
      } else {
        /* Switch: '<S106>/Switch2' incorporates:
         *  Delay: '<S101>/Delay'
         *  Sum: '<S109>/Add1'
         *  Switch: '<S109>/Switch'
         */
        ACCtl_pwrHeatingISum = ACCtl_pwrHeatingISum - ACCtl_pwrHeatingICor;
      }

      /* End of Switch: '<S109>/Switch' */
      break;

     case 1:
      /* Switch: '<S110>/Switch' */
      if (!ACCtl_tErrACPTCPosFlag) {
        /* Switch: '<S106>/Switch2' incorporates:
         *  Delay: '<S101>/Delay'
         *  Sum: '<S110>/Add1'
         *  Switch: '<S110>/Switch'
         */
        ACCtl_pwrHeatingISum = ACCtl_pwrHeatingISum - ACCtl_pwrHeatingICor;
      }

      /* End of Switch: '<S110>/Switch' */
      break;

     case 2:
      /* Switch: '<S107>/Switch' */
      if (ACCtl_tErrACPTCPosFlag) {
        /* Switch: '<S106>/Switch2' incorporates:
         *  Delay: '<S101>/Delay'
         *  Sum: '<S107>/Add'
         *  Switch: '<S107>/Switch'
         */
        ACCtl_pwrHeatingISum = ACCtl_pwrHeatingISum + ACCtl_pwrHeatingICor;
      }

      /* End of Switch: '<S107>/Switch' */
      break;

     case 3:
      break;
    }

    /* End of MultiPortSwitch: '<S105>/Multiport Switch' */

    /* Switch: '<S106>/Switch2' incorporates:
     *  Constant: '<S94>/Kp13'
     *  Constant: '<S94>/Kp8'
     *  RelationalOperator: '<S106>/LowerRelop1'
     *  RelationalOperator: '<S106>/UpperRelop'
     *  Sum: '<S101>/Add'
     *  Switch: '<S106>/Switch'
     */
    if (ACCtl_pwrHeatingISum > cal_PtcPwrDesValPID_IsumMax) {
      /* Switch: '<S101>/Switch1' incorporates:
       *  Switch: '<S106>/Switch2'
       */
      ACCtl_pwrHeatingISum = cal_PtcPwrDesValPID_IsumMax;
    } else if (ACCtl_pwrHeatingISum < cal_PtcPwrDesValPID_IsumMin) {
      /* Switch: '<S106>/Switch' incorporates:
       *  Constant: '<S94>/Kp13'
       *  Switch: '<S101>/Switch1'
       *  Switch: '<S106>/Switch2'
       */
      ACCtl_pwrHeatingISum = cal_PtcPwrDesValPID_IsumMin;
    }

    /* End of Switch: '<S106>/Switch2' */
  } else {
    /* Switch: '<S101>/Switch1' incorporates:
     *  Constant: '<S94>/Constant5'
     */
    ACCtl_pwrHeatingISum = 0.0F;
  }

  /* End of Switch: '<S101>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S103>/PI_Controller' */
  /* DataTypeConversion: '<S94>/Data Type Conversion' incorporates:
   *  Constant: '<S94>/Kp5'
   *  Constant: '<S94>/Kp6'
   */
  ME11_PI_Controller(rtb_LogicalOperator_k0, ACCtl_tErrACPTCPosFlag, (float32)
                     ACCtl_pwrHeatingFeed, ACCtl_pwrHeatingPCor,
                     ACCtl_pwrHeatingISum, (float32)cal_PtcPwrDesValPID_UL,
                     (float32)cal_PtcPwrDesValPID_LL, &rtb_PI_Cor_aw,
                     &rtb_IFreezFlag_mt);

  /* End of Outputs for SubSystem: '<S103>/PI_Controller' */

  /* DataTypeConversion: '<S94>/Data Type Conversion1' */
  rty_ACCtl_pwrHeatingReq_0 = (uint16)rtb_PI_Cor_aw;

  /* Update for Delay: '<S105>/Delay' incorporates:
   *  Delay: '<S94>/Delay1'
   */
  ME11__ARID_DEF_arg->Delay_DSTATE_l = ME11__ARID_DEF_arg->Delay1_DSTATE;

  /* Update for Delay: '<S94>/Delay1' */
  ME11__ARID_DEF_arg->Delay1_DSTATE = rtb_IFreezFlag_mt;
  return rty_ACCtl_pwrHeatingReq_0;
}

/*
 * Output and update for action system:
 *    '<S47>/ACCtlRecForPTCDvt'
 *    '<S47>/ACCtlRecForTargetOutTemp'
 *    '<S47>/ACCtlRecForTempLow'
 *    '<S47>/ACCtlRecForAQS'
 *    '<S47>/ACCtlRecLevelForPCUTemp'
 *    '<S47>/ACCtlRecForRemoteAC'
 */
void ME11_ACCtlRecForPTCDvt(boolean *rty_ACCtl_stRecOut, uint8
  *rty_ACCtl_rIntakeDoor)
{
  /* SignalConversion generated from: '<S147>/ACCtl_stRecOut' incorporates:
   *  Constant: '<S147>/Constant'
   */
  *rty_ACCtl_stRecOut = true;

  /* SignalConversion generated from: '<S147>/ACCtl_rIntakeDoor' incorporates:
   *  Constant: '<S147>/Constant1'
   */
  *rty_ACCtl_rIntakeDoor = 100U;
}

/*
 * System initialize for atomic system:
 *    '<S232>/deadzone'
 *    '<S251>/deadzone'
 *    '<S345>/deadzone'
 *    '<S367>/deadzone'
 *    '<S397>/deadzone'
 *    '<S421>/deadzone'
 */
void ME11_deadzone_a_Init(boolean *rty_flag)
{
  *rty_flag = false;
}

/*
 * Output and update for atomic system:
 *    '<S232>/deadzone'
 *    '<S251>/deadzone'
 *    '<S345>/deadzone'
 *    '<S367>/deadzone'
 *    '<S397>/deadzone'
 *    '<S421>/deadzone'
 */
void ME11_deadzone_h(float32 rtu_u, float64 rtu_Deadzone, boolean *rty_flag)
{
  /* Chart: '<S232>/deadzone' */
  *rty_flag = ((float32)fabs(rtu_u) < rtu_Deadzone);
}

/*
 * System initialize for atomic system:
 *    '<S497>/OverDuty1'
 *    '<S497>/OverDuty2'
 *    '<S497>/OverDuty3'
 *    '<S497>/OverDuty4'
 *    '<S497>/OverDuty5'
 */
void ME11_OverDuty1_Init(float64 *rty_Sts, float64 *rty_ClearFlt)
{
  *rty_Sts = 0.0;
  *rty_ClearFlt = 0.0;
}

/*
 * Output and update for atomic system:
 *    '<S497>/OverDuty1'
 *    '<S497>/OverDuty2'
 *    '<S497>/OverDuty3'
 *    '<S497>/OverDuty4'
 *    '<S497>/OverDuty5'
 */
void ME11_OverDuty1(uint8 rtu_PWRCtl_eTMSStatus, boolean rtu_FaultFlg, float64
                    *rty_Sts, float64 *rty_ClearFlt, ARID_DEF_OverDuty1_ME11_T
                    *ME11__ARID_DEF_arg)
{
  sint32 tmp;
  if (ME11__ARID_DEF_arg->temporalCounter_i1 < 31U) {
    ME11__ARID_DEF_arg->temporalCounter_i1++;
  }

  if (ME11__ARID_DEF_arg->temporalCounter_i2 < 511U) {
    ME11__ARID_DEF_arg->temporalCounter_i2++;
  }

  /* Chart: '<S497>/OverDuty1' */
  if (ME11__ARID_DEF_arg->is_active_c36_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c36_ME11 = 1U;
    ME11__ARID_DEF_arg->is_FaultJudge = ME11_IN_Normal;
    *rty_Sts = 0.0;
    ME11__ARID_DEF_arg->is_ClearFault = ME11_IN_HVOff;
    ME11__ARID_DEF_arg->Count = 0U;
    *rty_ClearFlt = 0.0;
  } else {
    switch (ME11__ARID_DEF_arg->is_FaultJudge) {
     case ME11_IN_Fault:
      *rty_Sts = 1.0;
      if ((!rtu_FaultFlg) && (ME11__ARID_DEF_arg->Count < 4)) {
        ME11__ARID_DEF_arg->is_FaultJudge = ME11_IN_Normal;
        *rty_Sts = 0.0;
      }
      break;

     case ME11_IN_Normal:
      *rty_Sts = 0.0;
      if (rtu_FaultFlg && (*rty_ClearFlt == 0.0)) {
        ME11__ARID_DEF_arg->is_FaultJudge = ME11_IN_wait;
        ME11__ARID_DEF_arg->temporalCounter_i1 = 0U;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11__ARID_DEF_arg->temporalCounter_i1 >= 20U) {
        ME11__ARID_DEF_arg->is_FaultJudge = ME11_IN_Fault;
        *rty_Sts = 1.0;
      } else if (!rtu_FaultFlg) {
        ME11__ARID_DEF_arg->is_FaultJudge = ME11_IN_Normal;
        *rty_Sts = 0.0;
      }
      break;
    }

    if (ME11__ARID_DEF_arg->is_ClearFault == ME11_IN_HVOff) {
      *rty_ClearFlt = 0.0;
      if (rtu_PWRCtl_eTMSStatus >= 2) {
        ME11__ARID_DEF_arg->is_ClearFault = ME11_IN_HVOn;
        ME11__ARID_DEF_arg->is_HVOn = ME11_IN_Normal;
        *rty_ClearFlt = 0.0;
      }

      /* case IN_HVOn: */
    } else if (rtu_PWRCtl_eTMSStatus < 2) {
      ME11__ARID_DEF_arg->is_HVOn = ME11_IN_NO_ACTIVE_CHILD;
      ME11__ARID_DEF_arg->is_ClearFault = ME11_IN_HVOff;
      ME11__ARID_DEF_arg->Count = 0U;
      *rty_ClearFlt = 0.0;
    } else {
      switch (ME11__ARID_DEF_arg->is_HVOn) {
       case ME11_IN_Clear:
        *rty_ClearFlt = 1.0;
        if (ME11__ARID_DEF_arg->temporalCounter_i2 >= 5U) {
          ME11__ARID_DEF_arg->is_HVOn = ME11_IN_wait1;
          ME11__ARID_DEF_arg->temporalCounter_i2 = 0U;
          *rty_ClearFlt = 0.0;
        }
        break;

       case ME11_IN_Normal:
        *rty_ClearFlt = 0.0;
        if ((*rty_Sts == 1.0) && (ME11__ARID_DEF_arg->Count < 4)) {
          ME11__ARID_DEF_arg->is_HVOn = ME11_IN_wait;
          ME11__ARID_DEF_arg->temporalCounter_i2 = 0U;
        }
        break;

       case ME11_IN_wait:
        if (ME11__ARID_DEF_arg->temporalCounter_i2 >= 50U) {
          ME11__ARID_DEF_arg->is_HVOn = ME11_IN_Clear;
          ME11__ARID_DEF_arg->temporalCounter_i2 = 0U;
          *rty_ClearFlt = 1.0;
          tmp = ME11__ARID_DEF_arg->Count + 1;
          if (ME11__ARID_DEF_arg->Count + 1 > 255) {
            tmp = 255;
          }

          ME11__ARID_DEF_arg->Count = (uint8)tmp;
        }
        break;

       default:
        /* case IN_wait1: */
        *rty_ClearFlt = 0.0;
        if (ME11__ARID_DEF_arg->temporalCounter_i2 >= 300U) {
          ME11__ARID_DEF_arg->is_HVOn = ME11_IN_Normal;
          *rty_ClearFlt = 0.0;
        }
        break;
      }
    }
  }

  /* End of Chart: '<S497>/OverDuty1' */
}

/*
 * System initialize for atomic system:
 *    '<S526>/Flg3Cal'
 *    '<S527>/Flg3Cal'
 */
void ME11_Flg3Cal_Init(boolean *rty_ACTCtl_eCOMPFlg3Cal)
{
  *rty_ACTCtl_eCOMPFlg3Cal = false;
}

/*
 * Output and update for atomic system:
 *    '<S526>/Flg3Cal'
 *    '<S527>/Flg3Cal'
 */
void ME11_Flg3Cal(float32 rtu_HPFlg3, boolean *rty_ACTCtl_eCOMPFlg3Cal,
                  ARID_DEF_Flg3Cal_ME11_T *ME11__ARID_DEF_arg)
{
  /* Chart: '<S526>/Flg3Cal' */
  if (ME11__ARID_DEF_arg->is_active_c34_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c34_ME11 = 1U;
    ME11__ARID_DEF_arg->is_c34_ME11 = ME11_IN_Default;
    *rty_ACTCtl_eCOMPFlg3Cal = false;
  } else if (ME11__ARID_DEF_arg->is_c34_ME11 == ME11_IN_Default) {
    *rty_ACTCtl_eCOMPFlg3Cal = false;
    if (rtu_HPFlg3 == 1.0F) {
      ME11__ARID_DEF_arg->is_c34_ME11 = ME11_IN_Flg3;
      *rty_ACTCtl_eCOMPFlg3Cal = true;
    }
  } else {
    /* case IN_Flg3: */
    *rty_ACTCtl_eCOMPFlg3Cal = true;
    if (rtu_HPFlg3 == 0.0F) {
      ME11__ARID_DEF_arg->is_c34_ME11 = ME11_IN_Default;
      *rty_ACTCtl_eCOMPFlg3Cal = false;
    }
  }

  /* End of Chart: '<S526>/Flg3Cal' */
}

/*
 * System initialize for atomic system:
 *    '<S572>/PwrOn'
 *    '<S573>/PwrOn'
 *    '<S744>/PwrOn'
 *    '<S745>/PwrOn'
 *    '<S814>/PwrOn'
 *    '<S815>/PwrOn'
 *    '<S830>/PwrOn'
 *    '<S831>/PwrOn'
 */
void ME11_PwrOn_Init(boolean *rty_flg)
{
  *rty_flg = false;
}

/*
 * Output and update for atomic system:
 *    '<S572>/PwrOn'
 *    '<S573>/PwrOn'
 *    '<S744>/PwrOn'
 *    '<S745>/PwrOn'
 *    '<S814>/PwrOn'
 *    '<S815>/PwrOn'
 *    '<S830>/PwrOn'
 *    '<S831>/PwrOn'
 */
void ME11_PwrOn(boolean *rty_flg, ARID_DEF_PwrOn_ME11_T *ME11__ARID_DEF_arg)
{
  if (ME11__ARID_DEF_arg->temporalCounter_i1 < 15U) {
    ME11__ARID_DEF_arg->temporalCounter_i1++;
  }

  /* Chart: '<S572>/PwrOn' */
  if (ME11__ARID_DEF_arg->is_active_c5_ME11Lib == 0U) {
    ME11__ARID_DEF_arg->is_active_c5_ME11Lib = 1U;
    ME11__ARID_DEF_arg->is_c5_ME11Lib = ME11_IN_Off;
    ME11__ARID_DEF_arg->temporalCounter_i1 = 0U;
    *rty_flg = true;
  } else if (ME11__ARID_DEF_arg->is_c5_ME11Lib == ME11_IN_Off) {
    *rty_flg = true;
    if (ME11__ARID_DEF_arg->temporalCounter_i1 >= 10U) {
      ME11__ARID_DEF_arg->is_c5_ME11Lib = ME11_IN_On;
      *rty_flg = false;
    }
  } else {
    /* case IN_On: */
    *rty_flg = false;
  }

  /* End of Chart: '<S572>/PwrOn' */
}

/*
 * System initialize for atomic system:
 *    '<S453>/deadzone'
 *    '<S682>/deadzone'
 *    '<S753>/deadzone'
 *    '<S824>/deadzone'
 */
void ME11_deadzone_p_Init(boolean *rty_flag)
{
  *rty_flag = false;
}

/*
 * Output and update for atomic system:
 *    '<S453>/deadzone'
 *    '<S682>/deadzone'
 *    '<S753>/deadzone'
 *    '<S824>/deadzone'
 */
void ME11_deadzone_h1(float32 rtu_u, float32 rtu_Deadzone, boolean *rty_flag)
{
  /* Chart: '<S453>/deadzone' */
  *rty_flag = ((float32)fabs(rtu_u) < rtu_Deadzone);
}

/*
 * System initialize for enable system:
 *    '<S583>/Descending_filter'
 *    '<S586>/Descending_filter'
 *    '<S715>/Descending_filter'
 *    '<S716>/Descending_filter'
 *    '<S783>/Descending_filter'
 *    '<S784>/Descending_filter'
 *    '<S861>/Descending_filter'
 *    '<S862>/Descending_filter'
 */
void ME11_Descending_filter_Init(ARID_DEF_Descending_filter_ME11_T
  *ME11__ARID_DEF_arg)
{
  /* InitializeConditions for UnitDelay: '<S601>/FixPt Unit Delay2' */
  ME11__ARID_DEF_arg->FixPtUnitDelay2_DSTATE = 1U;
}

/*
 * Output and update for enable system:
 *    '<S583>/Descending_filter'
 *    '<S586>/Descending_filter'
 *    '<S715>/Descending_filter'
 *    '<S716>/Descending_filter'
 *    '<S783>/Descending_filter'
 *    '<S784>/Descending_filter'
 *    '<S861>/Descending_filter'
 *    '<S862>/Descending_filter'
 */
void ME11_Descending_filter(boolean rtu_Enable, float32 rtu_Add, float32 rtu_Dec,
  float32 rtu_Speed, float32 rtu_COMP_EcompActSpd, float32 *rty_Y,
  ARID_DEF_Descending_filter_ME11_T *ME11__ARID_DEF_arg)
{
  /* Outputs for Enabled SubSystem: '<S583>/Descending_filter' incorporates:
   *  EnablePort: '<S596>/Enable'
   */
  if (rtu_Enable) {
    /* Switch: '<S601>/Init' incorporates:
     *  UnitDelay: '<S601>/FixPt Unit Delay1'
     *  UnitDelay: '<S601>/FixPt Unit Delay2'
     */
    if (ME11__ARID_DEF_arg->FixPtUnitDelay2_DSTATE != 0) {
      *rty_Y = rtu_Add;
    } else {
      *rty_Y = ME11__ARID_DEF_arg->FixPtUnitDelay1_DSTATE;
    }

    /* End of Switch: '<S601>/Init' */

    /* Switch: '<S596>/Switch2' incorporates:
     *  Constant: '<S599>/Constant'
     *  Constant: '<S600>/Constant'
     *  Delay: '<S596>/Delay'
     *  Logic: '<S596>/AND1'
     *  RelationalOperator: '<S599>/Compare'
     *  RelationalOperator: '<S600>/Compare'
     */
    if ((ME11__ARID_DEF_arg->Delay_DSTATE < 800.0F) && (rtu_COMP_EcompActSpd >=
         800.0F)) {
      /* Sum: '<S596>/Sum1' incorporates:
       *  UnitDelay: '<S601>/FixPt Unit Delay1'
       */
      ME11__ARID_DEF_arg->FixPtUnitDelay1_DSTATE = rtu_Add;
    } else {
      /* Sum: '<S596>/Sum1' incorporates:
       *  Sum: '<S596>/Sum2'
       *  Sum: '<S596>/Sum3'
       *  Switch: '<S596>/Switch'
       */
      ME11__ARID_DEF_arg->FixPtUnitDelay1_DSTATE = *rty_Y - rtu_Speed;

      /* Switch: '<S596>/Switch' incorporates:
       *  Constant: '<S597>/Constant'
       *  RelationalOperator: '<S597>/Compare'
       *  Sum: '<S596>/Sum2'
       */
      if (ME11__ARID_DEF_arg->FixPtUnitDelay1_DSTATE - rtu_Dec <= 0.0F) {
        /* Sum: '<S596>/Sum1' incorporates:
         *  Sum: '<S596>/Sum4'
         *  Switch: '<S596>/Switch1'
         */
        ME11__ARID_DEF_arg->FixPtUnitDelay1_DSTATE = *rty_Y + rtu_Speed;

        /* Switch: '<S596>/Switch1' incorporates:
         *  Constant: '<S598>/Constant'
         *  RelationalOperator: '<S598>/Compare'
         *  Sum: '<S596>/Sum1'
         */
        if (ME11__ARID_DEF_arg->FixPtUnitDelay1_DSTATE - rtu_Dec >= 0.0F) {
          /* UnitDelay: '<S601>/FixPt Unit Delay1' incorporates:
           *  Switch: '<S596>/Switch1'
           */
          ME11__ARID_DEF_arg->FixPtUnitDelay1_DSTATE = rtu_Dec;
        }
      }
    }

    /* End of Switch: '<S596>/Switch2' */

    /* Update for Delay: '<S596>/Delay' */
    ME11__ARID_DEF_arg->Delay_DSTATE = rtu_COMP_EcompActSpd;

    /* Update for UnitDelay: '<S601>/FixPt Unit Delay2' incorporates:
     *  Constant: '<S601>/FixPt Constant'
     */
    ME11__ARID_DEF_arg->FixPtUnitDelay2_DSTATE = 0U;
  }

  /* End of Outputs for SubSystem: '<S583>/Descending_filter' */
}

/*
 * System initialize for atomic system:
 *    '<S642>/Chart'
 *    '<S664>/Chart'
 */
void ME11_Chart_Init(boolean *rty_Flag)
{
  *rty_Flag = false;
}

/*
 * Output and update for atomic system:
 *    '<S642>/Chart'
 *    '<S664>/Chart'
 */
void ME11_Chart(boolean rtu_Condition, uint16 rtu_Timer, boolean *rty_Flag,
                ARID_DEF_Chart_ME11_T *ME11__ARID_DEF_arg)
{
  /* Chart: '<S642>/Chart' */
  if (ME11__ARID_DEF_arg->is_active_c153_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c153_ME11 = 1U;
    ME11__ARID_DEF_arg->is_c153_ME11 = ME11_IN_Default_f;
    *rty_Flag = false;
    ME11__ARID_DEF_arg->counter = 0U;
  } else {
    switch (ME11__ARID_DEF_arg->is_c153_ME11) {
     case ME11_IN_Default_f:
      *rty_Flag = false;
      if (rtu_Condition) {
        ME11__ARID_DEF_arg->is_c153_ME11 = ME11_IN_wait_n;
      }
      break;

     case ME11_IN_wait_n:
      if (!rtu_Condition) {
        ME11__ARID_DEF_arg->is_c153_ME11 = ME11_IN_Default_f;
        *rty_Flag = false;
        ME11__ARID_DEF_arg->counter = 0U;
      } else if (ME11__ARID_DEF_arg->counter >= rtu_Timer) {
        ME11__ARID_DEF_arg->is_c153_ME11 = ME11_IN_wait1_e;
        *rty_Flag = true;
      } else {
        ME11__ARID_DEF_arg->counter++;
      }
      break;

     default:
      /* case IN_wait1: */
      *rty_Flag = true;
      if (!rtu_Condition) {
        ME11__ARID_DEF_arg->is_c153_ME11 = ME11_IN_Default_f;
        *rty_Flag = false;
        ME11__ARID_DEF_arg->counter = 0U;
      }
      break;
    }
  }

  /* End of Chart: '<S642>/Chart' */
}

/*
 * System initialize for atomic system:
 *    '<S943>/ Abnormal_Over_temperatura_via _software_monitoring'
 *    '<S943>/ Outlet_Temp_High'
 *    '<S943>/Abnormal_Over_temperatura_via _hardware_monitoring'
 *    '<S943>/Core_Temp_High'
 *    '<S943>/Core_Temp_Sensor_Fault'
 *    '<S943>/Current_Sensor_Fault'
 *    '<S943>/HVIL_Fault'
 *    '<S943>/Inlet_Temp_Sensor_Fault'
 *    '<S943>/LV_Over_Voltage'
 *    '<S943>/LV_Under_Voltage'
 *    ...
 */
void ME11_Abnormal_Over_temperatura_via_software_monitoring_Init(boolean
  *rty_ErrSts)
{
  *rty_ErrSts = false;
}

/*
 * Output and update for atomic system:
 *    '<S943>/ Abnormal_Over_temperatura_via _software_monitoring'
 *    '<S943>/ Outlet_Temp_High'
 *    '<S943>/Abnormal_Over_temperatura_via _hardware_monitoring'
 *    '<S943>/Core_Temp_High'
 *    '<S943>/Core_Temp_Sensor_Fault'
 *    '<S943>/Current_Sensor_Fault'
 *    '<S943>/HVIL_Fault'
 *    '<S943>/Inlet_Temp_Sensor_Fault'
 *    '<S943>/LV_Over_Voltage'
 *    '<S943>/LV_Under_Voltage'
 *    ...
 */
void ME11_Abnormal_Over_temperatura_via_software_monitoring(boolean rtu_Flg,
  boolean *rty_ErrSts,
  ARID_DEF_Abnormal_Over_temperatura_via_software_monitoring_ME11_T
  *ME11__ARID_DEF_arg)
{
  if (ME11__ARID_DEF_arg->temporalCounter_i1 < 7U) {
    ME11__ARID_DEF_arg->temporalCounter_i1++;
  }

  /* Chart: '<S943>/ Abnormal_Over_temperatura_via _software_monitoring' */
  if (ME11__ARID_DEF_arg->is_active_c119_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c119_ME11 = 1U;
    ME11__ARID_DEF_arg->is_c119_ME11 = ME11_IN_Default_c;
    *rty_ErrSts = false;
  } else {
    switch (ME11__ARID_DEF_arg->is_c119_ME11) {
     case ME11_IN_Default_c:
      *rty_ErrSts = false;
      if (rtu_Flg) {
        ME11__ARID_DEF_arg->is_c119_ME11 = ME11_IN_wait_p;
        ME11__ARID_DEF_arg->temporalCounter_i1 = 0U;
      }
      break;

     case ME11_IN_Err:
      *rty_ErrSts = true;
      if (!rtu_Flg) {
        ME11__ARID_DEF_arg->is_c119_ME11 = ME11_IN_wait1_m;
        ME11__ARID_DEF_arg->temporalCounter_i1 = 0U;
      }
      break;

     case ME11_IN_wait_p:
      if (!rtu_Flg) {
        ME11__ARID_DEF_arg->is_c119_ME11 = ME11_IN_Default_c;
        *rty_ErrSts = false;
      } else if (ME11__ARID_DEF_arg->temporalCounter_i1 >= 5U) {
        ME11__ARID_DEF_arg->is_c119_ME11 = ME11_IN_Err;
        *rty_ErrSts = true;
      }
      break;

     default:
      /* case IN_wait1: */
      if (rtu_Flg) {
        ME11__ARID_DEF_arg->is_c119_ME11 = ME11_IN_Err;
        *rty_ErrSts = true;
      } else if (ME11__ARID_DEF_arg->temporalCounter_i1 >= 5U) {
        ME11__ARID_DEF_arg->is_c119_ME11 = ME11_IN_Default_c;
        *rty_ErrSts = false;
      }
      break;
    }
  }

  /* End of Chart: '<S943>/ Abnormal_Over_temperatura_via _software_monitoring' */
}

/*
 * System initialize for atomic system:
 *    '<S943>/External_Com_Fault'
 *    '<S943>/HV_Over_Voltage'
 *    '<S943>/HV_Under_Voltage'
 *    '<S943>/Inlet_Temp_High'
 *    '<S943>/Internal_Com_Fault'
 *    '<S943>/Internal_Voltage_Fault'
 *    '<S943>/PCB_Temp_High'
 *    '<S943>/Power_Target_Fault'
 */
void ME11_External_Com_Fault_Init(boolean *rty_ErrSts)
{
  *rty_ErrSts = false;
}

/*
 * Output and update for atomic system:
 *    '<S943>/External_Com_Fault'
 *    '<S943>/HV_Over_Voltage'
 *    '<S943>/HV_Under_Voltage'
 *    '<S943>/Inlet_Temp_High'
 *    '<S943>/Internal_Com_Fault'
 *    '<S943>/Internal_Voltage_Fault'
 *    '<S943>/PCB_Temp_High'
 *    '<S943>/Power_Target_Fault'
 */
void ME11_External_Com_Fault(boolean rtu_Flg, boolean *rty_ErrSts,
  ARID_DEF_External_Com_Fault_ME11_T *ME11__ARID_DEF_arg)
{
  if (ME11__ARID_DEF_arg->temporalCounter_i1 < 31U) {
    ME11__ARID_DEF_arg->temporalCounter_i1++;
  }

  /* Chart: '<S943>/External_Com_Fault' */
  if (ME11__ARID_DEF_arg->is_active_c66_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c66_ME11 = 1U;
    ME11__ARID_DEF_arg->is_c66_ME11 = ME11_IN_Default_d;
    *rty_ErrSts = false;
  } else {
    switch (ME11__ARID_DEF_arg->is_c66_ME11) {
     case ME11_IN_Default_d:
      *rty_ErrSts = false;
      if (rtu_Flg) {
        ME11__ARID_DEF_arg->is_c66_ME11 = ME11_IN_wait_o;
        ME11__ARID_DEF_arg->temporalCounter_i1 = 0U;
      }
      break;

     case ME11_IN_Err_b:
      *rty_ErrSts = true;
      if (!rtu_Flg) {
        ME11__ARID_DEF_arg->is_c66_ME11 = ME11_IN_wait1_d;
        ME11__ARID_DEF_arg->temporalCounter_i1 = 0U;
      }
      break;

     case ME11_IN_wait_o:
      if (!rtu_Flg) {
        ME11__ARID_DEF_arg->is_c66_ME11 = ME11_IN_Default_d;
        *rty_ErrSts = false;
      } else if (ME11__ARID_DEF_arg->temporalCounter_i1 >= 20U) {
        ME11__ARID_DEF_arg->is_c66_ME11 = ME11_IN_Err_b;
        *rty_ErrSts = true;
      }
      break;

     default:
      /* case IN_wait1: */
      if (rtu_Flg) {
        ME11__ARID_DEF_arg->is_c66_ME11 = ME11_IN_Err_b;
        *rty_ErrSts = true;
      } else if (ME11__ARID_DEF_arg->temporalCounter_i1 >= 20U) {
        ME11__ARID_DEF_arg->is_c66_ME11 = ME11_IN_Default_d;
        *rty_ErrSts = false;
      }
      break;
    }
  }

  /* End of Chart: '<S943>/External_Com_Fault' */
}

/*
 * System initialize for atomic system:
 *    '<S1022>/AcPMPFaultJudge'
 *    '<S1024>/AcPMPFaultJudge'
 */
void ME11_AcPMPFaultJudge_Init(boolean *rty_ACTCtl_bAcPMPFaultFlg)
{
  *rty_ACTCtl_bAcPMPFaultFlg = false;
}

/*
 * Output and update for atomic system:
 *    '<S1022>/AcPMPFaultJudge'
 *    '<S1024>/AcPMPFaultJudge'
 */
void ME11_AcPMPFaultJudge(boolean rtu_AcPMPFaultFlg, boolean
  *rty_ACTCtl_bAcPMPFaultFlg, ARID_DEF_AcPMPFaultJudge_ME11_T
  *ME11__ARID_DEF_arg)
{
  if (ME11__ARID_DEF_arg->temporalCounter_i1 < 127U) {
    ME11__ARID_DEF_arg->temporalCounter_i1++;
  }

  /* Chart: '<S1022>/AcPMPFaultJudge' */
  if (ME11__ARID_DEF_arg->is_active_c90_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c90_ME11 = 1U;
    ME11__ARID_DEF_arg->is_c90_ME11 = ME11_IN_Normal_f;
    *rty_ACTCtl_bAcPMPFaultFlg = false;
  } else {
    switch (ME11__ARID_DEF_arg->is_c90_ME11) {
     case ME11_IN_Fault_a:
      if (!rtu_AcPMPFaultFlg) {
        ME11__ARID_DEF_arg->is_c90_ME11 = ME11_IN_Normal_f;
        *rty_ACTCtl_bAcPMPFaultFlg = false;
      }
      break;

     case ME11_IN_Normal_f:
      if (rtu_AcPMPFaultFlg) {
        ME11__ARID_DEF_arg->is_c90_ME11 = ME11_IN_wait_g;
        ME11__ARID_DEF_arg->temporalCounter_i1 = 0U;
      }
      break;

     default:
      /* case IN_wait: */
      if (!rtu_AcPMPFaultFlg) {
        ME11__ARID_DEF_arg->is_c90_ME11 = ME11_IN_Normal_f;
        *rty_ACTCtl_bAcPMPFaultFlg = false;
      } else if (ME11__ARID_DEF_arg->temporalCounter_i1 >= 100U) {
        ME11__ARID_DEF_arg->is_c90_ME11 = ME11_IN_Fault_a;
        *rty_ACTCtl_bAcPMPFaultFlg = true;
      }
      break;
    }
  }

  /* End of Chart: '<S1022>/AcPMPFaultJudge' */
}

/*
 * System initialize for atomic system:
 *    '<S1093>/Judge'
 *    '<S1103>/Judge'
 *    '<S1762>/Judge'
 *    '<S1772>/Judge'
 *    '<S1782>/Judge'
 *    '<S1789>/Judge'
 *    '<S1796>/Judge'
 *    '<S1803>/Judge'
 *    '<S1810>/Judge'
 *    '<S1813>/Judge'
 *    ...
 */
void ME11_Judge_Init(uint8 *rty_SenSts)
{
  *rty_SenSts = 0U;
}

/*
 * Output and update for atomic system:
 *    '<S1093>/Judge'
 *    '<S1103>/Judge'
 *    '<S1762>/Judge'
 *    '<S1772>/Judge'
 *    '<S1782>/Judge'
 *    '<S1789>/Judge'
 *    '<S1796>/Judge'
 *    '<S1803>/Judge'
 *    '<S1810>/Judge'
 *    '<S1813>/Judge'
 *    ...
 */
void ME11_Judge(boolean rtu_MaxFlg, boolean rtu_MinFlg, uint8 rtu_timer, uint8
                *rty_SenSts, ARID_DEF_Judge_ME11_T *ME11__ARID_DEF_arg)
{
  sint32 tmp;

  /* Chart: '<S1093>/Judge' */
  if (ME11__ARID_DEF_arg->is_active_c2_ME11Lib == 0U) {
    ME11__ARID_DEF_arg->is_active_c2_ME11Lib = 1U;
    ME11__ARID_DEF_arg->is_c2_ME11Lib = ME11_IN_Init;
    *rty_SenSts = 0U;
    ME11__ARID_DEF_arg->T = 0U;
  } else {
    switch (ME11__ARID_DEF_arg->is_c2_ME11Lib) {
     case ME11_IN_Init:
      *rty_SenSts = 0U;
      if (rtu_MinFlg || rtu_MaxFlg) {
        ME11__ARID_DEF_arg->is_c2_ME11Lib = ME11_IN_judge;
        if (rtu_MinFlg) {
          ME11__ARID_DEF_arg->is_judge = ME11_IN_MinJudge;
          *rty_SenSts = 0U;
          tmp = ME11__ARID_DEF_arg->T + 1;
          if (ME11__ARID_DEF_arg->T + 1 > 255) {
            tmp = 255;
          }

          ME11__ARID_DEF_arg->T = (uint8)tmp;
        } else {
          ME11__ARID_DEF_arg->is_judge = ME11_IN_MaxJudge;
          *rty_SenSts = 0U;
          tmp = ME11__ARID_DEF_arg->T + 1;
          if (ME11__ARID_DEF_arg->T + 1 > 255) {
            tmp = 255;
          }

          ME11__ARID_DEF_arg->T = (uint8)tmp;
        }
      }
      break;

     case ME11_IN_judge:
      if ((!rtu_MinFlg) && (!rtu_MaxFlg)) {
        ME11__ARID_DEF_arg->is_judge = ME11_IN_NO_ACTIVE_CHILD_g;
        ME11__ARID_DEF_arg->is_c2_ME11Lib = ME11_IN_wait_h;
        tmp = ME11__ARID_DEF_arg->T + 1;
        if (ME11__ARID_DEF_arg->T + 1 > 255) {
          tmp = 255;
        }

        ME11__ARID_DEF_arg->T = (uint8)tmp;
      } else {
        switch (ME11__ARID_DEF_arg->is_judge) {
         case ME11_IN_MaxErr:
          *rty_SenSts = 2U;
          break;

         case ME11_IN_MaxJudge:
          *rty_SenSts = 0U;
          if (ME11__ARID_DEF_arg->T > rtu_timer) {
            ME11__ARID_DEF_arg->is_judge = ME11_IN_MaxErr;
            *rty_SenSts = 2U;
            ME11__ARID_DEF_arg->T = 0U;
          } else if (rtu_MinFlg) {
            ME11__ARID_DEF_arg->is_judge = ME11_IN_MinJudge;
            *rty_SenSts = 0U;
            ME11__ARID_DEF_arg->T = 1U;
          } else {
            tmp = ME11__ARID_DEF_arg->T + 1;
            if (ME11__ARID_DEF_arg->T + 1 > 255) {
              tmp = 255;
            }

            ME11__ARID_DEF_arg->T = (uint8)tmp;
          }
          break;

         case ME11_IN_MinErr:
          *rty_SenSts = 1U;
          break;

         default:
          /* case IN_MinJudge: */
          *rty_SenSts = 0U;
          if (rtu_MaxFlg) {
            ME11__ARID_DEF_arg->is_judge = ME11_IN_MaxJudge;
            *rty_SenSts = 0U;
            ME11__ARID_DEF_arg->T = 1U;
          } else if (ME11__ARID_DEF_arg->T > rtu_timer) {
            ME11__ARID_DEF_arg->is_judge = ME11_IN_MinErr;
            *rty_SenSts = 1U;
            ME11__ARID_DEF_arg->T = 0U;
          } else {
            tmp = ME11__ARID_DEF_arg->T + 1;
            if (ME11__ARID_DEF_arg->T + 1 > 255) {
              tmp = 255;
            }

            ME11__ARID_DEF_arg->T = (uint8)tmp;
          }
          break;
        }
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11__ARID_DEF_arg->T > rtu_timer) {
        ME11__ARID_DEF_arg->is_c2_ME11Lib = ME11_IN_Init;
        *rty_SenSts = 0U;
        ME11__ARID_DEF_arg->T = 0U;
      } else {
        tmp = ME11__ARID_DEF_arg->T + 1;
        if (ME11__ARID_DEF_arg->T + 1 > 255) {
          tmp = 255;
        }

        ME11__ARID_DEF_arg->T = (uint8)tmp;
      }
      break;
    }
  }

  /* End of Chart: '<S1093>/Judge' */
}

/*
 * System initialize for atomic system:
 *    '<S1223>/Delay'
 *    '<S1230>/Delay'
 */
void ME11_Delay_Init(boolean *rty_C)
{
  *rty_C = false;
}

/*
 * Output and update for atomic system:
 *    '<S1223>/Delay'
 *    '<S1230>/Delay'
 */
void ME11_Delay(boolean rtu_A, boolean *rty_C, ARID_DEF_Delay_ME11_T
                *ME11__ARID_DEF_arg)
{
  if (ME11__ARID_DEF_arg->temporalCounter_i1 < 63U) {
    ME11__ARID_DEF_arg->temporalCounter_i1++;
  }

  /* Chart: '<S1223>/Delay' */
  if (ME11__ARID_DEF_arg->is_active_c155_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c155_ME11 = 1U;
    ME11__ARID_DEF_arg->is_c155_ME11 = ME11_IN_Off_e;
    *rty_C = false;
  } else {
    switch (ME11__ARID_DEF_arg->is_c155_ME11) {
     case ME11_IN_Off_e:
      *rty_C = false;
      if (rtu_A) {
        ME11__ARID_DEF_arg->is_c155_ME11 = ME11_IN_On_l;
        *rty_C = true;
      }
      break;

     case ME11_IN_On_l:
      *rty_C = true;
      if (!rtu_A) {
        ME11__ARID_DEF_arg->is_c155_ME11 = ME11_IN_Wait;
        ME11__ARID_DEF_arg->temporalCounter_i1 = 0U;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11__ARID_DEF_arg->temporalCounter_i1 >= 50U) {
        ME11__ARID_DEF_arg->is_c155_ME11 = ME11_IN_Off_e;
        *rty_C = false;
      } else if (rtu_A) {
        ME11__ARID_DEF_arg->is_c155_ME11 = ME11_IN_On_l;
        *rty_C = true;
      }
      break;
    }
  }

  /* End of Chart: '<S1223>/Delay' */
}

/* System initialize for atomic system: '<S2>/IODriver' */
void ME11_TMSIODriverFunc_Init(void)
{
  /* SystemInitialize for Chart: '<S1223>/Delay' */
  ME11_Delay_Init(&ME11_TMSIODriverFunc_ARID_DEF.C_i);

  /* SystemInitialize for Chart: '<S1230>/Delay' */
  ME11_Delay_Init(&ME11_TMSIODriverFunc_ARID_DEF.C_g);
}

/* Outputs for atomic system: '<S2>/IODriver' */
void ME11_TMSIODriverFunc(void)
{
  sint32 tmp;
  uint8 rtb_CCaller_d;
  uint8 rtb_Gain2_g3;
  uint8 rtb_Switch_fds;
  boolean rtb_Switch_cc;
  boolean rtb_Switch_kk;

  /* Switch: '<S1242>/Switch' incorporates:
   *  Constant: '<S1242>/Constant1'
   *  RelationalOperator: '<S1244>/LowerRelop1'
   *  RelationalOperator: '<S1244>/UpperRelop'
   *  Switch: '<S1244>/Switch'
   *  Switch: '<S1244>/Switch2'
   */
  if (cal_BlwFanEnb) {
    /* Switch: '<S1242>/Switch' incorporates:
     *  Constant: '<S1242>/Constant'
     */
    IOCtl_BloweFanSpeed = cal_BlwFanData;
  } else if (ACCtl_BloweFanSpeed > ME11_TMSIODriverFunc_ARID_DEF.Delay_DSTATE) {
    /* Switch: '<S1244>/Switch2' incorporates:
     *  Switch: '<S1242>/Switch'
     */
    IOCtl_BloweFanSpeed = ME11_TMSIODriverFunc_ARID_DEF.Delay_DSTATE;
  } else if (ACCtl_BloweFanSpeed < AC_BlowerFanSpeedMin) {
    /* Switch: '<S1244>/Switch' incorporates:
     *  Switch: '<S1242>/Switch'
     *  Switch: '<S1244>/Switch2'
     */
    IOCtl_BloweFanSpeed = AC_BlowerFanSpeedMin;
  } else {
    /* Switch: '<S1242>/Switch' incorporates:
     *  Switch: '<S1244>/Switch'
     *  Switch: '<S1244>/Switch2'
     */
    IOCtl_BloweFanSpeed = ACCtl_BloweFanSpeed;
  }

  /* End of Switch: '<S1242>/Switch' */

  /* Switch: '<S1259>/Switch' incorporates:
   *  Constant: '<S1224>/Constant'
   *  Sum: '<S1224>/Add'
   */
  rtb_Switch_fds = (uint8)(100 - IOCtl_BloweFanSpeed);

  /* CCaller: '<S1224>/C Caller' incorporates:
   *  Constant: '<S1224>/Constant'
   *  Constant: '<S1224>/Constant5'
   *  Sum: '<S1224>/Add'
   */
  set_BlwFan(cal_BlwFrqVal, (uint8)(100 - IOCtl_BloweFanSpeed));

  /* CCaller: '<S1224>/C Caller1' incorporates:
   *  Constant: '<S1224>/Constant1'
   */
  Rte_DIDReadData(rtb_Switch_fds, ((uint8)DID_0xF26D));

  /* Switch: '<S1243>/Switch' incorporates:
   *  Constant: '<S1241>/Constant'
   *  Constant: '<S1243>/Constant'
   *  Constant: '<S1243>/Constant1'
   *  RelationalOperator: '<S1241>/Compare'
   */
  if (cal_PwrBlwEnb) {
    rtb_Switch_cc = cal_PwrBlwData;
  } else {
    rtb_Switch_cc = (ME11_ARID_DEF.DataTypeConversion1 >= 2);
  }

  /* CCaller: '<S1224>/C Caller2' incorporates:
   *  DataTypeConversion: '<S1224>/Data Type Conversion1'
   *  Switch: '<S1243>/Switch'
   */
  SetHw_PwrBlower(rtb_Switch_cc);

  /* Switch: '<S1235>/Switch' incorporates:
   *  Constant: '<S1225>/Constant'
   *  Constant: '<S1235>/Constant'
   *  Constant: '<S1235>/Constant1'
   *  RelationalOperator: '<S1225>/Compare'
   */
  if (cal_PwrFanEnb) {
    rtb_Switch_cc = cal_PwrFanData;
  } else {
    rtb_Switch_cc = (ME11_ARID_DEF.DataTypeConversion1 >= 1);
  }

  /* CCaller: '<S13>/C Caller7' incorporates:
   *  DataTypeConversion: '<S13>/Data Type Conversion3'
   *  Switch: '<S1235>/Switch'
   */
  set_PwrFanCabin(rtb_Switch_cc);

  /* Switch: '<S1236>/Switch' incorporates:
   *  Constant: '<S1226>/Constant'
   *  Constant: '<S1236>/Constant'
   *  Constant: '<S1236>/Constant1'
   *  RelationalOperator: '<S1226>/Compare'
   */
  if (cal_PwrSensorEnb) {
    rtb_Switch_cc = cal_PwrSensorData;
  } else {
    rtb_Switch_cc = (ME11_ARID_DEF.DataTypeConversion1 >= 1);
  }

  /* CCaller: '<S13>/C Caller8' incorporates:
   *  DataTypeConversion: '<S13>/Data Type Conversion4'
   *  Switch: '<S1236>/Switch'
   */
  set_PwrSensor(rtb_Switch_cc);

  /* CCaller: '<S1227>/C Caller' incorporates:
   *  Constant: '<S1227>/Constant1'
   */
  rtb_CCaller_d = Rte_IOCtrl(((uint8)IODID_0x0x3237));

  /* Chart: '<S1231>/Delay' */
  if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_h < 15U) {
    ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_h++;
  }

  if (ME11_TMSIODriverFunc_ARID_DEF.is_active_c13_ME11 == 0U) {
    ME11_TMSIODriverFunc_ARID_DEF.is_active_c13_ME11 = 1U;
    ME11_TMSIODriverFunc_ARID_DEF.is_c13_ME11 = ME11_IN_Off_p;
    ME11_TMSIODriverFunc_ARID_DEF.C = false;
  } else {
    switch (ME11_TMSIODriverFunc_ARID_DEF.is_c13_ME11) {
     case ME11_IN_Off_p:
      ME11_TMSIODriverFunc_ARID_DEF.C = false;
      if (ME11_ARID_DEF.DataTypeConversion1 >= 2) {
        ME11_TMSIODriverFunc_ARID_DEF.is_c13_ME11 = ME11_IN_On_i;
        ME11_TMSIODriverFunc_ARID_DEF.C = true;
      }
      break;

     case ME11_IN_On_i:
      ME11_TMSIODriverFunc_ARID_DEF.C = true;
      if (ME11_ARID_DEF.DataTypeConversion1 <= 1) {
        ME11_TMSIODriverFunc_ARID_DEF.is_c13_ME11 = ME11_IN_Wait_j;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_h = 0U;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_h >= 10U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_c13_ME11 = ME11_IN_Off_p;
        ME11_TMSIODriverFunc_ARID_DEF.C = false;
      } else if (ME11_ARID_DEF.DataTypeConversion1 >= 2) {
        ME11_TMSIODriverFunc_ARID_DEF.is_c13_ME11 = ME11_IN_On_i;
        ME11_TMSIODriverFunc_ARID_DEF.C = true;
      }
      break;
    }
  }

  /* End of Chart: '<S1231>/Delay' */

  /* Switch: '<S1254>/Switch' incorporates:
   *  Constant: '<S1252>/Constant'
   *  Constant: '<S1254>/Constant1'
   *  DataStoreRead: '<S1231>/Data Store Read1'
   *  RelationalOperator: '<S1252>/Compare'
   *  Switch: '<S1231>/Switch'
   */
  if (cal_PwrHVPartEnb) {
    /* Switch: '<S1254>/Switch' incorporates:
     *  Constant: '<S1254>/Constant'
     */
    rtb_Switch_cc = cal_PwrHVPartData;
  } else if (Rte_DcmDspData_3237_CtlFlg == 1) {
    /* Switch: '<S1231>/Switch' incorporates:
     *  Constant: '<S1245>/Constant'
     *  RelationalOperator: '<S1245>/Compare'
     *  S-Function (sfix_bitop): '<S1227>/Bitwise Operator1'
     *  Switch: '<S1254>/Switch'
     */
    rtb_Switch_cc = ((rtb_CCaller_d & 1) == 1);
  } else {
    /* Switch: '<S1254>/Switch' incorporates:
     *  Switch: '<S1231>/Switch'
     */
    rtb_Switch_cc = ME11_TMSIODriverFunc_ARID_DEF.C;
  }

  /* End of Switch: '<S1254>/Switch' */

  /* Chart: '<S1223>/Delay' */
  ME11_Delay(rtb_Switch_cc, &ME11_TMSIODriverFunc_ARID_DEF.C_i,
             &ME11_TMSIODriverFunc_ARID_DEF.ARID_DEF_Delay_m);

  /* Switch: '<S1240>/Switch' incorporates:
   *  Constant: '<S1238>/Constant'
   *  Constant: '<S1240>/Constant1'
   *  DataStoreRead: '<S1223>/Data Store Read1'
   *  RelationalOperator: '<S1238>/Compare'
   *  Switch: '<S1223>/Switch2'
   */
  if (cal_PwrACPumpEnb) {
    /* Switch: '<S1277>/Switch' incorporates:
     *  Constant: '<S1240>/Constant'
     */
    rtb_Switch_kk = cal_PwrACPumpData;
  } else if (Rte_DcmDspData_3237_CtlFlg == 1) {
    /* Switch: '<S1223>/Switch2' incorporates:
     *  Constant: '<S1247>/Constant'
     *  RelationalOperator: '<S1247>/Compare'
     *  S-Function (sfix_bitop): '<S1227>/Bitwise Operator3'
     *  Switch: '<S1277>/Switch'
     */
    rtb_Switch_kk = ((rtb_CCaller_d & 4) == 4);
  } else {
    /* Switch: '<S1277>/Switch' incorporates:
     *  Switch: '<S1223>/Switch2'
     */
    rtb_Switch_kk = ME11_TMSIODriverFunc_ARID_DEF.C_i;
  }

  /* End of Switch: '<S1240>/Switch' */

  /* CCaller: '<S1223>/C Caller6' incorporates:
   *  DataTypeConversion: '<S1223>/Data Type Conversion2'
   */
  set_PwrACPump(rtb_Switch_kk);

  /* Gain: '<S1228>/Gain2' */
  rtb_Gain2_g3 = (uint8)(rtb_Switch_kk << 3);

  /* Chart: '<S1230>/Delay' */
  ME11_Delay(rtb_Switch_cc, &ME11_TMSIODriverFunc_ARID_DEF.C_g,
             &ME11_TMSIODriverFunc_ARID_DEF.ARID_DEF_Delay);

  /* Switch: '<S1251>/Switch' incorporates:
   *  Constant: '<S1249>/Constant'
   *  Constant: '<S1251>/Constant1'
   *  DataStoreRead: '<S1230>/Data Store Read1'
   *  RelationalOperator: '<S1249>/Compare'
   *  Switch: '<S1230>/Switch1'
   */
  if (cal_PwrFanAndPumpDataEnb) {
    /* Switch: '<S1259>/Switch' incorporates:
     *  Constant: '<S1251>/Constant'
     */
    rtb_Switch_fds = cal_PwrFanAndPumpData;
  } else if (Rte_DcmDspData_3237_CtlFlg == 1) {
    /* Switch: '<S1230>/Switch1' incorporates:
     *  Constant: '<S1246>/Constant'
     *  RelationalOperator: '<S1246>/Compare'
     *  S-Function (sfix_bitop): '<S1227>/Bitwise Operator2'
     *  Switch: '<S1259>/Switch'
     */
    rtb_Switch_fds = (uint8)((rtb_CCaller_d & 2) == 2);
  } else {
    /* Switch: '<S1259>/Switch' incorporates:
     *  Switch: '<S1230>/Switch1'
     */
    rtb_Switch_fds = ME11_TMSIODriverFunc_ARID_DEF.C_g;
  }

  /* End of Switch: '<S1251>/Switch' */

  /* Switch: '<S1277>/Switch' incorporates:
   *  Constant: '<S1276>/Constant'
   *  Constant: '<S1277>/Constant1'
   *  DataStoreRead: '<S1237>/Data Store Read1'
   *  RelationalOperator: '<S1276>/Compare'
   *  Switch: '<S1237>/Switch5'
   */
  if (cal_SOVEnb) {
    /* Switch: '<S1277>/Switch' incorporates:
     *  Constant: '<S1277>/Constant'
     */
    rtb_Switch_kk = cal_SOVData;
  } else if (Rte_DcmDspData_3237_CtlFlg == 1) {
    /* Switch: '<S1237>/Switch5' incorporates:
     *  Constant: '<S1248>/Constant'
     *  RelationalOperator: '<S1248>/Compare'
     *  S-Function (sfix_bitop): '<S1227>/Bitwise Operator4'
     *  Switch: '<S1277>/Switch'
     */
    rtb_Switch_kk = ((rtb_CCaller_d & 8) == 8);
  } else {
    /* Switch: '<S1277>/Switch' incorporates:
     *  Constant: '<S1279>/Constant'
     *  RelationalOperator: '<S1279>/Compare'
     *  Switch: '<S1237>/Switch5'
     *  Switch: '<S1278>/Switch'
     */
    rtb_Switch_kk = ((ME11_ARID_DEF.DataTypeConversion1 >= 2) && ACTCtl_bSOVCmd);
  }

  /* End of Switch: '<S1277>/Switch' */

  /* Switch: '<S1260>/Switch' incorporates:
   *  Gain: '<S1228>/Gain1'
   *  Gain: '<S1228>/Gain3'
   *  Gain: '<S1228>/Gain4'
   *  Sum: '<S1228>/Add'
   */
  rtb_CCaller_d = (uint8)((((uint32)(rtb_Switch_cc << 2) + rtb_Gain2_g3) +
    (uint32)(rtb_Switch_fds << 1)) + rtb_Switch_kk);

  /* CCaller: '<S1228>/C Caller1' incorporates:
   *  Constant: '<S1228>/Constant1'
   */
  Rte_DIDReadData(rtb_CCaller_d, ((uint8)DID_0xF26F));

  /* RelationalOperator: '<S1228>/Relational Operator' incorporates:
   *  Constant: '<S1228>/Constant'
   */
  IOCtl_PwrNmReqFlg = (rtb_CCaller_d != 0);

  /* CCaller: '<S1230>/C Caller' */
  set_PwrFanAndPump(rtb_Switch_fds);

  /* CCaller: '<S1231>/C Caller5' incorporates:
   *  DataTypeConversion: '<S1231>/Data Type Conversion1'
   */
  set_PwrHVPart(rtb_Switch_cc);

  /* CCaller: '<S1237>/C Caller9' incorporates:
   *  DataTypeConversion: '<S1237>/Data Type Conversion'
   */
  set_PwrSOV(rtb_Switch_kk);

  /* Switch: '<S1273>/Switch' incorporates:
   *  Constant: '<S1234>/Constant'
   *  Constant: '<S1269>/Constant'
   *  Constant: '<S1270>/Constant'
   *  Constant: '<S1273>/Constant1'
   *  DataStoreRead: '<S1234>/Data Store Read'
   *  DataStoreRead: '<S1234>/Data Store Read2'
   *  Logic: '<S1234>/OR1'
   *  MultiPortSwitch: '<S1234>/Index Vector'
   *  RelationalOperator: '<S1269>/Compare'
   *  RelationalOperator: '<S1270>/Compare'
   *  S-Function (sfix_bitop): '<S1234>/Bitwise Operator1'
   *  Switch: '<S1234>/Switch'
   */
  if (cal_ModeMotorTrgPosDataEnb) {
    /* Switch: '<S1273>/Switch' incorporates:
     *  Constant: '<S1273>/Constant'
     */
    IOCtl_sModeMotorTrgPos = cal_ModeMotorTrgPosData;
  } else if (((Buffer_DcmDspData_3238[0] & 4) == 4) &&
             (Rte_DcmDspData_3238_CtlFlg == 1)) {
    /* Switch: '<S1273>/Switch' incorporates:
     *  Constant: '<S1234>/Constant1'
     *  DataStoreRead: '<S1234>/Data Store Read1'
     *  Lookup_n-D: '<S1234>/Rte_TMSPositions_ModeMotor'
     *  MultiPortSwitch: '<S1234>/Index Vector1'
     *  Switch: '<S1234>/Switch'
     */
    IOCtl_sModeMotorTrgPos =
      ME11_ConstP.Rte_TMSPositions_ModeMotor_tableData[plook_u32u8_binckan
      (Buffer_DcmDspData_3238[3],
       ME11_ConstP.Rte_TMSPositions_ModeMotor_bp01Data, 1U)];
  } else {
    /* Switch: '<S1273>/Switch' incorporates:
     *  DataTypeConversion: '<S4>/Data Type Conversion1'
     *  Lookup_n-D: '<S1234>/cal_ModeMotorTrgPos_CUR'
     *  Switch: '<S1234>/Switch'
     */
    IOCtl_sModeMotorTrgPos = cal_ModeMotorTrgPos_CUR[plook_u32u8_binckan
      (ME11_ARID_DEF.DataTypeConversion1_b, (const uint8 *)
       &cal_ModeMotorTrgPos_1X[0], 4U)];
  }

  /* End of Switch: '<S1273>/Switch' */

  /* RelationalOperator: '<S1271>/FixPt Relational Operator' incorporates:
   *  UnitDelay: '<S1271>/Delay Input1'
   *
   * Block description for '<S1271>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_Switch_cc = (IOCtl_sModeMotorTrgPos !=
                   ME11_TMSIODriverFunc_ARID_DEF.DelayInput1_DSTATE);

  /* Chart: '<S1234>/Judge' */
  if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 < 1023U) {
    ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1++;
  }

  if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2 < 15U) {
    ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2++;
  }

  if (ME11_TMSIODriverFunc_ARID_DEF.is_active_c61_ME11 == 0U) {
    ME11_TMSIODriverFunc_ARID_DEF.is_active_c61_ME11 = 1U;
    ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Default_e;
    rtb_CCaller_d = 0U;
    rtb_Gain2_g3 = 0U;
    ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
    ME11_TMSIODriverFunc_ARID_DEF.Sts = 0U;
    ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic = ME11_IN_Init_n;
    ME11_TMSIODriverFunc_ARID_DEF.TempVol = ACSen_sModeMotorVol;
  } else {
    switch (ME11_TMSIODriverFunc_ARID_DEF.is_Move) {
     case ME11_IN_ALLDefrost:
      rtb_CCaller_d = 1U;
      rtb_Gain2_g3 = 0U;
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 >= 50U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Default_e;
        rtb_CCaller_d = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts = 0U;
      }
      break;

     case ME11_IN_ALLFace:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 1U;
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 >= 50U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Default_e;
        rtb_Gain2_g3 = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts = 0U;
      }
      break;

     case ME11_IN_Default_e:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
      if ((IOCtl_sModeMotorTrgPos > ACSen_sModeMotorVol + cal_ModeMotorPErr) &&
          rtb_Switch_cc) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Face;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 = 0U;
        rtb_Gain2_g3 = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = true;
      } else if ((IOCtl_sModeMotorTrgPos < ACSen_sModeMotorVol -
                  cal_ModeMotorNErr) && rtb_Switch_cc) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Defrost;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 = 0U;
        rtb_CCaller_d = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = true;
      }
      break;

     case ME11_IN_Defrost:
      rtb_CCaller_d = 1U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts = true;
      if (IOCtl_sModeMotorTrgPos > ACSen_sModeMotorVol - cal_ModeMotorNErr) {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts = 0U;
        if (IOCtl_sModeMotorTrgPos <= 0.9F) {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_ALLDefrost;
          ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 = 0U;
        } else {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Default_e;
          rtb_CCaller_d = 0U;
          ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
          ME11_TMSIODriverFunc_ARID_DEF.Sts = 0U;
        }
      } else if (ME11_TMSIODriverFunc_ARID_DEF.Sts == 1) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Defrost_Stuck;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 = 0U;
        rtb_CCaller_d = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 >= 600U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Fault1_b;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 = 0U;
        rtb_CCaller_d = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
      }
      break;

     case ME11_IN_Defrost_Stuck:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
      if (ME11_TMSIODriverFunc_ARID_DEF.Sts == 2) {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Default_e;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts = 0U;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 >= 20U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Defrost;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 = 0U;
        rtb_CCaller_d = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = true;
      }
      break;

     case ME11_IN_Face:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 1U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts = true;
      if (IOCtl_sModeMotorTrgPos < ACSen_sModeMotorVol + cal_ModeMotorPErr) {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts = 0U;
        if (IOCtl_sModeMotorTrgPos >= 4.4F) {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_ALLFace;
          ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 = 0U;
        } else {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Default_e;
          rtb_Gain2_g3 = 0U;
          ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
          ME11_TMSIODriverFunc_ARID_DEF.Sts = 0U;
        }
      } else if (ME11_TMSIODriverFunc_ARID_DEF.Sts == 1) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Face_Stuck;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 = 0U;
        rtb_Gain2_g3 = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 >= 600U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Fault_l;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 = 0U;
        rtb_Gain2_g3 = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
      }
      break;

     case ME11_IN_Face_Stuck:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
      if (ME11_TMSIODriverFunc_ARID_DEF.Sts == 2) {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Default_e;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts = 0U;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 >= 20U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Face;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 = 0U;
        rtb_Gain2_g3 = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = true;
      }
      break;

     case ME11_IN_Fault_l:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
      if (cal_ModeMotorEnb || (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 >=
           1000U)) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Default_e;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts = 0U;
      }
      break;

     default:
      /* case IN_Fault1: */
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
      if (cal_ModeMotorEnb || (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1 >=
           1000U)) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move = ME11_IN_Default_e;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts = 0U;
      }
      break;
    }

    switch (ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic) {
     case ME11_IN_Init_n:
      if (ME11_TMSIODriverFunc_ARID_DEF.MoveSts) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic = ME11_IN_wait_j;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2 = 0U;
      } else {
        ME11_TMSIODriverFunc_ARID_DEF.TempVol = ACSen_sModeMotorVol;
      }
      break;

     case ME11_IN_Judge:
      ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic = ME11_IN_Init_n;
      ME11_TMSIODriverFunc_ARID_DEF.TempVol = ACSen_sModeMotorVol;
      break;

     default:
      /* case IN_wait: */
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2 >= 10U) {
        if ((float32)fabs(ME11_TMSIODriverFunc_ARID_DEF.TempVol -
                          ACSen_sModeMotorVol) < 0.04F) {
          ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic = ME11_IN_Judge;
          tmp = ME11_TMSIODriverFunc_ARID_DEF.Sts + 1;
          if (ME11_TMSIODriverFunc_ARID_DEF.Sts + 1 > 255) {
            tmp = 255;
          }

          ME11_TMSIODriverFunc_ARID_DEF.Sts = (uint8)tmp;
        } else {
          ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic = ME11_IN_Init_n;
          ME11_TMSIODriverFunc_ARID_DEF.TempVol = ACSen_sModeMotorVol;
        }
      }
      break;
    }
  }

  /* End of Chart: '<S1234>/Judge' */

  /* Switch: '<S1234>/Switch1' incorporates:
   *  Constant: '<S1234>/Constant3'
   *  Constant: '<S1234>/Constant4'
   *  Gain: '<S1234>/Gain'
   *  Logic: '<S1234>/OR'
   *  Switch: '<S1234>/Switch2'
   */
  if (ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts > 0) {
    rtb_Switch_fds = (uint8)(3U * ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts);
  } else if (ME11_TMSIODriverFunc_ARID_DEF.MoveSts) {
    /* Switch: '<S1234>/Switch2' incorporates:
     *  Gain: '<S1234>/Gain1'
     *  Switch: '<S1260>/Switch'
     */
    rtb_Switch_fds = (uint8)(ME11_TMSIODriverFunc_ARID_DEF.MoveSts << 1);
  } else {
    rtb_Switch_fds = (uint8)(cal_ModeMotorTrgPosDataEnb || cal_ModeMotorEnb);
  }

  /* CCaller: '<S1234>/C Caller1' incorporates:
   *  Constant: '<S1234>/Constant6'
   *  Switch: '<S1234>/Switch1'
   */
  Rte_DIDReadData(rtb_Switch_fds, ((uint8)DID_0xF269));

  /* Switch: '<S1275>/Switch' incorporates:
   *  Constant: '<S1274>/Constant'
   *  Constant: '<S1275>/Constant'
   *  Constant: '<S1275>/Constant1'
   *  Switch: '<S1274>/Switch'
   */
  if (cal_ModeMotorEnb) {
    rtb_CCaller_d = cal_ModeMotorPData;
    rtb_Gain2_g3 = cal_ModeMotorNData;
  }

  /* CCaller: '<S1234>/C Caller2' incorporates:
   *  Switch: '<S1274>/Switch'
   *  Switch: '<S1275>/Switch'
   */
  set_ModeMotor(rtb_CCaller_d, rtb_Gain2_g3);

  /* CCaller: '<S1234>/C Caller3' incorporates:
   *  Constant: '<S1234>/Constant7'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x943371),
                     ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts);

  /* SignalConversion: '<S1234>/Signal Copy' */
  IOCtl_bModeMoveSts = ME11_TMSIODriverFunc_ARID_DEF.MoveSts;

  /* CCaller: '<S1229>/C Caller1' incorporates:
   *  Constant: '<S1229>/Constant4'
   */
  set_CoolFan(100U, ME11_ARID_DEF.Add1);

  /* Switch: '<S1268>/Switch' incorporates:
   *  Constant: '<S1233>/Constant2'
   *  Constant: '<S1262>/Constant'
   *  Constant: '<S1263>/Constant'
   *  Constant: '<S1268>/Constant1'
   *  DataStoreRead: '<S1233>/Data Store Read'
   *  DataStoreRead: '<S1233>/Data Store Read2'
   *  Logic: '<S1233>/OR1'
   *  MultiPortSwitch: '<S1233>/Index Vector'
   *  RelationalOperator: '<S1262>/Compare'
   *  RelationalOperator: '<S1263>/Compare'
   *  S-Function (sfix_bitop): '<S1233>/Bitwise Operator1'
   *  Switch: '<S1233>/Switch'
   */
  if (cal_SetLeftMixDoorTrgDataEnb) {
    /* Switch: '<S1268>/Switch' incorporates:
     *  Constant: '<S1268>/Constant'
     */
    IOCtl_sMixDoorTrgPos = cal_SetLeftMixDoorTrgData;
  } else if (((Buffer_DcmDspData_3238[0] & 1) == 1) &&
             (Rte_DcmDspData_3238_CtlFlg == 1)) {
    /* Switch: '<S1233>/Switch' incorporates:
     *  Constant: '<S1233>/Constant3'
     *  DataStoreRead: '<S1233>/Data Store Read1'
     *  MultiPortSwitch: '<S1233>/Index Vector1'
     *  Switch: '<S1268>/Switch'
     */
    IOCtl_sMixDoorTrgPos = (float32)Buffer_DcmDspData_3238[1];
  } else {
    /* Switch: '<S1268>/Switch' incorporates:
     *  Switch: '<S1233>/Switch'
     */
    IOCtl_sMixDoorTrgPos = ThCo_rSetLeftMixDoor;
  }

  /* End of Switch: '<S1268>/Switch' */

  /* RelationalOperator: '<S1264>/FixPt Relational Operator' incorporates:
   *  UnitDelay: '<S1264>/Delay Input1'
   *
   * Block description for '<S1264>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_Switch_cc = (IOCtl_sMixDoorTrgPos !=
                   ME11_TMSIODriverFunc_ARID_DEF.DelayInput1_DSTATE_d);

  /* Chart: '<S1233>/Judge' incorporates:
   *  Constant: '<S1233>/Constant'
   *  Constant: '<S1233>/Constant1'
   */
  if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f < 1023U) {
    ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f++;
  }

  if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2_e < 15U) {
    ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2_e++;
  }

  if (ME11_TMSIODriverFunc_ARID_DEF.is_active_c62_ME11 == 0U) {
    ME11_TMSIODriverFunc_ARID_DEF.is_active_c62_ME11 = 1U;
    ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Default_d2;
    rtb_CCaller_d = 0U;
    rtb_Gain2_g3 = 0U;
    ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
    ME11_TMSIODriverFunc_ARID_DEF.Sts_a = 0U;
    ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_h = ME11_IN_Init_n;
    ME11_TMSIODriverFunc_ARID_DEF.TempVol_b = ACSen_sMixDoorPerc;
  } else {
    switch (ME11_TMSIODriverFunc_ARID_DEF.is_Move_b) {
     case ME11_IN_ALLCool:
      rtb_CCaller_d = 1U;
      rtb_Gain2_g3 = 0U;
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f >= 5U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Default_d2;
        rtb_CCaller_d = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_a = 0U;
      }
      break;

     case ME11_IN_AllWarm:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 1U;
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f >= 10U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Default_d2;
        rtb_Gain2_g3 = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_a = 0U;
      }
      break;

     case ME11_IN_Cool:
      rtb_CCaller_d = 1U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = true;
      if (IOCtl_sMixDoorTrgPos > ACSen_sMixDoorPerc - cal_MixDoorNErr) {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_f = false;
        if (IOCtl_sMixDoorTrgPos < cal_MixCoolTrgPos) {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_ALLCool;
          ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f = 0U;
        } else {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Default_d2;
          rtb_CCaller_d = 0U;
          ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
          ME11_TMSIODriverFunc_ARID_DEF.Sts_a = 0U;
        }
      } else if (ME11_TMSIODriverFunc_ARID_DEF.Sts_a == 1) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_OutMix_Stuck;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f = 0U;
        rtb_CCaller_d = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f >= 600U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Fault1_c;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f = 0U;
        rtb_CCaller_d = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
      }
      break;

     case ME11_IN_Default_d2:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
      if ((IOCtl_sMixDoorTrgPos > ACSen_sMixDoorPerc + cal_MixDoorPErr) &&
          rtb_Switch_cc) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Warm;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f = 0U;
        rtb_Gain2_g3 = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = true;
      } else if ((IOCtl_sMixDoorTrgPos < ACSen_sMixDoorPerc - cal_MixDoorNErr) &&
                 rtb_Switch_cc) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Cool;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f = 0U;
        rtb_CCaller_d = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = true;
      }
      break;

     case ME11_IN_Fault_d:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
      if (cal_MixDoorEnb || (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f >=
           1000U)) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Default_d2;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_a = 0U;
      }
      break;

     case ME11_IN_Fault1_c:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
      if (cal_MixDoorEnb || (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f >=
           1000U)) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Default_d2;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_a = 0U;
      }
      break;

     case ME11_IN_InMix_Stuck:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f >= 20U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Warm;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f = 0U;
        rtb_Gain2_g3 = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = true;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.Sts_a == 2) {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_f = true;
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Default_d2;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_a = 0U;
      }
      break;

     case ME11_IN_OutMix_Stuck:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
      if (ME11_TMSIODriverFunc_ARID_DEF.Sts_a == 2) {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_f = true;
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Default_d2;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_a = 0U;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f >= 20U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Cool;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f = 0U;
        rtb_CCaller_d = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = true;
      }
      break;

     default:
      /* case IN_Warm: */
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 1U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = true;
      if (IOCtl_sMixDoorTrgPos < ACSen_sMixDoorPerc + cal_MixDoorPErr) {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_f = false;
        if (IOCtl_sMixDoorTrgPos > cal_MixWarmTrgPos) {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_AllWarm;
          ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f = 0U;
        } else {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Default_d2;
          rtb_Gain2_g3 = 0U;
          ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
          ME11_TMSIODriverFunc_ARID_DEF.Sts_a = 0U;
        }
      } else if (ME11_TMSIODriverFunc_ARID_DEF.Sts_a == 1) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_InMix_Stuck;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f = 0U;
        rtb_Gain2_g3 = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f >= 600U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_b = ME11_IN_Fault_d;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_f = 0U;
        rtb_Gain2_g3 = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m = false;
      }
      break;
    }

    switch (ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_h) {
     case ME11_IN_Init_n:
      if (ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_h = ME11_IN_wait_j;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2_e = 0U;
      } else {
        ME11_TMSIODriverFunc_ARID_DEF.TempVol_b = ACSen_sMixDoorPerc;
      }
      break;

     case ME11_IN_Judge:
      ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_h = ME11_IN_Init_n;
      ME11_TMSIODriverFunc_ARID_DEF.TempVol_b = ACSen_sMixDoorPerc;
      break;

     default:
      /* case IN_wait: */
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2_e >= 10U) {
        if ((float32)fabs(ME11_TMSIODriverFunc_ARID_DEF.TempVol_b -
                          ACSen_sMixDoorPerc) < 0.04F) {
          ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_h = ME11_IN_Judge;
          tmp = ME11_TMSIODriverFunc_ARID_DEF.Sts_a + 1;
          if (ME11_TMSIODriverFunc_ARID_DEF.Sts_a + 1 > 255) {
            tmp = 255;
          }

          ME11_TMSIODriverFunc_ARID_DEF.Sts_a = (uint8)tmp;
        } else {
          ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_h = ME11_IN_Init_n;
          ME11_TMSIODriverFunc_ARID_DEF.TempVol_b = ACSen_sMixDoorPerc;
        }
      }
      break;
    }
  }

  /* End of Chart: '<S1233>/Judge' */

  /* Switch: '<S1233>/Switch1' incorporates:
   *  Constant: '<S1233>/Constant5'
   *  Constant: '<S1233>/Constant6'
   *  Gain: '<S1233>/Gain'
   *  Logic: '<S1233>/OR'
   *  Switch: '<S1233>/Switch2'
   *  Switch: '<S1260>/Switch'
   */
  if (ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_f) {
    rtb_Switch_fds = (uint8)(ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_f ? 3 : 0);
  } else if (ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m) {
    /* Switch: '<S1233>/Switch2' incorporates:
     *  Gain: '<S1233>/Gain1'
     *  Switch: '<S1260>/Switch'
     */
    rtb_Switch_fds = (uint8)(ME11_TMSIODriverFunc_ARID_DEF.MoveSts_m << 1);
  } else {
    rtb_Switch_fds = (uint8)(cal_SetLeftMixDoorTrgDataEnb || cal_MixDoorEnb);
  }

  /* CCaller: '<S1233>/C Caller1' incorporates:
   *  Constant: '<S1233>/Constant8'
   *  Switch: '<S1233>/Switch1'
   */
  Rte_DIDReadData(rtb_Switch_fds, ((uint8)DID_0xF26B));

  /* CCaller: '<S1233>/C Caller2' incorporates:
   *  Constant: '<S1233>/Constant9'
   *  DataTypeConversion: '<S1233>/Data Type Conversion'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x943571),
                     ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_f);

  /* Switch: '<S1267>/Switch' incorporates:
   *  Constant: '<S1266>/Constant'
   *  Constant: '<S1267>/Constant'
   *  Constant: '<S1267>/Constant1'
   *  Switch: '<S1266>/Switch'
   */
  if (cal_MixDoorEnb) {
    rtb_CCaller_d = cal_MixDoorPData;
    rtb_Gain2_g3 = cal_MixDoorNData;
  }

  /* CCaller: '<S1233>/C Caller3' incorporates:
   *  Switch: '<S1266>/Switch'
   *  Switch: '<S1267>/Switch'
   */
  set_MixDoor(rtb_CCaller_d, rtb_Gain2_g3);

  /* Switch: '<S1261>/Switch' incorporates:
   *  Constant: '<S1232>/Constant2'
   *  Constant: '<S1255>/Constant'
   *  Constant: '<S1256>/Constant'
   *  Constant: '<S1261>/Constant1'
   *  DataStoreRead: '<S1232>/Data Store Read'
   *  DataStoreRead: '<S1232>/Data Store Read2'
   *  Logic: '<S1232>/OR1'
   *  MultiPortSwitch: '<S1232>/Index Vector'
   *  RelationalOperator: '<S1255>/Compare'
   *  RelationalOperator: '<S1256>/Compare'
   *  S-Function (sfix_bitop): '<S1232>/Bitwise Operator1'
   *  Switch: '<S1232>/Switch'
   */
  if (cal_RecircTrgPosDataEnb) {
    /* Switch: '<S1261>/Switch' incorporates:
     *  Constant: '<S1261>/Constant'
     */
    IOCtl_RecircTrgPos = cal_RecircTrgPosData;
  } else if (((Buffer_DcmDspData_3238[0] & 8) == 8) &&
             (Rte_DcmDspData_3238_CtlFlg == 1)) {
    /* Switch: '<S1232>/Switch' incorporates:
     *  Constant: '<S1232>/Constant3'
     *  DataStoreRead: '<S1232>/Data Store Read1'
     *  MultiPortSwitch: '<S1232>/Index Vector1'
     *  Switch: '<S1261>/Switch'
     */
    IOCtl_RecircTrgPos = Buffer_DcmDspData_3238[4];
  } else {
    /* Switch: '<S1261>/Switch' incorporates:
     *  Switch: '<S1232>/Switch'
     */
    IOCtl_RecircTrgPos = ACCtl_IntakeRatio;
  }

  /* End of Switch: '<S1261>/Switch' */

  /* RelationalOperator: '<S1257>/FixPt Relational Operator' incorporates:
   *  UnitDelay: '<S1257>/Delay Input1'
   *
   * Block description for '<S1257>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_Switch_cc = (IOCtl_RecircTrgPos !=
                   ME11_TMSIODriverFunc_ARID_DEF.DelayInput1_DSTATE_n);

  /* Chart: '<S1232>/Judge' incorporates:
   *  Constant: '<S1232>/Constant'
   *  Constant: '<S1232>/Constant1'
   */
  if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m < 1023U) {
    ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m++;
  }

  if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2_k < 15U) {
    ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2_k++;
  }

  if (ME11_TMSIODriverFunc_ARID_DEF.is_active_c63_ME11 == 0U) {
    ME11_TMSIODriverFunc_ARID_DEF.is_active_c63_ME11 = 1U;
    ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Default_e;
    rtb_CCaller_d = 0U;
    rtb_Gain2_g3 = 0U;
    ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
    ME11_TMSIODriverFunc_ARID_DEF.Sts_e = 0U;
    ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_g = ME11_IN_Init_n;
    ME11_TMSIODriverFunc_ARID_DEF.TempVol_h = ACSen_eAirInletPer;
  } else {
    switch (ME11_TMSIODriverFunc_ARID_DEF.is_Move_f) {
     case ME11_IN_ALLInner:
      rtb_CCaller_d = 1U;
      rtb_Gain2_g3 = 0U;
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m >= 10U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Default_e;
        rtb_CCaller_d = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_e = 0U;
      }
      break;

     case ME11_IN_ALLOut:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 1U;
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m >= 10U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Default_e;
        rtb_Gain2_g3 = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_e = 0U;
      }
      break;

     case ME11_IN_Default_e:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
      if ((IOCtl_RecircTrgPos > (float32)ACSen_eAirInletPer + cal_RecircDoorPErr)
          && rtb_Switch_cc) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_InnerRec;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m = 0U;
        rtb_CCaller_d = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = true;
      } else if ((IOCtl_RecircTrgPos < (float32)ACSen_eAirInletPer -
                  cal_RecircDoorNErr) && rtb_Switch_cc) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_OutRec;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m = 0U;
        rtb_Gain2_g3 = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = true;
      }
      break;

     case ME11_IN_Fault_j:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
      if (cal_RecircMotorEnb ||
          (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m >= 1000U)) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Default_e;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_e = 0U;
      }
      break;

     case ME11_IN_Fault1:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
      if (cal_RecircMotorEnb ||
          (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m >= 1000U)) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Default_e;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_e = 0U;
      }
      break;

     case ME11_IN_InRec_Stuck:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
      if (ME11_TMSIODriverFunc_ARID_DEF.Sts_e == 2) {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_a = true;
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Default_e;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_e = 0U;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m >= 20U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_InnerRec;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m = 0U;
        rtb_CCaller_d = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = true;
      }
      break;

     case ME11_IN_InnerRec:
      rtb_CCaller_d = 1U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = true;
      if (IOCtl_RecircTrgPos < (float32)ACSen_eAirInletPer + cal_RecircDoorPErr)
      {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_a = false;
        if (IOCtl_RecircTrgPos > cal_InnerRecTrgPos) {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_ALLInner;
          ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m = 0U;
        } else {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Default_e;
          rtb_CCaller_d = 0U;
          ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
          ME11_TMSIODriverFunc_ARID_DEF.Sts_e = 0U;
        }
      } else if (ME11_TMSIODriverFunc_ARID_DEF.Sts_e == 1) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_InRec_Stuck;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m = 0U;
        rtb_CCaller_d = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m >= 600U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Fault_j;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m = 0U;
        rtb_CCaller_d = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
      }
      break;

     case ME11_IN_OutRec:
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 1U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = true;
      if (IOCtl_RecircTrgPos > (float32)ACSen_eAirInletPer - cal_RecircDoorNErr)
      {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_a = false;
        if (IOCtl_RecircTrgPos < cal_OutRecTrgPos) {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_ALLOut;
          ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m = 0U;
        } else {
          ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Default_e;
          rtb_Gain2_g3 = 0U;
          ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
          ME11_TMSIODriverFunc_ARID_DEF.Sts_e = 0U;
        }
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m >= 600U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Fault1;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m = 0U;
        rtb_Gain2_g3 = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.Sts_e == 1) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_OutRec_Stuck;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m = 0U;
        rtb_Gain2_g3 = 0U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
      }
      break;

     default:
      /* case IN_OutRec_Stuck: */
      rtb_CCaller_d = 0U;
      rtb_Gain2_g3 = 0U;
      ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
      if (ME11_TMSIODriverFunc_ARID_DEF.Sts_e == 2) {
        ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_a = true;
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_Default_e;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = false;
        ME11_TMSIODriverFunc_ARID_DEF.Sts_e = 0U;
      } else if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m >= 20U) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Move_f = ME11_IN_OutRec;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i1_m = 0U;
        rtb_Gain2_g3 = 1U;
        ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d = true;
      }
      break;
    }

    switch (ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_g) {
     case ME11_IN_Init_n:
      if (ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d) {
        ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_g = ME11_IN_wait_j;
        ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2_k = 0U;
      } else {
        ME11_TMSIODriverFunc_ARID_DEF.TempVol_h = ACSen_eAirInletPer;
      }
      break;

     case ME11_IN_Judge:
      ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_g = ME11_IN_Init_n;
      ME11_TMSIODriverFunc_ARID_DEF.TempVol_h = ACSen_eAirInletPer;
      break;

     default:
      /* case IN_wait: */
      if (ME11_TMSIODriverFunc_ARID_DEF.temporalCounter_i2_k >= 10U) {
        if ((float32)fabs(ME11_TMSIODriverFunc_ARID_DEF.TempVol_h - (float32)
                          ACSen_eAirInletPer) < 0.04F) {
          ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_g = ME11_IN_Judge;
          tmp = ME11_TMSIODriverFunc_ARID_DEF.Sts_e + 1;
          if (ME11_TMSIODriverFunc_ARID_DEF.Sts_e + 1 > 255) {
            tmp = 255;
          }

          ME11_TMSIODriverFunc_ARID_DEF.Sts_e = (uint8)tmp;
        } else {
          ME11_TMSIODriverFunc_ARID_DEF.is_Diagnostic_g = ME11_IN_Init_n;
          ME11_TMSIODriverFunc_ARID_DEF.TempVol_h = ACSen_eAirInletPer;
        }
      }
      break;
    }
  }

  /* End of Chart: '<S1232>/Judge' */

  /* Switch: '<S1232>/Switch1' incorporates:
   *  Constant: '<S1232>/Constant5'
   *  Constant: '<S1232>/Constant6'
   *  Gain: '<S1232>/Gain'
   *  Logic: '<S1232>/OR'
   *  Switch: '<S1232>/Switch2'
   *  Switch: '<S1260>/Switch'
   */
  if (ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_a) {
    rtb_Switch_fds = (uint8)(ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_a ? 3 : 0);
  } else if (ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d) {
    /* Switch: '<S1232>/Switch2' incorporates:
     *  Gain: '<S1232>/Gain1'
     *  Switch: '<S1260>/Switch'
     */
    rtb_Switch_fds = (uint8)(ME11_TMSIODriverFunc_ARID_DEF.MoveSts_d << 1);
  } else {
    rtb_Switch_fds = (uint8)(cal_RecircTrgPosDataEnb || cal_RecircMotorEnb);
  }

  /* CCaller: '<S1232>/C Caller1' incorporates:
   *  Constant: '<S1232>/Constant8'
   *  Switch: '<S1232>/Switch1'
   */
  Rte_DIDReadData(rtb_Switch_fds, ((uint8)DID_0xF26A));

  /* CCaller: '<S1232>/C Caller3' incorporates:
   *  Constant: '<S1232>/Constant9'
   *  DataTypeConversion: '<S1232>/Data Type Conversion'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x943271),
                     ME11_TMSIODriverFunc_ARID_DEF.Stuck_Sts_a);

  /* Switch: '<S1260>/Switch' incorporates:
   *  Constant: '<S1259>/Constant'
   *  Constant: '<S1260>/Constant'
   *  Constant: '<S1260>/Constant1'
   *  Switch: '<S1259>/Switch'
   */
  if (cal_RecircMotorEnb) {
    rtb_CCaller_d = cal_RecircMotorPData;
    rtb_Gain2_g3 = cal_RecircMotorNData;
  }

  /* CCaller: '<S1232>/C Caller4' incorporates:
   *  Switch: '<S1259>/Switch'
   *  Switch: '<S1260>/Switch'
   */
  set_RecircMotor(rtb_CCaller_d, rtb_Gain2_g3);
}

/* Update for atomic system: '<S2>/IODriver' */
void ME11_TMSIODriverFunc_Update(void)
{
  /* Update for Delay: '<S13>/Delay' */
  ME11_TMSIODriverFunc_ARID_DEF.Delay_DSTATE = AC_BlowerFanSpeedMax;

  /* Update for UnitDelay: '<S1271>/Delay Input1'
   *
   * Block description for '<S1271>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_TMSIODriverFunc_ARID_DEF.DelayInput1_DSTATE = IOCtl_sModeMotorTrgPos;

  /* Update for UnitDelay: '<S1264>/Delay Input1'
   *
   * Block description for '<S1264>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_TMSIODriverFunc_ARID_DEF.DelayInput1_DSTATE_d = IOCtl_sMixDoorTrgPos;

  /* Update for UnitDelay: '<S1257>/Delay Input1'
   *
   * Block description for '<S1257>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_TMSIODriverFunc_ARID_DEF.DelayInput1_DSTATE_n = IOCtl_RecircTrgPos;
}

/*
 * System initialize for atomic system:
 *    '<S1333>/Delay'
 *    '<S1373>/Chart'
 *    '<S1382>/Chart'
 *    '<S1576>/Chart1'
 *    '<S1612>/Chart1'
 *    '<S1612>/Chart2'
 *    '<S1612>/Chart3'
 *    '<S1612>/Chart4'
 *    '<S1644>/Chart'
 */
void ME11_Delay_j_Init(boolean *rty_B)
{
  *rty_B = false;
}

/*
 * Output and update for atomic system:
 *    '<S1333>/Delay'
 *    '<S1373>/Chart'
 *    '<S1382>/Chart'
 *    '<S1576>/Chart1'
 *    '<S1612>/Chart1'
 *    '<S1612>/Chart2'
 *    '<S1612>/Chart3'
 *    '<S1612>/Chart4'
 *    '<S1644>/Chart'
 */
void ME11_Delay_m(boolean rtu_A, boolean *rty_B, ARID_DEF_Delay_ME11_e_T
                  *ME11__ARID_DEF_arg)
{
  if (ME11__ARID_DEF_arg->temporalCounter_i1 < 511U) {
    ME11__ARID_DEF_arg->temporalCounter_i1++;
  }

  /* Chart: '<S1333>/Delay' */
  if (ME11__ARID_DEF_arg->is_active_c68_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c68_ME11 = 1U;
    ME11__ARID_DEF_arg->is_c68_ME11 = ME11_IN_False;
    *rty_B = false;
  } else {
    switch (ME11__ARID_DEF_arg->is_c68_ME11) {
     case ME11_IN_False:
      *rty_B = false;
      if (rtu_A) {
        ME11__ARID_DEF_arg->is_c68_ME11 = ME11_IN_Wait_g;
        ME11__ARID_DEF_arg->temporalCounter_i1 = 0U;
      }
      break;

     case ME11_IN_True:
      *rty_B = true;
      if (!rtu_A) {
        ME11__ARID_DEF_arg->is_c68_ME11 = ME11_IN_False;
        *rty_B = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11__ARID_DEF_arg->temporalCounter_i1 >= 300U) {
        ME11__ARID_DEF_arg->is_c68_ME11 = ME11_IN_True;
        *rty_B = true;
      } else if (!rtu_A) {
        ME11__ARID_DEF_arg->is_c68_ME11 = ME11_IN_False;
        *rty_B = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1333>/Delay' */
}

/*
 * System initialize for atomic system:
 *    '<S1320>/Chart'
 *    '<S1324>/Chart'
 */
void ME11_Chart_c_Init(boolean *rty_SOMCtl_bBatLTRFlg)
{
  *rty_SOMCtl_bBatLTRFlg = false;
}

/*
 * Output and update for atomic system:
 *    '<S1320>/Chart'
 *    '<S1324>/Chart'
 */
void ME11_Chart_i(boolean rtu_A, boolean rtu_B, boolean *rty_SOMCtl_bBatLTRFlg,
                  ARID_DEF_Chart_ME11_e_T *ME11__ARID_DEF_arg)
{
  /* Chart: '<S1320>/Chart' */
  if (ME11__ARID_DEF_arg->is_active_c75_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c75_ME11 = 1U;
    ME11__ARID_DEF_arg->is_c75_ME11 = ME11_IN_Off_h;
    *rty_SOMCtl_bBatLTRFlg = false;
  } else if (ME11__ARID_DEF_arg->is_c75_ME11 == ME11_IN_Off_h) {
    *rty_SOMCtl_bBatLTRFlg = false;
    if (rtu_A) {
      ME11__ARID_DEF_arg->is_c75_ME11 = ME11_IN_On_k;
      *rty_SOMCtl_bBatLTRFlg = true;
    }
  } else {
    /* case IN_On: */
    *rty_SOMCtl_bBatLTRFlg = true;
    if (rtu_B) {
      ME11__ARID_DEF_arg->is_c75_ME11 = ME11_IN_Off_h;
      *rty_SOMCtl_bBatLTRFlg = false;
    }
  }

  /* End of Chart: '<S1320>/Chart' */
}

/*
 * System initialize for atomic system:
 *    '<S1574>/Chart'
 *    '<S1575>/Chart'
 *    '<S1610>/Chart'
 *    '<S1611>/Chart'
 */
void ME11_Chart_k_Init(boolean *rty_B)
{
  *rty_B = false;
}

/*
 * Output and update for atomic system:
 *    '<S1574>/Chart'
 *    '<S1575>/Chart'
 *    '<S1610>/Chart'
 *    '<S1611>/Chart'
 */
void ME11_Chart_l(boolean rtu_A, boolean *rty_B, ARID_DEF_Chart_ME11_n_T
                  *ME11__ARID_DEF_arg)
{
  if (ME11__ARID_DEF_arg->temporalCounter_i1 < 15U) {
    ME11__ARID_DEF_arg->temporalCounter_i1++;
  }

  /* Chart: '<S1574>/Chart' */
  if (ME11__ARID_DEF_arg->is_active_c78_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c78_ME11 = 1U;
    ME11__ARID_DEF_arg->is_c78_ME11 = ME11_IN_False_n;
    *rty_B = false;
  } else {
    switch (ME11__ARID_DEF_arg->is_c78_ME11) {
     case ME11_IN_False_n:
      *rty_B = false;
      if (rtu_A) {
        ME11__ARID_DEF_arg->is_c78_ME11 = ME11_IN_Wait_h;
        ME11__ARID_DEF_arg->temporalCounter_i1 = 0U;
      }
      break;

     case ME11_IN_True_j:
      *rty_B = true;
      if (!rtu_A) {
        ME11__ARID_DEF_arg->is_c78_ME11 = ME11_IN_False_n;
        *rty_B = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11__ARID_DEF_arg->temporalCounter_i1 >= 10U) {
        ME11__ARID_DEF_arg->is_c78_ME11 = ME11_IN_True_j;
        *rty_B = true;
      } else if (!rtu_A) {
        ME11__ARID_DEF_arg->is_c78_ME11 = ME11_IN_False_n;
        *rty_B = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1574>/Chart' */
}

/*
 * System initialize for atomic system:
 *    '<S1325>/Chart'
 *    '<S1326>/Chart'
 */
void ME11_Chart_e_Init(boolean *rty_SOMCtl_bBatHeatB3tB1Flg)
{
  *rty_SOMCtl_bBatHeatB3tB1Flg = false;
}

/*
 * Output and update for atomic system:
 *    '<S1325>/Chart'
 *    '<S1326>/Chart'
 */
void ME11_Chart_n(boolean rtu_A, boolean rtu_B, boolean
                  *rty_SOMCtl_bBatHeatB3tB1Flg, ARID_DEF_Chart_ME11_ng_T
                  *ME11__ARID_DEF_arg)
{
  /* Chart: '<S1325>/Chart' */
  if (ME11__ARID_DEF_arg->is_active_c82_ME11 == 0U) {
    ME11__ARID_DEF_arg->is_active_c82_ME11 = 1U;
    ME11__ARID_DEF_arg->is_c82_ME11 = ME11_IN_Off_n;
    *rty_SOMCtl_bBatHeatB3tB1Flg = false;
  } else if (ME11__ARID_DEF_arg->is_c82_ME11 == ME11_IN_Off_n) {
    *rty_SOMCtl_bBatHeatB3tB1Flg = false;
    if (rtu_A) {
      ME11__ARID_DEF_arg->is_c82_ME11 = ME11_IN_On_d;
      *rty_SOMCtl_bBatHeatB3tB1Flg = true;
    }
  } else {
    /* case IN_On: */
    *rty_SOMCtl_bBatHeatB3tB1Flg = true;
    if (rtu_B) {
      ME11__ARID_DEF_arg->is_c82_ME11 = ME11_IN_Off_n;
      *rty_SOMCtl_bBatHeatB3tB1Flg = false;
    }
  }

  /* End of Chart: '<S1325>/Chart' */
}

/* System initialize for atomic system: '<S2>/Sensor' */
void ME11_TMSADCSampleFunc_Init(void)
{
  /* InitializeConditions for UnitDelay: '<S1774>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE = 1U;

  /* InitializeConditions for UnitDelay: '<S1784>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_a = 1U;

  /* InitializeConditions for UnitDelay: '<S1799>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_o = 1U;

  /* InitializeConditions for UnitDelay: '<S1806>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_l = 1U;

  /* InitializeConditions for UnitDelay: '<S1832>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_m = 1U;

  /* InitializeConditions for UnitDelay: '<S1860>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_f = 1U;

  /* InitializeConditions for UnitDelay: '<S1869>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_n = 1U;

  /* InitializeConditions for UnitDelay: '<S1792>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_f1 = 1U;

  /* InitializeConditions for UnitDelay: '<S1764>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_c = 1U;

  /* InitializeConditions for UnitDelay: '<S1816>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_g = 1U;

  /* InitializeConditions for UnitDelay: '<S1878>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_nc = 1U;

  /* InitializeConditions for UnitDelay: '<S1851>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_g3 = 1U;

  /* InitializeConditions for UnitDelay: '<S1825>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_e = 1U;

  /* InitializeConditions for UnitDelay: '<S1842>/FixPt Unit Delay2' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_j = 1U;

  /* SystemInitialize for Chart: '<S1810>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_nj);

  /* SystemInitialize for Atomic SubSystem: '<S1741>/Face' */

  /* SystemInitialize for Chart: '<S1772>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_c);

  /* End of SystemInitialize for SubSystem: '<S1741>/Face' */

  /* SystemInitialize for Atomic SubSystem: '<S1742>/Foot' */

  /* SystemInitialize for Chart: '<S1782>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_no);

  /* End of SystemInitialize for SubSystem: '<S1742>/Foot' */

  /* SystemInitialize for Chart: '<S1796>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_oo);

  /* SystemInitialize for Chart: '<S1803>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_lb);

  /* SystemInitialize for Atomic SubSystem: '<S1749>/EVAP' */

  /* SystemInitialize for Chart: '<S1830>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_n);

  /* End of SystemInitialize for SubSystem: '<S1749>/EVAP' */

  /* SystemInitialize for Atomic SubSystem: '<S1752>/Env' */

  /* SystemInitialize for Chart: '<S1858>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_fm);

  /* End of SystemInitialize for SubSystem: '<S1752>/Env' */

  /* SystemInitialize for Chart: '<S1866>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_f);

  /* SystemInitialize for Chart: '<S1789>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_e);

  /* SystemInitialize for Atomic SubSystem: '<S1739>/Cabin' */

  /* SystemInitialize for Chart: '<S1762>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_k);

  /* End of SystemInitialize for SubSystem: '<S1739>/Cabin' */

  /* SystemInitialize for Chart: '<S1813>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_fr);

  /* SystemInitialize for Atomic SubSystem: '<S1754>/ACCMHi' */

  /* SystemInitialize for Chart: '<S1876>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts);

  /* End of SystemInitialize for SubSystem: '<S1754>/ACCMHi' */

  /* SystemInitialize for Atomic SubSystem: '<S1751>/Env' */

  /* SystemInitialize for Chart: '<S1849>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_l);

  /* End of SystemInitialize for SubSystem: '<S1751>/Env' */

  /* SystemInitialize for Atomic SubSystem: '<S1748>/Chiller' */

  /* SystemInitialize for Chart: '<S1823>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_o);

  /* End of SystemInitialize for SubSystem: '<S1748>/Chiller' */

  /* SystemInitialize for Atomic SubSystem: '<S1750>/EvapSurface' */

  /* SystemInitialize for Chart: '<S1840>/Judge' */
  ME11_Judge_Init(&ME11_TMSADCSampleFunc_ARID_DEF.SenSts_f4);

  /* End of SystemInitialize for SubSystem: '<S1750>/EvapSurface' */
}

/* Output and update for atomic system: '<S2>/Sensor' */
void ME11_TMSADCSampleFunc(void)
{
  adc2_group0 expl_temp;
  adc2_group1 expl_temp_0;
  adc2_group2 expl_temp_1;
  float32 rtb_Add_hwr;
  float32 rtb_Add_kg;
  uint32 qY;
  uint16 rtb_DataTypeConversion1_fr;
  boolean rtb_Compare_e5v;

  /* CCaller: '<S1746>/C Caller' */
  SENCtl_uRecircDoorVol = get_RecircValtage();

  /* Sum: '<S1746>/Add' incorporates:
   *  CCaller: '<S1746>/C Caller'
   *  DataTypeConversion: '<S1746>/Data Type Conversion2'
   *  Lookup_n-D: '<S1746>/cal_RecircDoorVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uRecircDoorVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uRecircDoorVol, (const uint16 *)
    &cal_RecircDoorVolAmend_1X[0], (const sint16 *)&cal_RecircDoorVolAmend_CUR[0],
    1U));

  /* DataStoreWrite: '<S1746>/Data Store Write' incorporates:
   *  ArithShift: '<S1746>/Shift Arithmetic'
   *  DataTypeConversion: '<S1746>/Data Type Conversion'
   *  DataTypeConversion: '<S1746>/Data Type Conversion1'
   *  DataTypeConversion: '<S1746>/Data Type Conversion4'
   */
  Buffer_DcmDspData_F271H[0] = (uint8)(uint16)rtb_Add_kg;
  Buffer_DcmDspData_F271H[1] = (uint8)((uint32)(uint16)rtb_Add_kg >> 8);

  /* Chart: '<S1810>/Judge' incorporates:
   *  Constant: '<S1746>/Constant1'
   *  Constant: '<S1810>/Constant'
   *  Constant: '<S1810>/Constant1'
   *  RelationalOperator: '<S1810>/Relational Operator'
   *  RelationalOperator: '<S1810>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorVolUpFlg, rtb_Add_kg < cal_SensorVolDownFlg,
             20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_nj,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_f);

  /* DataTypeConversion: '<S1746>/Data Type Conversion3' */
  ACSen_eRecircSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_nj;

  /* CCaller: '<S1746>/C Caller2' incorporates:
   *  Constant: '<S1746>/Constant4'
   *  Constant: '<S1807>/Constant'
   *  DataTypeConversion: '<S1746>/Data Type Conversion3'
   *  RelationalOperator: '<S1807>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x943211), (uint8)
                     (ACSen_eRecircSenSts == Ground));

  /* CCaller: '<S1746>/C Caller3' incorporates:
   *  Constant: '<S1746>/Constant7'
   *  Constant: '<S1808>/Constant'
   *  DataTypeConversion: '<S1746>/Data Type Conversion3'
   *  RelationalOperator: '<S1808>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x943215), (uint8)
                     (ACSen_eRecircSenSts == Power));

  /* Switch: '<S1809>/Switch' incorporates:
   *  Constant: '<S1809>/Constant'
   *  Constant: '<S1809>/Constant1'
   *  Gain: '<S1746>/Gain'
   *  Lookup_n-D: '<S1746>/cal_RecirActVal_CUR'
   */
  if (cal_AirInletPerEnb) {
    ACSen_eAirInletPer = cal_AirInletPerData;
  } else {
    ACSen_eAirInletPer = look1_iflftu8Df_binlca(0.001F * rtb_Add_kg, (const
      float32 *)&cal_RecirActVal_1X[0], (const uint8 *)&cal_RecirActVal_CUR[0],
      1U);
  }

  /* End of Switch: '<S1809>/Switch' */

  /* CCaller: '<S1741>/C Caller' */
  SENCtl_uFaceDuctVal = get_FaceDuctValtage();

  /* Sum: '<S1741>/Add' incorporates:
   *  CCaller: '<S1741>/C Caller'
   *  DataTypeConversion: '<S1741>/Data Type Conversion1'
   *  Lookup_n-D: '<S1741>/cal_FaceDuctVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uFaceDuctVal -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uFaceDuctVal, (const uint16 *)
    &cal_FaceDuctVolAmend_1X[0], (const sint16 *)&cal_FaceDuctVolAmend_CUR[0],
    1U));

  /* Outputs for Atomic SubSystem: '<S1741>/Face' */
  /* Sum: '<S1768>/Add' incorporates:
   *  Constant: '<S1741>/Constant1'
   */
  rtb_Add_hwr = cal_ADCVCCVal - rtb_Add_kg;

  /* Chart: '<S1772>/Judge' incorporates:
   *  Constant: '<S1768>/Constant1'
   *  Constant: '<S1772>/Constant'
   *  Constant: '<S1772>/Constant1'
   *  RelationalOperator: '<S1772>/Relational Operator'
   *  RelationalOperator: '<S1772>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorTempUpFlt, rtb_Add_kg <
             cal_SensorTempDownFlg, 20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_c,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_pp);

  /* DataTypeConversion: '<S1768>/Data Type Conversion' */
  ACSen_eFaceDuctSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_c;

  /* Switch: '<S1768>/Switch' incorporates:
   *  Constant: '<S1771>/Constant'
   *  RelationalOperator: '<S1771>/Compare'
   */
  if (rtb_Add_hwr > 0.0F) {
    /* Switch: '<S1842>/Init' incorporates:
     *  Product: '<S1768>/Divide'
     */
    rtb_Add_kg /= rtb_Add_hwr;
  } else {
    /* Switch: '<S1842>/Init' incorporates:
     *  Constant: '<S1768>/Constant'
     */
    rtb_Add_kg = 1.0F;
  }

  /* End of Switch: '<S1768>/Switch' */

  /* Lookup_n-D: '<S1741>/cal_TDuctRaw_CUR' incorporates:
   *  Constant: '<S1741>/Constant3'
   *  Product: '<S1768>/Divide1'
   */
  SEN_TDuctRaw = look1_iflf_binlca(rtb_Add_kg * 10.0F, (const float32 *)
    &cal_TDuctRaw_1X[0], (const float32 *)&cal_TDuctRaw_CUR[0], 25U);

  /* End of Outputs for SubSystem: '<S1741>/Face' */

  /* Switch: '<S1774>/Init' incorporates:
   *  Constant: '<S1741>/Constant2'
   *  Product: '<S1770>/Product'
   *  Product: '<S1770>/Product1'
   *  Sum: '<S1770>/Sum1'
   *  UnitDelay: '<S1774>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE = SEN_TDuctRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE = SEN_TDuctRaw * 0.9F +
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE * 0.100000024F;

  /* End of Switch: '<S1774>/Init' */

  /* Switch: '<S1769>/Switch' incorporates:
   *  Constant: '<S1769>/Constant1'
   */
  if (cal_FaceDuctTempEnb) {
    /* Switch: '<S1769>/Switch' incorporates:
     *  Constant: '<S1769>/Constant'
     */
    ACSen_sFaceDuctTempFilter = cal_FaceDuctTempData;
  } else {
    /* Switch: '<S1769>/Switch' incorporates:
     *  UnitDelay: '<S1774>/FixPt Unit Delay1'
     */
    ACSen_sFaceDuctTempFilter =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE;
  }

  /* End of Switch: '<S1769>/Switch' */

  /* DataTypeConversion: '<S1745>/Data Type Conversion1' incorporates:
   *  Constant: '<S1741>/Constant4'
   *  Constant: '<S1741>/Constant5'
   *  Product: '<S1741>/Divide'
   *  Sum: '<S1741>/Add1'
   */
  rtb_DataTypeConversion1_fr = (uint16)((ACSen_sFaceDuctTempFilter + 40.0F) *
    10.0F);

  /* DataStoreWrite: '<S1741>/Data Store Write' incorporates:
   *  ArithShift: '<S1741>/Shift Arithmetic'
   *  DataTypeConversion: '<S1741>/Data Type Conversion'
   *  DataTypeConversion: '<S1741>/Data Type Conversion2'
   *  DataTypeConversion: '<S1745>/Data Type Conversion1'
   */
  Buffer_DcmDspData_F266H[0] = (uint8)rtb_DataTypeConversion1_fr;
  Buffer_DcmDspData_F266H[1] = (uint8)((uint32)rtb_DataTypeConversion1_fr >> 8);

  /* CCaller: '<S1741>/C Caller1' incorporates:
   *  Constant: '<S1741>/Constant6'
   *  Constant: '<S1765>/Constant'
   *  DataTypeConversion: '<S1768>/Data Type Conversion'
   *  RelationalOperator: '<S1765>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941311), (uint8)
                     (ACSen_eFaceDuctSenSts == Ground));

  /* CCaller: '<S1741>/C Caller2' incorporates:
   *  Constant: '<S1741>/Constant7'
   *  Constant: '<S1766>/Constant'
   *  DataTypeConversion: '<S1768>/Data Type Conversion'
   *  RelationalOperator: '<S1766>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941315), (uint8)
                     (ACSen_eFaceDuctSenSts == Power));

  /* RelationalOperator: '<S1767>/Compare' incorporates:
   *  Constant: '<S1767>/Constant'
   *  DataTypeConversion: '<S1768>/Data Type Conversion'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.Compare = (ACSen_eFaceDuctSenSts != Normal);

  /* CCaller: '<S1742>/C Caller' */
  SENCtl_uFootDuctVal = get_FootDuctValtage();

  /* Sum: '<S1742>/Add' incorporates:
   *  CCaller: '<S1742>/C Caller'
   *  DataTypeConversion: '<S1742>/Data Type Conversion1'
   *  Lookup_n-D: '<S1742>/cal_FootDuctVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uFootDuctVal -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uFootDuctVal, (const uint16 *)
    &cal_FootDuctVolAmend_1X[0], (const sint16 *)&cal_FootDuctVolAmend_CUR[0],
    1U));

  /* Outputs for Atomic SubSystem: '<S1742>/Foot' */
  /* Sum: '<S1778>/Add' incorporates:
   *  Constant: '<S1742>/Constant1'
   */
  rtb_Add_hwr = cal_ADCVCCVal - rtb_Add_kg;

  /* Chart: '<S1782>/Judge' incorporates:
   *  Constant: '<S1778>/Constant1'
   *  Constant: '<S1782>/Constant'
   *  Constant: '<S1782>/Constant1'
   *  RelationalOperator: '<S1782>/Relational Operator'
   *  RelationalOperator: '<S1782>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorTempUpFlt, rtb_Add_kg <
             cal_SensorTempDownFlg, 20,
             &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_no,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_n);

  /* DataTypeConversion: '<S1778>/Data Type Conversion' */
  ACSen_eFootDuctSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_no;

  /* Switch: '<S1778>/Switch' incorporates:
   *  Constant: '<S1781>/Constant'
   *  RelationalOperator: '<S1781>/Compare'
   */
  if (rtb_Add_hwr > 0.0F) {
    /* Switch: '<S1842>/Init' incorporates:
     *  Product: '<S1778>/Divide'
     */
    rtb_Add_kg /= rtb_Add_hwr;
  } else {
    /* Switch: '<S1842>/Init' incorporates:
     *  Constant: '<S1778>/Constant'
     */
    rtb_Add_kg = 1.0F;
  }

  /* End of Switch: '<S1778>/Switch' */

  /* Lookup_n-D: '<S1742>/cal_TDuctRaw_CUR' incorporates:
   *  Constant: '<S1742>/Constant3'
   *  Product: '<S1778>/Divide1'
   */
  SEN_TFootDuctRaw = look1_iflf_binlca(rtb_Add_kg * 10.0F, (const float32 *)
    &cal_TDuctRaw_1X[0], (const float32 *)&cal_TDuctRaw_CUR[0], 25U);

  /* End of Outputs for SubSystem: '<S1742>/Foot' */

  /* Switch: '<S1784>/Init' incorporates:
   *  Constant: '<S1742>/Constant2'
   *  Product: '<S1780>/Product'
   *  Product: '<S1780>/Product1'
   *  Sum: '<S1780>/Sum1'
   *  UnitDelay: '<S1784>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_a != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_j = SEN_TFootDuctRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_j = SEN_TFootDuctRaw *
    0.9F + ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_j *
    0.100000024F;

  /* End of Switch: '<S1784>/Init' */

  /* Switch: '<S1779>/Switch' incorporates:
   *  Constant: '<S1779>/Constant1'
   */
  if (cal_FootDuctTempEnb) {
    /* Switch: '<S1779>/Switch' incorporates:
     *  Constant: '<S1779>/Constant'
     */
    ACSen_sFootDuctTempFilter = cal_FootDuctTempData;
  } else {
    /* Switch: '<S1779>/Switch' incorporates:
     *  UnitDelay: '<S1784>/FixPt Unit Delay1'
     */
    ACSen_sFootDuctTempFilter =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_j;
  }

  /* End of Switch: '<S1779>/Switch' */

  /* DataTypeConversion: '<S1745>/Data Type Conversion1' incorporates:
   *  Constant: '<S1742>/Constant4'
   *  Constant: '<S1742>/Constant5'
   *  Product: '<S1742>/Divide'
   *  Sum: '<S1742>/Add1'
   */
  rtb_DataTypeConversion1_fr = (uint16)((ACSen_sFootDuctTempFilter + 40.0F) *
    10.0F);

  /* DataStoreWrite: '<S1742>/Data Store Write' incorporates:
   *  ArithShift: '<S1742>/Shift Arithmetic'
   *  DataTypeConversion: '<S1742>/Data Type Conversion'
   *  DataTypeConversion: '<S1742>/Data Type Conversion2'
   *  DataTypeConversion: '<S1745>/Data Type Conversion1'
   */
  Buffer_DcmDspData_F267H[0] = (uint8)rtb_DataTypeConversion1_fr;
  Buffer_DcmDspData_F267H[1] = (uint8)((uint32)rtb_DataTypeConversion1_fr >> 8);

  /* CCaller: '<S1742>/C Caller1' incorporates:
   *  Constant: '<S1742>/Constant6'
   *  Constant: '<S1775>/Constant'
   *  DataTypeConversion: '<S1778>/Data Type Conversion'
   *  RelationalOperator: '<S1775>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941411), (uint8)
                     (ACSen_eFootDuctSenSts == Ground));

  /* CCaller: '<S1742>/C Caller2' incorporates:
   *  Constant: '<S1742>/Constant7'
   *  Constant: '<S1776>/Constant'
   *  DataTypeConversion: '<S1778>/Data Type Conversion'
   *  RelationalOperator: '<S1776>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941515), (uint8)
                     (ACSen_eFootDuctSenSts == Power));

  /* RelationalOperator: '<S1777>/Compare' incorporates:
   *  Constant: '<S1777>/Constant'
   *  DataTypeConversion: '<S1778>/Data Type Conversion'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.Compare_k = (ACSen_eFootDuctSenSts != Normal);

  /* CCaller: '<S1744>/C Caller' */
  SENCtl_uMixDoorVol = get_MixDoorValtage();

  /* Switch: '<S1816>/Init' incorporates:
   *  CCaller: '<S1744>/C Caller'
   *  DataTypeConversion: '<S1744>/Data Type Conversion2'
   *  Lookup_n-D: '<S1744>/cal_MixDoorVolAmend_CUR'
   *  Sum: '<S1744>/Add'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uMixDoorVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uMixDoorVol, (const uint16 *)
    &cal_MixDoorVolAmend_1X[0], (const sint16 *)&cal_MixDoorVolAmend_CUR[0], 1U));

  /* DataStoreWrite: '<S1744>/Data Store Write' incorporates:
   *  ArithShift: '<S1744>/Shift Arithmetic'
   *  DataTypeConversion: '<S1744>/Data Type Conversion'
   *  DataTypeConversion: '<S1744>/Data Type Conversion1'
   *  DataTypeConversion: '<S1744>/Data Type Conversion4'
   */
  Buffer_DcmDspData_F272H[0] = (uint8)(uint16)rtb_Add_kg;
  Buffer_DcmDspData_F272H[1] = (uint8)((uint32)(uint16)rtb_Add_kg >> 8);

  /* Chart: '<S1796>/Judge' incorporates:
   *  Constant: '<S1744>/Constant1'
   *  Constant: '<S1796>/Constant'
   *  Constant: '<S1796>/Constant1'
   *  RelationalOperator: '<S1796>/Relational Operator'
   *  RelationalOperator: '<S1796>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorVolUpFlg, rtb_Add_kg < cal_SensorVolDownFlg,
             20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_oo,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_g1);

  /* DataTypeConversion: '<S1744>/Data Type Conversion3' */
  ACSen_eMixDoorSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_oo;

  /* CCaller: '<S1744>/C Caller2' incorporates:
   *  Constant: '<S1744>/Constant4'
   *  Constant: '<S1793>/Constant'
   *  DataTypeConversion: '<S1744>/Data Type Conversion3'
   *  RelationalOperator: '<S1793>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x943411), (uint8)
                     (ACSen_eMixDoorSenSts == Ground));

  /* CCaller: '<S1744>/C Caller3' incorporates:
   *  Constant: '<S1744>/Constant7'
   *  Constant: '<S1794>/Constant'
   *  DataTypeConversion: '<S1744>/Data Type Conversion3'
   *  RelationalOperator: '<S1794>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x943415), (uint8)
                     (ACSen_eMixDoorSenSts == Power));

  /* Lookup_n-D: '<S1744>/cal_MixDoorPerc_CUR' incorporates:
   *  Switch: '<S1816>/Init'
   */
  SEN_MixDoorRaw = look1_iflf_binlca(rtb_Add_kg, (const float32 *)
    &cal_MixDoorV_1X[0], (const float32 *)&cal_MixDoorPerc_CUR[0], 1U);

  /* Switch: '<S1799>/Init' incorporates:
   *  Constant: '<S1744>/Constant15'
   *  Product: '<S1797>/Product'
   *  Product: '<S1797>/Product1'
   *  Sum: '<S1797>/Sum1'
   *  UnitDelay: '<S1799>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_o != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_k = SEN_MixDoorRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_k = SEN_MixDoorRaw *
    0.9F + ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_k *
    0.100000024F;

  /* End of Switch: '<S1799>/Init' */

  /* Switch: '<S1795>/Switch' incorporates:
   *  Constant: '<S1795>/Constant'
   *  Constant: '<S1795>/Constant1'
   *  UnitDelay: '<S1799>/FixPt Unit Delay1'
   */
  if (cal_MixDoorPercDataEnb) {
    ACSen_sMixDoorPerc = cal_MixDoorPercData;
  } else {
    ACSen_sMixDoorPerc = ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_k;
  }

  /* End of Switch: '<S1795>/Switch' */

  /* CCaller: '<S1745>/C Caller' */
  SENCtl_uModeDoorVol = get_ModeMotorValtage();

  /* Switch: '<S1816>/Init' incorporates:
   *  CCaller: '<S1745>/C Caller'
   *  DataTypeConversion: '<S1745>/Data Type Conversion2'
   *  Lookup_n-D: '<S1745>/cal_ModeDoorVolAmend_CUR'
   *  Sum: '<S1745>/Add'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uModeDoorVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uModeDoorVol, (const uint16 *)
    &cal_ModeDoorVolAmend_1X[0], (const sint16 *)&cal_ModeDoorVolAmend_CUR[0],
    1U));

  /* DataStoreWrite: '<S1745>/Data Store Write' incorporates:
   *  ArithShift: '<S1745>/Shift Arithmetic'
   *  DataTypeConversion: '<S1745>/Data Type Conversion'
   *  DataTypeConversion: '<S1745>/Data Type Conversion1'
   *  DataTypeConversion: '<S1745>/Data Type Conversion4'
   */
  Buffer_DcmDspData_F270H[0] = (uint8)(uint16)rtb_Add_kg;
  Buffer_DcmDspData_F270H[1] = (uint8)((uint32)(uint16)rtb_Add_kg >> 8);

  /* Chart: '<S1803>/Judge' incorporates:
   *  Constant: '<S1745>/Constant1'
   *  Constant: '<S1803>/Constant'
   *  Constant: '<S1803>/Constant1'
   *  RelationalOperator: '<S1803>/Relational Operator'
   *  RelationalOperator: '<S1803>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorVolUpFlg, rtb_Add_kg < cal_SensorVolDownFlg,
             20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_lb,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_g);

  /* DataTypeConversion: '<S1745>/Data Type Conversion3' */
  ACSen_eModeSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_lb;

  /* CCaller: '<S1745>/C Caller2' incorporates:
   *  Constant: '<S1745>/Constant4'
   *  Constant: '<S1800>/Constant'
   *  DataTypeConversion: '<S1745>/Data Type Conversion3'
   *  RelationalOperator: '<S1800>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x943211), (uint8)
                     (ACSen_eModeSenSts == Ground));

  /* CCaller: '<S1745>/C Caller3' incorporates:
   *  Constant: '<S1745>/Constant7'
   *  Constant: '<S1801>/Constant'
   *  DataTypeConversion: '<S1745>/Data Type Conversion3'
   *  RelationalOperator: '<S1801>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x943315), (uint8)
                     (ACSen_eModeSenSts == Power));

  /* Switch: '<S1816>/Init' incorporates:
   *  Gain: '<S1745>/Gain'
   */
  rtb_Add_kg *= 0.001F;

  /* Switch: '<S1806>/Init' incorporates:
   *  Constant: '<S1745>/Constant13'
   *  Product: '<S1804>/Product'
   *  Product: '<S1804>/Product1'
   *  Sum: '<S1804>/Sum1'
   *  UnitDelay: '<S1806>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_l != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_g = rtb_Add_kg;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_g = rtb_Add_kg * 0.9F +
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_g * 0.100000024F;

  /* End of Switch: '<S1806>/Init' */

  /* Switch: '<S1802>/Switch' incorporates:
   *  Constant: '<S1802>/Constant'
   *  Constant: '<S1802>/Constant1'
   *  UnitDelay: '<S1806>/FixPt Unit Delay1'
   */
  if (cal_MotorModeEnb) {
    ACSen_sModeMotorVol = cal_MotorModeData;
  } else {
    ACSen_sModeMotorVol =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_g;
  }

  /* End of Switch: '<S1802>/Switch' */

  /* CCaller: '<S1749>/C Caller' */
  SENCtl_uEVAPXTempVol = get_EVAPTempValtage();

  /* Sum: '<S1749>/Add' incorporates:
   *  CCaller: '<S1749>/C Caller'
   *  DataTypeConversion: '<S1749>/Data Type Conversion1'
   *  Lookup_n-D: '<S1749>/cal_EVAPTempVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uEVAPXTempVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uEVAPXTempVol, (const uint16 *)
    &cal_EVAPTempVolAmend_1X[0], (const sint16 *)&cal_EVAPTempVolAmend_CUR[0],
    1U));

  /* Outputs for Atomic SubSystem: '<S1749>/EVAP' */
  /* Sum: '<S1826>/Add' incorporates:
   *  Constant: '<S1749>/Constant1'
   */
  rtb_Add_hwr = cal_ADCVCCVal - rtb_Add_kg;

  /* Chart: '<S1830>/Judge' incorporates:
   *  Constant: '<S1826>/Constant1'
   *  Constant: '<S1830>/Constant'
   *  Constant: '<S1830>/Constant1'
   *  RelationalOperator: '<S1830>/Relational Operator'
   *  RelationalOperator: '<S1830>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorTempUpFlt, rtb_Add_kg <
             cal_SensorTempDownFlg, 20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_n,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_b);

  /* DataTypeConversion: '<S1826>/Data Type Conversion' */
  ACSen_eEVAPTSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_n;

  /* Switch: '<S1826>/Switch' incorporates:
   *  Constant: '<S1829>/Constant'
   *  RelationalOperator: '<S1829>/Compare'
   */
  if (rtb_Add_hwr > 0.0F) {
    /* Switch: '<S1842>/Init' incorporates:
     *  Product: '<S1826>/Divide'
     */
    rtb_Add_kg /= rtb_Add_hwr;
  } else {
    /* Switch: '<S1842>/Init' incorporates:
     *  Constant: '<S1826>/Constant'
     */
    rtb_Add_kg = 1.0F;
  }

  /* End of Switch: '<S1826>/Switch' */

  /* Lookup_n-D: '<S1749>/cal_TEvapOutRaw_CUR' incorporates:
   *  Constant: '<S1749>/Constant3'
   *  Product: '<S1826>/Divide1'
   */
  SEN_EvapTRaw = look1_iflf_binlca(rtb_Add_kg * 3000.0F, (const float32 *)
    &cal_TEvapOutRaw_1X[0], (const float32 *)&cal_TEvapOutRaw_CUR[0], 29U);

  /* End of Outputs for SubSystem: '<S1749>/EVAP' */

  /* Switch: '<S1832>/Init' incorporates:
   *  Constant: '<S1749>/Constant7'
   *  Product: '<S1828>/Product'
   *  Product: '<S1828>/Product1'
   *  Sum: '<S1828>/Sum1'
   *  UnitDelay: '<S1832>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_m != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_o = SEN_EvapTRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_o = SEN_EvapTRaw * 0.9F
    + ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_o * 0.100000024F;

  /* End of Switch: '<S1832>/Init' */

  /* Switch: '<S1827>/Switch' incorporates:
   *  Constant: '<S1827>/Constant1'
   */
  if (cal_EvapTempDataEnb) {
    /* Switch: '<S1827>/Switch' incorporates:
     *  Constant: '<S1827>/Constant'
     */
    ACSen_sEvapTempFilter = cal_EvapTempData;
  } else {
    /* Switch: '<S1827>/Switch' incorporates:
     *  UnitDelay: '<S1832>/FixPt Unit Delay1'
     */
    ACSen_sEvapTempFilter =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_o;
  }

  /* End of Switch: '<S1827>/Switch' */

  /* CCaller: '<S1749>/C Caller1' incorporates:
   *  Constant: '<S1749>/Constant2'
   *  Constant: '<S1749>/Constant6'
   *  Sum: '<S1749>/Add1'
   */
  Rte_DIDReadData((uint8)(ACSen_sEvapTempFilter + 40.0F), ((uint8)DID_0xF263));

  /* CCaller: '<S1752>/C Caller' */
  SENCtl_uWCCHighTempVol = get_WCCHighTempValtage();

  /* Sum: '<S1752>/Add' incorporates:
   *  CCaller: '<S1752>/C Caller'
   *  DataTypeConversion: '<S1752>/Data Type Conversion1'
   *  Lookup_n-D: '<S1752>/cal_WCCHighTempVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uWCCHighTempVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uWCCHighTempVol, (const uint16 *)
    &cal_WCCHighTempVolAmend_1X[0], (const sint16 *)
    &cal_WCCHighTempVolAmend_CUR[0], 1U));

  /* Outputs for Atomic SubSystem: '<S1752>/Env' */
  /* Sum: '<S1854>/Add' incorporates:
   *  Constant: '<S1752>/Constant1'
   */
  rtb_Add_hwr = cal_ADCVCCVal - rtb_Add_kg;

  /* Chart: '<S1858>/Judge' incorporates:
   *  Constant: '<S1854>/Constant1'
   *  Constant: '<S1858>/Constant'
   *  Constant: '<S1858>/Constant1'
   *  RelationalOperator: '<S1858>/Relational Operator'
   *  RelationalOperator: '<S1858>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorTempUpFlt, rtb_Add_kg <
             cal_SensorTempDownFlg, 20,
             &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_fm,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_c);

  /* DataTypeConversion: '<S1854>/Data Type Conversion' */
  ACSen_eWCCHTSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_fm;

  /* Switch: '<S1854>/Switch' incorporates:
   *  Constant: '<S1857>/Constant'
   *  RelationalOperator: '<S1857>/Compare'
   */
  if (rtb_Add_hwr > 0.0F) {
    /* Switch: '<S1842>/Init' incorporates:
     *  Product: '<S1854>/Divide'
     */
    rtb_Add_kg /= rtb_Add_hwr;
  } else {
    /* Switch: '<S1842>/Init' incorporates:
     *  Constant: '<S1854>/Constant'
     */
    rtb_Add_kg = 1.0F;
  }

  /* End of Switch: '<S1854>/Switch' */

  /* Lookup_n-D: '<S1752>/cal_WCCTHiRaw_CUR' incorporates:
   *  Constant: '<S1752>/Constant3'
   *  Product: '<S1854>/Divide1'
   */
  SEN_WCCTHiRaw = look1_iflf_binlca(rtb_Add_kg * 20000.0F, (const float32 *)
    &cal_TLCCOutRaw_1X[0], (const float32 *)&cal_TLCCOutRaw_CUR[0], 19U);

  /* End of Outputs for SubSystem: '<S1752>/Env' */

  /* Switch: '<S1860>/Init' incorporates:
   *  Constant: '<S1752>/Constant5'
   *  Product: '<S1855>/Product'
   *  Product: '<S1855>/Product1'
   *  Sum: '<S1855>/Sum1'
   *  UnitDelay: '<S1860>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_f != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_a = SEN_WCCTHiRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_a = SEN_WCCTHiRaw * 0.9F
    + ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_a * 0.100000024F;

  /* End of Switch: '<S1860>/Init' */

  /* Switch: '<S1856>/Switch' incorporates:
   *  Constant: '<S1856>/Constant1'
   */
  if (cal_WCCTempDataEnb) {
    /* Switch: '<S1856>/Switch' incorporates:
     *  Constant: '<S1856>/Constant'
     */
    ACSen_sWCCHiTempFilter = cal_WCCTempData;
  } else {
    /* Switch: '<S1856>/Switch' incorporates:
     *  UnitDelay: '<S1860>/FixPt Unit Delay1'
     */
    ACSen_sWCCHiTempFilter =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_a;
  }

  /* End of Switch: '<S1856>/Switch' */

  /* CCaller: '<S1752>/C Caller1' incorporates:
   *  Constant: '<S1752>/Constant2'
   *  Constant: '<S1752>/Constant6'
   *  Sum: '<S1752>/Add1'
   */
  Rte_DIDReadData((uint8)(ACSen_sWCCHiTempFilter + 40.0F), ((uint8)DID_0xF265));

  /* CCaller: '<S1752>/C Caller2' incorporates:
   *  Constant: '<S1752>/Constant4'
   *  Constant: '<S1852>/Constant'
   *  DataTypeConversion: '<S1854>/Data Type Conversion'
   *  RelationalOperator: '<S1852>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941E11), (uint8)
                     (ACSen_eWCCHTSenSts == Ground));

  /* CCaller: '<S1752>/C Caller3' incorporates:
   *  Constant: '<S1752>/Constant7'
   *  Constant: '<S1853>/Constant'
   *  DataTypeConversion: '<S1854>/Data Type Conversion'
   *  RelationalOperator: '<S1853>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941E15), (uint8)
                     (ACSen_eWCCHTSenSts == Power));

  /* CCaller: '<S1753>/C Caller' */
  SENCtl_uWCCHPVol = get_WCCHighPressValtage();

  /* Sum: '<S1747>/Add' incorporates:
   *  CCaller: '<S1753>/C Caller'
   *  DataTypeConversion: '<S1753>/Data Type Conversion2'
   *  Lookup_n-D: '<S1753>/cal_WCCHPVolAmend_CUR'
   *  Sum: '<S1753>/Add'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uWCCHPVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uWCCHPVol, (const uint16 *)
    &cal_WCCHPVolAmend_1X[0], (const sint16 *)&cal_WCCHPVolAmend_CUR[0], 1U));

  /* Lookup_n-D: '<S1753>/cal_LCCOutHiPressRaw_CUR' incorporates:
   *  Sum: '<S1747>/Add'
   */
  SEN_WCCHiPressRaw = look1_iflf_binlca(rtb_Add_kg, (const float32 *)
    &cal_LCCOutHiPressRaw_1X[0], (const float32 *)&cal_LCCOutHiPressRaw_CUR[0],
    1U);

  /* Switch: '<S1869>/Init' incorporates:
   *  Constant: '<S1753>/Constant4'
   *  Product: '<S1867>/Product'
   *  Product: '<S1867>/Product1'
   *  Sum: '<S1867>/Sum1'
   *  UnitDelay: '<S1869>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_n != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_f = SEN_WCCHiPressRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_f = SEN_WCCHiPressRaw *
    0.9F + ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_f *
    0.100000024F;

  /* End of Switch: '<S1869>/Init' */

  /* Switch: '<S1864>/Switch' incorporates:
   *  Constant: '<S1753>/Constant'
   *  Constant: '<S1753>/Constant5'
   *  Constant: '<S1864>/Constant1'
   *  RelationalOperator: '<S1865>/LowerRelop1'
   *  RelationalOperator: '<S1865>/UpperRelop'
   *  Switch: '<S1865>/Switch'
   *  Switch: '<S1865>/Switch2'
   *  UnitDelay: '<S1869>/FixPt Unit Delay1'
   */
  if (cal_HiPressDataEnb) {
    /* Switch: '<S1864>/Switch' incorporates:
     *  Constant: '<S1864>/Constant'
     */
    ACSen_sHiPressFilter = cal_HiPressData;
  } else if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_f >
             cal_HPHighLmtVal) {
    /* Switch: '<S1865>/Switch2' incorporates:
     *  Constant: '<S1753>/Constant'
     *  Switch: '<S1864>/Switch'
     */
    ACSen_sHiPressFilter = cal_HPHighLmtVal;
  } else if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_f < 0.0F) {
    /* Switch: '<S1865>/Switch' incorporates:
     *  Constant: '<S1753>/Constant5'
     *  Switch: '<S1864>/Switch'
     *  Switch: '<S1865>/Switch2'
     */
    ACSen_sHiPressFilter = 0.0F;
  } else {
    /* Switch: '<S1864>/Switch' incorporates:
     *  Switch: '<S1865>/Switch'
     *  Switch: '<S1865>/Switch2'
     *  UnitDelay: '<S1869>/FixPt Unit Delay1'
     */
    ACSen_sHiPressFilter =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_f;
  }

  /* End of Switch: '<S1864>/Switch' */

  /* CCaller: '<S1753>/C Caller1' incorporates:
   *  Constant: '<S1753>/Constant3'
   *  Constant: '<S1753>/Constant6'
   *  Product: '<S1753>/Divide'
   */
  Rte_DIDReadData((uint8)(10.0F * ACSen_sHiPressFilter), ((uint8)DID_0xF264));

  /* Chart: '<S1866>/Judge' incorporates:
   *  Constant: '<S1753>/Constant1'
   *  Constant: '<S1866>/Constant'
   *  Constant: '<S1866>/Constant1'
   *  RelationalOperator: '<S1866>/Relational Operator'
   *  RelationalOperator: '<S1866>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorVolUpFlg, rtb_Add_kg < cal_SensorVolDownFlg,
             20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_f,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_m);

  /* DataTypeConversion: '<S1753>/Data Type Conversion3' */
  ACSen_eWCCHPSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_f;

  /* CCaller: '<S1753>/C Caller2' incorporates:
   *  Constant: '<S1753>/Constant2'
   *  Constant: '<S1861>/Constant'
   *  DataTypeConversion: '<S1753>/Data Type Conversion3'
   *  RelationalOperator: '<S1861>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941D11), (uint8)
                     (ACSen_eWCCHPSenSts == Ground));

  /* CCaller: '<S1753>/C Caller3' incorporates:
   *  Constant: '<S1753>/Constant7'
   *  Constant: '<S1862>/Constant'
   *  DataTypeConversion: '<S1753>/Data Type Conversion3'
   *  RelationalOperator: '<S1862>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941D15), (uint8)
                     (ACSen_eWCCHPSenSts == Power));

  /* RelationalOperator: '<S1863>/Compare' incorporates:
   *  Constant: '<S1863>/Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.Compare_g =
    (ME11_TMSADCSampleFunc_ARID_DEF.SenSts_f != 0);

  /* CCaller: '<S1743>/C Caller' */
  SENCtl_uWCCLPVol = get_LowPressValtage();

  /* Sum: '<S1747>/Add' incorporates:
   *  CCaller: '<S1743>/C Caller'
   *  DataTypeConversion: '<S1743>/Data Type Conversion2'
   *  Lookup_n-D: '<S1743>/cal_WCCLPVolAmend_CUR'
   *  Sum: '<S1743>/Add'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uWCCLPVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uWCCLPVol, (const uint16 *)
    &cal_WCCLPVolAmend_1X[0], (const sint16 *)&cal_WCCLPVolAmend_CUR[0], 1U));

  /* Lookup_n-D: '<S1743>/cal_LoPress_CUR' incorporates:
   *  Sum: '<S1747>/Add'
   */
  SEN_LoPressRaw = look1_iflf_binlca(rtb_Add_kg, (const float32 *)
    &cal_LoPressRaw_1X[0], (const float32 *)&cal_LoPressRaw_CUR[0], 1U);

  /* Switch: '<S1792>/Init' incorporates:
   *  Constant: '<S1743>/Constant9'
   *  Product: '<S1790>/Product'
   *  Product: '<S1790>/Product1'
   *  Sum: '<S1790>/Sum1'
   *  UnitDelay: '<S1792>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_f1 != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_fi = SEN_LoPressRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_fi = SEN_LoPressRaw *
    0.9F + ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_fi *
    0.100000024F;

  /* End of Switch: '<S1792>/Init' */

  /* Switch: '<S1788>/Switch' incorporates:
   *  Constant: '<S1788>/Constant1'
   */
  if (cal_LoPressDataEnb) {
    /* Switch: '<S1788>/Switch' incorporates:
     *  Constant: '<S1788>/Constant'
     */
    ACSen_sLoPressFilter = cal_LoPressData;
  } else {
    /* Switch: '<S1788>/Switch' incorporates:
     *  UnitDelay: '<S1792>/FixPt Unit Delay1'
     */
    ACSen_sLoPressFilter =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_fi;
  }

  /* End of Switch: '<S1788>/Switch' */

  /* CCaller: '<S1743>/C Caller1' incorporates:
   *  Constant: '<S1743>/Constant3'
   *  Constant: '<S1743>/Constant5'
   *  Product: '<S1743>/Divide'
   */
  Rte_DIDReadData((uint8)(100.0F * ACSen_sLoPressFilter), ((uint8)DID_0xF282));

  /* Chart: '<S1789>/Judge' incorporates:
   *  Constant: '<S1743>/Constant1'
   *  Constant: '<S1789>/Constant'
   *  Constant: '<S1789>/Constant1'
   *  RelationalOperator: '<S1789>/Relational Operator'
   *  RelationalOperator: '<S1789>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorVolUpFlg, rtb_Add_kg < cal_SensorVolDownFlg,
             20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_e,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_me);

  /* DataTypeConversion: '<S1743>/Data Type Conversion3' */
  ACSen_eLPSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_e;

  /* CCaller: '<S1743>/C Caller2' incorporates:
   *  Constant: '<S1743>/Constant4'
   *  Constant: '<S1785>/Constant'
   *  DataTypeConversion: '<S1743>/Data Type Conversion3'
   *  RelationalOperator: '<S1785>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942011), (uint8)
                     (ACSen_eLPSenSts == Ground));

  /* CCaller: '<S1743>/C Caller3' incorporates:
   *  Constant: '<S1743>/Constant7'
   *  Constant: '<S1786>/Constant'
   *  DataTypeConversion: '<S1743>/Data Type Conversion3'
   *  RelationalOperator: '<S1786>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942015), (uint8)
                     (ACSen_eLPSenSts == Power));

  /* RelationalOperator: '<S1787>/Compare' incorporates:
   *  Constant: '<S1787>/Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.Compare_n =
    (ME11_TMSADCSampleFunc_ARID_DEF.SenSts_e != 0);

  /* CCaller: '<S1739>/C Caller' */
  SENCtl_uCabinVoltage = get_CabinValtage();

  /* Sum: '<S1739>/Add' incorporates:
   *  CCaller: '<S1739>/C Caller'
   *  DataTypeConversion: '<S1739>/Data Type Conversion'
   *  Lookup_n-D: '<S1739>/cal_CabinVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uCabinVoltage -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uCabinVoltage, (const uint16 *)
    &cal_CabinVolAmend_1X[0], (const sint16 *)&cal_CabinVolAmend_CUR[0], 1U));

  /* Outputs for Atomic SubSystem: '<S1739>/Cabin' */
  /* Chart: '<S1762>/Judge' incorporates:
   *  Constant: '<S1755>/Constant1'
   *  Constant: '<S1762>/Constant'
   *  Constant: '<S1762>/Constant1'
   *  RelationalOperator: '<S1762>/Relational Operator'
   *  RelationalOperator: '<S1762>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorTempUpFlt, rtb_Add_kg <
             cal_SensorTempDownFlg, 20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_k,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_l);

  /* DataTypeConversion: '<S1755>/Data Type Conversion' */
  ACSen_eCabinSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_k;

  /* CCaller: '<S1755>/C Caller1' incorporates:
   *  Constant: '<S1755>/Constant2'
   *  Constant: '<S1759>/Constant'
   *  DataTypeConversion: '<S1755>/Data Type Conversion'
   *  RelationalOperator: '<S1759>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941211), (uint8)
                     (ACSen_eCabinSenSts == Ground));

  /* CCaller: '<S1755>/C Caller2' incorporates:
   *  Constant: '<S1755>/Constant3'
   *  Constant: '<S1760>/Constant'
   *  DataTypeConversion: '<S1755>/Data Type Conversion'
   *  RelationalOperator: '<S1760>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941215), (uint8)
                     (ACSen_eCabinSenSts == Power));

  /* Sum: '<S1755>/Add' incorporates:
   *  Constant: '<S1739>/Constant2'
   */
  rtb_Add_hwr = cal_ADCVCCVal - rtb_Add_kg;

  /* RelationalOperator: '<S1761>/Compare' incorporates:
   *  Constant: '<S1761>/Constant'
   *  DataTypeConversion: '<S1755>/Data Type Conversion'
   */
  rtb_Compare_e5v = (ACSen_eCabinSenSts != Normal);

  /* Switch: '<S1755>/Switch' incorporates:
   *  Constant: '<S1758>/Constant'
   *  RelationalOperator: '<S1758>/Compare'
   */
  if (rtb_Add_hwr > 0.0F) {
    /* Switch: '<S1842>/Init' incorporates:
     *  Product: '<S1755>/Divide'
     */
    rtb_Add_kg /= rtb_Add_hwr;
  } else {
    /* Switch: '<S1842>/Init' incorporates:
     *  Constant: '<S1755>/Constant'
     */
    rtb_Add_kg = 1.0F;
  }

  /* End of Switch: '<S1755>/Switch' */

  /* Lookup_n-D: '<S1739>/cal_TCabinRaw_CUR' incorporates:
   *  Constant: '<S1739>/Constant3'
   *  Product: '<S1755>/Divide1'
   */
  SEN_TCabinRaw = look1_iflf_binlca(rtb_Add_kg * 3.0F, (const float32 *)
    &cal_TCabinRaw_1X[0], (const float32 *)&cal_TCabinRaw_CUR[0], 26U);

  /* End of Outputs for SubSystem: '<S1739>/Cabin' */

  /* Switch: '<S1764>/Init' incorporates:
   *  Constant: '<S1739>/Constant'
   *  Product: '<S1757>/Product'
   *  Product: '<S1757>/Product1'
   *  Sum: '<S1757>/Sum1'
   *  UnitDelay: '<S1764>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_c != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_ow = SEN_TCabinRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_ow = SEN_TCabinRaw *
    0.99F + ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_ow *
    0.00999999F;

  /* End of Switch: '<S1764>/Init' */

  /* Switch: '<S1756>/Switch' incorporates:
   *  Constant: '<S1756>/Constant1'
   */
  if (cal_CabinTempEnb) {
    /* Switch: '<S1756>/Switch' incorporates:
     *  Constant: '<S1756>/Constant'
     */
    ACSen_sCabinTempFilter = cal_CabinTempData;
  } else {
    /* Switch: '<S1756>/Switch' incorporates:
     *  UnitDelay: '<S1764>/FixPt Unit Delay1'
     */
    ACSen_sCabinTempFilter =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_ow;
  }

  /* End of Switch: '<S1756>/Switch' */

  /* CCaller: '<S1739>/C Caller1' incorporates:
   *  Constant: '<S1739>/Constant1'
   *  Constant: '<S1739>/Constant4'
   *  Constant: '<S1739>/Constant5'
   *  Product: '<S1739>/Divide'
   *  Sum: '<S1739>/Add1'
   */
  Rte_DIDReadData((uint8)(2.0F * (ACSen_sCabinTempFilter + 40.0F)), ((uint8)
    DID_0xF261));

  /* SignalConversion: '<S1739>/Signal Copy1' */
  ACTCtl_bCabinFltFlg = rtb_Compare_e5v;

  /* CCaller: '<S1747>/C_Caller' */
  SENCtl_uSolorVol = get_SolorValtage();

  /* Sum: '<S1747>/Add' incorporates:
   *  CCaller: '<S1747>/C_Caller'
   *  DataTypeConversion: '<S1747>/Data Type Conversion2'
   *  Lookup_n-D: '<S1747>/cal_SolorVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uSolorVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uSolorVol, (const uint16 *)
    &cal_SolorVolAmend_1X[0], (const sint16 *)&cal_SolorVolAmend_CUR[0], 1U));

  /* Lookup_n-D: '<S1747>/cal_SolarValRaw_CUR' incorporates:
   *  Gain: '<S1747>/Gain'
   */
  SEN_SolarRaw = look1_iflftu16Df_binlca(0.001F * rtb_Add_kg, (const float32 *)
    &cal_SolarValRaw_1X[0], (const uint16 *)&cal_SolarValRaw_CUR[0], 10U);

  /* Switch: '<S1816>/Init' incorporates:
   *  Constant: '<S1747>/Constant13'
   *  DataTypeConversion: '<S1747>/Data Type Conversion'
   *  Product: '<S1814>/Product'
   *  Product: '<S1814>/Product1'
   *  Sum: '<S1814>/Sum1'
   *  UnitDelay: '<S1816>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_g != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_p = SEN_SolarRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_p = (float32)
    SEN_SolarRaw * 0.9F +
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_p * 0.100000024F;

  /* End of Switch: '<S1816>/Init' */

  /* Chart: '<S1813>/Judge' incorporates:
   *  Constant: '<S1747>/Constant1'
   *  Constant: '<S1813>/Constant'
   *  Constant: '<S1813>/Constant1'
   *  RelationalOperator: '<S1813>/Relational Operator'
   *  RelationalOperator: '<S1813>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorVolUpFlg, rtb_Add_kg < cal_SensorVolDownFlg,
             20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_fr,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_cv);

  /* DataTypeConversion: '<S1747>/Data Type Conversion3' */
  ACSen_eSOLARSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_fr;

  /* Switch: '<S1812>/Switch' incorporates:
   *  Constant: '<S1812>/Constant1'
   */
  if (cal_SolarEnb) {
    /* Switch: '<S1812>/Switch' incorporates:
     *  Constant: '<S1812>/Constant'
     */
    AC_rSolarRight = cal_SolarData;
  } else {
    /* Switch: '<S1812>/Switch' incorporates:
     *  DataTypeConversion: '<S1747>/Data Type Conversion1'
     *  UnitDelay: '<S1816>/FixPt Unit Delay1'
     */
    AC_rSolarRight = (uint16)
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_p;
  }

  /* End of Switch: '<S1812>/Switch' */

  /* CCaller: '<S1754>/C Caller' */
  SENCtl_uACCMHighTempVol = get_ACCMHighTempValtage();

  /* Sum: '<S1754>/Add' incorporates:
   *  CCaller: '<S1754>/C Caller'
   *  DataTypeConversion: '<S1754>/Data Type Conversion1'
   *  Lookup_n-D: '<S1754>/cal_ACCMHighTempVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uACCMHighTempVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uACCMHighTempVol, (const uint16 *)
    &cal_ACCMHighTempVolAmend_1X[0], (const sint16 *)
    &cal_ACCMHighTempVolAmend_CUR[0], 1U));

  /* Outputs for Atomic SubSystem: '<S1754>/ACCMHi' */
  /* Sum: '<S1870>/Add' incorporates:
   *  Constant: '<S1754>/Constant1'
   */
  rtb_Add_hwr = cal_ADCVCCVal - rtb_Add_kg;

  /* Chart: '<S1876>/Judge' incorporates:
   *  Constant: '<S1870>/Constant1'
   *  Constant: '<S1876>/Constant'
   *  Constant: '<S1876>/Constant1'
   *  RelationalOperator: '<S1876>/Relational Operator'
   *  RelationalOperator: '<S1876>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorTempUpFlt, rtb_Add_kg <
             cal_SensorTempDownFlg, 20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge);

  /* DataTypeConversion: '<S1870>/Data Type Conversion' */
  ACSen_eACCMHTSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts;

  /* Switch: '<S1870>/Switch' incorporates:
   *  Constant: '<S1875>/Constant'
   *  RelationalOperator: '<S1875>/Compare'
   */
  if (rtb_Add_hwr > 0.0F) {
    /* Switch: '<S1842>/Init' incorporates:
     *  Product: '<S1870>/Divide'
     */
    rtb_Add_kg /= rtb_Add_hwr;
  } else {
    /* Switch: '<S1842>/Init' incorporates:
     *  Constant: '<S1870>/Constant'
     */
    rtb_Add_kg = 1.0F;
  }

  /* End of Switch: '<S1870>/Switch' */

  /* Lookup_n-D: '<S1754>/cal_ACCMTHi_CUR' incorporates:
   *  Constant: '<S1754>/Constant2'
   *  Product: '<S1870>/Divide1'
   */
  SEN_ACCMTHiRaw = look1_iflf_binlca(rtb_Add_kg * 3000.0F, (const float32 *)
    &cal_TACCMOutRaw_1X[0], (const float32 *)&cal_TACCMOutRaw_CUR[0], 29U);

  /* End of Outputs for SubSystem: '<S1754>/ACCMHi' */

  /* Switch: '<S1878>/Init' incorporates:
   *  Constant: '<S1754>/Constant3'
   *  Product: '<S1874>/Product'
   *  Product: '<S1874>/Product1'
   *  Sum: '<S1874>/Sum1'
   *  UnitDelay: '<S1878>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_nc != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_m = SEN_ACCMTHiRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_m = SEN_ACCMTHiRaw *
    0.9F + ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_m *
    0.100000024F;

  /* End of Switch: '<S1878>/Init' */

  /* Switch: '<S1871>/Switch' incorporates:
   *  Constant: '<S1871>/Constant1'
   */
  if (cal_ACCMHiTempDataEnb) {
    /* Switch: '<S1871>/Switch' incorporates:
     *  Constant: '<S1871>/Constant'
     */
    ACSen_sACCMHiTempFilter = cal_ACCMHiTempData;
  } else {
    /* Switch: '<S1871>/Switch' incorporates:
     *  UnitDelay: '<S1878>/FixPt Unit Delay1'
     */
    ACSen_sACCMHiTempFilter =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_m;
  }

  /* End of Switch: '<S1871>/Switch' */

  /* CCaller: '<S1754>/C Caller1' incorporates:
   *  Constant: '<S1754>/Constant'
   *  Constant: '<S1754>/Constant5'
   *  Sum: '<S1754>/Add1'
   */
  Rte_DIDReadData((uint8)(ACSen_sACCMHiTempFilter + 10.0F), ((uint8)DID_0xF281));

  /* CCaller: '<S1754>/C Caller2' incorporates:
   *  Constant: '<S1754>/Constant4'
   *  Constant: '<S1872>/Constant'
   *  DataTypeConversion: '<S1870>/Data Type Conversion'
   *  RelationalOperator: '<S1872>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942111), (uint8)
                     (ACSen_eACCMHTSenSts == Ground));

  /* CCaller: '<S1754>/C Caller3' incorporates:
   *  Constant: '<S1754>/Constant7'
   *  Constant: '<S1873>/Constant'
   *  DataTypeConversion: '<S1870>/Data Type Conversion'
   *  RelationalOperator: '<S1873>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942115), (uint8)
                     (ACSen_eACCMHTSenSts == Power));

  /* CCaller: '<S1751>/C Caller' */
  SENCtl_uOHXTempVol = get_OHXTempValtage();

  /* Sum: '<S1751>/Add' incorporates:
   *  CCaller: '<S1751>/C Caller'
   *  DataTypeConversion: '<S1751>/Data Type Conversion1'
   *  Lookup_n-D: '<S1751>/cal_OHXTempVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uOHXTempVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uOHXTempVol, (const uint16 *)
    &cal_OHXTempVolAmend_1X[0], (const sint16 *)&cal_OHXTempVolAmend_CUR[0], 1U));

  /* Outputs for Atomic SubSystem: '<S1751>/Env' */
  /* Sum: '<S1845>/Add' incorporates:
   *  Constant: '<S1751>/Constant1'
   */
  rtb_Add_hwr = cal_ADCVCCVal - rtb_Add_kg;

  /* Chart: '<S1849>/Judge' incorporates:
   *  Constant: '<S1845>/Constant1'
   *  Constant: '<S1849>/Constant'
   *  Constant: '<S1849>/Constant1'
   *  RelationalOperator: '<S1849>/Relational Operator'
   *  RelationalOperator: '<S1849>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorTempUpFlt, rtb_Add_kg <
             cal_SensorTempDownFlg, 20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_l,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_k);

  /* DataTypeConversion: '<S1845>/Data Type Conversion' */
  ACSen_eOHXTSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_l;

  /* Switch: '<S1845>/Switch' incorporates:
   *  Constant: '<S1848>/Constant'
   *  RelationalOperator: '<S1848>/Compare'
   */
  if (rtb_Add_hwr > 0.0F) {
    /* Switch: '<S1842>/Init' incorporates:
     *  Product: '<S1845>/Divide'
     */
    rtb_Add_kg /= rtb_Add_hwr;
  } else {
    /* Switch: '<S1842>/Init' incorporates:
     *  Constant: '<S1845>/Constant'
     */
    rtb_Add_kg = 1.0F;
  }

  /* End of Switch: '<S1845>/Switch' */

  /* Lookup_n-D: '<S1751>/cal_OHXTRaw_CUR' incorporates:
   *  Constant: '<S1751>/Constant3'
   *  Product: '<S1845>/Divide1'
   */
  SEN_OHXTRaw = look1_iflf_binlca(rtb_Add_kg * 20000.0F, (const float32 *)
    &cal_TOHXOutRaw_1X[0], (const float32 *)&cal_TOHXOutRaw_CUR[0], 29U);

  /* End of Outputs for SubSystem: '<S1751>/Env' */

  /* Switch: '<S1851>/Init' incorporates:
   *  Constant: '<S1751>/Constant6'
   *  Product: '<S1847>/Product'
   *  Product: '<S1847>/Product1'
   *  Sum: '<S1847>/Sum1'
   *  UnitDelay: '<S1851>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_g3 != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_g4 = SEN_OHXTRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_g4 = SEN_OHXTRaw * 0.9F
    + ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_g4 * 0.100000024F;

  /* End of Switch: '<S1851>/Init' */

  /* Switch: '<S1846>/Switch' incorporates:
   *  Constant: '<S1846>/Constant1'
   */
  if (cal_OHXTempDataEnb) {
    /* Switch: '<S1846>/Switch' incorporates:
     *  Constant: '<S1846>/Constant'
     */
    ACSen_sOHXTempFilter = cal_OHXTempData;
  } else {
    /* Switch: '<S1846>/Switch' incorporates:
     *  UnitDelay: '<S1851>/FixPt Unit Delay1'
     */
    ACSen_sOHXTempFilter =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_g4;
  }

  /* End of Switch: '<S1846>/Switch' */

  /* CCaller: '<S1751>/C Caller1' incorporates:
   *  Constant: '<S1751>/Constant'
   *  Constant: '<S1751>/Constant5'
   *  Sum: '<S1751>/Add1'
   */
  Rte_DIDReadData((uint8)(ACSen_sOHXTempFilter + 40.0F), ((uint8)DID_0xF280));

  /* CCaller: '<S1751>/C Caller2' incorporates:
   *  Constant: '<S1751>/Constant4'
   *  Constant: '<S1843>/Constant'
   *  DataTypeConversion: '<S1845>/Data Type Conversion'
   *  RelationalOperator: '<S1843>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942211), (uint8)
                     (ACSen_eOHXTSenSts == Ground));

  /* CCaller: '<S1751>/C Caller3' incorporates:
   *  Constant: '<S1751>/Constant7'
   *  Constant: '<S1844>/Constant'
   *  DataTypeConversion: '<S1845>/Data Type Conversion'
   *  RelationalOperator: '<S1844>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942215), (uint8)
                     (ACSen_eOHXTSenSts == Power));

  /* CCaller: '<S1748>/C Caller' */
  SENCtl_uChillTempVol = get_ChillTempValtage();

  /* Sum: '<S1748>/Add' incorporates:
   *  CCaller: '<S1748>/C Caller'
   *  DataTypeConversion: '<S1748>/Data Type Conversion1'
   *  Lookup_n-D: '<S1748>/cal_ChillTempVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uChillTempVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uChillTempVol, (const uint16 *)
    &cal_ChillTempVolAmend_1X[0], (const sint16 *)&cal_ChillTempVolAmend_CUR[0],
    1U));

  /* Outputs for Atomic SubSystem: '<S1748>/Chiller' */
  /* Sum: '<S1818>/Add' incorporates:
   *  Constant: '<S1748>/Constant1'
   */
  rtb_Add_hwr = cal_ADCVCCVal - rtb_Add_kg;

  /* Chart: '<S1823>/Judge' incorporates:
   *  Constant: '<S1818>/Constant1'
   *  Constant: '<S1823>/Constant'
   *  Constant: '<S1823>/Constant1'
   *  RelationalOperator: '<S1823>/Relational Operator'
   *  RelationalOperator: '<S1823>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorTempUpFlt, rtb_Add_kg <
             cal_SensorTempDownFlg, 20, &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_o,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_p);

  /* DataTypeConversion: '<S1818>/Data Type Conversion' */
  ACSen_eChillerTSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_o;

  /* Switch: '<S1818>/Switch' incorporates:
   *  Constant: '<S1822>/Constant'
   *  RelationalOperator: '<S1822>/Compare'
   */
  if (rtb_Add_hwr > 0.0F) {
    /* Switch: '<S1842>/Init' incorporates:
     *  Product: '<S1818>/Divide'
     */
    rtb_Add_kg /= rtb_Add_hwr;
  } else {
    /* Switch: '<S1842>/Init' incorporates:
     *  Constant: '<S1818>/Constant'
     */
    rtb_Add_kg = 1.0F;
  }

  /* End of Switch: '<S1818>/Switch' */

  /* Lookup_n-D: '<S1748>/cal_TChillOutRaw_CUR' incorporates:
   *  Constant: '<S1748>/Constant3'
   *  Product: '<S1818>/Divide1'
   */
  SEN_ChiTRaw = look1_iflf_binlca(rtb_Add_kg * 20000.0F, (const float32 *)
    &cal_TChillOutRaw_1X[0], (const float32 *)&cal_TChillOutRaw_CUR[0], 26U);

  /* End of Outputs for SubSystem: '<S1748>/Chiller' */

  /* Switch: '<S1825>/Init' incorporates:
   *  Constant: '<S1748>/Constant8'
   *  Product: '<S1821>/Product'
   *  Product: '<S1821>/Product1'
   *  Sum: '<S1821>/Sum1'
   *  UnitDelay: '<S1825>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_e != 0) {
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_n = SEN_ChiTRaw;
  }

  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_n = SEN_ChiTRaw * 0.9F +
    ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_n * 0.100000024F;

  /* End of Switch: '<S1825>/Init' */

  /* Switch: '<S1817>/Switch' incorporates:
   *  Constant: '<S1817>/Constant1'
   */
  if (cal_ChiTempDataEnb) {
    /* Switch: '<S1817>/Switch' incorporates:
     *  Constant: '<S1817>/Constant'
     */
    ACSen_sChiTempFilter = cal_ChiTempData;
  } else {
    /* Switch: '<S1817>/Switch' incorporates:
     *  UnitDelay: '<S1825>/FixPt Unit Delay1'
     */
    ACSen_sChiTempFilter =
      ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_n;
  }

  /* End of Switch: '<S1817>/Switch' */

  /* CCaller: '<S1748>/C Caller1' incorporates:
   *  Constant: '<S1748>/Constant'
   *  Constant: '<S1748>/Constant5'
   *  Sum: '<S1748>/Add1'
   */
  Rte_DIDReadData((uint8)(ACSen_sChiTempFilter + 10.0F), ((uint8)DID_0xF27F));

  /* CCaller: '<S1748>/C Caller2' incorporates:
   *  Constant: '<S1748>/Constant4'
   *  Constant: '<S1819>/Constant'
   *  DataTypeConversion: '<S1818>/Data Type Conversion'
   *  RelationalOperator: '<S1819>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941F11), (uint8)
                     (ACSen_eChillerTSenSts == Ground));

  /* CCaller: '<S1748>/C Caller3' incorporates:
   *  Constant: '<S1748>/Constant7'
   *  Constant: '<S1820>/Constant'
   *  DataTypeConversion: '<S1818>/Data Type Conversion'
   *  RelationalOperator: '<S1820>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941F15), (uint8)
                     (ACSen_eChillerTSenSts == Power));

  /* CCaller: '<S1750>/C Caller' */
  SENCtl_uEVAPSurfTempVol = get_EVAPSurfTempValtage();

  /* Sum: '<S1750>/Add' incorporates:
   *  CCaller: '<S1750>/C Caller'
   *  DataTypeConversion: '<S1750>/Data Type Conversion1'
   *  Lookup_n-D: '<S1750>/cal_EVAPSurfTempVolAmend_CUR'
   */
  rtb_Add_kg = (float32)((sint16)SENCtl_uEVAPSurfTempVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uEVAPSurfTempVol, (const uint16 *)
    &cal_EVAPSurfTempVolAmend_1X[0], (const sint16 *)
    &cal_EVAPSurfTempVolAmend_CUR[0], 1U));

  /* Outputs for Atomic SubSystem: '<S1750>/EvapSurface' */
  /* Sum: '<S1836>/Add' incorporates:
   *  Constant: '<S1750>/Constant1'
   */
  rtb_Add_hwr = cal_ADCVCCVal - rtb_Add_kg;

  /* Chart: '<S1840>/Judge' incorporates:
   *  Constant: '<S1836>/Constant1'
   *  Constant: '<S1840>/Constant'
   *  Constant: '<S1840>/Constant1'
   *  RelationalOperator: '<S1840>/Relational Operator'
   *  RelationalOperator: '<S1840>/Relational Operator1'
   */
  ME11_Judge(rtb_Add_kg > cal_SensorTempUpFlt, rtb_Add_kg <
             cal_SensorTempDownFlg, 20,
             &ME11_TMSADCSampleFunc_ARID_DEF.SenSts_f4,
             &ME11_TMSADCSampleFunc_ARID_DEF.ARID_DEF_Judge_cx);

  /* DataTypeConversion: '<S1836>/Data Type Conversion' */
  ACSen_eEVAPSurfTSenSts = ME11_TMSADCSampleFunc_ARID_DEF.SenSts_f4;

  /* Switch: '<S1836>/Switch' incorporates:
   *  Constant: '<S1839>/Constant'
   *  RelationalOperator: '<S1839>/Compare'
   */
  if (rtb_Add_hwr > 0.0F) {
    /* Switch: '<S1842>/Init' incorporates:
     *  Product: '<S1836>/Divide'
     */
    rtb_Add_kg /= rtb_Add_hwr;
  } else {
    /* Switch: '<S1842>/Init' incorporates:
     *  Constant: '<S1836>/Constant'
     */
    rtb_Add_kg = 1.0F;
  }

  /* End of Switch: '<S1836>/Switch' */

  /* Lookup_n-D: '<S1750>/cal_TEvapSur_CUR' incorporates:
   *  Constant: '<S1750>/Constant3'
   *  Product: '<S1836>/Divide1'
   */
  SEN_TEvapSurRaw = look1_iflf_binlca(rtb_Add_kg * 3.0F, (const float32 *)
    &cal_TEvapSurfRaw_1X[0], (const float32 *)&cal_TEvapSurfRaw_CUR[0], 22U);

  /* End of Outputs for SubSystem: '<S1750>/EvapSurface' */

  /* Switch: '<S1842>/Init' incorporates:
   *  UnitDelay: '<S1842>/FixPt Unit Delay1'
   *  UnitDelay: '<S1842>/FixPt Unit Delay2'
   */
  if (ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_j != 0) {
    rtb_Add_kg = SEN_TEvapSurRaw;
  } else {
    rtb_Add_kg = ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_ad;
  }

  /* Sum: '<S1838>/Sum1' incorporates:
   *  Constant: '<S1750>/Constant12'
   *  Product: '<S1838>/Product'
   *  Product: '<S1838>/Product1'
   *  Switch: '<S1842>/Init'
   */
  rtb_Add_kg = SEN_TEvapSurRaw * 0.9F + rtb_Add_kg * 0.100000024F;

  /* Switch: '<S1837>/Switch' incorporates:
   *  Constant: '<S1837>/Constant1'
   */
  if (cal_EvapSurTempDataEnb) {
    /* Switch: '<S1837>/Switch' incorporates:
     *  Constant: '<S1837>/Constant'
     */
    ACSen_sEvapSurTemp = cal_EvapSurTempData;
  } else {
    /* Switch: '<S1837>/Switch' */
    ACSen_sEvapSurTemp = rtb_Add_kg;
  }

  /* End of Switch: '<S1837>/Switch' */

  /* CCaller: '<S1750>/C Caller1' incorporates:
   *  Constant: '<S1750>/Constant2'
   *  Constant: '<S1750>/Constant6'
   *  Sum: '<S1750>/Add1'
   */
  Rte_DIDReadData((uint8)(ACSen_sEvapSurTemp + 50.0F), ((uint8)DID_0xF262));

  /* CCaller: '<S1750>/C Caller2' incorporates:
   *  Constant: '<S1750>/Constant4'
   *  Constant: '<S1833>/Constant'
   *  DataTypeConversion: '<S1836>/Data Type Conversion'
   *  RelationalOperator: '<S1833>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941A11), (uint8)
                     (ACSen_eEVAPSurfTSenSts == Ground));

  /* CCaller: '<S1750>/C Caller3' incorporates:
   *  Constant: '<S1750>/Constant7'
   *  Constant: '<S1834>/Constant'
   *  DataTypeConversion: '<S1836>/Data Type Conversion'
   *  RelationalOperator: '<S1834>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941A15), (uint8)
                     (ACSen_eEVAPSurfTSenSts == Power));

  /* Chart: '<S33>/Cal_RunTime_20ms' */
  if (ME11_TMSADCSampleFunc_ARID_DEF.temporalCounter_i1 < 1U) {
    ME11_TMSADCSampleFunc_ARID_DEF.temporalCounter_i1++;
  }

  if (ME11_TMSADCSampleFunc_ARID_DEF.is_active_c156_ME11 == 0U) {
    ME11_TMSADCSampleFunc_ARID_DEF.is_active_c156_ME11 = 1U;
    ME11_TMSADCSampleFunc_ARID_DEF.is_c156_ME11 = ME11_IN_Counter_Init;
    ME11_TMSADCSampleFunc_ARID_DEF.temporalCounter_i1 = 0U;
    PWRCtl_uTMSRunTimer20ms = 0U;
  } else if (ME11_TMSADCSampleFunc_ARID_DEF.is_c156_ME11 == ME11_IN_Counter_Cal)
  {
    if (PWRCtl_uTMSRunTimer20ms >= 4294967294U) {
      ME11_TMSADCSampleFunc_ARID_DEF.is_c156_ME11 = ME11_IN_Counter_Init;
      ME11_TMSADCSampleFunc_ARID_DEF.temporalCounter_i1 = 0U;
      PWRCtl_uTMSRunTimer20ms = 0U;
    } else {
      qY = PWRCtl_uTMSRunTimer20ms + /*MW:OvSatOk*/ 1U;
      if (PWRCtl_uTMSRunTimer20ms + 1U < PWRCtl_uTMSRunTimer20ms) {
        qY = MAX_uint32_T;
      }

      PWRCtl_uTMSRunTimer20ms = qY;
    }

    /* case IN_Counter_Init: */
  } else if (ME11_TMSADCSampleFunc_ARID_DEF.temporalCounter_i1 >= 1) {
    ME11_TMSADCSampleFunc_ARID_DEF.is_c156_ME11 = ME11_IN_Counter_Cal;
  }

  /* End of Chart: '<S33>/Cal_RunTime_20ms' */

  /* CCaller: '<S1738>/C Caller' */
  expl_temp = Get_adc2_group0_resultbuffer();

  /* SignalConversion: '<S1738>/Signal Copy' incorporates:
   *  CCaller: '<S1738>/C Caller'
   */
  adc2_group0_0 = expl_temp.adc2_group0_0;

  /* SignalConversion: '<S1738>/Signal Copy1' incorporates:
   *  CCaller: '<S1738>/C Caller'
   */
  adc2_group0_1 = expl_temp.adc2_group0_1;

  /* SignalConversion: '<S1738>/Signal Copy2' incorporates:
   *  CCaller: '<S1738>/C Caller'
   */
  adc2_group0_2 = expl_temp.adc2_group0_2;

  /* CCaller: '<S1738>/C Caller1' */
  expl_temp_0 = Get_adc2_group1_resultbuffer();

  /* SignalConversion: '<S1738>/Signal Copy10' incorporates:
   *  CCaller: '<S1738>/C Caller1'
   */
  adc2_group1_7 = expl_temp_0.adc2_group1_7;

  /* SignalConversion: '<S1738>/Signal Copy11' incorporates:
   *  CCaller: '<S1738>/C Caller1'
   */
  adc2_group1_8 = expl_temp_0.adc2_group1_8;

  /* SignalConversion: '<S1738>/Signal Copy12' incorporates:
   *  CCaller: '<S1738>/C Caller1'
   */
  adc2_group1_9 = expl_temp_0.adc2_group1_9;

  /* SignalConversion: '<S1738>/Signal Copy3' incorporates:
   *  CCaller: '<S1738>/C Caller1'
   */
  adc2_group1_0 = expl_temp_0.adc2_group1_0;

  /* SignalConversion: '<S1738>/Signal Copy4' incorporates:
   *  CCaller: '<S1738>/C Caller1'
   */
  adc2_group1_1 = expl_temp_0.adc2_group1_1;

  /* SignalConversion: '<S1738>/Signal Copy5' incorporates:
   *  CCaller: '<S1738>/C Caller1'
   */
  adc2_group1_2 = expl_temp_0.adc2_group1_2;

  /* SignalConversion: '<S1738>/Signal Copy6' incorporates:
   *  CCaller: '<S1738>/C Caller1'
   */
  adc2_group1_3 = expl_temp_0.adc2_group1_3;

  /* SignalConversion: '<S1738>/Signal Copy7' incorporates:
   *  CCaller: '<S1738>/C Caller1'
   */
  adc2_group1_4 = expl_temp_0.adc2_group1_4;

  /* SignalConversion: '<S1738>/Signal Copy8' incorporates:
   *  CCaller: '<S1738>/C Caller1'
   */
  adc2_group1_5 = expl_temp_0.adc2_group1_5;

  /* SignalConversion: '<S1738>/Signal Copy9' incorporates:
   *  CCaller: '<S1738>/C Caller1'
   */
  adc2_group1_6 = expl_temp_0.adc2_group1_6;

  /* CCaller: '<S1738>/C Caller2' */
  expl_temp_1 = Get_adc2_group2_resultbuffer();

  /* SignalConversion: '<S1738>/Signal Copy13' incorporates:
   *  CCaller: '<S1738>/C Caller2'
   */
  adc2_group2_3 = expl_temp_1.adc2_group2_3;

  /* SignalConversion: '<S1738>/Signal Copy14' incorporates:
   *  CCaller: '<S1738>/C Caller2'
   */
  adc2_group2_4 = expl_temp_1.adc2_group2_4;

  /* SignalConversion: '<S1738>/Signal Copy17' incorporates:
   *  CCaller: '<S1738>/C Caller2'
   */
  adc2_group2_0 = expl_temp_1.adc2_group2_0;

  /* SignalConversion: '<S1738>/Signal Copy18' incorporates:
   *  CCaller: '<S1738>/C Caller2'
   */
  adc2_group2_1 = expl_temp_1.adc2_group2_1;

  /* SignalConversion: '<S1738>/Signal Copy19' incorporates:
   *  CCaller: '<S1738>/C Caller2'
   */
  adc2_group2_2 = expl_temp_1.adc2_group2_2;

  /* Update for UnitDelay: '<S1774>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1774>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE = 0U;

  /* Update for UnitDelay: '<S1784>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1784>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_a = 0U;

  /* Update for UnitDelay: '<S1799>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1799>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_o = 0U;

  /* Update for UnitDelay: '<S1806>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1806>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_l = 0U;

  /* Update for UnitDelay: '<S1832>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1832>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_m = 0U;

  /* Update for UnitDelay: '<S1860>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1860>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_f = 0U;

  /* Update for UnitDelay: '<S1869>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1869>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_n = 0U;

  /* Update for UnitDelay: '<S1792>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1792>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_f1 = 0U;

  /* Update for UnitDelay: '<S1764>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1764>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_c = 0U;

  /* Update for UnitDelay: '<S1816>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1816>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_g = 0U;

  /* Update for UnitDelay: '<S1878>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1878>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_nc = 0U;

  /* Update for UnitDelay: '<S1851>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1851>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_g3 = 0U;

  /* Update for UnitDelay: '<S1825>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1825>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_e = 0U;

  /* Update for UnitDelay: '<S1842>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1842>/FixPt Constant'
   */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay2_DSTATE_j = 0U;

  /* Update for UnitDelay: '<S1842>/FixPt Unit Delay1' */
  ME11_TMSADCSampleFunc_ARID_DEF.FixPtUnitDelay1_DSTATE_ad = rtb_Add_kg;
}

/* Function for Chart: '<S30>/CoBatCharg' */
void ME11_enter_internal_ThermalCoordinate(void)
{
  if ((Rte_IRead_Task_100ms_IPM_BMS_10_DC_ChargeStates_EPT_IPM_BMS_10_DC_ChargeStates_EPT
       ())->VIPM_BMSDCSActOprtMode_enum == 5) {
    ME11_ARID_DEF.is_ThermalCoordinate = ME11_IN_BTMS_QuickChargeThermal;
    PWRCtl_eBatChargSts = 2U;
  } else if
      (((Rte_IRead_Task_100ms_IPM_BMS_4_AC_ChargeState_EPT_IPM_BMS_4_AC_ChargeState_EPT
         ())->VIPM_BMSACChrgAtclSta_enum != 1) &&
       ((Rte_IRead_Task_100ms_IPM_BMS_10_DC_ChargeStates_EPT_IPM_BMS_10_DC_ChargeStates_EPT
         ())->VIPM_BMSDCSActOprtMode_enum != 5)) {
    ME11_ARID_DEF.is_ThermalCoordinate = ME11_IN_BTMS_NormalThermal;
    PWRCtl_eBatChargSts = 0U;
  } else if
      ((Rte_IRead_Task_100ms_IPM_BMS_4_AC_ChargeState_EPT_IPM_BMS_4_AC_ChargeState_EPT
        ())->VIPM_BMSACChrgAtclSta_enum == 1) {
    ME11_ARID_DEF.is_ThermalCoordinate = ME11_IN_BTMS_SlowChargeThermal;
    PWRCtl_eBatChargSts = 1U;
  } else {
    ME11_ARID_DEF.is_ThermalCoordinate = ME11_IN_BTMS_Default;
    PWRCtl_eBatChargSts = 0U;
  }
}

/* Function for Chart: '<S30>/TMSStatus' */
void ME11_enter_internal_Sts(uint8 *PWRCtl_eTMSStatus_a)
{
  switch (PWRCtl_eBatChargSts) {
   case 2:
    ME11_ARID_DEF.is_Sts = ME11_IN_DCchg;
    *PWRCtl_eTMSStatus_a = 4U;
    break;

   case 1:
    ME11_ARID_DEF.is_Sts = ME11_IN_ACchg;
    *PWRCtl_eTMSStatus_a = 3U;
    break;

   default:
    if (PWRCtl_eVCUPTSts == 2) {
      ME11_ARID_DEF.is_Sts = ME11_IN_PTReady;
      *PWRCtl_eTMSStatus_a = 5U;
    } else if (PWRCtl_bKL15swtSt && ((PWRCtl_eVCUPTSts == 0) ||
                (PWRCtl_eVCUPTSts == 3)) && (PWRCtl_eBatChargSts == 0)) {
      ME11_ARID_DEF.is_Sts = ME11_IN_LowVoltage;
      *PWRCtl_eTMSStatus_a = 1U;
    } else if ((PWRCtl_eVCUPTSts == 1) && (PWRCtl_eBatChargSts == 0)) {
      ME11_ARID_DEF.is_Sts = ME11_IN_Dischg;
      *PWRCtl_eTMSStatus_a = 2U;
    } else {
      ME11_ARID_DEF.is_Sts = ME11_IN_Default_o;
      *PWRCtl_eTMSStatus_a = 0U;
    }
    break;
  }
}

/* Function for Chart: '<S1119>/SetTemp' */
void ME11_Cal(const boolean *FixPtRelationalOperator)
{
  sint32 tmp;
  uint8 tmp_0;
  switch (ME11_ARID_DEF.is_Cal) {
   case ME11_IN_Init_i:
    if ((ME11_ARID_DEF.sfEvent == -1) && (ME11_ARID_DEF.temporalCounter_i1_fs >=
         10)) {
      ME11_ARID_DEF.is_Cal = ME11_IN_Nml;
      ME11_ARID_DEF.is_Nml = ME11_IN_Nml_Init;
    } else {
      /* DataStoreRead: '<S1119>/Data Store Read' */
      ME11_ARID_DEF.Fb = ME11_ARID_DEF.EERead_CabinSetTemp;
    }
    break;

   case ME11_IN_Max_d:
    if (*FixPtRelationalOperator) {
      ME11_ARID_DEF.is_Cal = ME11_IN_Nml;
      ME11_ARID_DEF.is_Nml = ME11_IN_Set;

      /* Delay: '<S1119>/Delay' */
      if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
        if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
          tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
        } else {
          tmp_0 = 0U;
        }
      } else {
        tmp_0 = MAX_uint8_T;
      }

      tmp = tmp_0 - 1;

      /* Delay: '<S1119>/Delay' */
      if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
        if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
          tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
        } else {
          tmp_0 = 0U;
        }
      } else {
        tmp_0 = MAX_uint8_T;
      }

      if (tmp_0 - 1 < 0) {
        tmp = 0;
      }

      ME11_ARID_DEF.Fb = (uint8)tmp;
    } else if (ME11_ARID_DEF.sfEvent == ME11_event_DecKey) {
      ME11_ARID_DEF.is_Cal = ME11_IN_Nml;
      ME11_ARID_DEF.is_Nml = ME11_IN_DecT;
      tmp = ME11_ARID_DEF.Fb - 1;
      if (ME11_ARID_DEF.Fb - 1 < 0) {
        tmp = 0;
      }

      ME11_ARID_DEF.Fb = (uint8)tmp;
    }
    break;

   case ME11_IN_Min_b:
    if (*FixPtRelationalOperator) {
      ME11_ARID_DEF.is_Cal = ME11_IN_Nml;
      ME11_ARID_DEF.is_Nml = ME11_IN_Set;

      /* Delay: '<S1119>/Delay' */
      if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
        if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
          tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
        } else {
          tmp_0 = 0U;
        }
      } else {
        tmp_0 = MAX_uint8_T;
      }

      tmp = tmp_0 - 1;

      /* Delay: '<S1119>/Delay' */
      if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
        if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
          tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
        } else {
          tmp_0 = 0U;
        }
      } else {
        tmp_0 = MAX_uint8_T;
      }

      if (tmp_0 - 1 < 0) {
        tmp = 0;
      }

      ME11_ARID_DEF.Fb = (uint8)tmp;
    } else if (ME11_ARID_DEF.sfEvent == ME11_event_AddKey) {
      ME11_ARID_DEF.is_Cal = ME11_IN_Nml;
      ME11_ARID_DEF.is_Nml = ME11_IN_AddT;
      tmp = ME11_ARID_DEF.Fb + 1;
      if (ME11_ARID_DEF.Fb + 1 > 255) {
        tmp = 255;
      }

      ME11_ARID_DEF.Fb = (uint8)tmp;
    }
    break;

   case ME11_IN_Nml:
    if (ME11_ARID_DEF.Fb >= 32) {
      ME11_ARID_DEF.is_Nml = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_ARID_DEF.is_Cal = ME11_IN_Max_d;
      ME11_ARID_DEF.Fb = 32U;
    } else if (ME11_ARID_DEF.Fb <= 0) {
      ME11_ARID_DEF.is_Nml = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_ARID_DEF.is_Cal = ME11_IN_Min_b;
    } else {
      switch (ME11_ARID_DEF.is_Nml) {
       case ME11_IN_AddT:
        if (*FixPtRelationalOperator) {
          ME11_ARID_DEF.is_Nml = ME11_IN_Set;

          /* Delay: '<S1119>/Delay' */
          if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
            if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
              tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
            } else {
              tmp_0 = 0U;
            }
          } else {
            tmp_0 = MAX_uint8_T;
          }

          tmp = tmp_0 - 1;

          /* Delay: '<S1119>/Delay' */
          if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
            if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
              tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
            } else {
              tmp_0 = 0U;
            }
          } else {
            tmp_0 = MAX_uint8_T;
          }

          if (tmp_0 - 1 < 0) {
            tmp = 0;
          }

          ME11_ARID_DEF.Fb = (uint8)tmp;
        } else {
          switch (ME11_ARID_DEF.sfEvent) {
           case ME11_event_AddKey:
            ME11_ARID_DEF.is_Nml = ME11_IN_AddT;
            ME11_ARID_DEF.Fb++;
            break;

           case ME11_event_DecKey:
            ME11_ARID_DEF.is_Nml = ME11_IN_DecT;
            ME11_ARID_DEF.Fb--;
            break;
          }
        }
        break;

       case ME11_IN_DecT:
        if (ME11_ARID_DEF.sfEvent == ME11_event_DecKey) {
          ME11_ARID_DEF.is_Nml = ME11_IN_DecT;
          ME11_ARID_DEF.Fb--;
        } else if (*FixPtRelationalOperator) {
          ME11_ARID_DEF.is_Nml = ME11_IN_Set;

          /* Delay: '<S1119>/Delay' */
          if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
            if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
              tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
            } else {
              tmp_0 = 0U;
            }
          } else {
            tmp_0 = MAX_uint8_T;
          }

          tmp = tmp_0 - 1;

          /* Delay: '<S1119>/Delay' */
          if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
            if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
              tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
            } else {
              tmp_0 = 0U;
            }
          } else {
            tmp_0 = MAX_uint8_T;
          }

          if (tmp_0 - 1 < 0) {
            tmp = 0;
          }

          ME11_ARID_DEF.Fb = (uint8)tmp;
        } else if (ME11_ARID_DEF.sfEvent == ME11_event_AddKey) {
          ME11_ARID_DEF.is_Nml = ME11_IN_AddT;
          ME11_ARID_DEF.Fb++;
        }
        break;

       case ME11_IN_Nml_Init:
        if (*FixPtRelationalOperator) {
          ME11_ARID_DEF.is_Nml = ME11_IN_Set;

          /* Delay: '<S1119>/Delay' */
          if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
            if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
              tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
            } else {
              tmp_0 = 0U;
            }
          } else {
            tmp_0 = MAX_uint8_T;
          }

          tmp = tmp_0 - 1;

          /* Delay: '<S1119>/Delay' */
          if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
            if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
              tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
            } else {
              tmp_0 = 0U;
            }
          } else {
            tmp_0 = MAX_uint8_T;
          }

          if (tmp_0 - 1 < 0) {
            tmp = 0;
          }

          ME11_ARID_DEF.Fb = (uint8)tmp;
        } else {
          switch (ME11_ARID_DEF.sfEvent) {
           case ME11_event_AddKey:
            ME11_ARID_DEF.is_Nml = ME11_IN_AddT;
            ME11_ARID_DEF.Fb++;
            break;

           case ME11_event_DecKey:
            ME11_ARID_DEF.is_Nml = ME11_IN_DecT;
            ME11_ARID_DEF.Fb--;
            break;
          }
        }
        break;

       case ME11_IN_Set:
        if (*FixPtRelationalOperator) {
          ME11_ARID_DEF.is_Nml = ME11_IN_Set;

          /* Delay: '<S1119>/Delay' */
          if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
            if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
              tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
            } else {
              tmp_0 = 0U;
            }
          } else {
            tmp_0 = MAX_uint8_T;
          }

          tmp = tmp_0 - 1;

          /* Delay: '<S1119>/Delay' */
          if (ME11_ARID_DEF.Delay_DSTATE_d < 256.0F) {
            if (ME11_ARID_DEF.Delay_DSTATE_d >= 0.0F) {
              tmp_0 = (uint8)ME11_ARID_DEF.Delay_DSTATE_d;
            } else {
              tmp_0 = 0U;
            }
          } else {
            tmp_0 = MAX_uint8_T;
          }

          if (tmp_0 - 1 < 0) {
            tmp = 0;
          }

          ME11_ARID_DEF.Fb = (uint8)tmp;
        } else {
          switch (ME11_ARID_DEF.sfEvent) {
           case ME11_event_AddKey:
            ME11_ARID_DEF.is_Nml = ME11_IN_AddT;
            ME11_ARID_DEF.Fb++;
            break;

           case ME11_event_DecKey:
            ME11_ARID_DEF.is_Nml = ME11_IN_DecT;
            ME11_ARID_DEF.Fb--;
            break;
          }
        }
        break;
      }
    }
    break;
  }
}

/* Function for Chart: '<S1117>/ModeSet' */
void ME11_enter_internal_Mode(void)
{
  boolean guard1 = false;

  /* Delay: '<S1117>/Delay' */
  guard1 = false;
  if (ME11_ARID_DEF.Delay_DSTATE_hx == 5) {
    guard1 = true;
  } else if (ME11_ARID_DEF.Delay_DSTATE_hx == 3) {
    ME11_ARID_DEF.is_Mode = ME11_IN_Defrost_Foot;
    ME11_ARID_DEF.mode = 3U;
  } else if (ME11_ARID_DEF.Delay_DSTATE_hx == 4) {
    ME11_ARID_DEF.is_Mode = ME11_IN_Face_Foot;
    ME11_ARID_DEF.mode = 4U;
  } else if (ME11_ARID_DEF.Delay_DSTATE_hx == 1) {
    ME11_ARID_DEF.is_Mode = ME11_IN_Defrost_a;
    ME11_ARID_DEF.mode = 1U;
  } else if (ME11_ARID_DEF.Delay_DSTATE_hx == 2) {
    ME11_ARID_DEF.is_Mode = ME11_IN_Foot;
    ME11_ARID_DEF.mode = 2U;
  } else {
    guard1 = true;
  }

  if (guard1) {
    ME11_ARID_DEF.is_Mode = ME11_IN_Face_l;
    ME11_ARID_DEF.mode = 5U;
  }

  /* End of Delay: '<S1117>/Delay' */
}

/* Function for Chart: '<S1095>/median' */
void ME11_sart(float64 v1, float64 v2, float64 *a, float64 *b)
{
  *a = v2;
  *b = v1;
}

/* Function for Chart: '<S546>/Judge' */
void ME11_enter_internal_Choice(const uint8 *SOMCtl_eRefModes_b)
{
  boolean guard1 = false;
  guard1 = false;
  if (((ME11_ARID_DEF.DataTypeConversion1 == 3) ||
       (ME11_ARID_DEF.DataTypeConversion1 == 4)) && (*SOMCtl_eRefModes_b == 3))
  {
    guard1 = true;
  } else if (((ME11_ARID_DEF.DataTypeConversion1 == 3) ||
              (ME11_ARID_DEF.DataTypeConversion1 == 4)) && (*SOMCtl_eRefModes_b ==
              2)) {
    ME11_ARID_DEF.is_Choice = ME11_IN_ChgBatCool;

    /* Constant: '<S546>/Constant2' */
    ME11_ARID_DEF.ACTCtl_sCOMPLmtSpd = cal_COMPBatMaxSpdLmt;
  } else if (((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
              (ME11_ARID_DEF.DataTypeConversion1 == 5)) && (*SOMCtl_eRefModes_b ==
              1) &&
             ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA
               ())->VIPM_ESCVehSpd_kph > 20.0F)) {
    ME11_ARID_DEF.is_Choice = ME11_IN_NmlBatCool2;

    /* Constant: '<S546>/Constant3' */
    ME11_ARID_DEF.ACTCtl_sCOMPLmtSpd = cal_COMPCabinCoolMaxSpdLmt;
  } else if (((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
              (ME11_ARID_DEF.DataTypeConversion1 == 5)) && (*SOMCtl_eRefModes_b ==
              1) &&
             ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA
               ())->VIPM_ESCVehSpd_kph <= 20.0F)) {
    ME11_ARID_DEF.is_Choice = ME11_IN_NmlBatCool1;
    ME11_ARID_DEF.ACTCtl_sCOMPLmtSpd = ACTCtl_sCOMPFanlevelLmtSpd;
  } else if (((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
              (ME11_ARID_DEF.DataTypeConversion1 == 5)) && (*SOMCtl_eRefModes_b ==
              2)) {
    ME11_ARID_DEF.is_Choice = ME11_IN_NmlBatCool;

    /* Constant: '<S546>/Constant2' */
    ME11_ARID_DEF.ACTCtl_sCOMPLmtSpd = cal_COMPBatMaxSpdLmt;
  } else if (((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
              (ME11_ARID_DEF.DataTypeConversion1 == 5)) && (*SOMCtl_eRefModes_b ==
              3) &&
             ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA
               ())->VIPM_ESCVehSpd_kph > 20.0F)) {
    ME11_ARID_DEF.is_Choice = ME11_IN_NmlDCoolHVS;
    ME11_ARID_DEF.ACTCtl_sCOMPLmtSpd = ACTCtl_sCOMPEnvLmtSpd;
  } else if (((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
              (ME11_ARID_DEF.DataTypeConversion1 == 5)) && (*SOMCtl_eRefModes_b ==
              3) &&
             ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA
               ())->VIPM_ESCVehSpd_kph <= 20.0F)) {
    ME11_ARID_DEF.is_Choice = ME11_IN_NmlDCoolLVS;
    ME11_ARID_DEF.ACTCtl_sCOMPLmtSpd = ACTCtl_sCOMPFanlevelLmtSpd;
  } else {
    guard1 = true;
  }

  if (guard1) {
    ME11_ARID_DEF.is_Choice = ME11_IN_ChgDCool;
    ME11_ARID_DEF.ACTCtl_sCOMPLmtSpd = ACTCtl_sCOMPEnvLmtSpd;
  }
}

/* Model step function for TID1 */
void Task_100ms(void)                  /* Explicit Task: TMS_Task */
{
  /* local block i/o variables */
  boolean rtb_SOMCtl_bBatHeatB3tB1Flg;
  boolean rtb_SOMCtl_bBatHeatB3tB1Flg_e;
  boolean rtb_SOMCtl_bBatLTRFlg_k;
  boolean rtb_SOMCtl_bBatLTRFlg_b;
  boolean rtb_flag;
  boolean rtb_flg;
  boolean rtb_flg_d;
  boolean rtb_flg_g;
  boolean rtb_flg_o;
  boolean rtb_flag_l;
  boolean rtb_flg_dg;
  boolean rtb_flg_f;
  boolean rtb_flag_c;
  boolean rtb_flag_k;
  boolean rtb_flg_n;
  boolean rtb_flg_m;
  boolean rtb_ACTCtl_eCOMPFlg3Cal;
  boolean rtb_ACTCtl_eCOMPFlg3Cal_c;
  boolean rtb_flag_f;
  boolean rtb_flag_g;
  boolean rtb_flag_n;
  boolean rtb_flag_nk;
  boolean rtb_flag_d;
  boolean rtb_flag_a;
  boolean rtb_flag_g4;
  boolean rtb_flag_de;
  boolean rtb_flag_ko;
  TMS2VCU_AC_1_Command_Outputs rtb_BusCreator1;
  TMS2VCU_AC_2_State_Outputs rtb_BusCreator2;
  TMS2VCU_AC_3_State_Outputs rtb_BusCreator3;
  TMS2VCU_AC_8_status_Outputs rtb_BusCreator4;
  TMS2VCU_AC_ACStatuts_Outputs rtb_BusCreator5;
  TMS2VCU_AC_COMP_Outputs rtb_BusCreator6;
  TMS2VCU_HVCH_Command_Outputs rtb_BusCreator7;
  TMS2VCU_PPVAddSignalGroup_Outputs rtb_BusCreator11;
  TMS2VCU_TMS_LINTestData1_Outputs rtb_BusCreator8;
  TMS2VCU_TMS_LINTestData2_Outputs rtb_BusCreator9;
  TMS2VCU_TMS_LINTestData3_Outputs rtb_BusCreator10;
  Tms2Vcu_Info rtb_BusCreator;
  float64 a;
  float64 b;
  sint32 b_previousEvent;
  sint32 rtb_SOMCtl_bBatTSFlg;
  float32 rtb_ACFanLevel5EnvCor;
  float32 rtb_ACFanLevel6EnvCor;
  float32 rtb_ACFanLevel7EnvCor;
  float32 rtb_ACFanLevel8EnvCor;
  float32 rtb_Add_ok;
  float32 rtb_Delay;
  float32 rtb_Delay1_ie;
  float32 rtb_Gain6;
  float32 rtb_Merge;
  float32 rtb_Merge1;
  float32 rtb_Merge1_m;
  float32 rtb_Merge_g;
  float32 rtb_MultiportSwitch2_e;
  float32 rtb_PI_Cor_d;
  float32 rtb_PI_Cor_n;
  float32 rtb_Saturation_ou;
  uint32 rtb_Divide1_f;
  sint16 rtb_DataTypeConversion1_i;
  sint16 rtb_DataTypeConversion2;
  sint16 rtb_DataTypeConversion3;
  sint16 rtb_DataTypeConversion4;
  sint16 rtb_DataTypeConversion_dt;
  uint16 rtb_Add_ei_0;
  uint16 rtb_Divide_ox;
  uint16 rtb_Gain1_j_0;
  ACEconMode rtb_DataTypeConversion_f;
  BlowerModes rtb_DataTypeConversion_ks;
  BlowerModes rtb_Delay_n2;
  uint8 rtb_VectorConcatenate[12];
  uint8 rtb_Add2_j5;
  uint8 rtb_Add3_do;
  uint8 rtb_Add4_ox;
  uint8 rtb_Add5_d;
  uint8 rtb_Add6_d;
  uint8 rtb_Add7_i;
  uint8 rtb_Add_b1;
  uint8 rtb_DataTypeConversion1_j0;
  uint8 rtb_DataTypeConversion_jr;
  uint8 rtb_Gain_gr;
  uint8 rtb_IFreezFlag;
  uint8 rtb_IFreezFlag_bd;
  uint8 rtb_IFreezFlag_c;
  uint8 rtb_IFreezFlag_d;
  uint8 rtb_IFreezFlag_jz;
  uint8 rtb_IFreezFlag_k;
  uint8 rtb_IFreezFlag_m;
  uint8 rtb_IFreezFlag_o;
  uint8 rtb_IndexVector8_j;
  uint8 rtb_MultiportSwitch1;
  uint8 rtb_SOMCtl_eBatModeSts_l;
  uint8 rtb_Switch1_l2;
  uint8 rtb_Switch1_mn;
  uint8 rtb_Switch2_ip;
  uint8 rtb_Switch3_l;
  uint8 rtb_Switch_dwm;
  uint8 u1;
  boolean rtb_Compare_no[6];
  boolean rtb_Compare_gw[5];
  boolean FixPtRelationalOperator;
  boolean guard1 = false;
  boolean guard2 = false;
  boolean rtb_AND1_hh;
  boolean rtb_AND2_of;
  boolean rtb_AND_b3z;
  boolean rtb_Compare_dy;
  boolean rtb_Compare_fx;
  boolean rtb_Compare_mgx;
  boolean rtb_Delay1_ag;
  boolean rtb_Delay_j3;
  boolean rtb_Delay_mz3;
  boolean rtb_FixPtRelationalOperator_a0;
  boolean rtb_FixPtRelationalOperator_fk;
  boolean rtb_FixPtRelationalOperator_i1;
  boolean rtb_FixPtRelationalOperator_mk;
  boolean rtb_OR_k0;
  boolean rtb_RelationalOperator_nf;

  /* RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' incorporates:
   *  SubSystem: '<Root>/ME11_TMS'
   */
  /* DataStoreWrite: '<S2>/Data Store Write' incorporates:
   *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
   */
  GLB_ESC_VehicleSpeedValid =
    (Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA())
    ->VIPM_ESCVehSpdVld_flg;

  /* DataStoreWrite: '<S2>/Data Store Write1' incorporates:
   *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
   */
  GLB_ESC_VehicleSpeed =
    (Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA())
    ->VIPM_ESCVehSpd_kph;

  /* Outputs for Atomic SubSystem: '<S2>/Sensor' */
  ME11_TMSADCSampleFunc();

  /* End of Outputs for SubSystem: '<S2>/Sensor' */

  /* Switch: '<S211>/Init' incorporates:
   *  Constant: '<S185>/ACCtrl_facSolarFlt_C'
   *  Constant: '<S209>/Constant'
   *  DataTypeConversion: '<S185>/Data Type Conversion'
   *  MinMax: '<S185>/MinMax'
   *  Product: '<S209>/Product'
   *  Product: '<S209>/Product1'
   *  Sum: '<S209>/Sum'
   *  Sum: '<S209>/Sum1'
   *  UnitDelay: '<S211>/FixPt Unit Delay1'
   *  UnitDelay: '<S211>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE != 0) {
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE = AC_rSolarRight;
  }

  ME11_ARID_DEF.FixPtUnitDelay1_DSTATE = (1.0F - cal_U_DVTFFSolarFilterRate) *
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE + (float32)AC_rSolarRight *
    cal_U_DVTFFSolarFilterRate;

  /* End of Switch: '<S211>/Init' */

  /* Chart: '<S210>/TempRampBaseTimeAndStep' incorporates:
   *  Constant: '<S185>/TempRampStep1'
   *  Constant: '<S185>/TempRampStep2'
   *  DataTypeConversion: '<S185>/Data Type Conversion1'
   *  UnitDelay: '<S211>/FixPt Unit Delay1'
   */
  if (ME11_ARID_DEF.is_active_c41_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c41_ME11 = 1U;
    ME11_ARID_DEF.OutData_f = (uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE;
    ME11_ARID_DEF.is_c41_ME11 = ME11_IN_DontChange;
    ME11_ARID_DEF.count_g = 0U;
  } else {
    guard1 = false;
    switch (ME11_ARID_DEF.is_c41_ME11) {
     case ME11_IN_DecreaseTemp:
      if (AC_rSunloadFlt <= (uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE) {
        ME11_ARID_DEF.is_DecreaseTemp_ji = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_c41_ME11 = ME11_IN_DontChange;
        ME11_ARID_DEF.count_g = 0U;
      } else {
        rtb_Divide1_f = ME11_ARID_DEF.count_g + 1U;
        if (ME11_ARID_DEF.count_g + 1U > 65535U) {
          rtb_Divide1_f = 65535U;
        }

        ME11_ARID_DEF.count_g = (uint16)rtb_Divide1_f;
        if (ME11_ARID_DEF.is_DecreaseTemp_ji == ME11_IN_Delay) {
          if (ME11_ARID_DEF.count_g > cal_FalseTime2Solar) {
            ME11_ARID_DEF.is_DecreaseTemp_ji = ME11_IN_Delaychecked;
            ME11_ARID_DEF.count_g = 0U;
            rtb_Divide1_f = (uint32)(uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE
              + cal_SolarFalseStep;
            if (rtb_Divide1_f > 65535U) {
              rtb_Divide1_f = 65535U;
            }

            if (AC_rSunloadFlt > (sint32)rtb_Divide1_f) {
              rtb_Divide1_f = (uint32)AC_rSunloadFlt - /*MW:OvSatOk*/
                cal_SolarFalseStep;
              if (rtb_Divide1_f > AC_rSunloadFlt) {
                rtb_Divide1_f = 0U;
              }

              ME11_ARID_DEF.OutData_f = (uint16)rtb_Divide1_f;
            } else {
              ME11_ARID_DEF.OutData_f = (uint16)
                ME11_ARID_DEF.FixPtUnitDelay1_DSTATE;
            }
          } else {
            ME11_ARID_DEF.is_DecreaseTemp_ji = ME11_IN_Delay;
          }

          /* case IN_Delaychecked: */
        } else if (ME11_ARID_DEF.count_g > cal_FalseTime2Solar) {
          ME11_ARID_DEF.is_DecreaseTemp_ji = ME11_IN_Delaychecked;
          ME11_ARID_DEF.count_g = 0U;
          rtb_Divide1_f = (uint32)(uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE +
            cal_SolarFalseStep;
          if (rtb_Divide1_f > 65535U) {
            rtb_Divide1_f = 65535U;
          }

          if (AC_rSunloadFlt > (sint32)rtb_Divide1_f) {
            rtb_Divide1_f = (uint32)AC_rSunloadFlt - /*MW:OvSatOk*/
              cal_SolarFalseStep;
            if (rtb_Divide1_f > AC_rSunloadFlt) {
              rtb_Divide1_f = 0U;
            }

            ME11_ARID_DEF.OutData_f = (uint16)rtb_Divide1_f;
          } else {
            ME11_ARID_DEF.OutData_f = (uint16)
              ME11_ARID_DEF.FixPtUnitDelay1_DSTATE;
          }
        } else {
          ME11_ARID_DEF.is_DecreaseTemp_ji = ME11_IN_Delay;
        }
      }
      break;

     case ME11_IN_DontChange:
      rtb_Divide1_f = (uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE - 20U;
      if ((uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE - 20U > (uint16)
          ME11_ARID_DEF.FixPtUnitDelay1_DSTATE) {
        rtb_Divide1_f = 0U;
      }

      if (AC_rSunloadFlt < (sint32)rtb_Divide1_f) {
        rtb_Divide1_f = ME11_ARID_DEF.count_g + 1U;
        if (ME11_ARID_DEF.count_g + 1U > 65535U) {
          rtb_Divide1_f = 65535U;
        }

        ME11_ARID_DEF.count_g = (uint16)rtb_Divide1_f;
        rtb_Divide1_f = cal_UpAndDownStartTime - 10U;
        if (cal_UpAndDownStartTime - 10U > cal_UpAndDownStartTime) {
          rtb_Divide1_f = 0U;
        }

        if (ME11_ARID_DEF.count_g > (sint32)rtb_Divide1_f) {
          ME11_ARID_DEF.is_c41_ME11 = ME11_IN_IncreaseTemp;
          ME11_ARID_DEF.count_g = 0U;
          if (ME11_ARID_DEF.count_g > cal_RiseTime2Solar) {
            ME11_ARID_DEF.is_IncreaseTemp_g = ME11_IN_Delaychecked;
            ME11_ARID_DEF.count_g = 0U;
            rtb_Divide1_f = (uint32)(uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE
              - /*MW:OvSatOk*/ cal_SolarRiseStep;
            if (rtb_Divide1_f > (uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE) {
              rtb_Divide1_f = 0U;
            }

            if (AC_rSunloadFlt < (sint32)rtb_Divide1_f) {
              rtb_Divide1_f = (uint32)AC_rSunloadFlt + cal_SolarRiseStep;
              if (rtb_Divide1_f > 65535U) {
                rtb_Divide1_f = 65535U;
              }

              ME11_ARID_DEF.OutData_f = (uint16)rtb_Divide1_f;
            } else {
              ME11_ARID_DEF.OutData_f = (uint16)
                ME11_ARID_DEF.FixPtUnitDelay1_DSTATE;
            }
          } else {
            ME11_ARID_DEF.is_IncreaseTemp_g = ME11_IN_Delay;
          }
        } else {
          guard1 = true;
        }
      } else {
        guard1 = true;
      }
      break;

     default:
      /* case IN_IncreaseTemp: */
      if (AC_rSunloadFlt >= (uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE) {
        ME11_ARID_DEF.is_IncreaseTemp_g = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_c41_ME11 = ME11_IN_DontChange;
        ME11_ARID_DEF.count_g = 0U;
      } else {
        rtb_Divide1_f = ME11_ARID_DEF.count_g + 1U;
        if (ME11_ARID_DEF.count_g + 1U > 65535U) {
          rtb_Divide1_f = 65535U;
        }

        ME11_ARID_DEF.count_g = (uint16)rtb_Divide1_f;
        if (ME11_ARID_DEF.is_IncreaseTemp_g == ME11_IN_Delay) {
          if (ME11_ARID_DEF.count_g > cal_RiseTime2Solar) {
            ME11_ARID_DEF.is_IncreaseTemp_g = ME11_IN_Delaychecked;
            ME11_ARID_DEF.count_g = 0U;
            rtb_Divide1_f = (uint32)(uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE
              - /*MW:OvSatOk*/ cal_SolarRiseStep;
            if (rtb_Divide1_f > (uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE) {
              rtb_Divide1_f = 0U;
            }

            if (AC_rSunloadFlt < (sint32)rtb_Divide1_f) {
              rtb_Divide1_f = (uint32)AC_rSunloadFlt + cal_SolarRiseStep;
              if (rtb_Divide1_f > 65535U) {
                rtb_Divide1_f = 65535U;
              }

              ME11_ARID_DEF.OutData_f = (uint16)rtb_Divide1_f;
            } else {
              ME11_ARID_DEF.OutData_f = (uint16)
                ME11_ARID_DEF.FixPtUnitDelay1_DSTATE;
            }
          } else {
            ME11_ARID_DEF.is_IncreaseTemp_g = ME11_IN_Delay;
          }

          /* case IN_Delaychecked: */
        } else if (ME11_ARID_DEF.count_g > cal_RiseTime2Solar) {
          ME11_ARID_DEF.is_IncreaseTemp_g = ME11_IN_Delaychecked;
          ME11_ARID_DEF.count_g = 0U;
          rtb_Divide1_f = (uint32)(uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE -
            /*MW:OvSatOk*/ cal_SolarRiseStep;
          if (rtb_Divide1_f > (uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE) {
            rtb_Divide1_f = 0U;
          }

          if (AC_rSunloadFlt < (sint32)rtb_Divide1_f) {
            rtb_Divide1_f = (uint32)AC_rSunloadFlt + cal_SolarRiseStep;
            if (rtb_Divide1_f > 65535U) {
              rtb_Divide1_f = 65535U;
            }

            ME11_ARID_DEF.OutData_f = (uint16)rtb_Divide1_f;
          } else {
            ME11_ARID_DEF.OutData_f = (uint16)
              ME11_ARID_DEF.FixPtUnitDelay1_DSTATE;
          }
        } else {
          ME11_ARID_DEF.is_IncreaseTemp_g = ME11_IN_Delay;
        }
      }
      break;
    }

    if (guard1) {
      rtb_Divide1_f = (uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE + 20U;
      if ((uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE + 20U > 65535U) {
        rtb_Divide1_f = 65535U;
      }

      if (AC_rSunloadFlt > (sint32)rtb_Divide1_f) {
        rtb_Divide1_f = ME11_ARID_DEF.count_g + 1U;
        if (ME11_ARID_DEF.count_g + 1U > 65535U) {
          rtb_Divide1_f = 65535U;
        }

        ME11_ARID_DEF.count_g = (uint16)rtb_Divide1_f;
        if (ME11_ARID_DEF.count_g > cal_UpAndDownStartTime) {
          ME11_ARID_DEF.is_c41_ME11 = ME11_IN_DecreaseTemp;
          ME11_ARID_DEF.count_g = 0U;
          if (ME11_ARID_DEF.count_g > cal_FalseTime2Solar) {
            ME11_ARID_DEF.is_DecreaseTemp_ji = ME11_IN_Delaychecked;
            ME11_ARID_DEF.count_g = 0U;
            rtb_Divide1_f = (uint32)(uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE
              + cal_SolarFalseStep;
            if (rtb_Divide1_f > 65535U) {
              rtb_Divide1_f = 65535U;
            }

            if (AC_rSunloadFlt > (sint32)rtb_Divide1_f) {
              rtb_Divide1_f = (uint32)AC_rSunloadFlt - /*MW:OvSatOk*/
                cal_SolarFalseStep;
              if (rtb_Divide1_f > AC_rSunloadFlt) {
                rtb_Divide1_f = 0U;
              }

              ME11_ARID_DEF.OutData_f = (uint16)rtb_Divide1_f;
            } else {
              ME11_ARID_DEF.OutData_f = (uint16)
                ME11_ARID_DEF.FixPtUnitDelay1_DSTATE;
            }
          } else {
            ME11_ARID_DEF.is_DecreaseTemp_ji = ME11_IN_Delay;
          }
        }
      }
    }
  }

  /* End of Chart: '<S210>/TempRampBaseTimeAndStep' */

  /* Saturate: '<S210>/Saturation' */
  if (ME11_ARID_DEF.OutData_f > 1200) {
    /* Saturate: '<S210>/Saturation' */
    AC_rSunloadFlt = 1200U;
  } else if (ME11_ARID_DEF.OutData_f < 20) {
    /* Saturate: '<S210>/Saturation' */
    AC_rSunloadFlt = 20U;
  } else {
    /* Saturate: '<S210>/Saturation' */
    AC_rSunloadFlt = ME11_ARID_DEF.OutData_f;
  }

  /* End of Saturate: '<S210>/Saturation' */

  /* DataStoreWrite: '<S210>/Data Store Write' incorporates:
   *  ArithShift: '<S210>/Shift Arithmetic'
   *  DataTypeConversion: '<S210>/Data Type Conversion'
   *  DataTypeConversion: '<S210>/Data Type Conversion1'
   *  Saturate: '<S210>/Saturation'
   */
  Buffer_DcmDspData_F268H[0] = (uint8)AC_rSunloadFlt;
  Buffer_DcmDspData_F268H[1] = (uint8)((uint32)AC_rSunloadFlt >> 8);

  /* SignalConversion: '<S2>/Signal Copy200' incorporates:
   *  Inport: '<Root>/IPM_HU_B_BAC'
   */
  HU_LeftTempSet = (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
    ->VIPM_HULeftTempSet_enum;

  /* SignalConversion: '<S2>/Signal Copy183' incorporates:
   *  Inport: '<Root>/Vcu2BcmTms_outputs'
   */
  PWRCtl_eVCUPTSts = (Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs
                      ())->VHVM_PTActOprtMode_enum;

  /* Chart: '<S30>/CoBatCharg' */
  if (ME11_ARID_DEF.is_active_c58_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c58_ME11 = 1U;
    ME11_enter_internal_ThermalCoordinate();
  } else {
    switch (ME11_ARID_DEF.is_ThermalCoordinate) {
     case ME11_IN_BTMS_Default:
      PWRCtl_eBatChargSts = 0U;
      ME11_ARID_DEF.is_ThermalCoordinate = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_ThermalCoordinate();
      break;

     case ME11_IN_BTMS_NormalThermal:
      PWRCtl_eBatChargSts = 0U;
      ME11_ARID_DEF.is_ThermalCoordinate = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_ThermalCoordinate();
      break;

     case ME11_IN_BTMS_QuickChargeThermal:
      PWRCtl_eBatChargSts = 2U;
      ME11_ARID_DEF.is_ThermalCoordinate = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_ThermalCoordinate();
      break;

     default:
      /* case IN_BTMS_SlowChargeThermal: */
      PWRCtl_eBatChargSts = 1U;
      ME11_ARID_DEF.is_ThermalCoordinate = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_ThermalCoordinate();
      break;
    }
  }

  /* End of Chart: '<S30>/CoBatCharg' */

  /* Switch: '<S46>/Switch2' incorporates:
   *  CCaller: '<S2>/C Caller'
   */
  rtb_Switch2_ip = GetHw_KL15A();

  /* Switch: '<S46>/Switch1' incorporates:
   *  CCaller: '<S2>/C Caller1'
   */
  rtb_Switch1_l2 = GetHw_KL15B();

  /* Logic: '<S2>/OR' */
  PWRCtl_bKL15swtSt = ((rtb_Switch2_ip != 0) || (rtb_Switch1_l2 != 0));

  /* Chart: '<S30>/TMSStatus' */
  if (ME11_ARID_DEF.is_active_c7_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c7_ME11 = 1U;
    ME11_enter_internal_Sts(&rtb_Switch2_ip);
  } else {
    switch (ME11_ARID_DEF.is_Sts) {
     case ME11_IN_ACchg:
      rtb_Switch2_ip = 3U;
      ME11_ARID_DEF.is_Sts = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Sts(&rtb_Switch2_ip);
      break;

     case ME11_IN_DCchg:
      rtb_Switch2_ip = 4U;
      ME11_ARID_DEF.is_Sts = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Sts(&rtb_Switch2_ip);
      break;

     case ME11_IN_Default_o:
      rtb_Switch2_ip = 0U;
      ME11_ARID_DEF.is_Sts = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Sts(&rtb_Switch2_ip);
      break;

     case ME11_IN_Dischg:
      rtb_Switch2_ip = 2U;
      ME11_ARID_DEF.is_Sts = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Sts(&rtb_Switch2_ip);
      break;

     case ME11_IN_LowVoltage:
      rtb_Switch2_ip = 1U;
      ME11_ARID_DEF.is_Sts = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Sts(&rtb_Switch2_ip);
      break;

     default:
      /* case IN_PTReady: */
      rtb_Switch2_ip = 5U;
      ME11_ARID_DEF.is_Sts = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Sts(&rtb_Switch2_ip);
      break;
    }
  }

  /* End of Chart: '<S30>/TMSStatus' */

  /* Switch: '<S1296>/Switch' incorporates:
   *  Constant: '<S1296>/Constant1'
   */
  if (cal_TMSStatusEnb > 0) {
    /* Switch: '<S1296>/Switch' incorporates:
     *  Constant: '<S1296>/Constant'
     */
    PWRCtl_eTMSStatus = cal_TMSStatusData;
  } else {
    /* Switch: '<S1296>/Switch' incorporates:
     *  DataTypeConversion: '<S1290>/Data Type Conversion'
     */
    PWRCtl_eTMSStatus = rtb_Switch2_ip;
  }

  /* End of Switch: '<S1296>/Switch' */

  /* DataTypeConversion: '<S1290>/Data Type Conversion1' incorporates:
   *  Switch: '<S1296>/Switch'
   */
  ME11_ARID_DEF.DataTypeConversion1 = PWRCtl_eTMSStatus;

  /* Outputs for Enabled SubSystem: '<S2>/HMI' incorporates:
   *  EnablePort: '<S12>/Enable'
   */
  /* Logic: '<S2>/AND' incorporates:
   *  Constant: '<S9>/Constant'
   *  RelationalOperator: '<S9>/Compare'
   */
  if ((ME11_ARID_DEF.DataTypeConversion1 >= 2) && PWRCtl_bKL15swtSt) {
    ME11_ARID_DEF.HMI_MODE = true;

    /* Delay: '<S12>/Delay' */
    rtb_Delay_mz3 = ME11_ARID_DEF.Delay_DSTATE_ot;

    /* Logic: '<S1119>/AND' incorporates:
     *  Constant: '<S1157>/Constant'
     *  RelationalOperator: '<S1157>/Compare'
     *  RelationalOperator: '<S1159>/FixPt Relational Operator'
     *  UnitDelay: '<S1159>/Delay Input1'
     *
     * Block description for '<S1159>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_AND_b3z = ((HU_LeftTempSet != ME11_ARID_DEF.DelayInput1_DSTATE_d1) &&
                   (HU_LeftTempSet != 0));

    /* Switch: '<S1119>/Switch1' incorporates:
     *  Delay: '<S1119>/Delay'
     */
    if (rtb_AND_b3z) {
      ME11_ARID_DEF.Delay_DSTATE_d = HU_LeftTempSet;
    }

    /* End of Switch: '<S1119>/Switch1' */

    /* RelationalOperator: '<S1158>/FixPt Relational Operator' incorporates:
     *  UnitDelay: '<S1158>/Delay Input1'
     *
     * Block description for '<S1158>/Delay Input1':
     *
     *  Store in Global RAM
     */
    FixPtRelationalOperator = (rtb_AND_b3z !=
      ME11_ARID_DEF.DelayInput1_DSTATE_kr);

    /* Chart: '<S1119>/SetTemp' incorporates:
     *  DataStoreRead: '<S1119>/Data Store Read'
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     */
    if (ME11_ARID_DEF.temporalCounter_i5 < 7U) {
      ME11_ARID_DEF.temporalCounter_i5++;
    }

    if (ME11_ARID_DEF.temporalCounter_i6 < 7U) {
      ME11_ARID_DEF.temporalCounter_i6++;
    }

    ME11_ARID_DEF.sfEvent = -1;
    if (ME11_ARID_DEF.temporalCounter_i1_fs < 15U) {
      ME11_ARID_DEF.temporalCounter_i1_fs++;
    }

    if (ME11_ARID_DEF.temporalCounter_i2_fk < 7U) {
      ME11_ARID_DEF.temporalCounter_i2_fk++;
    }

    if (ME11_ARID_DEF.temporalCounter_i3 < 7U) {
      ME11_ARID_DEF.temporalCounter_i3++;
    }

    if (ME11_ARID_DEF.temporalCounter_i4 < 3U) {
      ME11_ARID_DEF.temporalCounter_i4++;
    }

    if (ME11_ARID_DEF.is_active_c56_ME11 == 0U) {
      ME11_ARID_DEF.is_active_c56_ME11 = 1U;
      ME11_ARID_DEF.is_active_Cal = 1U;
      ME11_ARID_DEF.is_Cal = ME11_IN_Init_i;
      ME11_ARID_DEF.temporalCounter_i1_fs = 0U;
      ME11_ARID_DEF.Fb = ME11_ARID_DEF.EERead_CabinSetTemp;
      ME11_ARID_DEF.is_active_Add = 1U;
      ME11_ARID_DEF.is_Add = ME11_IN_Init_o;
      ME11_ARID_DEF.temporalCounter_i2_fk = 0U;
      ME11_ARID_DEF.is_active_Dec = 1U;
      ME11_ARID_DEF.is_Dec = ME11_IN_Init_o;
      ME11_ARID_DEF.temporalCounter_i3 = 0U;
      ME11_ARID_DEF.is_active_ChgJudge = 1U;
      ME11_ARID_DEF.is_ChgJudge = ME11_IN_Chg_Off;
      ME11_ARID_DEF.HMICtl_bChgFlg = false;
    } else {
      if (ME11_ARID_DEF.is_active_Cal != 0U) {
        ME11_Cal(&FixPtRelationalOperator);
      }

      if (ME11_ARID_DEF.is_active_Add != 0U) {
        switch (ME11_ARID_DEF.is_Add) {
         case ME11_IN_Add:
          if (!(Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                ())->VIPM_CCPTempAddKey_flg) {
            ME11_ARID_DEF.is_Add = ME11_IN_Init_o;
            ME11_ARID_DEF.temporalCounter_i2_fk = 0U;
          } else {
            ME11_ARID_DEF.is_Add = ME11_IN_Wait_c;
            ME11_ARID_DEF.temporalCounter_i5 = 0U;
          }
          break;

         case ME11_IN_Init_o:
          if ((ME11_ARID_DEF.sfEvent == -1) &&
              (ME11_ARID_DEF.temporalCounter_i2_fk >= 4) &&
              (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
               ())->VIPM_CCPTempAddKey_flg) {
            ME11_ARID_DEF.is_Add = ME11_IN_NO_ACTIVE_CHILD_gl;
            b_previousEvent = ME11_ARID_DEF.sfEvent;
            ME11_ARID_DEF.sfEvent = ME11_event_AddKey;
            if (ME11_ARID_DEF.is_active_Cal != 0U) {
              ME11_Cal(&FixPtRelationalOperator);
            }

            ME11_ARID_DEF.sfEvent = b_previousEvent;
            ME11_ARID_DEF.is_Add = ME11_IN_Wait_c;
            ME11_ARID_DEF.temporalCounter_i5 = 0U;
          }
          break;

         case ME11_IN_Wait_c:
          if (ME11_ARID_DEF.temporalCounter_i5 >= 5U) {
            ME11_ARID_DEF.is_Add = ME11_IN_Add;
            b_previousEvent = ME11_ARID_DEF.sfEvent;
            ME11_ARID_DEF.sfEvent = ME11_event_AddKey;
            if (ME11_ARID_DEF.is_active_Cal != 0U) {
              ME11_Cal(&FixPtRelationalOperator);
            }

            ME11_ARID_DEF.sfEvent = b_previousEvent;
          } else if
              (!(Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                 ())->VIPM_CCPTempAddKey_flg) {
            ME11_ARID_DEF.is_Add = ME11_IN_Init_o;
            ME11_ARID_DEF.temporalCounter_i2_fk = 0U;
          }
          break;
        }
      }

      if (ME11_ARID_DEF.is_active_Dec != 0U) {
        switch (ME11_ARID_DEF.is_Dec) {
         case ME11_IN_Add:
          if (!(Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                ())->VIPM_CCPTempDecKey_flg) {
            ME11_ARID_DEF.is_Dec = ME11_IN_Init_o;
            ME11_ARID_DEF.temporalCounter_i3 = 0U;
          } else {
            ME11_ARID_DEF.is_Dec = ME11_IN_Wait_c;
            ME11_ARID_DEF.temporalCounter_i6 = 0U;
          }
          break;

         case ME11_IN_Init_o:
          if ((ME11_ARID_DEF.sfEvent == -1) && (ME11_ARID_DEF.temporalCounter_i3
               >= 4) &&
              (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
               ())->VIPM_CCPTempDecKey_flg) {
            ME11_ARID_DEF.is_Dec = ME11_IN_NO_ACTIVE_CHILD_gl;
            b_previousEvent = ME11_ARID_DEF.sfEvent;
            ME11_ARID_DEF.sfEvent = ME11_event_DecKey;
            if (ME11_ARID_DEF.is_active_Cal != 0U) {
              ME11_Cal(&FixPtRelationalOperator);
            }

            ME11_ARID_DEF.sfEvent = b_previousEvent;
            ME11_ARID_DEF.is_Dec = ME11_IN_Wait_c;
            ME11_ARID_DEF.temporalCounter_i6 = 0U;
          }
          break;

         case ME11_IN_Wait_c:
          if (ME11_ARID_DEF.temporalCounter_i6 >= 5U) {
            ME11_ARID_DEF.is_Dec = ME11_IN_Add;
            b_previousEvent = ME11_ARID_DEF.sfEvent;
            ME11_ARID_DEF.sfEvent = ME11_event_DecKey;
            if (ME11_ARID_DEF.is_active_Cal != 0U) {
              ME11_Cal(&FixPtRelationalOperator);
            }

            ME11_ARID_DEF.sfEvent = b_previousEvent;
          } else if
              (!(Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                 ())->VIPM_CCPTempDecKey_flg) {
            ME11_ARID_DEF.is_Dec = ME11_IN_Init_o;
            ME11_ARID_DEF.temporalCounter_i3 = 0U;
          }
          break;
        }
      }

      if (ME11_ARID_DEF.is_active_ChgJudge != 0U) {
        switch (ME11_ARID_DEF.is_ChgJudge) {
         case ME11_IN_Chg_Off:
          ME11_ARID_DEF.HMICtl_bChgFlg = false;
          if (FixPtRelationalOperator || (ME11_ARID_DEF.sfEvent ==
               ME11_event_AddKey) || (ME11_ARID_DEF.sfEvent == ME11_event_DecKey))
          {
            ME11_ARID_DEF.is_ChgJudge = ME11_IN_Chg_On;
            ME11_ARID_DEF.temporalCounter_i4 = 0U;
            ME11_ARID_DEF.HMICtl_bChgFlg = true;
          }
          break;

         case ME11_IN_Chg_On:
          ME11_ARID_DEF.HMICtl_bChgFlg = true;
          if ((ME11_ARID_DEF.sfEvent == -1) && (ME11_ARID_DEF.temporalCounter_i4
               >= 2)) {
            ME11_ARID_DEF.is_ChgJudge = ME11_IN_Chg_Off;
            ME11_ARID_DEF.HMICtl_bChgFlg = false;
          }
          break;
        }
      }
    }

    /* End of Chart: '<S1119>/SetTemp' */

    /* Switch: '<S1119>/Switch' incorporates:
     *  Constant: '<S1119>/Constant3'
     *  Delay: '<S1119>/Delay1'
     *  Delay: '<S12>/Delay'
     *  Logic: '<S1119>/OR'
     *  RelationalOperator: '<S1160>/FixPt Relational Operator'
     *  RelationalOperator: '<S1161>/FixPt Relational Operator'
     *  RelationalOperator: '<S1162>/FixPt Relational Operator'
     *  Switch: '<S1119>/Switch2'
     *  UnitDelay: '<S1160>/Delay Input1'
     *  UnitDelay: '<S1161>/Delay Input1'
     *  UnitDelay: '<S1162>/Delay Input1'
     *
     * Block description for '<S1160>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1161>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1162>/Delay Input1':
     *
     *  Store in Global RAM
     */
    if ((sint32)ME11_ARID_DEF.Delay_DSTATE_ot > (sint32)
        ME11_ARID_DEF.DelayInput1_DSTATE_jg) {
      ME11_ARID_DEF.Delay1_DSTATE_fq = 32U;
    } else if ((ME11_ARID_DEF.Fb != ME11_ARID_DEF.DelayInput1_DSTATE_gt) ||
               ME11_ARID_DEF.HMICtl_bChgFlg || ((sint32)
                ME11_ARID_DEF.Delay_DSTATE_ot < (sint32)
                ME11_ARID_DEF.DelayInput1_DSTATE_f0)) {
      /* Switch: '<S1119>/Switch2' incorporates:
       *  Delay: '<S1119>/Delay1'
       */
      ME11_ARID_DEF.Delay1_DSTATE_fq = ME11_ARID_DEF.Fb;
    }

    /* End of Switch: '<S1119>/Switch' */

    /* Switch: '<S1165>/Switch' incorporates:
     *  Constant: '<S1165>/Constant1'
     */
    if (cal_tLeftSetPointEnb) {
      /* Switch: '<S1165>/Switch' incorporates:
       *  Constant: '<S1165>/Constant'
       */
      HMICtl_sLeftSetPoint = cal_tLeftSetPointData;
    } else {
      /* Switch: '<S1165>/Switch' incorporates:
       *  Constant: '<S1119>/Constant1'
       *  Constant: '<S1119>/Constant2'
       *  Delay: '<S1119>/Delay1'
       *  Product: '<S1119>/Divide'
       *  Sum: '<S1119>/Add'
       */
      HMICtl_sLeftSetPoint = 0.5F * (float32)ME11_ARID_DEF.Delay1_DSTATE_fq +
        16.0F;
    }

    /* End of Switch: '<S1165>/Switch' */

    /* Product: '<S12>/Divide' incorporates:
     *  Constant: '<S12>/Constant'
     */
    rtb_Divide_ox = (uint16)(10.0F * HMICtl_sLeftSetPoint);

    /* DataTypeConversion: '<S12>/Data Type Conversion' incorporates:
     *  Concatenate: '<S12>/Vector Concatenate'
     *  DataStoreWrite: '<S12>/Data Store Write'
     */
    Buffer_DcmDspData_F26CH[0] = (uint8)rtb_Divide_ox;

    /* DataTypeConversion: '<S12>/Data Type Conversion1' incorporates:
     *  ArithShift: '<S12>/Shift Arithmetic'
     *  Concatenate: '<S12>/Vector Concatenate'
     *  DataStoreWrite: '<S12>/Data Store Write'
     *  Product: '<S12>/Divide'
     */
    Buffer_DcmDspData_F26CH[1] = (uint8)((uint32)rtb_Divide_ox >> 8);

    /* Delay: '<S1168>/Delay3' */
    rtb_Switch2_ip = HMICtl_eACSts;

    /* Delay: '<S1168>/Delay1' */
    rtb_Delay1_ie = ME11_ARID_DEF.Delay1_DSTATE_d;

    /* RelationalOperator: '<S1126>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *  UnitDelay: '<S1126>/Delay Input1'
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     */
    FixPtRelationalOperator = ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUFrntFanSpdSet_enum > ME11_ARID_DEF.DelayInput1_DSTATE_di);

    /* RelationalOperator: '<S1127>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *  UnitDelay: '<S1127>/Delay Input1'
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_hg = ((sint32)
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPBlwrLvlAddKey_flg > (sint32)ME11_ARID_DEF.DelayInput1_DSTATE_hg);

    /* RelationalOperator: '<S1128>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx = ((sint32)
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPBlwrLvlDecKey_flg > (sint32)ME11_ARID_DEF.DelayInput1_DSTATE_bx);

    /* Logic: '<S1105>/AND1' incorporates:
     *  UnitDelay: '<S1127>/Delay Input1'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_AND1_hh = (FixPtRelationalOperator ||
                   ME11_ARID_DEF.DelayInput1_DSTATE_hg ||
                   ME11_ARID_DEF.DelayInput1_DSTATE_bx);

    /* UnitDelay: '<S1144>/Delay Input1' incorporates:
     *  UnitDelay: '<S1126>/Delay Input1'
     *
     * Block description for '<S1144>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_di = ME11_ARID_DEF.DelayInput1_DSTATE_iv;

    /* RelationalOperator: '<S1144>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *  UnitDelay: '<S1126>/Delay Input1'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx =
      ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
       ->VIPM_HUAirInletModeSet_enum > ME11_ARID_DEF.DelayInput1_DSTATE_di);

    /* UnitDelay: '<S1143>/Delay Input1' incorporates:
     *  UnitDelay: '<S1127>/Delay Input1'
     *
     * Block description for '<S1143>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_hg = ME11_ARID_DEF.DelayInput1_DSTATE_br;

    /* RelationalOperator: '<S1143>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *  UnitDelay: '<S1127>/Delay Input1'
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_FixPtRelationalOperator_mk = ((sint32)
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPAirInletModeKey_flg > (sint32)
      ME11_ARID_DEF.DelayInput1_DSTATE_hg);

    /* Logic: '<S1115>/OR' incorporates:
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    FixPtRelationalOperator = (ME11_ARID_DEF.DelayInput1_DSTATE_bx ||
      rtb_FixPtRelationalOperator_mk);

    /* Delay: '<S1120>/Delay' */
    rtb_Delay_j3 = ME11_ARID_DEF.Delay_DSTATE_by;

    /* Delay: '<S1120>/Delay1' */
    rtb_Delay1_ag = ME11_ARID_DEF.Delay1_DSTATE_c1;

    /* UnitDelay: '<S1150>/Delay Input1' incorporates:
     *  UnitDelay: '<S1126>/Delay Input1'
     *
     * Block description for '<S1150>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_di = ME11_ARID_DEF.DelayInput1_DSTATE_op;

    /* RelationalOperator: '<S1150>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *  UnitDelay: '<S1126>/Delay Input1'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx =
      ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
       ->VIPM_HUBlwrModeSet_enum != ME11_ARID_DEF.DelayInput1_DSTATE_di);

    /* RelationalOperator: '<S1149>/Compare' incorporates:
     *  Constant: '<S1149>/Constant'
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *  UnitDelay: '<S1127>/Delay Input1'
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_hg =
      ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
       ->VIPM_HUBlwrModeSet_enum != 0);

    /* Logic: '<S1117>/AND' incorporates:
     *  UnitDelay: '<S1127>/Delay Input1'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx = (ME11_ARID_DEF.DelayInput1_DSTATE_bx &&
      ME11_ARID_DEF.DelayInput1_DSTATE_hg);

    /* Delay: '<S1117>/Delay' incorporates:
     *  UnitDelay: '<S1126>/Delay Input1'
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_di = ME11_ARID_DEF.Delay_DSTATE_hx;

    /* Switch: '<S1117>/Switch' incorporates:
     *  Delay: '<S1117>/Delay'
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    if (ME11_ARID_DEF.DelayInput1_DSTATE_bx) {
      ME11_ARID_DEF.Delay_DSTATE_hx =
        (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
        ->VIPM_HUBlwrModeSet_enum;
    }

    /* End of Switch: '<S1117>/Switch' */

    /* Chart: '<S1117>/ModeSet' */
    if (ME11_ARID_DEF.is_active_c60_ME11 == 0U) {
      ME11_ARID_DEF.is_active_c60_ME11 = 1U;
      ME11_enter_internal_Mode();
    } else {
      switch (ME11_ARID_DEF.is_Mode) {
       case ME11_IN_Defrost_a:
        ME11_ARID_DEF.mode = 1U;
        ME11_ARID_DEF.is_Mode = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_enter_internal_Mode();
        break;

       case ME11_IN_Defrost_Foot:
        ME11_ARID_DEF.mode = 3U;
        ME11_ARID_DEF.is_Mode = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_enter_internal_Mode();
        break;

       case ME11_IN_Face_l:
        ME11_ARID_DEF.mode = 5U;
        ME11_ARID_DEF.is_Mode = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_enter_internal_Mode();
        break;

       case ME11_IN_Face_Foot:
        ME11_ARID_DEF.mode = 4U;
        ME11_ARID_DEF.is_Mode = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_enter_internal_Mode();
        break;

       default:
        /* case IN_Foot: */
        ME11_ARID_DEF.mode = 2U;
        ME11_ARID_DEF.is_Mode = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_enter_internal_Mode();
        break;
      }
    }

    /* End of Chart: '<S1117>/ModeSet' */

    /* Switch: '<S1153>/Switch2' incorporates:
     *  Constant: '<S1117>/Constant'
     *  Constant: '<S1117>/Constant1'
     *  DataStoreRead: '<S1117>/Data Store Read'
     *  RelationalOperator: '<S1153>/LowerRelop1'
     *  RelationalOperator: '<S1153>/UpperRelop'
     *  Switch: '<S1153>/Switch'
     */
    if (ME11_ARID_DEF.EERead_CabinModeDoor > 5) {
      /* Switch: '<S1153>/Switch2' */
      rtb_Switch1_l2 = 5U;
    } else if (ME11_ARID_DEF.EERead_CabinModeDoor < 1) {
      /* Switch: '<S1153>/Switch' incorporates:
       *  Constant: '<S1117>/Constant'
       *  Switch: '<S1153>/Switch2'
       */
      rtb_Switch1_l2 = 1U;
    } else {
      /* Switch: '<S1153>/Switch2' incorporates:
       *  Switch: '<S1153>/Switch'
       */
      rtb_Switch1_l2 = ME11_ARID_DEF.EERead_CabinModeDoor;
    }

    /* End of Switch: '<S1153>/Switch2' */

    /* Chart: '<S1117>/CCPCtrl' incorporates:
     *  Delay: '<S1117>/Delay1'
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     */
    if (ME11_ARID_DEF.temporalCounter_i2_k < 15U) {
      ME11_ARID_DEF.temporalCounter_i2_k++;
    }

    if (ME11_ARID_DEF.temporalCounter_i1_fj < 15U) {
      ME11_ARID_DEF.temporalCounter_i1_fj++;
    }

    if (ME11_ARID_DEF.is_active_c99_ME11 == 0U) {
      ME11_ARID_DEF.is_active_c99_ME11 = 1U;
      ME11_ARID_DEF.is_c99_ME11 = ME11_IN_Init_i;
      ME11_ARID_DEF.temporalCounter_i1_fj = 0U;
      ME11_ARID_DEF.setMode = rtb_Switch1_l2;
    } else {
      switch (ME11_ARID_DEF.is_c99_ME11) {
       case ME11_IN_Init_i:
        if (ME11_ARID_DEF.temporalCounter_i1_fj >= 10) {
          ME11_ARID_DEF.is_c99_ME11 = ME11_IN_Normal_l;
          ME11_ARID_DEF.is_Normal = ME11_IN_Init_nt;
          ME11_ARID_DEF.setMode = ME11_ARID_DEF.Delay1_DSTATE_es;
        } else {
          ME11_ARID_DEF.setMode = rtb_Switch1_l2;
        }
        break;

       case ME11_IN_Max_d:
        if (ME11_ARID_DEF.Delay1_DSTATE_es < 5) {
          ME11_ARID_DEF.is_c99_ME11 = ME11_IN_Normal_l;
          ME11_ARID_DEF.is_Normal = ME11_IN_Init_nt;
          ME11_ARID_DEF.setMode = ME11_ARID_DEF.Delay1_DSTATE_es;
        } else if
            ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
              ())->VIPM_CCPBlwngModePrevKey_flg) {
          ME11_ARID_DEF.is_c99_ME11 = ME11_IN_Normal_l;
          ME11_ARID_DEF.is_Normal = ME11_IN_Dec_d;
          ME11_ARID_DEF.is_Dec_j = ME11_IN_Two_h;
          ME11_ARID_DEF.temporalCounter_i2_k = 0U;
          b_previousEvent = ME11_ARID_DEF.setMode - 1;
          if (ME11_ARID_DEF.setMode - 1 < 0) {
            b_previousEvent = 0;
          }

          ME11_ARID_DEF.setMode = (uint8)b_previousEvent;
        } else {
          ME11_ARID_DEF.setMode = ME11_ARID_DEF.Delay1_DSTATE_es;
        }
        break;

       case ME11_IN_Min_b:
        if (ME11_ARID_DEF.Delay1_DSTATE_es > 1) {
          ME11_ARID_DEF.is_c99_ME11 = ME11_IN_Normal_l;
          ME11_ARID_DEF.is_Normal = ME11_IN_Init_nt;
          ME11_ARID_DEF.setMode = ME11_ARID_DEF.Delay1_DSTATE_es;
        } else if
            ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
              ())->VIPM_CCPBlwngModeNextKey_flg) {
          ME11_ARID_DEF.is_c99_ME11 = ME11_IN_Normal_l;
          ME11_ARID_DEF.is_Normal = ME11_IN_Add;
          ME11_ARID_DEF.is_Add_p = ME11_IN_One_l;
          ME11_ARID_DEF.temporalCounter_i2_k = 0U;
          b_previousEvent = ME11_ARID_DEF.setMode + 1;
          if (ME11_ARID_DEF.setMode + 1 > 255) {
            b_previousEvent = 255;
          }

          ME11_ARID_DEF.setMode = (uint8)b_previousEvent;
        } else {
          ME11_ARID_DEF.setMode = ME11_ARID_DEF.Delay1_DSTATE_es;
        }
        break;

       default:
        /* case IN_Normal: */
        if (ME11_ARID_DEF.setMode > 4) {
          ME11_ARID_DEF.is_Add_p = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_Dec_j = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_Normal = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_c99_ME11 = ME11_IN_Max_d;
          ME11_ARID_DEF.setMode = ME11_ARID_DEF.Delay1_DSTATE_es;
        } else if (ME11_ARID_DEF.setMode < 2) {
          ME11_ARID_DEF.is_Add_p = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_Dec_j = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_Normal = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_c99_ME11 = ME11_IN_Min_b;
          ME11_ARID_DEF.setMode = ME11_ARID_DEF.Delay1_DSTATE_es;
        } else {
          switch (ME11_ARID_DEF.is_Normal) {
           case ME11_IN_Add:
            if (!(Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                  ())->VIPM_CCPBlwngModeNextKey_flg) {
              ME11_ARID_DEF.is_Add_p = ME11_IN_NO_ACTIVE_CHILD_gl;
              ME11_ARID_DEF.is_Normal = ME11_IN_Init_nt;
              ME11_ARID_DEF.setMode = ME11_ARID_DEF.Delay1_DSTATE_es;
            } else if (ME11_ARID_DEF.is_Add_p == ME11_IN_One_l) {
              if (ME11_ARID_DEF.temporalCounter_i2_k >= 10U) {
                ME11_ARID_DEF.is_Add_p = ME11_IN_wait_pz;
              }

              /* case IN_wait: */
            } else if
                ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                  ())->VIPM_CCPBlwngModeNextKey_flg) {
              ME11_ARID_DEF.is_Add_p = ME11_IN_One_l;
              ME11_ARID_DEF.temporalCounter_i2_k = 0U;
              b_previousEvent = ME11_ARID_DEF.setMode + 1;
              if (ME11_ARID_DEF.setMode + 1 > 255) {
                b_previousEvent = 255;
              }

              ME11_ARID_DEF.setMode = (uint8)b_previousEvent;
            }
            break;

           case ME11_IN_Dec_d:
            if (!(Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                  ())->VIPM_CCPBlwngModePrevKey_flg) {
              ME11_ARID_DEF.is_Dec_j = ME11_IN_NO_ACTIVE_CHILD_gl;
              ME11_ARID_DEF.is_Normal = ME11_IN_Init_nt;
              ME11_ARID_DEF.setMode = ME11_ARID_DEF.Delay1_DSTATE_es;
            } else if (ME11_ARID_DEF.is_Dec_j == ME11_IN_Two_h) {
              if (ME11_ARID_DEF.temporalCounter_i2_k >= 10U) {
                ME11_ARID_DEF.is_Dec_j = ME11_IN_wait_pz;
              }

              /* case IN_wait: */
            } else if
                ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                  ())->VIPM_CCPBlwngModePrevKey_flg) {
              ME11_ARID_DEF.is_Dec_j = ME11_IN_Two_h;
              ME11_ARID_DEF.temporalCounter_i2_k = 0U;
              b_previousEvent = ME11_ARID_DEF.setMode - 1;
              if (ME11_ARID_DEF.setMode - 1 < 0) {
                b_previousEvent = 0;
              }

              ME11_ARID_DEF.setMode = (uint8)b_previousEvent;
            }
            break;

           default:
            /* case IN_Init: */
            if ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                 ())->VIPM_CCPBlwngModeNextKey_flg) {
              ME11_ARID_DEF.is_Normal = ME11_IN_Add;
              ME11_ARID_DEF.is_Add_p = ME11_IN_One_l;
              ME11_ARID_DEF.temporalCounter_i2_k = 0U;
              b_previousEvent = ME11_ARID_DEF.setMode + 1;
              if (ME11_ARID_DEF.setMode + 1 > 255) {
                b_previousEvent = 255;
              }

              ME11_ARID_DEF.setMode = (uint8)b_previousEvent;
            } else if
                ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                  ())->VIPM_CCPBlwngModePrevKey_flg) {
              ME11_ARID_DEF.is_Normal = ME11_IN_Dec_d;
              ME11_ARID_DEF.is_Dec_j = ME11_IN_Two_h;
              ME11_ARID_DEF.temporalCounter_i2_k = 0U;
              b_previousEvent = ME11_ARID_DEF.setMode - 1;
              if (ME11_ARID_DEF.setMode - 1 < 0) {
                b_previousEvent = 0;
              }

              ME11_ARID_DEF.setMode = (uint8)b_previousEvent;
            } else {
              ME11_ARID_DEF.setMode = ME11_ARID_DEF.Delay1_DSTATE_es;
            }
            break;
          }
        }
        break;
      }
    }

    /* End of Chart: '<S1117>/CCPCtrl' */

    /* Switch: '<S1117>/Switch1' incorporates:
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    if (ME11_ARID_DEF.DelayInput1_DSTATE_bx) {
      /* Switch: '<S1117>/Switch1' */
      ME11_ARID_DEF.Delay1_DSTATE_es = ME11_ARID_DEF.mode;
    } else {
      /* Switch: '<S1117>/Switch1' */
      ME11_ARID_DEF.Delay1_DSTATE_es = ME11_ARID_DEF.setMode;
    }

    /* End of Switch: '<S1117>/Switch1' */

    /* Switch: '<S1154>/Switch2' incorporates:
     *  Constant: '<S1117>/Constant3'
     *  Constant: '<S1117>/Constant4'
     *  Delay: '<S1117>/Delay1'
     *  RelationalOperator: '<S1154>/LowerRelop1'
     *  RelationalOperator: '<S1154>/UpperRelop'
     *  Switch: '<S1154>/Switch'
     */
    if (ME11_ARID_DEF.Delay1_DSTATE_es > 5) {
      ME11_ARID_DEF.Delay1_DSTATE_es = 5U;
    } else if (ME11_ARID_DEF.Delay1_DSTATE_es < 1) {
      /* Switch: '<S1154>/Switch' incorporates:
       *  Constant: '<S1117>/Constant3'
       *  Delay: '<S1117>/Delay1'
       */
      ME11_ARID_DEF.Delay1_DSTATE_es = 1U;
    }

    /* End of Switch: '<S1154>/Switch2' */

    /* Switch: '<S1152>/Switch' incorporates:
     *  Constant: '<S1152>/Constant1'
     */
    if (cal_eModeMotorEnb) {
      /* Switch: '<S1152>/Switch' incorporates:
       *  Constant: '<S1152>/Constant'
       */
      HMICtl_eModeMotor = cal_eModeMotorData;
    } else {
      /* Switch: '<S1152>/Switch' incorporates:
       *  Delay: '<S1117>/Delay1'
       */
      HMICtl_eModeMotor = ME11_ARID_DEF.Delay1_DSTATE_es;
    }

    /* End of Switch: '<S1152>/Switch' */

    /* Switch: '<S1168>/Switch3' incorporates:
     *  Constant: '<S1168>/Constant2'
     *  Constant: '<S1186>/Constant'
     *  Constant: '<S1187>/Constant'
     *  Delay: '<S1120>/Delay1'
     *  Delay: '<S1168>/Delay'
     *  Delay: '<S1168>/Delay3'
     *  Logic: '<S1168>/AND2'
     *  Logic: '<S1168>/AND5'
     *  Logic: '<S1168>/AND7'
     *  RelationalOperator: '<S1186>/Compare'
     *  RelationalOperator: '<S1187>/Compare'
     *  RelationalOperator: '<S1190>/FixPt Relational Operator'
     *  RelationalOperator: '<S1191>/FixPt Relational Operator'
     *  RelationalOperator: '<S1192>/FixPt Relational Operator'
     *  RelationalOperator: '<S1193>/FixPt Relational Operator'
     *  RelationalOperator: '<S1194>/FixPt Relational Operator'
     *  RelationalOperator: '<S1196>/FixPt Relational Operator'
     *  UnitDelay: '<S1190>/Delay Input1'
     *  UnitDelay: '<S1191>/Delay Input1'
     *  UnitDelay: '<S1192>/Delay Input1'
     *  UnitDelay: '<S1193>/Delay Input1'
     *  UnitDelay: '<S1194>/Delay Input1'
     *  UnitDelay: '<S1196>/Delay Input1'
     *
     * Block description for '<S1190>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1191>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1192>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1193>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1194>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1196>/Delay Input1':
     *
     *  Store in Global RAM
     */
    if (((HMICtl_eACSts != ME11_ARID_DEF.DelayInput1_DSTATE_l) && (HMICtl_eACSts
          == 3)) || (rtb_Delay1_ie < ME11_ARID_DEF.DelayInput1_DSTATE_or) ||
        rtb_AND1_hh || (FixPtRelationalOperator !=
                        ME11_ARID_DEF.DelayInput1_DSTATE_jx) || ((sint32)
         rtb_Delay_j3 < (sint32)ME11_ARID_DEF.DelayInput1_DSTATE_c) || ((sint32)
         ME11_ARID_DEF.Delay1_DSTATE_c1 > (sint32)
         ME11_ARID_DEF.DelayInput1_DSTATE_fq) || ((HMICtl_eModeMotor !=
          ME11_ARID_DEF.DelayInput1_DSTATE_gr) && (HMICtl_eModeMotor != 1))) {
      ME11_ARID_DEF.Delay_DSTATE_hv = false;
    } else {
      /* RelationalOperator: '<S1188>/FixPt Relational Operator' incorporates:
       *  Inport: '<Root>/IPM_HU_B_BAC'
       *  UnitDelay: '<S1188>/Delay Input1'
       *
       * Block description for '<S1188>/Delay Input1':
       *
       *  Store in Global RAM
       */
      rtb_FixPtRelationalOperator_i1 =
        ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
         ->VIPM_HUManlDefrstCtl_enum != ME11_ARID_DEF.DelayInput1_DSTATE_ov);

      /* RelationalOperator: '<S1184>/Compare' incorporates:
       *  Constant: '<S1184>/Constant'
       *  Inport: '<Root>/IPM_HU_B_BAC'
       */
      rtb_Compare_mgx = ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
                         ->VIPM_HUManlDefrstCtl_enum == 2);

      /* Switch: '<S1168>/Switch' incorporates:
       *  Logic: '<S1168>/AND'
       */
      if (rtb_Compare_mgx && rtb_FixPtRelationalOperator_i1) {
        /* Delay: '<S1168>/Delay' incorporates:
         *  Constant: '<S1168>/Constant'
         *  Switch: '<S1168>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_hv = true;
      } else {
        /* RelationalOperator: '<S1189>/FixPt Relational Operator' incorporates:
         *  Inport: '<Root>/IPM_HU_B_BAC'
         *  UnitDelay: '<S1189>/Delay Input1'
         *
         * Block description for '<S1189>/Delay Input1':
         *
         *  Store in Global RAM
         */
        rtb_FixPtRelationalOperator_i1 =
          ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
           ->VIPM_HUManlDefrstCtl_enum != ME11_ARID_DEF.DelayInput1_DSTATE_ie);

        /* RelationalOperator: '<S1185>/Compare' incorporates:
         *  Constant: '<S1185>/Constant'
         *  Inport: '<Root>/IPM_HU_B_BAC'
         */
        rtb_Compare_mgx = ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
                           ->VIPM_HUManlDefrstCtl_enum == 1);

        /* Switch: '<S1168>/Switch1' incorporates:
         *  Logic: '<S1168>/AND1'
         */
        if (rtb_Compare_mgx && rtb_FixPtRelationalOperator_i1) {
          /* Delay: '<S1168>/Delay' incorporates:
           *  Constant: '<S1168>/Constant1'
           *  Switch: '<S1168>/Switch'
           *  Switch: '<S1168>/Switch1'
           */
          ME11_ARID_DEF.Delay_DSTATE_hv = false;
        } else {
          /* RelationalOperator: '<S1195>/FixPt Relational Operator' incorporates:
           *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
           *  UnitDelay: '<S1195>/Delay Input1'
           *
           * Block description for '<S1195>/Delay Input1':
           *
           *  Store in Global RAM
           */
          rtb_FixPtRelationalOperator_i1 = ((sint32)
            (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
             ())->VIPM_CCPFrntWindDefrstKey_flg > (sint32)
            ME11_ARID_DEF.DelayInput1_DSTATE_jd);

          /* Switch: '<S1168>/Switch2' */
          if (rtb_FixPtRelationalOperator_i1) {
            /* Delay: '<S1168>/Delay' incorporates:
             *  Logic: '<S1168>/NOT'
             *  Switch: '<S1168>/Switch'
             *  Switch: '<S1168>/Switch2'
             */
            ME11_ARID_DEF.Delay_DSTATE_hv = !ME11_ARID_DEF.Delay_DSTATE_hv;
          }

          /* End of Switch: '<S1168>/Switch2' */
        }

        /* End of Switch: '<S1168>/Switch1' */
      }

      /* End of Switch: '<S1168>/Switch' */
    }

    /* End of Switch: '<S1168>/Switch3' */

    /* Switch: '<S1197>/Switch' incorporates:
     *  Constant: '<S1197>/Constant1'
     */
    if (cal_bACDefrostEnb) {
      /* Switch: '<S1197>/Switch' incorporates:
       *  Constant: '<S1197>/Constant'
       */
      HMICtl_bACDefrost = cal_bACDefrostData;
    } else {
      /* Switch: '<S1197>/Switch' incorporates:
       *  Delay: '<S1168>/Delay'
       *  Switch: '<S1168>/Switch4'
       */
      HMICtl_bACDefrost = (PWRCtl_bKL15swtSt && ME11_ARID_DEF.Delay_DSTATE_hv);
    }

    /* End of Switch: '<S1197>/Switch' */

    /* UnitDelay: '<S1218>/Delay Input1' incorporates:
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1218>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx = ME11_ARID_DEF.DelayInput1_DSTATE_os;

    /* RelationalOperator: '<S1218>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_FixPtRelationalOperator_i1 = ((sint32)
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPModeKey_flg > (sint32)ME11_ARID_DEF.DelayInput1_DSTATE_bx);

    /* Chart: '<S1170>/Chart' incorporates:
     *  DataStoreRead: '<S1170>/Data Store Read'
     *  Delay: '<S1170>/Delay'
     */
    if (ME11_ARID_DEF.temporalCounter_i1_b5 < 15U) {
      ME11_ARID_DEF.temporalCounter_i1_b5++;
    }

    if (ME11_ARID_DEF.is_active_c100_ME11 == 0U) {
      ME11_ARID_DEF.is_active_c100_ME11 = 1U;
      ME11_ARID_DEF.is_c100_ME11 = ME11_IN_Init_nt;
      ME11_ARID_DEF.temporalCounter_i1_b5 = 0U;
      ME11_ARID_DEF.Mode = ME11_ARID_DEF.EERead_CabinMode;
    } else {
      switch (ME11_ARID_DEF.is_c100_ME11) {
       case ME11_IN_Active:
        if (ME11_ARID_DEF.Mode > 3) {
          ME11_ARID_DEF.is_c100_ME11 = ME11_IN_Max_n;
          ME11_ARID_DEF.temporalCounter_i1_b5 = 0U;
          ME11_ARID_DEF.Mode = 1U;
        } else if (rtb_FixPtRelationalOperator_i1) {
          ME11_ARID_DEF.is_c100_ME11 = ME11_IN_Active;
          b_previousEvent = ME11_ARID_DEF.Delay_DSTATE_cf + 1;
          if (ME11_ARID_DEF.Delay_DSTATE_cf + 1 > 255) {
            b_previousEvent = 255;
          }

          ME11_ARID_DEF.Mode = (uint8)b_previousEvent;
        } else {
          ME11_ARID_DEF.is_c100_ME11 = ME11_IN_Default_c4;
          ME11_ARID_DEF.Mode = ME11_ARID_DEF.Delay_DSTATE_cf;
        }
        break;

       case ME11_IN_Default_c4:
        if (rtb_FixPtRelationalOperator_i1) {
          ME11_ARID_DEF.is_c100_ME11 = ME11_IN_Active;
          b_previousEvent = ME11_ARID_DEF.Delay_DSTATE_cf + 1;
          if (ME11_ARID_DEF.Delay_DSTATE_cf + 1 > 255) {
            b_previousEvent = 255;
          }

          ME11_ARID_DEF.Mode = (uint8)b_previousEvent;
        } else {
          ME11_ARID_DEF.Mode = ME11_ARID_DEF.Delay_DSTATE_cf;
        }
        break;

       case ME11_IN_Init_nt:
        if (ME11_ARID_DEF.temporalCounter_i1_b5 >= 10) {
          ME11_ARID_DEF.is_c100_ME11 = ME11_IN_Default_c4;
          ME11_ARID_DEF.Mode = ME11_ARID_DEF.Delay_DSTATE_cf;
        } else {
          ME11_ARID_DEF.Mode = ME11_ARID_DEF.EERead_CabinMode;
        }
        break;

       default:
        /* case IN_Max: */
        if (ME11_ARID_DEF.temporalCounter_i1_b5 >= 1) {
          ME11_ARID_DEF.is_c100_ME11 = ME11_IN_Default_c4;
          ME11_ARID_DEF.Mode = ME11_ARID_DEF.Delay_DSTATE_cf;
        }
        break;
      }
    }

    /* End of Chart: '<S1170>/Chart' */

    /* Switch: '<S1170>/Switch4' incorporates:
     *  Constant: '<S1214>/Constant'
     *  Delay: '<S1120>/Delay1'
     *  Delay: '<S1170>/Delay'
     *  Logic: '<S1170>/AND3'
     *  Logic: '<S1170>/AND4'
     *  RelationalOperator: '<S1214>/Compare'
     *  RelationalOperator: '<S1219>/FixPt Relational Operator'
     *  RelationalOperator: '<S1220>/FixPt Relational Operator'
     *  UnitDelay: '<S1219>/Delay Input1'
     *  UnitDelay: '<S1220>/Delay Input1'
     *
     * Block description for '<S1219>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1220>/Delay Input1':
     *
     *  Store in Global RAM
     */
    if ((((sint32)HMICtl_bACDefrost > (sint32)
          ME11_ARID_DEF.DelayInput1_DSTATE_dz) || ((sint32)
          ME11_ARID_DEF.Delay1_DSTATE_c1 > (sint32)
          ME11_ARID_DEF.DelayInput1_DSTATE_a)) && (ME11_ARID_DEF.Delay_DSTATE_cf
         == 3)) {
      /* Switch: '<S1170>/Switch4' incorporates:
       *  Constant: '<S1170>/Constant1'
       */
      ME11_ARID_DEF.Delay_DSTATE_cf = 1U;
    } else {
      /* RelationalOperator: '<S1215>/FixPt Relational Operator' incorporates:
       *  Inport: '<Root>/IPM_HU_B_BAC'
       *  UnitDelay: '<S1215>/Delay Input1'
       *
       * Block description for '<S1215>/Delay Input1':
       *
       *  Store in Global RAM
       */
      rtb_FixPtRelationalOperator_i1 =
        ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
         ->VIPM_HUHybEcoModeSet_enum != ME11_ARID_DEF.DelayInput1_DSTATE_k);

      /* Logic: '<S1170>/AND' incorporates:
       *  Constant: '<S1211>/Constant'
       *  Inport: '<Root>/IPM_HU_B_BAC'
       *  RelationalOperator: '<S1211>/Compare'
       */
      rtb_Compare_mgx = ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
                         ->VIPM_HUHybEcoModeSet_enum == 2);
      rtb_Compare_mgx = (rtb_Compare_mgx && rtb_FixPtRelationalOperator_i1);

      /* Switch: '<S1170>/Switch' */
      if (rtb_Compare_mgx) {
        /* Switch: '<S1170>/Switch4' incorporates:
         *  Inport: '<Root>/IPM_HU_B_BAC'
         *  Switch: '<S1170>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_cf =
          (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
          ->VIPM_HUHybEcoModeSet_enum;
      } else {
        /* RelationalOperator: '<S1216>/FixPt Relational Operator' incorporates:
         *  Inport: '<Root>/IPM_HU_B_BAC'
         *  UnitDelay: '<S1216>/Delay Input1'
         *
         * Block description for '<S1216>/Delay Input1':
         *
         *  Store in Global RAM
         */
        rtb_FixPtRelationalOperator_i1 =
          ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
           ->VIPM_HUHybEcoModeSet_enum != ME11_ARID_DEF.DelayInput1_DSTATE_gy);

        /* Logic: '<S1170>/AND1' incorporates:
         *  Constant: '<S1212>/Constant'
         *  Inport: '<Root>/IPM_HU_B_BAC'
         *  RelationalOperator: '<S1212>/Compare'
         */
        rtb_Compare_mgx = ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
                           ->VIPM_HUHybEcoModeSet_enum == 1);
        rtb_Compare_mgx = (rtb_Compare_mgx && rtb_FixPtRelationalOperator_i1);

        /* Switch: '<S1170>/Switch1' */
        if (rtb_Compare_mgx) {
          /* Switch: '<S1170>/Switch4' incorporates:
           *  Inport: '<Root>/IPM_HU_B_BAC'
           *  Switch: '<S1170>/Switch1'
           */
          ME11_ARID_DEF.Delay_DSTATE_cf =
            (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
            ->VIPM_HUHybEcoModeSet_enum;
        } else {
          /* RelationalOperator: '<S1217>/FixPt Relational Operator' incorporates:
           *  Inport: '<Root>/IPM_HU_B_BAC'
           *  UnitDelay: '<S1217>/Delay Input1'
           *
           * Block description for '<S1217>/Delay Input1':
           *
           *  Store in Global RAM
           */
          rtb_FixPtRelationalOperator_i1 =
            ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
             ->VIPM_HUHybEcoModeSet_enum != ME11_ARID_DEF.DelayInput1_DSTATE_p);

          /* Logic: '<S1170>/AND2' incorporates:
           *  Constant: '<S1213>/Constant'
           *  Inport: '<Root>/IPM_HU_B_BAC'
           *  RelationalOperator: '<S1213>/Compare'
           */
          rtb_Compare_mgx = ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC()
                             )->VIPM_HUHybEcoModeSet_enum == 3);
          rtb_Compare_mgx = (rtb_Compare_mgx && rtb_FixPtRelationalOperator_i1);

          /* Switch: '<S1170>/Switch2' incorporates:
           *  MinMax: '<S1170>/Min'
           */
          if (rtb_Compare_mgx) {
            /* Switch: '<S1170>/Switch4' incorporates:
             *  Inport: '<Root>/IPM_HU_B_BAC'
             *  Switch: '<S1170>/Switch1'
             *  Switch: '<S1170>/Switch2'
             */
            ME11_ARID_DEF.Delay_DSTATE_cf =
              (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
              ->VIPM_HUHybEcoModeSet_enum;
          } else if (ME11_ARID_DEF.Mode <= 3) {
            /* MinMax: '<S1170>/Min' incorporates:
             *  Switch: '<S1170>/Switch1'
             *  Switch: '<S1170>/Switch2'
             *  Switch: '<S1170>/Switch4'
             */
            ME11_ARID_DEF.Delay_DSTATE_cf = ME11_ARID_DEF.Mode;
          } else {
            /* Switch: '<S1170>/Switch4' incorporates:
             *  MinMax: '<S1170>/Min'
             *  Switch: '<S1170>/Switch1'
             *  Switch: '<S1170>/Switch2'
             */
            ME11_ARID_DEF.Delay_DSTATE_cf = 3U;
          }

          /* End of Switch: '<S1170>/Switch2' */
        }

        /* End of Switch: '<S1170>/Switch1' */
      }

      /* End of Switch: '<S1170>/Switch' */
    }

    /* End of Switch: '<S1170>/Switch4' */

    /* Switch: '<S1222>/Switch2' incorporates:
     *  Constant: '<S1170>/Constant2'
     *  Constant: '<S1170>/Constant4'
     *  Delay: '<S1170>/Delay'
     *  RelationalOperator: '<S1222>/LowerRelop1'
     *  RelationalOperator: '<S1222>/UpperRelop'
     *  Switch: '<S1222>/Switch'
     */
    if (ME11_ARID_DEF.Delay_DSTATE_cf > 3) {
      ME11_ARID_DEF.Delay_DSTATE_cf = 3U;
    } else if (ME11_ARID_DEF.Delay_DSTATE_cf < 1) {
      /* Switch: '<S1222>/Switch' incorporates:
       *  Constant: '<S1170>/Constant4'
       *  Delay: '<S1170>/Delay'
       */
      ME11_ARID_DEF.Delay_DSTATE_cf = 1U;
    }

    /* End of Switch: '<S1222>/Switch2' */

    /* Switch: '<S1221>/Switch' incorporates:
     *  Constant: '<S1221>/Constant1'
     */
    if (cal_eACStsEnb) {
      /* Switch: '<S1221>/Switch' incorporates:
       *  Constant: '<S1221>/Constant'
       */
      HMICtl_eACSts = cal_eACStsData;
    } else {
      /* Switch: '<S1221>/Switch' incorporates:
       *  Delay: '<S1170>/Delay'
       */
      HMICtl_eACSts = ME11_ARID_DEF.Delay_DSTATE_cf;
    }

    /* End of Switch: '<S1221>/Switch' */

    /* Logic: '<S1167>/AND6' incorporates:
     *  RelationalOperator: '<S1174>/Compare'
     *  RelationalOperator: '<S1176>/Compare'
     */
    rtb_FixPtRelationalOperator_i1 = ((!rtb_Delay_j3) || HMICtl_bACDefrost);

    /* Chart: '<S1167>/Chart' incorporates:
     *  DataStoreRead: '<S1167>/Data Store Read'
     *  Delay: '<S1167>/Delay'
     */
    if (ME11_ARID_DEF.temporalCounter_i1_i0 < 15U) {
      ME11_ARID_DEF.temporalCounter_i1_i0++;
    }

    if (ME11_ARID_DEF.is_active_c39_ME11 == 0U) {
      ME11_ARID_DEF.is_active_c39_ME11 = 1U;
      ME11_ARID_DEF.is_c39_ME11 = ME11_IN_Init_h;
      ME11_ARID_DEF.temporalCounter_i1_i0 = 0U;
      ME11_ARID_DEF.Sts_j = ME11_ARID_DEF.EERead_bACAutoSts;
    } else {
      switch (ME11_ARID_DEF.is_c39_ME11) {
       case ME11_IN_After:
        if (rtb_FixPtRelationalOperator_i1 && ME11_ARID_DEF.Delay_DSTATE_ly) {
          ME11_ARID_DEF.is_c39_ME11 = ME11_IN_wait_b;
          ME11_ARID_DEF.temporalCounter_i1_i0 = 0U;
          ME11_ARID_DEF.Sts_j = ME11_ARID_DEF.Delay_DSTATE_ly;
        } else {
          ME11_ARID_DEF.Sts_j = ME11_ARID_DEF.Delay_DSTATE_ly;
        }
        break;

       case ME11_IN_Enter:
        if (!rtb_FixPtRelationalOperator_i1) {
          ME11_ARID_DEF.is_c39_ME11 = ME11_IN_Exit;
          ME11_ARID_DEF.temporalCounter_i1_i0 = 0U;
          ME11_ARID_DEF.Sts_j = true;
        }
        break;

       case ME11_IN_Exit:
        if (ME11_ARID_DEF.temporalCounter_i1_i0 >= 3) {
          ME11_ARID_DEF.is_c39_ME11 = ME11_IN_After;
        }
        break;

       case ME11_IN_Init_h:
        if (ME11_ARID_DEF.temporalCounter_i1_i0 >= 10) {
          ME11_ARID_DEF.is_c39_ME11 = ME11_IN_After;
        } else {
          ME11_ARID_DEF.Sts_j = ME11_ARID_DEF.EERead_bACAutoSts;
        }
        break;

       default:
        /* case IN_wait: */
        if (!rtb_FixPtRelationalOperator_i1) {
          ME11_ARID_DEF.is_c39_ME11 = ME11_IN_Exit;
          ME11_ARID_DEF.temporalCounter_i1_i0 = 0U;
          ME11_ARID_DEF.Sts_j = true;
        } else if (ME11_ARID_DEF.temporalCounter_i1_i0 >= 2) {
          ME11_ARID_DEF.is_c39_ME11 = ME11_IN_Enter;
          ME11_ARID_DEF.Sts_j = false;
        }
        break;
      }
    }

    /* End of Chart: '<S1167>/Chart' */

    /* Switch: '<S1167>/Switch3' incorporates:
     *  Constant: '<S1167>/Constant2'
     *  Constant: '<S1175>/Constant'
     *  Delay: '<S1167>/Delay'
     *  Logic: '<S1167>/AND4'
     *  Logic: '<S1167>/AND5'
     *  RelationalOperator: '<S1175>/Compare'
     *  RelationalOperator: '<S1179>/FixPt Relational Operator'
     *  RelationalOperator: '<S1180>/FixPt Relational Operator'
     *  RelationalOperator: '<S1181>/FixPt Relational Operator'
     *  UnitDelay: '<S1179>/Delay Input1'
     *  UnitDelay: '<S1180>/Delay Input1'
     *  UnitDelay: '<S1181>/Delay Input1'
     *
     * Block description for '<S1179>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1180>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1181>/Delay Input1':
     *
     *  Store in Global RAM
     */
    if ((FixPtRelationalOperator != ME11_ARID_DEF.DelayInput1_DSTATE_m1) ||
        ((HMICtl_eACSts != ME11_ARID_DEF.DelayInput1_DSTATE_n) && (HMICtl_eACSts
          == 3)) || rtb_AND1_hh || (HMICtl_eModeMotor !=
         ME11_ARID_DEF.DelayInput1_DSTATE_m)) {
      ME11_ARID_DEF.Delay_DSTATE_ly = false;
    } else {
      /* RelationalOperator: '<S1177>/FixPt Relational Operator' incorporates:
       *  Inport: '<Root>/IPM_HU_B_BAC'
       *  UnitDelay: '<S1177>/Delay Input1'
       *
       * Block description for '<S1177>/Delay Input1':
       *
       *  Store in Global RAM
       */
      rtb_FixPtRelationalOperator_i1 =
        ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
         ->VIPM_HUACAutoCtl_enum != ME11_ARID_DEF.DelayInput1_DSTATE_hx);

      /* RelationalOperator: '<S1172>/Compare' incorporates:
       *  Constant: '<S1172>/Constant'
       *  Inport: '<Root>/IPM_HU_B_BAC'
       */
      rtb_Compare_mgx = ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
                         ->VIPM_HUACAutoCtl_enum == 2);

      /* Switch: '<S1167>/Switch' incorporates:
       *  Logic: '<S1167>/AND'
       */
      if (rtb_Compare_mgx && rtb_FixPtRelationalOperator_i1) {
        /* Delay: '<S1167>/Delay' incorporates:
         *  Constant: '<S1167>/Constant'
         *  Switch: '<S1167>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_ly = true;
      } else {
        /* RelationalOperator: '<S1178>/FixPt Relational Operator' incorporates:
         *  Inport: '<Root>/IPM_HU_B_BAC'
         *  UnitDelay: '<S1178>/Delay Input1'
         *
         * Block description for '<S1178>/Delay Input1':
         *
         *  Store in Global RAM
         */
        rtb_FixPtRelationalOperator_i1 =
          ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
           ->VIPM_HUACAutoCtl_enum != ME11_ARID_DEF.DelayInput1_DSTATE_kw);

        /* RelationalOperator: '<S1173>/Compare' incorporates:
         *  Constant: '<S1173>/Constant'
         *  Inport: '<Root>/IPM_HU_B_BAC'
         */
        rtb_Compare_mgx = ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
                           ->VIPM_HUACAutoCtl_enum == 1);

        /* Switch: '<S1167>/Switch1' incorporates:
         *  Logic: '<S1167>/AND1'
         */
        if (rtb_Compare_mgx && rtb_FixPtRelationalOperator_i1) {
          /* Delay: '<S1167>/Delay' incorporates:
           *  Constant: '<S1167>/Constant1'
           *  Switch: '<S1167>/Switch1'
           */
          ME11_ARID_DEF.Delay_DSTATE_ly = false;
        } else {
          /* RelationalOperator: '<S1182>/FixPt Relational Operator' incorporates:
           *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
           *  UnitDelay: '<S1182>/Delay Input1'
           *
           * Block description for '<S1182>/Delay Input1':
           *
           *  Store in Global RAM
           */
          rtb_FixPtRelationalOperator_i1 = ((sint32)
            (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
             ())->VIPM_CCPACAutoKey_flg > (sint32)
            ME11_ARID_DEF.DelayInput1_DSTATE_h2);

          /* Switch: '<S1167>/Switch2' */
          if (rtb_FixPtRelationalOperator_i1) {
            /* Delay: '<S1167>/Delay' incorporates:
             *  Logic: '<S1167>/NOT'
             *  Switch: '<S1167>/Switch1'
             *  Switch: '<S1167>/Switch2'
             */
            ME11_ARID_DEF.Delay_DSTATE_ly = !ME11_ARID_DEF.Sts_j;
          } else {
            /* Delay: '<S1167>/Delay' incorporates:
             *  Switch: '<S1167>/Switch1'
             *  Switch: '<S1167>/Switch2'
             */
            ME11_ARID_DEF.Delay_DSTATE_ly = ME11_ARID_DEF.Sts_j;
          }

          /* End of Switch: '<S1167>/Switch2' */
        }

        /* End of Switch: '<S1167>/Switch1' */
      }

      /* End of Switch: '<S1167>/Switch' */
    }

    /* End of Switch: '<S1167>/Switch3' */

    /* Switch: '<S1183>/Switch' incorporates:
     *  Constant: '<S1183>/Constant1'
     */
    if (cal_bACAutoEnb) {
      /* Switch: '<S1183>/Switch' incorporates:
       *  Constant: '<S1183>/Constant'
       */
      HMICtl_bACAuto = cal_bACAutoData;
    } else {
      /* Switch: '<S1183>/Switch' incorporates:
       *  Delay: '<S1167>/Delay'
       *  Switch: '<S1167>/Switch4'
       */
      HMICtl_bACAuto = (PWRCtl_bKL15swtSt && ME11_ARID_DEF.Delay_DSTATE_ly);
    }

    /* End of Switch: '<S1183>/Switch' */

    /* Chart: '<S1105>/ccpCtrl' incorporates:
     *  DataStoreRead: '<S1105>/Data Store Read'
     *  Delay: '<S1105>/Delay'
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     */
    if (ME11_ARID_DEF.temporalCounter_i2_d < 15U) {
      ME11_ARID_DEF.temporalCounter_i2_d++;
    }

    if (ME11_ARID_DEF.temporalCounter_i1_dp < 15U) {
      ME11_ARID_DEF.temporalCounter_i1_dp++;
    }

    if (ME11_ARID_DEF.is_active_c59_ME11 == 0U) {
      ME11_ARID_DEF.is_active_c59_ME11 = 1U;
      ME11_ARID_DEF.is_c59_ME11 = ME11_IN_NvmRead;
      ME11_ARID_DEF.temporalCounter_i1_dp = 0U;
      ME11_ARID_DEF.setBlw = ME11_ARID_DEF.EERead_CabinBlower;
    } else {
      switch (ME11_ARID_DEF.is_c59_ME11) {
       case ME11_IN_Max:
        if (ME11_ARID_DEF.Delay_DSTATE_oz < 8) {
          ME11_ARID_DEF.is_c59_ME11 = ME11_IN_Normal_i;
          ME11_ARID_DEF.is_Normal_i = ME11_IN_Init_nt;
          ME11_ARID_DEF.setBlw = ME11_ARID_DEF.Delay_DSTATE_oz;
        } else if
            ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
              ())->VIPM_CCPBlwrLvlDecKey_flg) {
          ME11_ARID_DEF.is_c59_ME11 = ME11_IN_Normal_i;
          ME11_ARID_DEF.is_Normal_i = ME11_IN_Dec_d;
          ME11_ARID_DEF.is_Dec_c = ME11_IN_Two;
          b_previousEvent = ME11_ARID_DEF.Delay_DSTATE_oz - 1;
          if (ME11_ARID_DEF.Delay_DSTATE_oz - 1 < 0) {
            b_previousEvent = 0;
          }

          ME11_ARID_DEF.setBlw = (uint8)b_previousEvent;
        } else {
          ME11_ARID_DEF.setBlw = ME11_ARID_DEF.Delay_DSTATE_oz;
        }
        break;

       case ME11_IN_Min:
        if (ME11_ARID_DEF.Delay_DSTATE_oz > 0) {
          ME11_ARID_DEF.is_c59_ME11 = ME11_IN_Normal_i;
          ME11_ARID_DEF.is_Normal_i = ME11_IN_Init_nt;
          ME11_ARID_DEF.setBlw = ME11_ARID_DEF.Delay_DSTATE_oz;
        } else if
            ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
              ())->VIPM_CCPBlwrLvlAddKey_flg) {
          ME11_ARID_DEF.is_c59_ME11 = ME11_IN_Normal_i;
          ME11_ARID_DEF.is_Normal_i = ME11_IN_Add;
          ME11_ARID_DEF.is_Add_f = ME11_IN_One;
          b_previousEvent = ME11_ARID_DEF.Delay_DSTATE_oz + 1;
          if (ME11_ARID_DEF.Delay_DSTATE_oz + 1 > 255) {
            b_previousEvent = 255;
          }

          ME11_ARID_DEF.setBlw = (uint8)b_previousEvent;
        } else {
          ME11_ARID_DEF.setBlw = ME11_ARID_DEF.Delay_DSTATE_oz;
        }
        break;

       case ME11_IN_Normal_i:
        if (ME11_ARID_DEF.setBlw >= 8) {
          ME11_ARID_DEF.is_Add_f = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_Dec_c = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_Normal_i = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_c59_ME11 = ME11_IN_Max;
          ME11_ARID_DEF.setBlw = ME11_ARID_DEF.Delay_DSTATE_oz;
        } else if (ME11_ARID_DEF.setBlw <= 0) {
          ME11_ARID_DEF.is_Add_f = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_Dec_c = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_Normal_i = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_c59_ME11 = ME11_IN_Min;
          ME11_ARID_DEF.setBlw = ME11_ARID_DEF.Delay_DSTATE_oz;
        } else {
          switch (ME11_ARID_DEF.is_Normal_i) {
           case ME11_IN_Add:
            if (!(Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                  ())->VIPM_CCPBlwrLvlAddKey_flg) {
              ME11_ARID_DEF.is_Add_f = ME11_IN_NO_ACTIVE_CHILD_gl;
              ME11_ARID_DEF.is_Normal_i = ME11_IN_Init_nt;
              ME11_ARID_DEF.setBlw = ME11_ARID_DEF.Delay_DSTATE_oz;
            } else {
              switch (ME11_ARID_DEF.is_Add_f) {
               case ME11_IN_Continue:
                if ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                     ())->VIPM_CCPBlwrLvlAddKey_flg) {
                  ME11_ARID_DEF.is_Add_f = ME11_IN_wait_k;
                  ME11_ARID_DEF.temporalCounter_i2_d = 0U;
                }
                break;

               case ME11_IN_One:
                if ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                     ())->VIPM_CCPBlwrLvlAddKey_flg) {
                  ME11_ARID_DEF.is_Add_f = ME11_IN_wait_k;
                  ME11_ARID_DEF.temporalCounter_i2_d = 0U;
                }
                break;

               default:
                /* case IN_wait: */
                if (ME11_ARID_DEF.temporalCounter_i2_d >= 10U) {
                  ME11_ARID_DEF.is_Add_f = ME11_IN_Continue;
                  b_previousEvent = ME11_ARID_DEF.Delay_DSTATE_oz + 1;
                  if (ME11_ARID_DEF.Delay_DSTATE_oz + 1 > 255) {
                    b_previousEvent = 255;
                  }

                  ME11_ARID_DEF.setBlw = (uint8)b_previousEvent;
                }
                break;
              }
            }
            break;

           case ME11_IN_Dec_d:
            if (!(Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                  ())->VIPM_CCPBlwrLvlDecKey_flg) {
              ME11_ARID_DEF.is_Dec_c = ME11_IN_NO_ACTIVE_CHILD_gl;
              ME11_ARID_DEF.is_Normal_i = ME11_IN_Init_nt;
              ME11_ARID_DEF.setBlw = ME11_ARID_DEF.Delay_DSTATE_oz;
            } else {
              switch (ME11_ARID_DEF.is_Dec_c) {
               case ME11_IN_Continue:
                if ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                     ())->VIPM_CCPBlwrLvlDecKey_flg) {
                  ME11_ARID_DEF.is_Dec_c = ME11_IN_wait_k;
                  ME11_ARID_DEF.temporalCounter_i2_d = 0U;
                }
                break;

               case ME11_IN_Two:
                if ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                     ())->VIPM_CCPBlwrLvlDecKey_flg) {
                  ME11_ARID_DEF.is_Dec_c = ME11_IN_wait_k;
                  ME11_ARID_DEF.temporalCounter_i2_d = 0U;
                }
                break;

               default:
                /* case IN_wait: */
                if (ME11_ARID_DEF.temporalCounter_i2_d >= 10U) {
                  ME11_ARID_DEF.is_Dec_c = ME11_IN_Continue;
                  b_previousEvent = ME11_ARID_DEF.Delay_DSTATE_oz - 1;
                  if (ME11_ARID_DEF.Delay_DSTATE_oz - 1 < 0) {
                    b_previousEvent = 0;
                  }

                  ME11_ARID_DEF.setBlw = (uint8)b_previousEvent;
                }
                break;
              }
            }
            break;

           default:
            /* case IN_Init: */
            if ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                 ())->VIPM_CCPBlwrLvlAddKey_flg) {
              ME11_ARID_DEF.is_Normal_i = ME11_IN_Add;
              ME11_ARID_DEF.is_Add_f = ME11_IN_One;
              b_previousEvent = ME11_ARID_DEF.Delay_DSTATE_oz + 1;
              if (ME11_ARID_DEF.Delay_DSTATE_oz + 1 > 255) {
                b_previousEvent = 255;
              }

              ME11_ARID_DEF.setBlw = (uint8)b_previousEvent;
            } else if
                ((Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD
                  ())->VIPM_CCPBlwrLvlDecKey_flg) {
              ME11_ARID_DEF.is_Normal_i = ME11_IN_Dec_d;
              ME11_ARID_DEF.is_Dec_c = ME11_IN_Two;
              b_previousEvent = ME11_ARID_DEF.Delay_DSTATE_oz - 1;
              if (ME11_ARID_DEF.Delay_DSTATE_oz - 1 < 0) {
                b_previousEvent = 0;
              }

              ME11_ARID_DEF.setBlw = (uint8)b_previousEvent;
            } else {
              ME11_ARID_DEF.setBlw = ME11_ARID_DEF.Delay_DSTATE_oz;
            }
            break;
          }
        }
        break;

       default:
        /* case IN_NvmRead: */
        if (ME11_ARID_DEF.temporalCounter_i1_dp >= 10) {
          ME11_ARID_DEF.is_c59_ME11 = ME11_IN_Normal_i;
          ME11_ARID_DEF.is_Normal_i = ME11_IN_Init_nt;
          ME11_ARID_DEF.setBlw = ME11_ARID_DEF.Delay_DSTATE_oz;
        } else {
          ME11_ARID_DEF.setBlw = ME11_ARID_DEF.EERead_CabinBlower;
        }
        break;
      }
    }

    /* End of Chart: '<S1105>/ccpCtrl' */

    /* Switch: '<S1105>/Switch4' incorporates:
     *  Constant: '<S1123>/Constant'
     *  Logic: '<S1105>/AND'
     *  RelationalOperator: '<S1123>/Compare'
     *  RelationalOperator: '<S1125>/FixPt Relational Operator'
     *  UnitDelay: '<S1125>/Delay Input1'
     *
     * Block description for '<S1125>/Delay Input1':
     *
     *  Store in Global RAM
     */
    if ((HMICtl_eACSts == 3) && ((sint32)HMICtl_bACAuto < (sint32)
         ME11_ARID_DEF.DelayInput1_DSTATE_go)) {
      /* Switch: '<S1105>/Switch4' incorporates:
       *  Constant: '<S1105>/Constant3'
       */
      ME11_ARID_DEF.Delay_DSTATE_oz = 3U;
    } else {
      /* RelationalOperator: '<S1124>/FixPt Relational Operator' incorporates:
       *  Inport: '<Root>/IPM_HU_B_BAC'
       *  UnitDelay: '<S1124>/Delay Input1'
       *
       * Block description for '<S1124>/Delay Input1':
       *
       *  Store in Global RAM
       */
      rtb_FixPtRelationalOperator_i1 =
        ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
         ->VIPM_HUFrntFanSpdSet_enum != ME11_ARID_DEF.DelayInput1_DSTATE_f);

      /* Switch: '<S1105>/Switch' */
      if (rtb_FixPtRelationalOperator_i1) {
        /* RelationalOperator: '<S1122>/Compare' incorporates:
         *  Constant: '<S1122>/Constant'
         *  Inport: '<Root>/IPM_HU_B_BAC'
         */
        rtb_FixPtRelationalOperator_i1 =
          ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
           ->VIPM_HUFrntFanSpdSet_enum >= 1);

        /* Switch: '<S1105>/Switch2' */
        if (rtb_FixPtRelationalOperator_i1) {
          /* Switch: '<S1105>/Switch' incorporates:
           *  Constant: '<S1105>/Constant'
           *  Inport: '<Root>/IPM_HU_B_BAC'
           *  Sum: '<S1105>/Add'
           *  Switch: '<S1105>/Switch2'
           */
          ME11_ARID_DEF.Delay_DSTATE_oz = (uint8)
            ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
             ->VIPM_HUFrntFanSpdSet_enum - 1);
        }

        /* End of Switch: '<S1105>/Switch2' */
      } else {
        /* Switch: '<S1105>/Switch' */
        ME11_ARID_DEF.Delay_DSTATE_oz = ME11_ARID_DEF.setBlw;
      }

      /* End of Switch: '<S1105>/Switch' */

      /* MinMax: '<S1105>/Min' */
      if (ME11_ARID_DEF.Delay_DSTATE_oz <= 1) {
        /* Switch: '<S1105>/Switch4' */
        ME11_ARID_DEF.Delay_DSTATE_oz = 1U;
      }

      /* End of MinMax: '<S1105>/Min' */
    }

    /* End of Switch: '<S1105>/Switch4' */

    /* Switch: '<S1130>/Switch2' incorporates:
     *  Constant: '<S1105>/Constant5'
     *  Delay: '<S1105>/Delay'
     *  RelationalOperator: '<S1130>/LowerRelop1'
     */
    if (ME11_ARID_DEF.Delay_DSTATE_oz > 8) {
      ME11_ARID_DEF.Delay_DSTATE_oz = 8U;
    }

    /* End of Switch: '<S1130>/Switch2' */

    /* DataStoreWrite: '<S1105>/Data Store Write' incorporates:
     *  Delay: '<S1105>/Delay'
     */
    ME11_ARID_DEF.EEWrite_CabinBlower = ME11_ARID_DEF.Delay_DSTATE_oz;

    /* Switch: '<S1105>/Switch1' */
    if (HMICtl_bACDefrost) {
      /* Switch: '<S1132>/Switch4' incorporates:
       *  Constant: '<S1132>/Constant1'
       *  Constant: '<S1132>/Constant2'
       *  Constant: '<S1133>/Constant'
       *  RelationalOperator: '<S1133>/Compare'
       */
      if (HMICtl_eACSts == 1) {
        ME11_ARID_DEF.Switch1_n = 6U;
      } else {
        ME11_ARID_DEF.Switch1_n = 5U;
      }

      /* MinMax: '<S1105>/Max' incorporates:
       *  Delay: '<S1105>/Delay'
       *  Switch: '<S1132>/Switch4'
       */
      if (ME11_ARID_DEF.Switch1_n < ME11_ARID_DEF.Delay_DSTATE_oz) {
        /* Switch: '<S1105>/Switch1' */
        ME11_ARID_DEF.Switch1_n = ME11_ARID_DEF.Delay_DSTATE_oz;
      }

      /* End of MinMax: '<S1105>/Max' */
    } else {
      /* Switch: '<S1132>/Switch4' incorporates:
       *  Delay: '<S1105>/Delay'
       *  Switch: '<S1105>/Switch1'
       */
      ME11_ARID_DEF.Switch1_n = ME11_ARID_DEF.Delay_DSTATE_oz;
    }

    /* End of Switch: '<S1105>/Switch1' */

    /* Switch: '<S1129>/Switch' incorporates:
     *  Constant: '<S1129>/Constant1'
     *  Delay: '<S12>/Delay2'
     *  Switch: '<S1105>/Switch3'
     */
    if (cal_eBlwStsEnb) {
      /* Switch: '<S1129>/Switch' incorporates:
       *  Constant: '<S1129>/Constant'
       */
      HMICtl_eBlwSts = cal_eBlwStsData;
    } else if (ME11_ARID_DEF.Delay2_DSTATE_pb) {
      /* Switch: '<S1105>/Switch3' incorporates:
       *  Switch: '<S1129>/Switch'
       */
      HMICtl_eBlwSts = ME11_ARID_DEF.Switch1_n;
    } else {
      /* Switch: '<S1129>/Switch' incorporates:
       *  Constant: '<S1105>/Constant1'
       *  Switch: '<S1105>/Switch3'
       */
      HMICtl_eBlwSts = 0U;
    }

    /* End of Switch: '<S1129>/Switch' */

    /* Switch: '<S1164>/Switch' incorporates:
     *  Constant: '<S1164>/Constant1'
     */
    if (cal_bLeftSetLowEnb) {
      /* Switch: '<S1164>/Switch' incorporates:
       *  Constant: '<S1164>/Constant'
       */
      HMICtl_bLeftSetLow = cal_bLeftSetLowData;
    } else {
      /* Switch: '<S1164>/Switch' incorporates:
       *  Constant: '<S1155>/Constant'
       *  RelationalOperator: '<S1155>/Compare'
       */
      HMICtl_bLeftSetLow = (HMICtl_sLeftSetPoint == 16.0F);
    }

    /* End of Switch: '<S1164>/Switch' */

    /* Switch: '<S1163>/Switch' incorporates:
     *  Constant: '<S1163>/Constant1'
     */
    if (cal_bLeftSetHighEnb) {
      /* Switch: '<S1163>/Switch' incorporates:
       *  Constant: '<S1163>/Constant'
       */
      HMICtl_bLeftSetHigh = cal_bLeftSetHighData;
    } else {
      /* Switch: '<S1163>/Switch' incorporates:
       *  Constant: '<S1156>/Constant'
       *  RelationalOperator: '<S1156>/Compare'
       */
      HMICtl_bLeftSetHigh = (HMICtl_sLeftSetPoint == 32.0F);
    }

    /* End of Switch: '<S1163>/Switch' */

    /* Logic: '<S1115>/AND4' incorporates:
     *  Delay: '<S1115>/Delay1'
     *  Logic: '<S1115>/AND3'
     *  RelationalOperator: '<S1139>/Compare'
     */
    rtb_FixPtRelationalOperator_i1 = (HMICtl_bLeftSetLow ||
      ((!ME11_ARID_DEF.Delay1_DSTATE_ez) && HMICtl_bLeftSetHigh));

    /* Switch: '<S1115>/Switch5' */
    if (rtb_FixPtRelationalOperator_i1) {
      /* Switch: '<S1115>/Switch5' incorporates:
       *  Constant: '<S1115>/Constant2'
       */
      rtb_Switch1_l2 = 0U;
    } else {
      /* Switch: '<S1115>/Switch5' incorporates:
       *  Inport: '<Root>/IPM_HU_B_BAC'
       */
      rtb_Switch1_l2 = (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
        ->VIPM_HUAirInletModeSet_enum;
    }

    /* End of Switch: '<S1115>/Switch5' */

    /* Chart: '<S1115>/Chart' incorporates:
     *  DataStoreRead: '<S1115>/Data Store Read1'
     *  Delay: '<S1115>/Delay'
     */
    if (ME11_ARID_DEF.temporalCounter_i1_l4 < 15U) {
      ME11_ARID_DEF.temporalCounter_i1_l4++;
    }

    if (ME11_ARID_DEF.is_active_c128_ME11 == 0U) {
      ME11_ARID_DEF.is_active_c128_ME11 = 1U;
      ME11_ARID_DEF.is_c128_ME11 = ME11_IN_Init_i;
      ME11_ARID_DEF.temporalCounter_i1_l4 = 0U;
      ME11_ARID_DEF.Result = ME11_ARID_DEF.EERead_CabinRecDoor;
    } else if (ME11_ARID_DEF.is_c128_ME11 == ME11_IN_Init_i) {
      if (ME11_ARID_DEF.temporalCounter_i1_l4 >= 10) {
        ME11_ARID_DEF.is_c128_ME11 = ME11_IN_Normal_k;
      } else {
        ME11_ARID_DEF.Result = ME11_ARID_DEF.EERead_CabinRecDoor;
      }
    } else {
      /* case IN_Normal: */
      ME11_ARID_DEF.Result = ME11_ARID_DEF.Delay_DSTATE_f;
    }

    /* End of Chart: '<S1115>/Chart' */

    /* Switch: '<S1115>/Switch' incorporates:
     *  Constant: '<S1135>/Constant'
     *  Constant: '<S1136>/Constant'
     *  Constant: '<S1137>/Constant'
     *  Logic: '<S1115>/AND'
     *  Logic: '<S1115>/AND1'
     *  Logic: '<S1115>/AND2'
     *  RelationalOperator: '<S1135>/Compare'
     *  RelationalOperator: '<S1136>/Compare'
     *  RelationalOperator: '<S1137>/Compare'
     *  RelationalOperator: '<S1140>/FixPt Relational Operator'
     *  RelationalOperator: '<S1141>/FixPt Relational Operator'
     *  RelationalOperator: '<S1142>/FixPt Relational Operator'
     *  Switch: '<S1115>/Switch1'
     *  Switch: '<S1115>/Switch2'
     *  UnitDelay: '<S1140>/Delay Input1'
     *  UnitDelay: '<S1141>/Delay Input1'
     *  UnitDelay: '<S1142>/Delay Input1'
     *
     * Block description for '<S1140>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1141>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1142>/Delay Input1':
     *
     *  Store in Global RAM
     */
    if ((rtb_Switch1_l2 == 2) && (rtb_Switch1_l2 !=
         ME11_ARID_DEF.DelayInput1_DSTATE_nu)) {
      /* Switch: '<S1115>/Switch' */
      ME11_ARID_DEF.Delay_DSTATE_f = 2U;
    } else if ((rtb_Switch1_l2 == 1) && (rtb_Switch1_l2 !=
                ME11_ARID_DEF.DelayInput1_DSTATE_dl)) {
      /* Switch: '<S1115>/Switch1' incorporates:
       *  Switch: '<S1115>/Switch'
       */
      ME11_ARID_DEF.Delay_DSTATE_f = 1U;
    } else if ((rtb_Switch1_l2 == 3) && (rtb_Switch1_l2 !=
                ME11_ARID_DEF.DelayInput1_DSTATE_p3)) {
      /* Switch: '<S1115>/Switch2' incorporates:
       *  Switch: '<S1115>/Switch'
       *  Switch: '<S1115>/Switch1'
       */
      ME11_ARID_DEF.Delay_DSTATE_f = 3U;
    } else {
      /* Switch: '<S1115>/Switch' incorporates:
       *  Switch: '<S1115>/Switch1'
       *  Switch: '<S1115>/Switch2'
       */
      ME11_ARID_DEF.Delay_DSTATE_f = ME11_ARID_DEF.Result;
    }

    /* End of Switch: '<S1115>/Switch' */

    /* Switch: '<S1115>/Switch7' incorporates:
     *  Constant: '<S1115>/Constant6'
     *  Delay: '<S1115>/Delay'
     *  Logic: '<S1115>/AND5'
     *  Switch: '<S1115>/Switch3'
     *  Switch: '<S1115>/Switch6'
     */
    if (rtb_FixPtRelationalOperator_i1 || HMICtl_bACAuto) {
      ME11_ARID_DEF.Delay_DSTATE_f = 1U;
    } else if (rtb_FixPtRelationalOperator_mk) {
      /* Switch: '<S1115>/Switch4' incorporates:
       *  Constant: '<S1138>/Constant'
       *  RelationalOperator: '<S1138>/Compare'
       *  Switch: '<S1115>/Switch3'
       */
      if (ME11_ARID_DEF.Delay_DSTATE_f == 2) {
        /* Delay: '<S1115>/Delay' incorporates:
         *  Constant: '<S1115>/Constant'
         *  Switch: '<S1115>/Switch3'
         */
        ME11_ARID_DEF.Delay_DSTATE_f = 1U;
      } else {
        /* Delay: '<S1115>/Delay' incorporates:
         *  Constant: '<S1115>/Constant1'
         *  Switch: '<S1115>/Switch3'
         */
        ME11_ARID_DEF.Delay_DSTATE_f = 2U;
      }

      /* End of Switch: '<S1115>/Switch4' */
    }

    /* End of Switch: '<S1115>/Switch7' */

    /* Switch: '<S1145>/Switch' incorporates:
     *  Constant: '<S1145>/Constant1'
     *  Delay: '<S1115>/Delay1'
     *  Switch: '<S1115>/Switch8'
     */
    if (cal_eInnerEnb) {
      /* Switch: '<S1145>/Switch' incorporates:
       *  Constant: '<S1145>/Constant'
       */
      HMICtl_eInner = cal_eInnerData;
    } else {
      if (ME11_ARID_DEF.Delay1_DSTATE_ez) {
        /* Switch: '<S1115>/Switch8' incorporates:
         *  Constant: '<S1115>/Constant7'
         */
        HMICtl_eInner = 2U;
      } else {
        /* Switch: '<S1115>/Switch8' incorporates:
         *  Delay: '<S1115>/Delay'
         */
        HMICtl_eInner = ME11_ARID_DEF.Delay_DSTATE_f;
      }

      /* Switch: '<S1146>/Switch2' incorporates:
       *  Constant: '<S1115>/Constant4'
       *  Constant: '<S1115>/Constant5'
       *  RelationalOperator: '<S1146>/LowerRelop1'
       *  RelationalOperator: '<S1146>/UpperRelop'
       *  Switch: '<S1146>/Switch'
       */
      if (HMICtl_eInner > 3) {
        /* Switch: '<S1145>/Switch' incorporates:
         *  Switch: '<S1146>/Switch2'
         */
        HMICtl_eInner = 3U;
      } else if (HMICtl_eInner < 1) {
        /* Switch: '<S1146>/Switch' incorporates:
         *  Constant: '<S1115>/Constant4'
         *  Switch: '<S1145>/Switch'
         *  Switch: '<S1146>/Switch2'
         */
        HMICtl_eInner = 1U;
      }

      /* End of Switch: '<S1146>/Switch2' */
    }

    /* End of Switch: '<S1145>/Switch' */

    /* DataStoreWrite: '<S1115>/Data Store Write' */
    ME11_ARID_DEF.EEWrite_CabinRecDoor = HMICtl_eInner;

    /* DataStoreWrite: '<S1117>/Data Store Write' incorporates:
     *  Delay: '<S1117>/Delay1'
     */
    ME11_ARID_DEF.EEWrite_CabinModeDoor = ME11_ARID_DEF.Delay1_DSTATE_es;

    /* DataStoreWrite: '<S1119>/Data Store Write' */
    ME11_ARID_DEF.EEWrite_CabinSetTemp = ME11_ARID_DEF.Fb;

    /* DataTypeConversion: '<S1167>/Data Type Conversion1' incorporates:
     *  DataStoreWrite: '<S1167>/Data Store Write2'
     *  Delay: '<S1167>/Delay'
     */
    ME11_ARID_DEF.EEWrite_bACAutoSts = ME11_ARID_DEF.Delay_DSTATE_ly;

    /* RelationalOperator: '<S1204>/FixPt Relational Operator' incorporates:
     *  Delay: '<S1120>/Delay1'
     *  UnitDelay: '<S1204>/Delay Input1'
     *
     * Block description for '<S1204>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_FixPtRelationalOperator_mk = ((sint32)ME11_ARID_DEF.Delay1_DSTATE_c1 >
      (sint32)ME11_ARID_DEF.DelayInput1_DSTATE_ovb);

    /* RelationalOperator: '<S1205>/FixPt Relational Operator' incorporates:
     *  UnitDelay: '<S1205>/Delay Input1'
     *
     * Block description for '<S1205>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_FixPtRelationalOperator_i1 = ((sint32)HMICtl_bACDefrost > (sint32)
      ME11_ARID_DEF.DelayInput1_DSTATE_in);

    /* UnitDelay: '<S1206>/Delay Input1' incorporates:
     *  UnitDelay: '<S1126>/Delay Input1'
     *
     * Block description for '<S1206>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_di = ME11_ARID_DEF.DelayInput1_DSTATE_b;

    /* RelationalOperator: '<S1206>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *  UnitDelay: '<S1126>/Delay Input1'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx =
      ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
       ->VIPM_HUHybEcoModeSet_enum > ME11_ARID_DEF.DelayInput1_DSTATE_di);

    /* RelationalOperator: '<S1198>/Compare' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *  UnitDelay: '<S1127>/Delay Input1'
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_hg =
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPModeKey_flg;

    /* Logic: '<S1169>/AND1' incorporates:
     *  UnitDelay: '<S1127>/Delay Input1'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_Compare_mgx = (ME11_ARID_DEF.DelayInput1_DSTATE_bx ||
                       ME11_ARID_DEF.DelayInput1_DSTATE_hg);

    /* UnitDelay: '<S1207>/Delay Input1' incorporates:
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1207>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx = ME11_ARID_DEF.DelayInput1_DSTATE_ey;

    /* RelationalOperator: '<S1207>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx = ((sint32)
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPTempAddKey_flg > (sint32)ME11_ARID_DEF.DelayInput1_DSTATE_bx);

    /* UnitDelay: '<S1208>/Delay Input1' incorporates:
     *  UnitDelay: '<S1127>/Delay Input1'
     *
     * Block description for '<S1208>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_hg = ME11_ARID_DEF.DelayInput1_DSTATE_jm;

    /* RelationalOperator: '<S1208>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *  UnitDelay: '<S1127>/Delay Input1'
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_hg = ((sint32)
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPTempDecKey_flg > (sint32)ME11_ARID_DEF.DelayInput1_DSTATE_hg);

    /* Logic: '<S1169>/AND2' incorporates:
     *  RelationalOperator: '<S1202>/FixPt Relational Operator'
     *  UnitDelay: '<S1127>/Delay Input1'
     *  UnitDelay: '<S1128>/Delay Input1'
     *  UnitDelay: '<S1202>/Delay Input1'
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1202>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_AND2_of = ((HU_LeftTempSet != ME11_ARID_DEF.DelayInput1_DSTATE_nm) ||
                   ME11_ARID_DEF.DelayInput1_DSTATE_bx ||
                   ME11_ARID_DEF.DelayInput1_DSTATE_hg);

    /* UnitDelay: '<S1200>/Delay Input1' incorporates:
     *  UnitDelay: '<S1126>/Delay Input1'
     *
     * Block description for '<S1200>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_di = ME11_ARID_DEF.DelayInput1_DSTATE_fm;

    /* RelationalOperator: '<S1200>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *  UnitDelay: '<S1126>/Delay Input1'
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_FixPtRelationalOperator_a0 =
      ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())->VIPM_HUACPwrCtl_enum
       != ME11_ARID_DEF.DelayInput1_DSTATE_di);

    /* UnitDelay: '<S1203>/Delay Input1' incorporates:
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1203>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx = ME11_ARID_DEF.DelayInput1_DSTATE_id;

    /* RelationalOperator: '<S1203>/FixPt Relational Operator' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_FixPtRelationalOperator_fk = ((sint32)
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPACSwKey_flg > (sint32)ME11_ARID_DEF.DelayInput1_DSTATE_bx);

    /* Chart: '<S1169>/DealWith' incorporates:
     *  DataStoreRead: '<S1169>/Data Store Read'
     *  Inport: '<Root>/IPM_HU_B_BAC'
     */
    if (ME11_ARID_DEF.is_active_c101_ME11 == 0U) {
      ME11_ARID_DEF.is_active_c101_ME11 = 1U;
      ME11_ARID_DEF.is_c101_ME11 = ME11_IN_Init_i;
      ME11_ARID_DEF.HMICtl_bACOnOff_e = ME11_ARID_DEF.EERead_bACOnOff;
    } else {
      switch (ME11_ARID_DEF.is_c101_ME11) {
       case ME11_IN_Init_i:
        if (((rtb_FixPtRelationalOperator_a0 &&
              ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
               ->VIPM_HUACPwrCtl_enum == 1)) || rtb_FixPtRelationalOperator_fk) &&
            ME11_ARID_DEF.HMICtl_bACOnOff_e) {
          ME11_ARID_DEF.is_c101_ME11 = ME11_IN_Off_l;
          ME11_ARID_DEF.HMICtl_bACOnOff_e = false;
        } else if ((((rtb_FixPtRelationalOperator_a0 &&
                      ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
                       ->VIPM_HUACPwrCtl_enum == 2)) ||
                     rtb_FixPtRelationalOperator_fk) &&
                    (!ME11_ARID_DEF.HMICtl_bACOnOff_e)) ||
                   (rtb_FixPtRelationalOperator_i1 ||
                    rtb_FixPtRelationalOperator_mk || rtb_Compare_mgx ||
                    rtb_AND2_of || rtb_AND1_hh)) {
          ME11_ARID_DEF.is_c101_ME11 = ME11_IN_On_kf;
          ME11_ARID_DEF.HMICtl_bACOnOff_e = true;
        } else {
          ME11_ARID_DEF.HMICtl_bACOnOff_e = ME11_ARID_DEF.EERead_bACOnOff;
        }
        break;

       case ME11_IN_Off_l:
        if ((((rtb_FixPtRelationalOperator_a0 &&
               ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
                ->VIPM_HUACPwrCtl_enum == 2)) || rtb_FixPtRelationalOperator_fk)
             && (!ME11_ARID_DEF.HMICtl_bACOnOff_e)) ||
            (rtb_FixPtRelationalOperator_i1 || rtb_FixPtRelationalOperator_mk ||
             rtb_Compare_mgx || rtb_AND2_of || rtb_AND1_hh)) {
          ME11_ARID_DEF.is_c101_ME11 = ME11_IN_On_kf;
          ME11_ARID_DEF.HMICtl_bACOnOff_e = true;
        }
        break;

       default:
        /* case IN_On: */
        if (((rtb_FixPtRelationalOperator_a0 &&
              ((Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
               ->VIPM_HUACPwrCtl_enum == 1)) || rtb_FixPtRelationalOperator_fk) &&
            ME11_ARID_DEF.HMICtl_bACOnOff_e) {
          ME11_ARID_DEF.is_c101_ME11 = ME11_IN_Off_l;
          ME11_ARID_DEF.HMICtl_bACOnOff_e = false;
        }
        break;
      }
    }

    /* End of Chart: '<S1169>/DealWith' */

    /* Switch: '<S1209>/Switch' incorporates:
     *  Constant: '<S1209>/Constant1'
     */
    if (cal_bACOnOffEnb) {
      /* Switch: '<S1209>/Switch' incorporates:
       *  Constant: '<S1209>/Constant'
       */
      HMICtl_bACOnOff = cal_bACOnOffData;
    } else {
      /* Switch: '<S1209>/Switch' */
      HMICtl_bACOnOff = ME11_ARID_DEF.HMICtl_bACOnOff_e;
    }

    /* End of Switch: '<S1209>/Switch' */

    /* DataTypeConversion: '<S1169>/Data Type Conversion' incorporates:
     *  DataStoreWrite: '<S1169>/Data Store Write'
     */
    ME11_ARID_DEF.EEWrite_bACOnOff = HMICtl_bACOnOff;

    /* Switch: '<S1169>/Switch' */
    ME11_ARID_DEF.Switch_c = (PWRCtl_bKL15swtSt && HMICtl_bACOnOff);

    /* DataStoreWrite: '<S1170>/Data Store Write' */
    ME11_ARID_DEF.EEWrite_CabinMode = HMICtl_eACSts;

    /* CCaller: '<S1170>/C Caller1' incorporates:
     *  Constant: '<S1170>/Constant5'
     */
    Rte_DIDReadData(HMICtl_eACSts, ((uint8)DID_0xF273));

    /* RelationalOperator: '<S1106>/Compare' incorporates:
     *  Constant: '<S1106>/Constant'
     *  Inport: '<Root>/Vcu2BcmTms_outputs'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx =
      ((Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs())
       ->VGSM_VehActGearPstn_enum == 0);

    /* Logic: '<S12>/AND2' incorporates:
     *  Constant: '<S1107>/Constant'
     *  Constant: '<S1108>/Constant'
     *  Constant: '<S1109>/Constant'
     *  Constant: '<S1110>/Constant'
     *  Delay: '<S1105>/Delay'
     *  RelationalOperator: '<S1107>/Compare'
     *  RelationalOperator: '<S1108>/Compare'
     *  RelationalOperator: '<S1109>/Compare'
     *  RelationalOperator: '<S1110>/Compare'
     *  RelationalOperator: '<S1113>/Compare'
     *  RelationalOperator: '<S1114>/Compare'
     *  UnitDelay: '<S1128>/Delay Input1'
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ACCtl_bExhaustFlg = (HMICtl_bLeftSetHigh && (ME11_ARID_DEF.Delay_DSTATE_oz ==
      5) && (HMICtl_eACSts == 3) && (HMICtl_eInner == 1) && (HMICtl_eModeMotor ==
      1) && ME11_ARID_DEF.DelayInput1_DSTATE_bx && (!HMICtl_bACDefrost) &&
                         (!ME11_ARID_DEF.Switch_c));

    /* RelationalOperator: '<S1112>/Compare' incorporates:
     *  Constant: '<S1112>/Constant'
     */
    rtb_AND1_hh = (ME11_ARID_DEF.DataTypeConversion1 == 0);

    /* Chart: '<S12>/exhaust' incorporates:
     *  Constant: '<S1111>/Constant'
     *  Constant: '<S12>/Constant7'
     *  RelationalOperator: '<S1111>/Compare'
     */
    if (ME11_ARID_DEF.temporalCounter_i1_i < 1048575U) {
      ME11_ARID_DEF.temporalCounter_i1_i++;
    }

    if (ME11_ARID_DEF.is_active_c148_ME11 == 0U) {
      ME11_ARID_DEF.is_active_c148_ME11 = 1U;
      ME11_ARID_DEF.is_c148_ME11 = ME11_IN_Init_i;
      ACCtl_bExhFlg = false;
    } else {
      switch (ME11_ARID_DEF.is_c148_ME11) {
       case ME11_IN_Init_i:
        ACCtl_bExhFlg = false;
        if (ACCtl_bExhaustFlg && (ME11_ARID_DEF.DataTypeConversion1 >= 2)) {
          ME11_ARID_DEF.is_c148_ME11 = ME11_IN_On_kf;
          ME11_ARID_DEF.temporalCounter_i1_i = 0U;
          ACCtl_bExhFlg = true;
        }
        break;

       case ME11_IN_Off_l:
        ACCtl_bExhFlg = false;
        if (rtb_AND1_hh) {
          ME11_ARID_DEF.is_c148_ME11 = ME11_IN_Init_i;
        }
        break;

       default:
        /* case IN_On: */
        ACCtl_bExhFlg = true;
        if (ME11_ARID_DEF.temporalCounter_i1_i >= (uint32)(cal_ExhaustTime * 10))
        {
          ME11_ARID_DEF.is_c148_ME11 = ME11_IN_Off_l;
          ACCtl_bExhFlg = false;
        } else if (rtb_AND1_hh) {
          ME11_ARID_DEF.is_c148_ME11 = ME11_IN_Init_i;
          ACCtl_bExhFlg = false;
        }
        break;
      }
    }

    /* End of Chart: '<S12>/exhaust' */

    /* Switch: '<S1118>/Switch' incorporates:
     *  Constant: '<S1118>/Constant1'
     */
    if (cal_bExhFlgEnb) {
      /* Switch: '<S1118>/Switch' incorporates:
       *  Constant: '<S1118>/Constant'
       */
      ACCtl_bExhFlg = cal_bExhFlgData;
    }

    /* End of Switch: '<S1118>/Switch' */

    /* Switch: '<S12>/Switch1' incorporates:
     *  Switch: '<S12>/Switch2'
     *  Switch: '<S12>/Switch3'
     */
    if (HMICtl_bACDefrost) {
      /* Switch: '<S12>/Switch1' incorporates:
       *  Constant: '<S12>/Constant2'
       */
      ME11_ARID_DEF.Switch1_nv = 15U;
    } else if (HMICtl_bACAuto) {
      /* Switch: '<S12>/Switch2' incorporates:
       *  Constant: '<S12>/Constant3'
       *  Switch: '<S12>/Switch1'
       */
      ME11_ARID_DEF.Switch1_nv = 7U;
    } else if (ME11_ARID_DEF.Switch_c) {
      /* Switch: '<S12>/Switch3' incorporates:
       *  Constant: '<S12>/Constant4'
       *  Switch: '<S12>/Switch1'
       *  Switch: '<S12>/Switch2'
       */
      ME11_ARID_DEF.Switch1_nv = 0U;
    } else {
      /* Switch: '<S12>/Switch1' incorporates:
       *  Constant: '<S12>/Constant5'
       *  Switch: '<S12>/Switch2'
       *  Switch: '<S12>/Switch3'
       */
      ME11_ARID_DEF.Switch1_nv = 8U;
    }

    /* End of Switch: '<S12>/Switch1' */

    /* Switch: '<S1147>/Switch' incorporates:
     *  Constant: '<S1147>/Constant1'
     */
    if (cal_sMixDoorEnb) {
      /* Switch: '<S1147>/Switch' incorporates:
       *  Constant: '<S1147>/Constant'
       */
      HMICtl_sMixDoor = cal_sMixDoorData;
    } else {
      /* Switch: '<S1147>/Switch' */
      HMICtl_sMixDoor = 0.0F;
    }

    /* End of Switch: '<S1147>/Switch' */

    /* SignalConversion generated from: '<S12>/HMICtl_bPTCOnReq' */
    ME11_ARID_DEF.OutportBufferForHMICtl_bPTCOnReq = false;

    /* Update for Delay: '<S12>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_ot = HMICtl_bACDefrost;

    /* Update for UnitDelay: '<S1162>/Delay Input1'
     *
     * Block description for '<S1162>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_jg = rtb_Delay_mz3;

    /* Update for UnitDelay: '<S1159>/Delay Input1'
     *
     * Block description for '<S1159>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_d1 = HU_LeftTempSet;

    /* Update for UnitDelay: '<S1158>/Delay Input1'
     *
     * Block description for '<S1158>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_kr = rtb_AND_b3z;

    /* Update for UnitDelay: '<S1160>/Delay Input1'
     *
     * Block description for '<S1160>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_gt = ME11_ARID_DEF.Fb;

    /* Update for UnitDelay: '<S1161>/Delay Input1'
     *
     * Block description for '<S1161>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_f0 = rtb_Delay_mz3;

    /* Update for UnitDelay: '<S1190>/Delay Input1'
     *
     * Block description for '<S1190>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_l = rtb_Switch2_ip;

    /* Update for Delay: '<S1168>/Delay1' */
    ME11_ARID_DEF.Delay1_DSTATE_d = HMICtl_sLeftSetPoint;

    /* Update for UnitDelay: '<S1193>/Delay Input1'
     *
     * Block description for '<S1193>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_or = rtb_Delay1_ie;

    /* Update for UnitDelay: '<S1126>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1126>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_di =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUFrntFanSpdSet_enum;

    /* Update for UnitDelay: '<S1127>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *
     * Block description for '<S1127>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_hg =
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPBlwrLvlAddKey_flg;

    /* Update for UnitDelay: '<S1128>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *
     * Block description for '<S1128>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_bx =
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPBlwrLvlDecKey_flg;

    /* Update for UnitDelay: '<S1144>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1144>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_iv =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUAirInletModeSet_enum;

    /* Update for UnitDelay: '<S1143>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *
     * Block description for '<S1143>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_br =
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPAirInletModeKey_flg;

    /* Update for UnitDelay: '<S1191>/Delay Input1'
     *
     * Block description for '<S1191>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_jx = FixPtRelationalOperator;

    /* Update for Delay: '<S1120>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_by = ME11_ARID_DEF.Switch_c;

    /* Update for UnitDelay: '<S1194>/Delay Input1'
     *
     * Block description for '<S1194>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_c = rtb_Delay_j3;

    /* Update for Delay: '<S1120>/Delay1' */
    ME11_ARID_DEF.Delay1_DSTATE_c1 = HMICtl_bACAuto;

    /* Update for UnitDelay: '<S1196>/Delay Input1'
     *
     * Block description for '<S1196>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_fq = rtb_Delay1_ag;

    /* Update for UnitDelay: '<S1150>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1150>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_op =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUBlwrModeSet_enum;

    /* Update for UnitDelay: '<S1192>/Delay Input1'
     *
     * Block description for '<S1192>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_gr = HMICtl_eModeMotor;

    /* Update for UnitDelay: '<S1188>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1188>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_ov =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUManlDefrstCtl_enum;

    /* Update for UnitDelay: '<S1189>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1189>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_ie =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUManlDefrstCtl_enum;

    /* Update for UnitDelay: '<S1195>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *
     * Block description for '<S1195>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_jd =
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPFrntWindDefrstKey_flg;

    /* Update for UnitDelay: '<S1219>/Delay Input1'
     *
     * Block description for '<S1219>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_dz = HMICtl_bACDefrost;

    /* Update for UnitDelay: '<S1220>/Delay Input1'
     *
     * Block description for '<S1220>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_a = rtb_Delay1_ag;

    /* Update for UnitDelay: '<S1215>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1215>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_k =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUHybEcoModeSet_enum;

    /* Update for UnitDelay: '<S1216>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1216>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_gy =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUHybEcoModeSet_enum;

    /* Update for UnitDelay: '<S1217>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1217>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_p =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUHybEcoModeSet_enum;

    /* Update for UnitDelay: '<S1218>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *
     * Block description for '<S1218>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_os =
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPModeKey_flg;

    /* Update for UnitDelay: '<S1181>/Delay Input1'
     *
     * Block description for '<S1181>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_m1 = FixPtRelationalOperator;

    /* Update for UnitDelay: '<S1179>/Delay Input1'
     *
     * Block description for '<S1179>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_n = HMICtl_eACSts;

    /* Update for UnitDelay: '<S1180>/Delay Input1'
     *
     * Block description for '<S1180>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_m = HMICtl_eModeMotor;

    /* Update for UnitDelay: '<S1177>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1177>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_hx =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())->VIPM_HUACAutoCtl_enum;

    /* Update for UnitDelay: '<S1178>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1178>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_kw =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())->VIPM_HUACAutoCtl_enum;

    /* Update for UnitDelay: '<S1182>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *
     * Block description for '<S1182>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_h2 =
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPACAutoKey_flg;

    /* Update for UnitDelay: '<S1125>/Delay Input1'
     *
     * Block description for '<S1125>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_go = HMICtl_bACAuto;

    /* Update for UnitDelay: '<S1124>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1124>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_f =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUFrntFanSpdSet_enum;

    /* Update for Delay: '<S12>/Delay2' */
    ME11_ARID_DEF.Delay2_DSTATE_pb = ME11_ARID_DEF.Switch_c;

    /* Update for Delay: '<S1115>/Delay1' */
    ME11_ARID_DEF.Delay1_DSTATE_ez = HMICtl_bACDefrost;

    /* Update for UnitDelay: '<S1140>/Delay Input1'
     *
     * Block description for '<S1140>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_nu = rtb_Switch1_l2;

    /* Update for UnitDelay: '<S1141>/Delay Input1'
     *
     * Block description for '<S1141>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_dl = rtb_Switch1_l2;

    /* Update for UnitDelay: '<S1142>/Delay Input1'
     *
     * Block description for '<S1142>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_p3 = rtb_Switch1_l2;

    /* Update for UnitDelay: '<S1204>/Delay Input1'
     *
     * Block description for '<S1204>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_ovb = rtb_Delay1_ag;

    /* Update for UnitDelay: '<S1205>/Delay Input1'
     *
     * Block description for '<S1205>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_in = HMICtl_bACDefrost;

    /* Update for UnitDelay: '<S1206>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1206>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_b =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())
      ->VIPM_HUHybEcoModeSet_enum;

    /* Update for UnitDelay: '<S1202>/Delay Input1'
     *
     * Block description for '<S1202>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_nm = HU_LeftTempSet;

    /* Update for UnitDelay: '<S1207>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *
     * Block description for '<S1207>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_ey =
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPTempAddKey_flg;

    /* Update for UnitDelay: '<S1208>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *
     * Block description for '<S1208>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_jm =
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPTempDecKey_flg;

    /* Update for UnitDelay: '<S1200>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_HU_B_BAC'
     *
     * Block description for '<S1200>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_fm =
      (Rte_IRead_Task_100ms_IPM_HU_B_BAC_IPM_HU_B_BAC())->VIPM_HUACPwrCtl_enum;

    /* Update for UnitDelay: '<S1203>/Delay Input1' incorporates:
     *  Inport: '<Root>/IPM_CCP_PanelStatus_BOD'
     *
     * Block description for '<S1203>/Delay Input1':
     *
     *  Store in Global RAM
     */
    ME11_ARID_DEF.DelayInput1_DSTATE_id =
      (Rte_IRead_Task_100ms_IPM_CCP_PanelStatus_BOD_IPM_CCP_PanelStatus_BOD())
      ->VIPM_CCPACSwKey_flg;
  } else if (ME11_ARID_DEF.HMI_MODE) {
    /* Disable for Switch: '<S1183>/Switch' incorporates:
     *  Outport: '<S12>/HMICtl_bACAuto'
     *
     * Block description for '<S12>/HMICtl_bACAuto':
     *  AC_stAutoFun
     *  0   
     *  7  
     *  8  
     *  15 
     */
    HMICtl_bACAuto = false;

    /* Disable for Switch: '<S1169>/Switch' incorporates:
     *  Outport: '<S12>/HMICtl_bACOnOff'
     */
    ME11_ARID_DEF.Switch_c = false;

    /* Disable for Switch: '<S1197>/Switch' incorporates:
     *  Outport: '<S12>/HMICtl_bACDefrost'
     */
    HMICtl_bACDefrost = false;

    /* Disable for Switch: '<S1118>/Switch' incorporates:
     *  Outport: '<S12>/ACCtl_bExhFlg'
     */
    ACCtl_bExhFlg = false;
    ME11_ARID_DEF.HMI_MODE = false;
  }

  /* End of Logic: '<S2>/AND' */
  /* End of Outputs for SubSystem: '<S2>/HMI' */

  /* Switch: '<S185>/Switch2' incorporates:
   *  Constant: '<S185>/Constant3'
   *  Constant: '<S207>/Constant'
   *  RelationalOperator: '<S207>/Compare'
   */
  if (HMICtl_sLeftSetPoint == cal_DefaultSetTemp) {
    rtb_Add_ok = 0.0F;
  } else {
    rtb_Add_ok = cal_PsEnv4SetSelect;
  }

  /* Sum: '<S185>/Sum3' incorporates:
   *  Switch: '<S185>/Switch2'
   */
  ACCtl_tRightSetPointModeCor = rtb_Add_ok + HMICtl_sLeftSetPoint;

  /* Switch: '<S4>/Switch' incorporates:
   *  Constant: '<S36>/Constant'
   *  RelationalOperator: '<S36>/Compare'
   */
  if (HMICtl_eACSts == 0) {
    /* DataTypeConversion: '<S4>/Data Type Conversion' incorporates:
     *  Constant: '<S4>/Constant'
     */
    rtb_DataTypeConversion_f = 2U;
  } else {
    /* DataTypeConversion: '<S4>/Data Type Conversion' incorporates:
     *  Constant: '<S4>/Constant1'
     *  Sum: '<S4>/Add'
     */
    rtb_DataTypeConversion_f = (uint8)(HMICtl_eACSts - 1);
  }

  /* End of Switch: '<S4>/Switch' */

  /* Delay: '<S1081>/Delay' */
  rtb_Delay = ME11_ARID_DEF.Delay_DSTATE;

  /* CCaller: '<S1074>/C Caller' */
  SENCtl_uEnvVoltage = get_EnvValtage();

  /* Sum: '<S1074>/Add' incorporates:
   *  CCaller: '<S1074>/C Caller'
   *  DataTypeConversion: '<S1074>/Data Type Conversion1'
   *  Lookup_n-D: '<S1074>/cal_EnvVolAmend_CUR'
   */
  rtb_Delay1_ie = (float32)((sint16)SENCtl_uEnvVoltage -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uEnvVoltage, (const uint16 *)
    &cal_EnvVolAmend_1X[0], (const sint16 *)&cal_EnvVolAmend_CUR[0], 1U));

  /* Outputs for Atomic SubSystem: '<S1074>/Env' */
  /* Sum: '<S1089>/Add' incorporates:
   *  Constant: '<S1074>/Constant2'
   */
  rtb_Add_ok = cal_ADCVCCVal - rtb_Delay1_ie;

  /* Chart: '<S1093>/Judge' incorporates:
   *  Constant: '<S1089>/Constant1'
   *  Constant: '<S1093>/Constant'
   *  Constant: '<S1093>/Constant1'
   *  RelationalOperator: '<S1093>/Relational Operator'
   *  RelationalOperator: '<S1093>/Relational Operator1'
   */
  ME11_Judge(rtb_Delay1_ie > cal_SensorTempUpFlt, rtb_Delay1_ie <
             cal_SensorTempDownFlg, 20, &ME11_ARID_DEF.SenSts_a,
             &ME11_ARID_DEF.ARID_DEF_Judge_n);

  /* DataTypeConversion: '<S1089>/Data Type Conversion' */
  ACSen_eEnvSenSts = ME11_ARID_DEF.SenSts_a;

  /* Switch: '<S1089>/Switch' incorporates:
   *  Constant: '<S1092>/Constant'
   *  RelationalOperator: '<S1092>/Compare'
   */
  if (rtb_Add_ok > 0.0F) {
    /* Gain: '<S8>/Gain6' incorporates:
     *  Product: '<S1089>/Divide'
     */
    rtb_Gain6 = rtb_Delay1_ie / rtb_Add_ok;
  } else {
    /* Gain: '<S8>/Gain6' incorporates:
     *  Constant: '<S1089>/Constant'
     */
    rtb_Gain6 = 1.0F;
  }

  /* End of Switch: '<S1089>/Switch' */

  /* Lookup_n-D: '<S1074>/cal_TEnvRaw_CUR' incorporates:
   *  Constant: '<S1074>/Constant3'
   *  Product: '<S1089>/Divide1'
   */
  SEN_TEnvRaw = look1_iflf_binlca(rtb_Gain6 * 5.1F, (const float32 *)
    &cal_TEnvRaw_1X[0], (const float32 *)&cal_TEnvRaw_CUR[0], 26U);

  /* End of Outputs for SubSystem: '<S1074>/Env' */

  /* Switch: '<S1097>/Init' incorporates:
   *  Constant: '<S1074>/Constant1'
   *  Product: '<S1091>/Product'
   *  Product: '<S1091>/Product1'
   *  Sum: '<S1091>/Sum1'
   *  UnitDelay: '<S1097>/FixPt Unit Delay1'
   *  UnitDelay: '<S1097>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_l != 0) {
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_h = SEN_TEnvRaw;
  }

  ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_h = SEN_TEnvRaw * 0.9F +
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_h * 0.100000024F;

  /* End of Switch: '<S1097>/Init' */

  /* Chart: '<S1095>/median' incorporates:
   *  Constant: '<S1090>/Constant'
   *  UnitDelay: '<S1097>/FixPt Unit Delay1'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_g < 1U) {
    ME11_ARID_DEF.temporalCounter_i1_g++;
  }

  if (ME11_ARID_DEF.is_active_c4_ME11Lib == 0U) {
    ME11_ARID_DEF.is_active_c4_ME11Lib = 1U;
    ME11_ARID_DEF.is_c4_ME11Lib = ME11_IN_init;
    ME11_ARID_DEF.temporalCounter_i1_g = 0U;
    ME11_ARID_DEF.even = 2.0F;

    /*  init  */
    ME11_ARID_DEF.i = 0U;
    while (ME11_ARID_DEF.i < 5) {
      ME11_ARID_DEF.y[ME11_ARID_DEF.i] = ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_h;
      b_previousEvent = ME11_ARID_DEF.i + 1;
      if (ME11_ARID_DEF.i + 1 > 255) {
        b_previousEvent = 255;
      }

      ME11_ARID_DEF.i = (uint8)b_previousEvent;
    }
  } else {
    switch (ME11_ARID_DEF.is_c4_ME11Lib) {
     case ME11_IN_GetData:
      if (ME11_ARID_DEF.i >= 5) {
        ME11_ARID_DEF.is_c4_ME11Lib = ME11_IN_Middle;

        /*    */
        ME11_ARID_DEF.i = 0U;
        while (ME11_ARID_DEF.i < 5) {
          for (b_previousEvent = 0; b_previousEvent < ME11_ARID_DEF.i;
               b_previousEvent++) {
            if (ME11_ARID_DEF.y[b_previousEvent] >
                ME11_ARID_DEF.y[b_previousEvent + 1]) {
              ME11_sart((float64)ME11_ARID_DEF.y[b_previousEvent], (float64)
                        ME11_ARID_DEF.y[b_previousEvent + 1], &a, &b);
              ME11_ARID_DEF.y[b_previousEvent] = (float32)a;
              ME11_ARID_DEF.y[b_previousEvent + 1] = (float32)b;
            }
          }

          b_previousEvent = ME11_ARID_DEF.i + 1;
          if (ME11_ARID_DEF.i + 1 > 255) {
            b_previousEvent = 255;
          }

          ME11_ARID_DEF.i = (uint8)b_previousEvent;
        }

        ME11_ARID_DEF.i = 0U;
        ME11_ARID_DEF.flag = 0.0;
      } else {
        ME11_ARID_DEF.y[ME11_ARID_DEF.i] =
          ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_h;
        b_previousEvent = ME11_ARID_DEF.i + 1;
        if (ME11_ARID_DEF.i + 1 > 255) {
          b_previousEvent = 255;
        }

        ME11_ARID_DEF.i = (uint8)b_previousEvent;
      }
      break;

     case ME11_IN_Middle:
      if (ME11_ARID_DEF.flag == 0.0) {
        ME11_ARID_DEF.is_c4_ME11Lib = ME11_IN_GetData;
        ME11_ARID_DEF.flag = 1.0;
        ME11_ARID_DEF.y[ME11_ARID_DEF.i] =
          ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_h;
        b_previousEvent = ME11_ARID_DEF.i + 1;
        if (ME11_ARID_DEF.i + 1 > 255) {
          b_previousEvent = 255;
        }

        ME11_ARID_DEF.i = (uint8)b_previousEvent;
      }
      break;

     default:
      /* case IN_init: */
      if (ME11_ARID_DEF.temporalCounter_i1_g >= 1) {
        ME11_ARID_DEF.i = 0U;
        ME11_ARID_DEF.is_c4_ME11Lib = ME11_IN_GetData;
        ME11_ARID_DEF.flag = 1.0;
        ME11_ARID_DEF.y[ME11_ARID_DEF.i] =
          ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_h;
        b_previousEvent = ME11_ARID_DEF.i + 1;
        if (ME11_ARID_DEF.i + 1 > 255) {
          b_previousEvent = 255;
        }

        ME11_ARID_DEF.i = (uint8)b_previousEvent;
      }
      break;
    }
  }

  /* End of Chart: '<S1095>/median' */

  /* Switch: '<S1095>/Switch' */
  if (ME11_ARID_DEF.even > 0.0F) {
    /* Switch: '<S1095>/Switch' incorporates:
     *  MultiPortSwitch: '<S1095>/Index Vector1'
     */
    ACSen_sEnvTempFilter = ME11_ARID_DEF.y[3];
  } else {
    /* Switch: '<S1095>/Switch' incorporates:
     *  MultiPortSwitch: '<S1095>/Index Vector8'
     */
    ACSen_sEnvTempFilter = ME11_ARID_DEF.y[2];
  }

  /* End of Switch: '<S1095>/Switch' */

  /* Switch: '<S1072>/Switch8' incorporates:
   *  Abs: '<S1072>/Abs'
   *  DataStoreRead: '<S11>/Data Store Read'
   *  Delay: '<S1072>/Delay'
   *  Sum: '<S1072>/Add'
   *  Switch: '<S1072>/Switch12'
   */
  if (ME11_ARID_DEF.Delay_DSTATE_px) {
    /* Gain: '<S8>/Gain8' */
    rtb_Delay1_ie = ACSen_sEnvTempFilter;
  } else {
    if ((float32)fabs(ACSen_sEnvTempFilter - ME11_ARID_DEF.EERead_AmbienceTemp) >
        cal_EEEnvAndEnvDiffVal) {
      /* Switch: '<S1072>/Switch12' */
      rtb_Delay1_ie = ACSen_sEnvTempFilter;
    } else {
      /* Switch: '<S1072>/Switch12' incorporates:
       *  DataStoreRead: '<S11>/Data Store Read'
       */
      rtb_Delay1_ie = ME11_ARID_DEF.EERead_AmbienceTemp;
    }

    /* Switch: '<S1072>/Switch4' incorporates:
     *  Constant: '<S1072>/AC_swtInCabinTempEquip_C1'
     *  Constant: '<S1072>/AC_swtInCabinTempEquip_C4'
     *  Logic: '<S1072>/Logical Operator'
     *  Logic: '<S1078>/FixPt Logical Operator'
     *  RelationalOperator: '<S1078>/Lower Test'
     *  RelationalOperator: '<S1078>/Upper Test'
     */
    if ((rtb_Delay1_ie < -40.0F) || (rtb_Delay1_ie > 80.0F)) {
      /* Switch: '<S1072>/Switch4' */
      rtb_Delay1_ie = ACSen_sEnvTempFilter;
    }

    /* End of Switch: '<S1072>/Switch4' */

    /* Switch: '<S1072>/Switch3' incorporates:
     *  DataStoreRead: '<S11>/Data Store Read1'
     *  RelationalOperator: '<S1072>/Relational Operator'
     *  Switch: '<S1072>/Switch5'
     */
    if (ACSen_sEnvTempFilter < rtb_Delay1_ie) {
      /* Gain: '<S8>/Gain8' incorporates:
       *  Switch: '<S1072>/Switch3'
       */
      rtb_Delay1_ie = ACSen_sEnvTempFilter;
    } else if (GLB_CoAC_stColdStart) {
      /* Switch: '<S1072>/Switch5' incorporates:
       *  Gain: '<S8>/Gain8'
       *  Switch: '<S1072>/Switch3'
       */
      rtb_Delay1_ie = ACSen_sEnvTempFilter;
    }

    /* End of Switch: '<S1072>/Switch3' */
  }

  /* End of Switch: '<S1072>/Switch8' */

  /* Switch: '<S1080>/Switch2' incorporates:
   *  Constant: '<S1072>/AC_swtInCabinTempEquip_C2'
   *  Constant: '<S1072>/AC_swtInCabinTempEquip_C3'
   *  RelationalOperator: '<S1080>/LowerRelop1'
   *  RelationalOperator: '<S1080>/UpperRelop'
   *  Switch: '<S1072>/Switch2'
   *  Switch: '<S1080>/Switch'
   */
  if (rtb_Delay1_ie > 80.0F) {
    /* Switch: '<S1080>/Switch2' */
    rtb_Add_ok = 80.0F;
  } else if (rtb_Delay1_ie < -40.0F) {
    /* Switch: '<S1080>/Switch' incorporates:
     *  Constant: '<S1072>/AC_swtInCabinTempEquip_C3'
     *  Switch: '<S1080>/Switch2'
     */
    rtb_Add_ok = -40.0F;
  } else {
    /* Switch: '<S1080>/Switch2' */
    rtb_Add_ok = rtb_Delay1_ie;
  }

  /* End of Switch: '<S1080>/Switch2' */

  /* CCaller: '<S1075>/C Caller' */
  SENCtl_uMotInletTempVol = get_MotInletTempValtage();

  /* Sum: '<S1075>/Add' incorporates:
   *  CCaller: '<S1075>/C Caller'
   *  DataTypeConversion: '<S1075>/Data Type Conversion1'
   *  Lookup_n-D: '<S1075>/cal_MotInletTempVolAmend_CUR'
   */
  rtb_Delay1_ie = (float32)((sint16)SENCtl_uMotInletTempVol -
    look1_iu16lu64n48ts16Ds32_binlcas(SENCtl_uMotInletTempVol, (const uint16 *)
    &cal_MotInletTempVolAmend_1X[0], (const sint16 *)
    &cal_MotInletTempVolAmend_CUR[0], 1U));

  /* Outputs for Atomic SubSystem: '<S1075>/motor' */
  /* Sum: '<S1100>/Add' incorporates:
   *  Constant: '<S1075>/Constant1'
   */
  rtb_Gain6 = cal_ADCVCCVal - rtb_Delay1_ie;

  /* Chart: '<S1103>/Judge' incorporates:
   *  Constant: '<S1100>/Constant1'
   *  Constant: '<S1103>/Constant'
   *  Constant: '<S1103>/Constant1'
   *  RelationalOperator: '<S1103>/Relational Operator'
   *  RelationalOperator: '<S1103>/Relational Operator1'
   */
  ME11_Judge(rtb_Delay1_ie > cal_SensorTempUpFlt, rtb_Delay1_ie <
             cal_SensorTempDownFlg, 20, &ME11_ARID_DEF.SenSts,
             &ME11_ARID_DEF.ARID_DEF_Judge);

  /* DataTypeConversion: '<S1100>/Data Type Conversion' */
  ACSen_eMOTORTSenSts = ME11_ARID_DEF.SenSts;

  /* Switch: '<S1100>/Switch' incorporates:
   *  Constant: '<S1102>/Constant'
   *  RelationalOperator: '<S1102>/Compare'
   */
  if (rtb_Gain6 > 0.0F) {
    /* Gain: '<S8>/Gain6' incorporates:
     *  Product: '<S1100>/Divide'
     */
    rtb_Gain6 = rtb_Delay1_ie / rtb_Gain6;
  } else {
    /* Gain: '<S8>/Gain6' incorporates:
     *  Constant: '<S1100>/Constant'
     */
    rtb_Gain6 = 1.0F;
  }

  /* End of Switch: '<S1100>/Switch' */

  /* Lookup_n-D: '<S1075>/cal_TMot_CUR' incorporates:
   *  Constant: '<S1075>/Constant3'
   *  Product: '<S1100>/Divide1'
   */
  SEN_TMotRaw = look1_iflf_binlca(rtb_Gain6 * 10000.0F, (const float32 *)
    &cal_TMotEntRaw_1X[0], (const float32 *)&cal_TMotEntRaw_CUR[0], 16U);

  /* End of Outputs for SubSystem: '<S1075>/motor' */

  /* Switch: '<S1101>/Init' incorporates:
   *  Constant: '<S1075>/Constant11'
   *  Product: '<S1099>/Product'
   *  Product: '<S1099>/Product1'
   *  Sum: '<S1099>/Sum1'
   *  UnitDelay: '<S1101>/FixPt Unit Delay1'
   *  UnitDelay: '<S1101>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_n != 0) {
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_c = SEN_TMotRaw;
  }

  ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_c = SEN_TMotRaw * 0.9F +
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_c * 0.100000024F;

  /* End of Switch: '<S1101>/Init' */

  /* Switch: '<S1098>/Switch' incorporates:
   *  Constant: '<S1098>/Constant1'
   */
  if (cal_MotTempDataEnb) {
    /* Switch: '<S1098>/Switch' incorporates:
     *  Constant: '<S1098>/Constant'
     */
    ACSen_sMotTempFilter = cal_MotTempData;
  } else {
    /* Switch: '<S1098>/Switch' incorporates:
     *  UnitDelay: '<S1101>/FixPt Unit Delay1'
     */
    ACSen_sMotTempFilter = ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_c;
  }

  /* End of Switch: '<S1098>/Switch' */

  /* Gain: '<S8>/Gain8' incorporates:
   *  Delay: '<S1072>/Delay1'
   */
  rtb_Delay1_ie = ME11_ARID_DEF.Delay1_DSTATE;

  /* Lookup_n-D: '<S1072>/cal_ColdPCUTempMinByEnv_CUR' incorporates:
   *  Gain: '<S8>/Gain8'
   */
  ColdPCUTempMinByEnv = cal_ColdPCUTempMinByEnv_CUR[plook_u32f_bincka
    (rtb_Delay1_ie, (const float32 *)&cal_ColdPCUTempMinByEnv_1X[0], 14U)];

  /* Switch: '<S1072>/Switch10' incorporates:
   *  RelationalOperator: '<S1072>/Relational Operator1'
   */
  if (rtb_Add_ok > rtb_Delay1_ie) {
    /* Switch: '<S1072>/Switch6' incorporates:
     *  DataStoreRead: '<S11>/Data Store Read3'
     */
    if (GLB_ESC_VehicleSpeedValid) {
      /* Switch: '<S1072>/Switch7' incorporates:
       *  Constant: '<S1076>/Constant'
       *  Constant: '<S1077>/Constant'
       *  DataStoreRead: '<S11>/Data Store Read4'
       *  RelationalOperator: '<S1076>/Compare'
       *  RelationalOperator: '<S1077>/Compare'
       *  Switch: '<S1072>/Switch9'
       */
      if (GLB_ESC_VehicleSpeed >= cal_VehicleSpeedHighVs) {
        /* Switch: '<S1072>/Switch10' incorporates:
         *  Constant: '<S1072>/Constant2'
         *  Switch: '<S1072>/Switch7'
         */
        rtb_Gain6 = cal_TempRampStepFast;
      } else if (GLB_ESC_VehicleSpeed <= cal_VehicleSpeedLowVs) {
        /* Switch: '<S1072>/Switch1' incorporates:
         *  RelationalOperator: '<S1072>/Relational Operator2'
         *  Switch: '<S1072>/Switch9'
         */
        if (ACSen_sMotTempFilter >= ColdPCUTempMinByEnv) {
          /* Switch: '<S1072>/Switch10' incorporates:
           *  Constant: '<S1072>/TempRampStep1'
           *  Switch: '<S1072>/Switch7'
           *  Switch: '<S1072>/Switch9'
           */
          rtb_Gain6 = 0.0F;
        } else {
          /* Switch: '<S1072>/Switch10' incorporates:
           *  Constant: '<S1072>/TempRampStep4'
           *  Switch: '<S1072>/Switch7'
           *  Switch: '<S1072>/Switch9'
           */
          rtb_Gain6 = cal_TempRampStepLoVSpeed;
        }

        /* End of Switch: '<S1072>/Switch1' */
      } else {
        /* Switch: '<S1072>/Switch10' incorporates:
         *  Constant: '<S1072>/Constant1'
         *  Switch: '<S1072>/Switch7'
         *  Switch: '<S1072>/Switch9'
         */
        rtb_Gain6 = cal_TempRampStepSlow;
      }

      /* End of Switch: '<S1072>/Switch7' */
    } else {
      /* Switch: '<S1072>/Switch10' incorporates:
       *  Constant: '<S1072>/TempRampStep2'
       *  Switch: '<S1072>/Switch6'
       */
      rtb_Gain6 = 0.0F;
    }

    /* End of Switch: '<S1072>/Switch6' */
  } else {
    /* Switch: '<S1072>/Switch10' incorporates:
     *  Constant: '<S1072>/Constant3'
     */
    rtb_Gain6 = cal_EnvTempRiseStep;
  }

  /* End of Switch: '<S1072>/Switch10' */

  /* Sum: '<S1082>/Add' */
  rtb_Delay1_ie = rtb_Delay + rtb_Gain6;

  /* MinMax: '<S1082>/MinMax' */
  if (rtb_Delay1_ie > 80.0F) {
    /* MinMax: '<S1082>/MinMax' */
    rtb_Delay1_ie = 80.0F;
  }

  /* End of MinMax: '<S1082>/MinMax' */

  /* Switch: '<S1083>/Switch' incorporates:
   *  Constant: '<S1083>/AC_swtInCabinTempEquip_C3'
   *  RelationalOperator: '<S1083>/Relational Operator'
   *  Sum: '<S1083>/Add2'
   */
  if (rtb_Delay - -40.0F >= rtb_Gain6) {
    /* Switch: '<S1083>/Switch' incorporates:
     *  Sum: '<S1083>/Add1'
     */
    rtb_Gain6 = rtb_Delay - rtb_Gain6;
  } else {
    /* Switch: '<S1083>/Switch' incorporates:
     *  Constant: '<S1083>/AC_swtInCabinTempEquip_C1'
     */
    rtb_Gain6 = -40.0F;
  }

  /* End of Switch: '<S1083>/Switch' */

  /* Chart: '<S1081>/TempRampBaseTimeAndStep' incorporates:
   *  Constant: '<S1072>/TempRampStep'
   *  Constant: '<S1072>/TempRampStep3'
   */
  if (ME11_ARID_DEF.is_active_c50_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c50_ME11 = 1U;
    ME11_ARID_DEF.OutData = rtb_Add_ok;
    ME11_ARID_DEF.is_c50_ME11 = ME11_IN_DontChange;
    ME11_ARID_DEF.count = 0U;
  } else {
    switch (ME11_ARID_DEF.is_c50_ME11) {
     case ME11_IN_DecreaseTemp:
      if (rtb_Delay <= rtb_Add_ok) {
        ME11_ARID_DEF.is_DecreaseTemp = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_c50_ME11 = ME11_IN_DontChange;
        ME11_ARID_DEF.count = 0U;
      } else {
        rtb_Divide1_f = ME11_ARID_DEF.count + 1U;
        if (ME11_ARID_DEF.count + 1U > 65535U) {
          rtb_Divide1_f = 65535U;
        }

        ME11_ARID_DEF.count = (uint16)rtb_Divide1_f;
        if (ME11_ARID_DEF.is_DecreaseTemp == ME11_IN_Delay) {
          ME11_ARID_DEF.is_DecreaseTemp = ME11_IN_NO_ACTIVE_CHILD_gl;
          if (ME11_ARID_DEF.count > cal_FallTime2Tamb) {
            ME11_ARID_DEF.is_DecreaseTemp = ME11_IN_Delaychecked;
            ME11_ARID_DEF.OutData = rtb_Gain6;
            ME11_ARID_DEF.count = 0U;
          } else {
            ME11_ARID_DEF.is_DecreaseTemp = ME11_IN_Delay;
            ME11_ARID_DEF.OutData = rtb_Delay;
          }
        } else {
          /* case IN_Delaychecked: */
          ME11_ARID_DEF.is_DecreaseTemp = ME11_IN_NO_ACTIVE_CHILD_gl;
          if (ME11_ARID_DEF.count > cal_FallTime2Tamb) {
            ME11_ARID_DEF.is_DecreaseTemp = ME11_IN_Delaychecked;
            ME11_ARID_DEF.OutData = rtb_Gain6;
            ME11_ARID_DEF.count = 0U;
          } else {
            ME11_ARID_DEF.is_DecreaseTemp = ME11_IN_Delay;
            ME11_ARID_DEF.OutData = rtb_Delay;
          }
        }
      }
      break;

     case ME11_IN_DontChange:
      if (rtb_Delay < rtb_Add_ok) {
        ME11_ARID_DEF.is_c50_ME11 = ME11_IN_IncreaseTemp;
        ME11_ARID_DEF.count = 0U;
        if (ME11_ARID_DEF.count > cal_RiseTime2Tamb) {
          ME11_ARID_DEF.is_IncreaseTemp = ME11_IN_Delaychecked;
          ME11_ARID_DEF.OutData = rtb_Delay1_ie;
          ME11_ARID_DEF.count = 0U;
        } else {
          ME11_ARID_DEF.is_IncreaseTemp = ME11_IN_Delay;
          ME11_ARID_DEF.OutData = rtb_Delay;
        }
      } else if (rtb_Delay > rtb_Add_ok) {
        ME11_ARID_DEF.is_c50_ME11 = ME11_IN_DecreaseTemp;
        ME11_ARID_DEF.count = 0U;
        if (ME11_ARID_DEF.count > cal_FallTime2Tamb) {
          ME11_ARID_DEF.is_DecreaseTemp = ME11_IN_Delaychecked;
          ME11_ARID_DEF.OutData = rtb_Gain6;
          ME11_ARID_DEF.count = 0U;
        } else {
          ME11_ARID_DEF.is_DecreaseTemp = ME11_IN_Delay;
          ME11_ARID_DEF.OutData = rtb_Delay;
        }
      }
      break;

     default:
      /* case IN_IncreaseTemp: */
      if (rtb_Delay >= rtb_Add_ok) {
        ME11_ARID_DEF.is_IncreaseTemp = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_c50_ME11 = ME11_IN_DontChange;
        ME11_ARID_DEF.count = 0U;
      } else {
        rtb_Divide1_f = ME11_ARID_DEF.count + 1U;
        if (ME11_ARID_DEF.count + 1U > 65535U) {
          rtb_Divide1_f = 65535U;
        }

        ME11_ARID_DEF.count = (uint16)rtb_Divide1_f;
        if (ME11_ARID_DEF.is_IncreaseTemp == ME11_IN_Delay) {
          ME11_ARID_DEF.is_IncreaseTemp = ME11_IN_NO_ACTIVE_CHILD_gl;
          if (ME11_ARID_DEF.count > cal_RiseTime2Tamb) {
            ME11_ARID_DEF.is_IncreaseTemp = ME11_IN_Delaychecked;
            ME11_ARID_DEF.OutData = rtb_Delay1_ie;
            ME11_ARID_DEF.count = 0U;
          } else {
            ME11_ARID_DEF.is_IncreaseTemp = ME11_IN_Delay;
            ME11_ARID_DEF.OutData = rtb_Delay;
          }
        } else {
          /* case IN_Delaychecked: */
          ME11_ARID_DEF.is_IncreaseTemp = ME11_IN_NO_ACTIVE_CHILD_gl;
          if (ME11_ARID_DEF.count > cal_RiseTime2Tamb) {
            ME11_ARID_DEF.is_IncreaseTemp = ME11_IN_Delaychecked;
            ME11_ARID_DEF.OutData = rtb_Delay1_ie;
            ME11_ARID_DEF.count = 0U;
          } else {
            ME11_ARID_DEF.is_IncreaseTemp = ME11_IN_Delay;
            ME11_ARID_DEF.OutData = rtb_Delay;
          }
        }
      }
      break;
    }
  }

  /* End of Chart: '<S1081>/TempRampBaseTimeAndStep' */

  /* Switch: '<S1073>/Switch' incorporates:
   *  Constant: '<S1073>/Constant10'
   *  DataStoreRead: '<S11>/Data Store Read2'
   *  Logic: '<S1073>/OR'
   *  RelationalOperator: '<S1073>/Relational Operator'
   */
  if ((GLB_CoAC_stwork == 2) || (GLB_CoAC_stwork == 3) || (GLB_CoAC_stwork == 5))
  {
    /* Switch: '<S1073>/Switch' */
    rtb_Delay1_ie = ME11_ARID_DEF.OutData;
  } else {
    /* Switch: '<S1073>/Switch' */
    rtb_Delay1_ie = ACSen_sEnvTempFilter;
  }

  /* End of Switch: '<S1073>/Switch' */

  /* Lookup_n-D: '<S1073>/cal_EnvTAme_CUR' incorporates:
   *  Switch: '<S1073>/Switch'
   */
  ACSen_sEnvTAme = look1_iflf_binlca(rtb_Delay1_ie, (const float32 *)
    &cal_EnvTAme_1X[0], (const float32 *)&cal_EnvTAme_CUR[0], 10U);

  /* Switch: '<S1085>/Switch' incorporates:
   *  Constant: '<S1085>/Constant1'
   */
  if (cal_EnvTempCorEnb) {
    /* Switch: '<S1085>/Switch' incorporates:
     *  Constant: '<S1085>/Constant'
     */
    ACSen_sEnvTempCor = cal_EnvTempCorData;
  } else {
    /* Switch: '<S1085>/Switch' incorporates:
     *  Sum: '<S1073>/Add'
     */
    ACSen_sEnvTempCor = ACSen_sEnvTAme + rtb_Delay1_ie;
  }

  /* End of Switch: '<S1085>/Switch' */

  /* Switch: '<S30>/Switch' incorporates:
   *  Inport: '<Root>/Bcm2VcuTms_outputs'
   */
  if ((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
      ->BCM_SysPwrModeV > 0) {
    /* Switch: '<S30>/Switch' */
    rtb_Switch2_ip = (Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs
                      ())->BCM_SysPwrMode;
  } else {
    /* Switch: '<S30>/Switch' incorporates:
     *  Constant: '<S30>/Constant1'
     */
    rtb_Switch2_ip = 0U;
  }

  /* End of Switch: '<S30>/Switch' */

  /* Chart: '<S30>/T15SwtCheck' */
  guard1 = false;
  guard2 = false;
  if (ME11_ARID_DEF.is_active_c43_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c43_ME11 = 1U;
    if (PWRCtl_bKL15swtSt || (rtb_Switch2_ip == 2) || (PWRCtl_eBatChargSts != 0))
    {
      ME11_ARID_DEF.is_c43_ME11 = ME11_IN_T15_ON;
      guard2 = true;
    } else {
      ME11_ARID_DEF.is_c43_ME11 = ME11_IN_T15_OFF;
      guard1 = true;
    }
  } else if (ME11_ARID_DEF.is_c43_ME11 == ME11_IN_T15_OFF) {
    if (PWRCtl_bKL15swtSt || (rtb_Switch2_ip == 2) || (PWRCtl_eBatChargSts != 0))
    {
      ME11_ARID_DEF.is_c43_ME11 = ME11_IN_T15_ON;
      guard2 = true;
    } else {
      guard1 = true;
    }

    /* case IN_T15_ON: */
  } else if ((!PWRCtl_bKL15swtSt) && (rtb_Switch2_ip == 0) &&
             (PWRCtl_eBatChargSts == 0)) {
    ME11_ARID_DEF.is_c43_ME11 = ME11_IN_T15_OFF;
    guard1 = true;
  } else {
    guard2 = true;
  }

  if (guard2) {
    /* MinMax: '<S1291>/MinMax' incorporates:
     *  Constant: '<S1291>/Constant4'
     *  Delay: '<S1291>/Delay'
     *  Sum: '<S1291>/Add'
     *  Switch: '<S1291>/Switch3'
     */
    if ((uint16)(ME11_ARID_DEF.Delay_DSTATE_ns + 1U) <= 40000) {
      ME11_ARID_DEF.Delay_DSTATE_ns++;
    } else {
      ME11_ARID_DEF.Delay_DSTATE_ns = 40000U;
    }

    /* End of MinMax: '<S1291>/MinMax' */

    /* Switch: '<S1291>/Switch1' incorporates:
     *  Constant: '<S30>/Constant3'
     *  Delay: '<S1291>/Delay'
     *  RelationalOperator: '<S1291>/Relational Operator2'
     */
    AC_stIGNON = (ME11_ARID_DEF.Delay_DSTATE_ns > cal_IGNONDelayTime);
  }

  if (guard1) {
    /* Switch: '<S1291>/Switch3' incorporates:
     *  Constant: '<S1291>/Constant6'
     *  Delay: '<S1291>/Delay'
     */
    ME11_ARID_DEF.Delay_DSTATE_ns = 0U;

    /* Switch: '<S1291>/Switch1' */
    AC_stIGNON = false;
  }

  /* End of Chart: '<S30>/T15SwtCheck' */

  /* Chart: '<S30>/RDCWorkStates' incorporates:
   *  Inport: '<Root>/Bcm2VcuTms_outputs'
   */
  if (ME11_ARID_DEF.is_active_c42_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c42_ME11 = 1U;
    ME11_ARID_DEF.is_Run = ME11_IN_CoAC_stStop;
    ME11_ARID_DEF.CoAC_tiStandBy = 0U;
    ME11_ARID_DEF.CoAC_stwork_l = 0U;
  } else {
    switch (ME11_ARID_DEF.is_Run) {
     case ME11_IN_CoAC_stAfterRun:
      ME11_ARID_DEF.CoAC_stwork_l = 4U;
      if ((ME11_ARID_DEF.CoAC_tiStandBy > 6) || AC_stIGNON) {
        ME11_ARID_DEF.is_Run = ME11_IN_CoAC_stStop;
        ME11_ARID_DEF.CoAC_tiStandBy = 0U;
        ME11_ARID_DEF.CoAC_stwork_l = 0U;
      } else {
        b_previousEvent = ME11_ARID_DEF.CoAC_tiStandBy + 1;
        if (ME11_ARID_DEF.CoAC_tiStandBy + 1 > 255) {
          b_previousEvent = 255;
        }

        ME11_ARID_DEF.CoAC_tiStandBy = (uint8)b_previousEvent;
      }
      break;

     case ME11_IN_CoAC_stInit:
      ME11_ARID_DEF.CoAC_stwork_l = 1U;
      if (!AC_stIGNON) {
        ME11_ARID_DEF.is_Run = ME11_IN_CoAC_stStop;
        ME11_ARID_DEF.CoAC_tiStandBy = 0U;
        ME11_ARID_DEF.CoAC_stwork_l = 0U;
      } else if (ME11_ARID_DEF.CoAC_tiStandBy > 51) {
        ME11_ARID_DEF.is_Run = ME11_IN_CoAC_stNormal;
        if (((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
             ->BCM_SysPowerSts == 1) && PWRCtl_bKL15swtSt) {
          ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stNativeWakeUp;
          ME11_ARID_DEF.CoAC_stwork_l = 2U;
        } else if (((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
                    ->BCM_SysPowerSts == 2) && PWRCtl_bKL15swtSt) {
          ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stRemoteWakeUp;
          ME11_ARID_DEF.CoAC_stwork_l = 3U;
        } else {
          ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stChargeWakeUp;
          ME11_ARID_DEF.CoAC_stwork_l = 5U;
        }
      } else {
        b_previousEvent = ME11_ARID_DEF.CoAC_tiStandBy + 1;
        if (ME11_ARID_DEF.CoAC_tiStandBy + 1 > 255) {
          b_previousEvent = 255;
        }

        ME11_ARID_DEF.CoAC_tiStandBy = (uint8)b_previousEvent;
      }
      break;

     case ME11_IN_CoAC_stNormal:
      if (!AC_stIGNON) {
        ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_Run = ME11_IN_CoAC_stAfterRun;
        ME11_ARID_DEF.CoAC_stwork_l = 4U;
        ME11_ARID_DEF.CoAC_tiStandBy = 0U;
      } else if ((((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
                   ->BCM_SysPowerSts == 3) ||
                  ((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
                   ->BCM_SysPowerSts == 5)) && PWRCtl_bKL15swtSt &&
                 (ME11_ARID_DEF.CoAC_stwork_l != 1)) {
        ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_Run = ME11_IN_CoAC_stOTA;
      } else {
        switch (ME11_ARID_DEF.is_CoAC_stNormal) {
         case ME11_IN_CoAC_stChargeWakeUp:
          ME11_ARID_DEF.CoAC_stwork_l = 5U;
          if (((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
               ->BCM_SysPowerSts == 2) && PWRCtl_bKL15swtSt) {
            ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stRemoteWakeUp;
            ME11_ARID_DEF.CoAC_stwork_l = 3U;
          } else if
              (((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
                ->BCM_SysPowerSts == 1) && PWRCtl_bKL15swtSt) {
            ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stNativeWakeUp;
            ME11_ARID_DEF.CoAC_stwork_l = 2U;
          }
          break;

         case ME11_IN_CoAC_stNativeWakeUp:
          ME11_ARID_DEF.CoAC_stwork_l = 2U;
          if ((!PWRCtl_bKL15swtSt) &&
              ((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
               ->BCM_SysPowerSts == 0) && (PWRCtl_eBatChargSts != 0)) {
            ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stChargeWakeUp;
            ME11_ARID_DEF.CoAC_stwork_l = 5U;
          } else if ((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs
                      ())->BCM_SysPowerSts == 2) {
            ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stRemoteWakeUp;
            ME11_ARID_DEF.CoAC_stwork_l = 3U;
          }
          break;

         default:
          /* case IN_CoAC_stRemoteWakeUp: */
          ME11_ARID_DEF.CoAC_stwork_l = 3U;
          if ((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
              ->BCM_SysPowerSts == 1) {
            ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stNativeWakeUp;
            ME11_ARID_DEF.CoAC_stwork_l = 2U;
          } else if ((!PWRCtl_bKL15swtSt) &&
                     ((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs
                       ())->BCM_SysPowerSts == 0) && (PWRCtl_eBatChargSts != 0))
          {
            ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stChargeWakeUp;
            ME11_ARID_DEF.CoAC_stwork_l = 5U;
          }
          break;
        }
      }
      break;

     case ME11_IN_CoAC_stOTA:
      if (((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
           ->BCM_SysPowerSts != 3) &&
          ((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
           ->BCM_SysPowerSts != 5)) {
        ME11_ARID_DEF.is_Run = ME11_IN_CoAC_stNormal;
        if (((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
             ->BCM_SysPowerSts == 1) && PWRCtl_bKL15swtSt) {
          ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stNativeWakeUp;
          ME11_ARID_DEF.CoAC_stwork_l = 2U;
        } else if (((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
                    ->BCM_SysPowerSts == 2) && PWRCtl_bKL15swtSt) {
          ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stRemoteWakeUp;
          ME11_ARID_DEF.CoAC_stwork_l = 3U;
        } else {
          ME11_ARID_DEF.is_CoAC_stNormal = ME11_IN_CoAC_stChargeWakeUp;
          ME11_ARID_DEF.CoAC_stwork_l = 5U;
        }
      } else if (!AC_stIGNON) {
        ME11_ARID_DEF.is_Run = ME11_IN_CoAC_stAfterRun;
        ME11_ARID_DEF.CoAC_stwork_l = 4U;
        ME11_ARID_DEF.CoAC_tiStandBy = 0U;
      }
      break;

     default:
      /* case IN_CoAC_stStop: */
      ME11_ARID_DEF.CoAC_stwork_l = 0U;
      if (AC_stIGNON) {
        ME11_ARID_DEF.is_Run = ME11_IN_CoAC_stInit;
        ME11_ARID_DEF.CoAC_stwork_l = 1U;
      }
      break;
    }
  }

  /* End of Chart: '<S30>/RDCWorkStates' */

  /* Switch: '<S30>/Switch1' incorporates:
   *  Constant: '<S2>/Constant'
   */
  if (cal_CANAliveEnable) {
    /* Switch: '<S30>/Switch1' */
    CoAC_stwork = ME11_ARID_DEF.CoAC_stwork_l;
  } else {
    /* Switch: '<S30>/Switch1' incorporates:
     *  Constant: '<S30>/Constant2'
     */
    CoAC_stwork = 0U;
  }

  /* End of Switch: '<S30>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S180>/TempRamp' incorporates:
   *  EnablePort: '<S186>/Enable'
   */
  /* Logic: '<S180>/OR' incorporates:
   *  Constant: '<S180>/Constant'
   *  RelationalOperator: '<S180>/Relational Operator'
   */
  if ((CoAC_stwork == 2) || (CoAC_stwork == 3) || (CoAC_stwork == 5)) {
    /* Sum: '<S213>/Add' incorporates:
     *  Constant: '<S180>/Constant3'
     */
    rtb_Delay1_ie = ME11_ARID_DEF.Delay_DSTATE_o + cal_EnvTempStep;

    /* MinMax: '<S213>/MinMax' */
    if (rtb_Delay1_ie > 80.0F) {
      /* MinMax: '<S213>/MinMax' */
      rtb_Delay1_ie = 80.0F;
    }

    /* End of MinMax: '<S213>/MinMax' */

    /* Switch: '<S215>/Switch' incorporates:
     *  Constant: '<S180>/Constant3'
     *  Constant: '<S215>/AC_swtInCabinTempEquip_C3'
     *  RelationalOperator: '<S215>/Relational Operator'
     *  Sum: '<S215>/Add2'
     */
    if (ME11_ARID_DEF.Delay_DSTATE_o - -40.0F >= cal_EnvTempStep) {
      /* Switch: '<S215>/Switch' incorporates:
       *  Sum: '<S215>/Add1'
       */
      rtb_Delay = ME11_ARID_DEF.Delay_DSTATE_o - cal_EnvTempStep;
    } else {
      /* Switch: '<S215>/Switch' incorporates:
       *  Constant: '<S215>/AC_swtInCabinTempEquip_C1'
       */
      rtb_Delay = -40.0F;
    }

    /* End of Switch: '<S215>/Switch' */

    /* Chart: '<S186>/TempRampBaseTimeAndStep' incorporates:
     *  Constant: '<S180>/TempRampStep'
     *  Constant: '<S180>/TempRampStep3'
     *  MinMax: '<S214>/MinMax'
     *  Switch: '<S216>/Switch'
     */
    if (ME11_ARID_DEF.is_active_c45_ME11 == 0U) {
      ME11_ARID_DEF.is_active_c45_ME11 = 1U;
      AC_tEnvInvent = ACSen_sEnvTempCor;
      ME11_ARID_DEF.is_c45_ME11 = ME11_IN_DontChange;
      ME11_ARID_DEF.count_o = 0U;
    } else {
      switch (ME11_ARID_DEF.is_c45_ME11) {
       case ME11_IN_DecreaseTemp:
        if (ME11_ARID_DEF.Delay_DSTATE_o <= ACSen_sEnvTempCor) {
          ME11_ARID_DEF.is_DecreaseTemp_j = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_c45_ME11 = ME11_IN_DontChange;
          ME11_ARID_DEF.count_o = 0U;
        } else {
          rtb_Divide1_f = ME11_ARID_DEF.count_o + 1U;
          if (ME11_ARID_DEF.count_o + 1U > 65535U) {
            rtb_Divide1_f = 65535U;
          }

          ME11_ARID_DEF.count_o = (uint16)rtb_Divide1_f;
          if (ME11_ARID_DEF.is_DecreaseTemp_j == ME11_IN_Delay) {
            if (ME11_ARID_DEF.count_o > cal_FalseTime2EnvTamb) {
              ME11_ARID_DEF.is_DecreaseTemp_j = ME11_IN_Delaychecked;
              AC_tEnvInvent = rtb_Delay;
              ME11_ARID_DEF.count_o = 0U;
            } else {
              ME11_ARID_DEF.is_DecreaseTemp_j = ME11_IN_Delay;
              AC_tEnvInvent = ME11_ARID_DEF.Delay_DSTATE_o;
            }

            /* case IN_Delaychecked: */
          } else if (ME11_ARID_DEF.count_o > cal_FalseTime2EnvTamb) {
            ME11_ARID_DEF.is_DecreaseTemp_j = ME11_IN_Delaychecked;
            AC_tEnvInvent = rtb_Delay;
            ME11_ARID_DEF.count_o = 0U;
          } else {
            ME11_ARID_DEF.is_DecreaseTemp_j = ME11_IN_Delay;
            AC_tEnvInvent = ME11_ARID_DEF.Delay_DSTATE_o;
          }
        }
        break;

       case ME11_IN_DontChange:
        /* Switch: '<S216>/Switch' incorporates:
         *  Constant: '<S180>/Constant3'
         *  Constant: '<S216>/AC_swtInCabinTempEquip_C1'
         *  Constant: '<S216>/AC_swtInCabinTempEquip_C3'
         *  RelationalOperator: '<S216>/Relational Operator'
         *  Sum: '<S216>/Add1'
         *  Sum: '<S216>/Add2'
         */
        if (ACSen_sEnvTempCor - -40.0F >= cal_EnvTempStep) {
          rtb_Add_ok = ACSen_sEnvTempCor - cal_EnvTempStep;
        } else {
          rtb_Add_ok = -40.0F;
        }

        if (ME11_ARID_DEF.Delay_DSTATE_o < rtb_Add_ok) {
          ME11_ARID_DEF.is_c45_ME11 = ME11_IN_IncreaseTemp;
          ME11_ARID_DEF.count_o = 0U;
          if (ME11_ARID_DEF.count_o > cal_RiseTime2EnvTamb) {
            ME11_ARID_DEF.is_IncreaseTemp_l = ME11_IN_Delaychecked;
            AC_tEnvInvent = rtb_Delay1_ie;
            ME11_ARID_DEF.count_o = 0U;
          } else {
            ME11_ARID_DEF.is_IncreaseTemp_l = ME11_IN_Delay;
            AC_tEnvInvent = ME11_ARID_DEF.Delay_DSTATE_o;
          }
        } else {
          /* Sum: '<S214>/Add' incorporates:
           *  Constant: '<S180>/Constant3'
           */
          rtb_Delay1_ie = ACSen_sEnvTempCor + cal_EnvTempStep;

          /* MinMax: '<S214>/MinMax' */
          if (rtb_Delay1_ie > 80.0F) {
            rtb_Delay1_ie = 80.0F;
          }

          if (ME11_ARID_DEF.Delay_DSTATE_o > rtb_Delay1_ie) {
            ME11_ARID_DEF.is_c45_ME11 = ME11_IN_DecreaseTemp;
            ME11_ARID_DEF.count_o = 0U;
            if (ME11_ARID_DEF.count_o > cal_FalseTime2EnvTamb) {
              ME11_ARID_DEF.is_DecreaseTemp_j = ME11_IN_Delaychecked;
              AC_tEnvInvent = rtb_Delay;
              ME11_ARID_DEF.count_o = 0U;
            } else {
              ME11_ARID_DEF.is_DecreaseTemp_j = ME11_IN_Delay;
              AC_tEnvInvent = ME11_ARID_DEF.Delay_DSTATE_o;
            }
          }
        }
        break;

       default:
        /* case IN_IncreaseTemp: */
        if (ME11_ARID_DEF.Delay_DSTATE_o >= ACSen_sEnvTempCor) {
          ME11_ARID_DEF.is_IncreaseTemp_l = ME11_IN_NO_ACTIVE_CHILD_gl;
          ME11_ARID_DEF.is_c45_ME11 = ME11_IN_DontChange;
          ME11_ARID_DEF.count_o = 0U;
        } else {
          rtb_Divide1_f = ME11_ARID_DEF.count_o + 1U;
          if (ME11_ARID_DEF.count_o + 1U > 65535U) {
            rtb_Divide1_f = 65535U;
          }

          ME11_ARID_DEF.count_o = (uint16)rtb_Divide1_f;
          if (ME11_ARID_DEF.is_IncreaseTemp_l == ME11_IN_Delay) {
            if (ME11_ARID_DEF.count_o > cal_RiseTime2EnvTamb) {
              ME11_ARID_DEF.is_IncreaseTemp_l = ME11_IN_Delaychecked;
              AC_tEnvInvent = rtb_Delay1_ie;
              ME11_ARID_DEF.count_o = 0U;
            } else {
              ME11_ARID_DEF.is_IncreaseTemp_l = ME11_IN_Delay;
              AC_tEnvInvent = ME11_ARID_DEF.Delay_DSTATE_o;
            }

            /* case IN_Delaychecked: */
          } else if (ME11_ARID_DEF.count_o > cal_RiseTime2EnvTamb) {
            ME11_ARID_DEF.is_IncreaseTemp_l = ME11_IN_Delaychecked;
            AC_tEnvInvent = rtb_Delay1_ie;
            ME11_ARID_DEF.count_o = 0U;
          } else {
            ME11_ARID_DEF.is_IncreaseTemp_l = ME11_IN_Delay;
            AC_tEnvInvent = ME11_ARID_DEF.Delay_DSTATE_o;
          }
        }
        break;
      }
    }

    /* End of Chart: '<S186>/TempRampBaseTimeAndStep' */

    /* Update for Delay: '<S186>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_o = AC_tEnvInvent;
  }

  /* End of Logic: '<S180>/OR' */
  /* End of Outputs for SubSystem: '<S180>/TempRamp' */

  /* Lookup_n-D: '<S185>/cal_ACDVTPreSetSolarCor_MAP' incorporates:
   *  Saturate: '<S210>/Saturation'
   */
  ACDVTPreSetSolarCor = look2_iu16flftf_binlca(AC_rSunloadFlt, AC_tEnvInvent, (
    const uint16 *)&cal_ACDVTPreSetSolarCor_2X[0], (const float32 *)
    &cal_ACDVTPreSetSolarCor_2Y[0], (const float32 *)
    &cal_ACDVTPreSetSolarCor_MAP[0],
    ME11_ConstP.cal_ACDVTPreSetSolarCor_MAP_maxIndex, 8U);

  /* Lookup_n-D: '<S185>/cal_ACDVTPreSetSolarCorByVx_MAP' incorporates:
   *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
   *  Saturate: '<S210>/Saturation'
   */
  ACDVTPreSetSolarCorByVx = look2_iu16flftf_binlca(AC_rSunloadFlt,
    (Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA())
    ->VIPM_ESCVehSpd_kph, (const uint16 *)&cal_ACDVTPreSetSolarCorByVx_2X[0], (
    const float32 *)&cal_ACDVTPreSetSolarCorByVx_2Y[0], (const float32 *)
    &cal_ACDVTPreSetSolarCorByVx_MAP[0], ME11_ConstP.pooled38, 6U);

  /* Lookup_n-D: '<S185>/cal_ACCabinPreSetByEnv_MAP' incorporates:
   *  Switch: '<S1165>/Switch'
   */
  ACCCtl_sACCabinPreSetByEnv = look2_iflf_binlca(AC_tEnvInvent,
    HMICtl_sLeftSetPoint, (const float32 *)&cal_ACCabinPreSetByEnv_2X[0], (const
    float32 *)&cal_ACCabinPreSetByEnv_2Y[0], (const float32 *)
    &cal_ACCabinPreSetByEnv_MAP[0], ME11_ConstP.pooled39, 12U);

  /* Lookup_n-D: '<S185>/cal_CabinDesTempSolarCor_MAP' incorporates:
   *  Saturate: '<S210>/Saturation'
   */
  CabinDesTempSolarCor = look2_iu16flftf_binlca(AC_rSunloadFlt, AC_tEnvInvent, (
    const uint16 *)&cal_CabinDesTempSolarCor_2X[0], (const float32 *)
    &cal_CabinDesTempSolarCor_2Y[0], (const float32 *)
    &cal_CabinDesTempSolarCor_MAP[0], ME11_ConstP.pooled40, 14U);

  /* Lookup_n-D: '<S185>/cal_ACCabinPreSetByEnvECO_MAP' incorporates:
   *  Switch: '<S1165>/Switch'
   */
  ACCCtl_sACCabinPreSetByEnvECO = look2_iflf_binlca(AC_tEnvInvent,
    HMICtl_sLeftSetPoint, (const float32 *)&cal_ACCabinPreSetByEnvECO_2X[0], (
    const float32 *)&cal_ACCabinPreSetByEnvECO_2Y[0], (const float32 *)
    &cal_ACCabinPreSetByEnvECO_MAP[0], ME11_ConstP.pooled39, 12U);

  /* Lookup_n-D: '<S185>/cal_CabinDesTempSolarCorECO_MAP' incorporates:
   *  Saturate: '<S210>/Saturation'
   */
  CabinDesTempSolarCorECO = look2_iu16flftf_binlca(AC_rSunloadFlt, AC_tEnvInvent,
    (const uint16 *)&cal_CabinDesTempSolarCorECO_2X[0], (const float32 *)
    &cal_CabinDesTempSolarCorECO_2Y[0], (const float32 *)
    &cal_CabinDesTempSolarCorECO_MAP[0], ME11_ConstP.pooled40, 14U);

  /* Switch: '<S185>/Switch3' incorporates:
   *  Constant: '<S185>/ACEconMode.Economy'
   *  RelationalOperator: '<S185>/Relational Operator'
   */
  if (rtb_DataTypeConversion_f != ACEconMode_Economy) {
    /* Switch: '<S185>/Switch3' incorporates:
     *  Sum: '<S185>/Sum4'
     */
    ACCtl_tDesFrontCabin = ACCCtl_sACCabinPreSetByEnv + CabinDesTempSolarCor;
  } else {
    /* Switch: '<S185>/Switch3' incorporates:
     *  Sum: '<S185>/Sum5'
     */
    ACCtl_tDesFrontCabin = ACCCtl_sACCabinPreSetByEnvECO +
      CabinDesTempSolarCorECO;
  }

  /* End of Switch: '<S185>/Switch3' */

  /* Lookup_n-D: '<S185>/cal_ACDVTPreSetByEnv_MAP' incorporates:
   *  Switch: '<S185>/Switch3'
   */
  AC_DVTPreSetByEnv = look2_iflf_binlca(ACCtl_tDesFrontCabin, AC_tEnvInvent, (
    const float32 *)&cal_ACDVTPreSetByEnv_2X[0], (const float32 *)
    &cal_ACDVTPreSetByEnv_2Y[0], (const float32 *)&cal_ACDVTPreSetByEnv_MAP[0],
    ME11_ConstP.pooled36, 10U);

  /* Sum: '<S185>/Sum6' incorporates:
   *  Lookup_n-D: '<S185>/cal_ACDVTPreSetEnvCor_CUR'
   *  Sum: '<S185>/Sum1'
   *  Sum: '<S185>/Sum2'
   */
  ACCtl_tDVTFeedfoward = ((look1_iflf_binlca(AC_tEnvInvent, (const float32 *)
    &cal_ACDVTPreSetEnvCor_1X[0], (const float32 *)&cal_ACDVTPreSetEnvCor_CUR[0],
    15U) + ACDVTPreSetSolarCor) + ACDVTPreSetSolarCorByVx) + AC_DVTPreSetByEnv;

  /* Switch: '<S208>/Switch2' incorporates:
   *  Constant: '<S185>/Constant'
   *  Constant: '<S185>/Constant1'
   *  RelationalOperator: '<S208>/LowerRelop1'
   *  RelationalOperator: '<S208>/UpperRelop'
   *  Switch: '<S208>/Switch'
   */
  if (ACCtl_tDVTFeedfoward > 80.0F) {
    /* Switch: '<S208>/Switch2' */
    ACCtl_tDVTFeedfoward = 80.0F;
  } else if (ACCtl_tDVTFeedfoward < -40.0F) {
    /* Switch: '<S208>/Switch' incorporates:
     *  Constant: '<S185>/Constant1'
     *  Switch: '<S208>/Switch2'
     */
    ACCtl_tDVTFeedfoward = -40.0F;
  }

  /* End of Switch: '<S208>/Switch2' */

  /* Logic: '<S177>/Logical Operator1' incorporates:
   *  Constant: '<S177>/Constant'
   *  Logic: '<S177>/Logical Operator'
   *  RelationalOperator: '<S177>/Relational Operator1'
   */
  rtb_Delay_mz3 = ((!ACTCtl_bCabinFltFlg) && (ME11_ARID_DEF.Switch1_nv != ACOff)
                   && ME11_ARID_DEF.Switch_c);

  /* UnitDelay: '<S176>/Unit Delay3' */
  rtb_Delay1_ie = ME11_ARID_DEF.UnitDelay3_DSTATE;

  /* Switch: '<S176>/Switch4' incorporates:
   *  RelationalOperator: '<S176>/Relational Operator1'
   *  Sum: '<S176>/Add3'
   *  Sum: '<S176>/Add4'
   *  UnitDelay: '<S176>/Unit Delay3'
   */
  if (ACSen_sCabinTempFilter > ACCtl_tDesFrontCabin) {
    ME11_ARID_DEF.UnitDelay3_DSTATE = ACSen_sCabinTempFilter -
      ACCtl_tDesFrontCabin;
  } else {
    ME11_ARID_DEF.UnitDelay3_DSTATE = ACCtl_tDesFrontCabin -
      ACSen_sCabinTempFilter;
  }

  /* End of Switch: '<S176>/Switch4' */

  /* RelationalOperator: '<S1371>/Relational Operator5' incorporates:
   *  Constant: '<S176>/Constant2'
   *  Constant: '<S176>/Constant3'
   *  Logic: '<S176>/AND'
   *  Logic: '<S176>/Logical Operator'
   *  Logic: '<S176>/Logical Operator2'
   *  Logic: '<S176>/OR'
   *  RelationalOperator: '<S176>/Relational Operator2'
   *  RelationalOperator: '<S176>/Relational Operator3'
   *  RelationalOperator: '<S270>/FixPt Relational Operator'
   *  RelationalOperator: '<S271>/FixPt Relational Operator'
   *  RelationalOperator: '<S272>/FixPt Relational Operator'
   *  RelationalOperator: '<S273>/FixPt Relational Operator'
   *  Sum: '<S176>/Add5'
   *  Sum: '<S176>/Add6'
   *  UnitDelay: '<S176>/Unit Delay2'
   *  UnitDelay: '<S176>/Unit Delay3'
   *  UnitDelay: '<S270>/Delay Input1'
   *  UnitDelay: '<S271>/Delay Input1'
   *  UnitDelay: '<S272>/Delay Input1'
   *  UnitDelay: '<S273>/Delay Input1'
   *
   * Block description for '<S270>/Delay Input1':
   *
   *  Store in Global RAM
   *
   * Block description for '<S271>/Delay Input1':
   *
   *  Store in Global RAM
   *
   * Block description for '<S272>/Delay Input1':
   *
   *  Store in Global RAM
   *
   * Block description for '<S273>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_AND_b3z = ((HMICtl_sLeftSetPoint != ME11_ARID_DEF.DelayInput1_DSTATE) ||
                 (HMICtl_sLeftSetPoint != ME11_ARID_DEF.DelayInput1_DSTATE_j) ||
                 ((sint32)rtb_Delay_mz3 > (sint32)
                  ME11_ARID_DEF.DelayInput1_DSTATE_gyl) || (((rtb_Delay1_ie >
    ME11_ARID_DEF.UnitDelay3_DSTATE + 1.0F) || (ME11_ARID_DEF.UnitDelay3_DSTATE >
    ME11_ARID_DEF.UnitDelay2_DSTATE + 1.0F)) && (ME11_ARID_DEF.UnitDelay3_DSTATE
    > ME11_ARID_DEF.DelayInput1_DSTATE_d)));

  /* Logic: '<S175>/Logical Operator' incorporates:
   *  Logic: '<S175>/Logical Operator1'
   */
  rtb_FixPtRelationalOperator_a0 = (ME11_TMSADCSampleFunc_ARID_DEF.Compare ||
    ME11_TMSADCSampleFunc_ARID_DEF.Compare_k);

  /* Delay: '<S4>/Delay' */
  rtb_Delay_n2 = ME11_ARID_DEF.Delay_DSTATE_fl;

  /* Switch: '<S175>/Switch' incorporates:
   *  Logic: '<S175>/Logical Operator'
   */
  if (rtb_FixPtRelationalOperator_a0) {
    /* Switch: '<S175>/Switch' incorporates:
     *  Constant: '<S175>/cal_DrDuctSensorFailDefault'
     */
    ACCtl_tLeftDuct = cal_DrDuctSenFailDeflt;
  } else {
    /* MultiPortSwitch: '<S226>/Multiport Switch2' incorporates:
     *  Delay: '<S4>/Delay'
     */
    switch (ME11_ARID_DEF.Delay_DSTATE_fl) {
     case BlowerModes_FaceMode:
      /* Switch: '<S175>/Switch' incorporates:
       *  MultiPortSwitch: '<S226>/Multiport Switch2'
       */
      ACCtl_tLeftDuct = ACSen_sFaceDuctTempFilter;
      break;

     case BlowerModes_FaceHeaterMode:
      /* Switch: '<S175>/Switch' incorporates:
       *  Constant: '<S226>/Constant3'
       *  Constant: '<S226>/Constant4'
       *  MultiPortSwitch: '<S226>/Multiport Switch2'
       *  Product: '<S226>/Product'
       *  Product: '<S226>/Product1'
       *  Sum: '<S226>/Add'
       */
      ACCtl_tLeftDuct = ACSen_sFaceDuctTempFilter * cal_DrDuctFaceFloorFaFactor
        + ACSen_sFootDuctTempFilter * cal_DrDuctFaceFloorFoFactor;
      break;

     case BlowerModes_HeaterMode:
      /* Switch: '<S175>/Switch' incorporates:
       *  MultiPortSwitch: '<S226>/Multiport Switch2'
       */
      ACCtl_tLeftDuct = ACSen_sFootDuctTempFilter;
      break;

     case BlowerModes_HeaterDeforstMode:
      /* Switch: '<S175>/Switch' incorporates:
       *  MultiPortSwitch: '<S226>/Multiport Switch2'
       */
      ACCtl_tLeftDuct = ACSen_sFootDuctTempFilter;
      break;

     case BlowerModes_DeforstMode:
      /* Switch: '<S175>/Switch' incorporates:
       *  Constant: '<S226>/Constant1'
       *  MultiPortSwitch: '<S226>/Multiport Switch2'
       */
      ACCtl_tLeftDuct = 0.0F;
      break;

     default:
      /* Switch: '<S175>/Switch' incorporates:
       *  Constant: '<S226>/Constant1'
       *  MultiPortSwitch: '<S226>/Multiport Switch2'
       */
      ACCtl_tLeftDuct = 0.0F;
      break;
    }

    /* End of MultiPortSwitch: '<S226>/Multiport Switch2' */
  }

  /* End of Switch: '<S175>/Switch' */

  /* Switch: '<S176>/Switch3' incorporates:
   *  RelationalOperator: '<S176>/Relational Operator'
   *  Sum: '<S176>/Add1'
   *  Sum: '<S176>/Add2'
   *  UnitDelay: '<S176>/Unit Delay1'
   */
  if (ACCtl_tDesFrontCabin > ME11_ARID_DEF.UnitDelay1_DSTATE) {
    rtb_Add_ok = ACCtl_tDesFrontCabin - ME11_ARID_DEF.UnitDelay1_DSTATE;
  } else {
    rtb_Add_ok = ME11_ARID_DEF.UnitDelay1_DSTATE - ACCtl_tDesFrontCabin;
  }

  /* Switch: '<S176>/Switch' incorporates:
   *  Constant: '<S269>/Constant'
   *  RelationalOperator: '<S269>/Compare'
   *  Switch: '<S176>/Switch3'
   */
  if (rtb_Add_ok <= 0.5F) {
    /* Lookup_n-D: '<S676>/cal_SuperHeat_CUR' incorporates:
     *  Constant: '<S176>/Constant'
     */
    rtb_Delay = 0.0F;
  } else {
    /* Lookup_n-D: '<S676>/cal_SuperHeat_CUR' incorporates:
     *  Lookup_n-D: '<S176>/cal_CabinTempDuctUpStepCor_CUR'
     *  Sum: '<S176>/Add7'
     */
    rtb_Delay = look1_iflf_binlca(ACCtl_tLeftDuct - ACSen_sCabinTempFilter, (
      const float32 *)&cal_CabinTempDuctUpStepCor_1X[0], (const float32 *)
      &cal_CabinTempDuctUpStepCor_CUR[0], 9U);
  }

  /* End of Switch: '<S176>/Switch' */

  /* Switch: '<S274>/Init' incorporates:
   *  Logic: '<S274>/FixPt Logical Operator'
   *  UnitDelay: '<S274>/FixPt Unit Delay2'
   */
  if (rtb_AND_b3z || (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_j != 0)) {
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_m = ACSen_sCabinTempFilter;
  }

  /* Gain: '<S8>/Gain8' incorporates:
   *  Sum: '<S176>/Add'
   *  Switch: '<S274>/Init'
   */
  rtb_Delay1_ie = ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_m + rtb_Delay;

  /* Saturate: '<S176>/Saturation' */
  if (rtb_Delay1_ie > 80.0F) {
    ME11_ARID_DEF.UnitDelay1_DSTATE = 80.0F;
  } else if (rtb_Delay1_ie < -40.0F) {
    ME11_ARID_DEF.UnitDelay1_DSTATE = -40.0F;
  } else {
    ME11_ARID_DEF.UnitDelay1_DSTATE = rtb_Delay1_ie;
  }

  /* End of Saturate: '<S176>/Saturation' */

  /* Switch: '<S176>/Switch2' incorporates:
   *  Constant: '<S176>/Constant1'
   */
  if (cal_CabinTCorSelect != 0) {
    /* Switch: '<S176>/Switch2' incorporates:
     *  UnitDelay: '<S176>/Unit Delay1'
     */
    GlbDa_tCabinInvent = ME11_ARID_DEF.UnitDelay1_DSTATE;
  } else {
    /* Switch: '<S176>/Switch2' */
    GlbDa_tCabinInvent = ACSen_sCabinTempFilter;
  }

  /* End of Switch: '<S176>/Switch2' */

  /* Outputs for Enabled SubSystem: '<S184>/PID_CalDVT_FIX' incorporates:
   *  EnablePort: '<S187>/Enable'
   */
  /* Constant: '<S184>/Constant' */
  if (cal_FixPIDSecletFlag) {
    /* Sum: '<S187>/Add2' incorporates:
     *  Sum: '<S189>/Sum'
     */
    rtb_Delay = ACCtl_tDesFrontCabin - GlbDa_tCabinInvent;

    /* Constant: '<S187>/Constant7' */
    ACCtl_DVTIDeadBand = cal_DvtDesValPIDIntegDeadBand;

    /* Chart: '<S189>/deadzone' incorporates:
     *  Constant: '<S187>/Constant20'
     */
    ME11_deadzone(rtb_Delay, 0.5F, &rtb_flag_ko);

    /* RelationalOperator: '<S189>/Relational Operator' */
    ACCtl_tErrDVTFlag = (ACCtl_tDesFrontCabin >= GlbDa_tCabinInvent);

    /* Switch: '<S189>/Switch1' incorporates:
     *  Switch: '<S189>/Switch'
     */
    if (rtb_flag_ko) {
      /* Switch: '<S189>/Switch1' incorporates:
       *  Constant: '<S189>/Constant'
       */
      ACCtl_tErrDVT = 0.0F;
    } else if (ACCtl_tErrDVTFlag) {
      /* Switch: '<S189>/Switch' incorporates:
       *  Switch: '<S189>/Switch1'
       */
      ACCtl_tErrDVT = rtb_Delay;
    } else {
      /* Switch: '<S189>/Switch1' incorporates:
       *  Sum: '<S189>/Sum1'
       *  Switch: '<S189>/Switch'
       */
      ACCtl_tErrDVT = GlbDa_tCabinInvent - ACCtl_tDesFrontCabin;
    }

    /* End of Switch: '<S189>/Switch1' */

    /* Lookup_n-D: '<S187>/cal_DvtDesValPIDKi_CUR' incorporates:
     *  Sum: '<S187>/Add2'
     */
    rtb_Add_ok = look1_iflf_binlca(rtb_Delay, (const float32 *)
      &cal_DvtDesValPIDKi_1X[0], (const float32 *)&cal_DvtDesValPIDKi_CUR[0], 8U);

    /* Outputs for Enabled SubSystem: '<S192>/P_NEG' */
    /* Logic: '<S192>/Logical Operator' incorporates:
     *  Constant: '<S187>/Kp7'
     */
    ME11_P_NEG(!ACCtl_tErrDVTFlag, ACCtl_tErrDVT, ACCtl_DVTIDeadBand, rtb_Add_ok,
               cal_DvtDesValPID_Ki, (float32 *)&ACCtl_tDvtICor);

    /* End of Outputs for SubSystem: '<S192>/P_NEG' */

    /* Outputs for Enabled SubSystem: '<S192>/P_POS' */
    /* Constant: '<S187>/Kp7' */
    ME11_P_POS(ACCtl_tErrDVTFlag, ACCtl_tErrDVT, ACCtl_DVTIDeadBand, rtb_Add_ok,
               cal_DvtDesValPID_Ki, (float32 *)&ACCtl_tDvtICor);

    /* End of Outputs for SubSystem: '<S192>/P_POS' */

    /* Switch: '<S187>/Switch' incorporates:
     *  Constant: '<S187>/Constant17'
     */
    if (ACCtl_tErrDVTFlag) {
      rtb_Add_ok = ACCtl_tErrDVT;
    } else {
      rtb_Add_ok = 0.0F;
    }

    /* Lookup_n-D: '<S187>/cal_PidCabinX_IsumMaxByDVT_CUR' incorporates:
     *  Switch: '<S187>/Switch'
     */
    PidCabinX_IsumMax = look1_iflf_binlca(rtb_Add_ok, (const float32 *)
      &cal_DvtDesIsumMaxByCabinTDiff_1X[0], (const float32 *)
      &cal_DvtDesIsumMaxByCabinTDiff_CUR[0], 7U);

    /* Switch: '<S187>/Switch3' incorporates:
     *  Constant: '<S187>/Constant18'
     */
    if (ACCtl_tErrDVTFlag) {
      rtb_Add_ok = 0.0F;
    } else {
      rtb_Add_ok = ACCtl_tErrDVT;
    }

    /* Lookup_n-D: '<S187>/cal_PidCabinX_IsumMinByDVT_CUR' incorporates:
     *  Switch: '<S187>/Switch3'
     */
    PidCabinX_IsumMin = look1_iflf_binlca(rtb_Add_ok, (const float32 *)
      &cal_DvtDesIsumMinByCabinTDiff_1X[0], (const float32 *)
      &cal_DvtDesIsumMinByCabinTDiff_CUR[0], 7U);

    /* Switch: '<S188>/Switch1' */
    if (rtb_Delay_mz3) {
      /* MultiPortSwitch: '<S192>/Multiport Switch' incorporates:
       *  Delay: '<S192>/Delay'
       */
      switch (ME11_ARID_DEF.Delay_DSTATE_e1) {
       case 0:
        /* Switch: '<S196>/Switch' */
        if (ACCtl_tErrDVTFlag) {
          /* Switch: '<S193>/Switch2' incorporates:
           *  Delay: '<S188>/Delay'
           *  Sum: '<S196>/Add'
           *  Switch: '<S196>/Switch'
           */
          ACCtl_tDvtISum = ACCtl_tDvtISum + ACCtl_tDvtICor;
        } else {
          /* Switch: '<S193>/Switch2' incorporates:
           *  Delay: '<S188>/Delay'
           *  Sum: '<S196>/Add1'
           *  Switch: '<S196>/Switch'
           */
          ACCtl_tDvtISum = ACCtl_tDvtISum - ACCtl_tDvtICor;
        }

        /* End of Switch: '<S196>/Switch' */
        break;

       case 1:
        /* Switch: '<S197>/Switch' */
        if (!ACCtl_tErrDVTFlag) {
          /* Switch: '<S193>/Switch2' incorporates:
           *  Delay: '<S188>/Delay'
           *  Sum: '<S197>/Add1'
           *  Switch: '<S197>/Switch'
           */
          ACCtl_tDvtISum = ACCtl_tDvtISum - ACCtl_tDvtICor;
        }

        /* End of Switch: '<S197>/Switch' */
        break;

       case 2:
        /* Switch: '<S194>/Switch' */
        if (ACCtl_tErrDVTFlag) {
          /* Switch: '<S193>/Switch2' incorporates:
           *  Delay: '<S188>/Delay'
           *  Sum: '<S194>/Add'
           *  Switch: '<S194>/Switch'
           */
          ACCtl_tDvtISum = ACCtl_tDvtISum + ACCtl_tDvtICor;
        }

        /* End of Switch: '<S194>/Switch' */
        break;

       case 3:
        break;
      }

      /* End of MultiPortSwitch: '<S192>/Multiport Switch' */

      /* Switch: '<S193>/Switch2' incorporates:
       *  RelationalOperator: '<S193>/LowerRelop1'
       *  RelationalOperator: '<S193>/UpperRelop'
       *  Sum: '<S188>/Add'
       *  Switch: '<S193>/Switch'
       */
      if (ACCtl_tDvtISum > PidCabinX_IsumMax) {
        /* Switch: '<S188>/Switch1' incorporates:
         *  Switch: '<S193>/Switch2'
         */
        ACCtl_tDvtISum = PidCabinX_IsumMax;
      } else if (ACCtl_tDvtISum < PidCabinX_IsumMin) {
        /* Switch: '<S193>/Switch' incorporates:
         *  Switch: '<S188>/Switch1'
         *  Switch: '<S193>/Switch2'
         */
        ACCtl_tDvtISum = PidCabinX_IsumMin;
      }

      /* End of Switch: '<S193>/Switch2' */
    } else {
      /* Switch: '<S188>/Switch1' incorporates:
       *  Constant: '<S187>/Constant5'
       */
      ACCtl_tDvtISum = 0.0F;
    }

    /* End of Switch: '<S188>/Switch1' */

    /* Outputs for Enabled SubSystem: '<S190>/PI_Controller1' */
    /* Logic: '<S190>/Logical Operator' */
    ME11_PI_Controller1(!rtb_Delay_mz3, ACCtl_tDVTFeedfoward, (float32 *)
                        &ACCtl_tDVTPIBas, (uint8 *)&ACCtl_stDvtPIDFreez);

    /* End of Outputs for SubSystem: '<S190>/PI_Controller1' */

    /* Lookup_n-D: '<S187>/cal_DvtDesValPIDKp_CUR' incorporates:
     *  Sum: '<S187>/Add2'
     */
    rtb_Delay = look1_iflf_binlca(rtb_Delay, (const float32 *)
      &cal_DvtDesValPIDKp_1X[0], (const float32 *)&cal_DvtDesValPIDKp_CUR[0], 8U);

    /* Outputs for Enabled SubSystem: '<S191>/P_NEG' */
    /* Logic: '<S191>/Logical Operator' incorporates:
     *  Constant: '<S187>/Kp'
     *  Constant: '<S187>/Kp4'
     */
    ME11_P_NEG_h(!ACCtl_tErrDVTFlag, ACCtl_tErrDVT, cal_DvtDesValPID_pWinNeg,
                 rtb_Delay, cal_DvtDesValPID_Kp, (float32 *)&ACCtl_tDvtPCor);

    /* End of Outputs for SubSystem: '<S191>/P_NEG' */

    /* Outputs for Enabled SubSystem: '<S191>/P_POS' */
    /* Constant: '<S187>/Kp3' incorporates:
     *  Constant: '<S187>/Kp'
     */
    ME11_P_POS_c(ACCtl_tErrDVTFlag, ACCtl_tErrDVT, cal_DvtDesValPID_pWinPos,
                 rtb_Delay, cal_DvtDesValPID_Kp, (float32 *)&ACCtl_tDvtPCor);

    /* End of Outputs for SubSystem: '<S191>/P_POS' */

    /* Switch: '<S187>/Switch8' incorporates:
     *  Constant: '<S187>/Constant19'
     */
    if (ACCtl_tErrDVTFlag) {
      rtb_Add_ok = ACCtl_tErrDVT;
    } else {
      rtb_Add_ok = 0.0F;
    }

    /* Lookup_n-D: '<S187>/cal_DvtDesLmtByCabinTDiff_MAP' incorporates:
     *  Switch: '<S1085>/Switch'
     *  Switch: '<S187>/Switch8'
     */
    AC_PidCabinT_UL = look2_iflf_binlca(rtb_Add_ok, ACSen_sEnvTempCor, (const
      float32 *)&cal_DvtDesLmtByCabinTDiff_2X[0], (const float32 *)
      &cal_DvtDesLmtByCabinTDiff_2Y[0], (const float32 *)
      &cal_DvtDesLmtByCabinTDiff_MAP[0], ME11_ConstP.pooled36, 10U);

    /* Outputs for Enabled SubSystem: '<S190>/PI_Controller' */
    /* Constant: '<S187>/Kp6' */
    ME11_PI_Controller(rtb_Delay_mz3, ACCtl_tErrDVTFlag, ACCtl_tDVTFeedfoward,
                       ACCtl_tDvtPCor, ACCtl_tDvtISum, AC_PidCabinT_UL,
                       cal_DvtDesValPID_LL, (float32 *)&ACCtl_tDVTPIBas, (uint8 *)
                       &ACCtl_stDvtPIDFreez);

    /* End of Outputs for SubSystem: '<S190>/PI_Controller' */

    /* Update for Delay: '<S192>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_e1 = ACCtl_stDvtPIDFreez;
  }

  /* End of Constant: '<S184>/Constant' */
  /* End of Outputs for SubSystem: '<S184>/PID_CalDVT_FIX' */

  /* Switch: '<S220>/Init' incorporates:
   *  DataTypeConversion: '<S181>/Data Type Conversion'
   *  UnitDelay: '<S220>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_e != 0) {
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_d = AC_rSolarRight;
  }

  /* Product: '<S219>/Product' incorporates:
   *  Constant: '<S181>/ACCtrl_facSolarFlt_C'
   *  DataTypeConversion: '<S181>/Data Type Conversion'
   */
  rtb_Delay = (float32)AC_rSolarRight * cal_U_DVTFFSolarFilterRate;

  /* Switch: '<S220>/Init' incorporates:
   *  Constant: '<S181>/ACCtrl_facSolarFlt_C'
   *  Constant: '<S219>/Constant'
   *  Product: '<S219>/Product'
   *  Product: '<S219>/Product1'
   *  Sum: '<S219>/Sum'
   *  Sum: '<S219>/Sum1'
   *  UnitDelay: '<S220>/FixPt Unit Delay1'
   */
  ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_d = (1.0F - cal_U_DVTFFSolarFilterRate) *
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_d + rtb_Delay;

  /* DataTypeConversion: '<S181>/Data Type Conversion1' incorporates:
   *  UnitDelay: '<S220>/FixPt Unit Delay1'
   */
  GlbDa_LeftSolar = (uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_d;

  /* Lookup_n-D: '<S181>/cal_ACDrDVTSolarCor_MAP' incorporates:
   *  DataTypeConversion: '<S181>/Data Type Conversion1'
   *  Switch: '<S1085>/Switch'
   */
  ACCtl_tDrDVTSolarCor = look2_iu16flftf_binlca(GlbDa_LeftSolar,
    ACSen_sEnvTempCor, (const uint16 *)&cal_ACDrDVTSolarCor_2X[0], (const
    float32 *)&cal_ACDrDVTSolarCor_2Y[0], (const float32 *)
    &cal_ACDrDVTSolarCor_MAP[0], ME11_ConstP.pooled35, 15U);

  /* Switch: '<S181>/Switch3' incorporates:
   *  Switch: '<S181>/Switch2'
   */
  if (HMICtl_bLeftSetLow) {
    /* Switch: '<S181>/Switch3' incorporates:
     *  Constant: '<S181>/Kp2'
     */
    ACCtl_tDrDVT = cal_DvtDesValPID_LL;
  } else if (HMICtl_bLeftSetHigh) {
    /* Switch: '<S181>/Switch3' incorporates:
     *  Constant: '<S181>/Kp1'
     *  Switch: '<S181>/Switch2'
     */
    ACCtl_tDrDVT = cal_DvtDesValPID_UL;
  } else {
    /* Sum: '<S181>/Pass_dvt_sum2' incorporates:
     *  Switch: '<S181>/Switch2'
     */
    ACCtl_tDrDVT = ACCtl_tDrDVTSolarCor + ACCtl_tDVTPIBas;

    /* Switch: '<S218>/Switch2' incorporates:
     *  Constant: '<S181>/Kp5'
     *  Constant: '<S181>/Kp6'
     *  RelationalOperator: '<S218>/LowerRelop1'
     *  RelationalOperator: '<S218>/UpperRelop'
     *  Switch: '<S181>/Switch2'
     *  Switch: '<S218>/Switch'
     */
    if (ACCtl_tDrDVT > cal_DvtDesValPID_UL) {
      /* Switch: '<S181>/Switch3' incorporates:
       *  Switch: '<S218>/Switch2'
       */
      ACCtl_tDrDVT = cal_DvtDesValPID_UL;
    } else if (ACCtl_tDrDVT < cal_DvtDesValPID_LL) {
      /* Switch: '<S218>/Switch' incorporates:
       *  Constant: '<S181>/Kp6'
       *  Switch: '<S181>/Switch3'
       *  Switch: '<S218>/Switch2'
       */
      ACCtl_tDrDVT = cal_DvtDesValPID_LL;
    }

    /* End of Switch: '<S218>/Switch2' */
  }

  /* End of Switch: '<S181>/Switch3' */

  /* Switch: '<S223>/Init' incorporates:
   *  Constant: '<S182>/ACCtrl_facSolarFlt_C'
   *  Constant: '<S222>/Constant'
   *  DataTypeConversion: '<S182>/Data Type Conversion1'
   *  Product: '<S219>/Product'
   *  Product: '<S222>/Product1'
   *  Sum: '<S222>/Sum'
   *  Sum: '<S222>/Sum1'
   *  UnitDelay: '<S223>/FixPt Unit Delay1'
   *  UnitDelay: '<S223>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_k != 0) {
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_md = AC_rSolarRight;
  }

  ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_md = (1.0F - cal_U_DVTFFSolarFilterRate) *
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_md + rtb_Delay;

  /* End of Switch: '<S223>/Init' */

  /* DataTypeConversion: '<S182>/Data Type Conversion' incorporates:
   *  UnitDelay: '<S223>/FixPt Unit Delay1'
   */
  GlbDa_RightSolar = (uint16)ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_md;

  /* Sum: '<S182>/Sum2' */
  AC_Ps2DrSetTempDvt = ACCtl_tRightSetPointModeCor - HMICtl_sLeftSetPoint;

  /* Lookup_n-D: '<S182>/cal_ACPsDVTSetCorByEnv_MAP' incorporates:
   *  Sum: '<S182>/Sum2'
   *  Switch: '<S1085>/Switch'
   */
  ACCtl_tPsDVTCabinCor = look2_iflf_binlca(AC_Ps2DrSetTempDvt, ACSen_sEnvTempCor,
    (const float32 *)&cal_ACPsDVTSetCorByEnv_2X[0], (const float32 *)
    &cal_ACPsDVTSetCorByEnv_2Y[0], (const float32 *)&cal_ACPsDVTSetCorByEnv_MAP
    [0], ME11_ConstP.pooled40, 14U);

  /* Lookup_n-D: '<S182>/cal_ACPsDVTSolarCor_MAP' incorporates:
   *  DataTypeConversion: '<S182>/Data Type Conversion'
   *  Switch: '<S1085>/Switch'
   */
  ACCtl_tPsDVTSolarCor = look2_iu16flftf_binlca(GlbDa_RightSolar,
    ACSen_sEnvTempCor, (const uint16 *)&cal_ACPsDVTSolarCor_2X[0], (const
    float32 *)&cal_ACPsDVTSolarCor_2Y[0], (const float32 *)
    &cal_ACPsDVTSolarCor_MAP[0], ME11_ConstP.pooled35, 15U);

  /* Switch: '<S182>/Switch1' incorporates:
   *  Switch: '<S182>/Switch'
   */
  if (HMICtl_bLeftSetLow) {
    /* Switch: '<S182>/Switch1' incorporates:
     *  Constant: '<S182>/Kp2'
     */
    ACCtl_tPsDVT = cal_DvtDesValPID_LL;
  } else if (HMICtl_bLeftSetHigh) {
    /* Switch: '<S182>/Switch1' incorporates:
     *  Constant: '<S182>/Kp1'
     *  Switch: '<S182>/Switch'
     */
    ACCtl_tPsDVT = cal_DvtDesValPID_UL;
  } else {
    /* Sum: '<S182>/sum1' incorporates:
     *  Sum: '<S182>/sum'
     *  Switch: '<S182>/Switch'
     */
    ACCtl_tPsDVT = (ACCtl_tPsDVTCabinCor + ACCtl_tPsDVTSolarCor) +
      ACCtl_tDVTPIBas;

    /* Switch: '<S221>/Switch2' incorporates:
     *  Constant: '<S182>/Kp5'
     *  Constant: '<S182>/Kp6'
     *  RelationalOperator: '<S221>/LowerRelop1'
     *  RelationalOperator: '<S221>/UpperRelop'
     *  Switch: '<S182>/Switch'
     *  Switch: '<S221>/Switch'
     */
    if (ACCtl_tPsDVT > cal_DvtDesValPID_UL) {
      /* Switch: '<S182>/Switch1' incorporates:
       *  Switch: '<S221>/Switch2'
       */
      ACCtl_tPsDVT = cal_DvtDesValPID_UL;
    } else if (ACCtl_tPsDVT < cal_DvtDesValPID_LL) {
      /* Switch: '<S221>/Switch' incorporates:
       *  Constant: '<S182>/Kp6'
       *  Switch: '<S182>/Switch1'
       *  Switch: '<S221>/Switch2'
       */
      ACCtl_tPsDVT = cal_DvtDesValPID_LL;
    }

    /* End of Switch: '<S221>/Switch2' */
  }

  /* End of Switch: '<S182>/Switch1' */

  /* MinMax: '<S183>/MinMax' */
  if (ACCtl_tPsDVT >= ACCtl_tDrDVT) {
    /* Lookup_n-D: '<S676>/cal_SuperHeat_CUR' */
    rtb_Delay = ACCtl_tPsDVT;
  } else {
    /* Lookup_n-D: '<S676>/cal_SuperHeat_CUR' */
    rtb_Delay = ACCtl_tDrDVT;
  }

  /* End of MinMax: '<S183>/MinMax' */

  /* Switch: '<S225>/Init' incorporates:
   *  Constant: '<S183>/Constant'
   *  Constant: '<S224>/Constant'
   *  Product: '<S224>/Product'
   *  Product: '<S224>/Product1'
   *  Sum: '<S224>/Sum'
   *  Sum: '<S224>/Sum1'
   *  UnitDelay: '<S225>/FixPt Unit Delay1'
   *  UnitDelay: '<S225>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_kj != 0) {
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn = rtb_Delay;
  }

  ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn = (1.0F - cal_DvtCoff) *
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn + rtb_Delay * cal_DvtCoff;

  /* End of Switch: '<S225>/Init' */

  /* Delay: '<S228>/Delay1' */
  rtb_Switch2_ip = ME11_ARID_DEF.Delay1_DSTATE_hx;

  /* Outputs for Enabled SubSystem: '<S335>/CalAirCondPTCAimTemp_FIXPID' incorporates:
   *  EnablePort: '<S342>/Enable'
   */
  /* Outputs for Enabled SubSystem: '<S275>/CalAirCondEvapAimTemp_FIXPID' incorporates:
   *  EnablePort: '<S281>/Enable'
   */
  /* Sum: '<S232>/Sum' incorporates:
   *  Sum: '<S285>/Sum'
   *  Sum: '<S345>/Sum'
   */
  rtb_Gain6 = ACCtl_tDrDVT - ACCtl_tLeftDuct;

  /* End of Outputs for SubSystem: '<S275>/CalAirCondEvapAimTemp_FIXPID' */
  /* End of Outputs for SubSystem: '<S335>/CalAirCondPTCAimTemp_FIXPID' */

  /* Chart: '<S232>/deadzone' incorporates:
   *  Constant: '<S228>/Constant'
   *  Sum: '<S232>/Sum'
   */
  ME11_deadzone_h(rtb_Gain6, 0.5, &rtb_flag_de);

  /* RelationalOperator: '<S232>/Relational Operator' */
  rtb_Delay_j3 = (ACCtl_tDrDVT >= ACCtl_tLeftDuct);

  /* Switch: '<S232>/Switch1' incorporates:
   *  Switch: '<S232>/Switch'
   */
  if (rtb_flag_de) {
    /* Switch: '<S232>/Switch1' incorporates:
     *  Constant: '<S232>/Constant'
     */
    rtb_Delay = 0.0F;
  } else if (rtb_Delay_j3) {
    /* Switch: '<S232>/Switch' incorporates:
     *  Sum: '<S232>/Sum'
     *  Switch: '<S232>/Switch1'
     */
    rtb_Delay = rtb_Gain6;
  } else {
    /* Switch: '<S232>/Switch1' incorporates:
     *  Sum: '<S232>/Sum1'
     *  Switch: '<S232>/Switch'
     */
    rtb_Delay = ACCtl_tLeftDuct - ACCtl_tDrDVT;
  }

  /* End of Switch: '<S232>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S235>/P_NEG' */
  /* Logic: '<S235>/Logical Operator' incorporates:
   *  Constant: '<S228>/Kp11'
   *  Constant: '<S228>/Kp7'
   *  Constant: '<S228>/Kp9'
   */
  ME11_P_NEG(!rtb_Delay_j3, rtb_Delay, cal_DcutTPidDeadBand,
             cal_DcutTempPid_KiNeg, cal_DcutTempPid_Ki, &rtb_Merge1);

  /* End of Outputs for SubSystem: '<S235>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S235>/P_POS' */
  /* Constant: '<S228>/Kp11' incorporates:
   *  Constant: '<S228>/Kp10'
   *  Constant: '<S228>/Kp7'
   */
  ME11_P_POS(rtb_Delay_j3, rtb_Delay, cal_DcutTPidDeadBand,
             cal_DcutTempPid_KiPos, cal_DcutTempPid_Ki, &rtb_Merge1);

  /* End of Outputs for SubSystem: '<S235>/P_POS' */

  /* Logic: '<S1338>/E' incorporates:
   *  Constant: '<S229>/1 - DEFROST'
   *  Constant: '<S229>/Constant'
   *  Delay: '<S4>/Delay'
   *  Logic: '<S229>/Logical Operator2'
   *  Logic: '<S229>/Logical Operator3'
   *  RelationalOperator: '<S229>/Relational Operator'
   *  RelationalOperator: '<S229>/Relational Operator1'
   */
  FixPtRelationalOperator = ((ME11_ARID_DEF.Delay_DSTATE_fl !=
    BlowerModes_DeforstMode) && ((ME11_ARID_DEF.Switch1_nv != ACOff) &&
    ME11_ARID_DEF.Switch_c));

  /* Logic: '<S229>/Logical Operator' incorporates:
   *  Logic: '<S175>/Logical Operator'
   *  Logic: '<S229>/Logical Operator4'
   */
  rtb_AND1_hh = !rtb_FixPtRelationalOperator_a0;

  /* Logic: '<S229>/Logical Operator1' incorporates:
   *  Logic: '<S229>/Logical Operator'
   */
  rtb_FixPtRelationalOperator_mk = (rtb_AND1_hh && FixPtRelationalOperator);

  /* Switch: '<S231>/Switch1' incorporates:
   *  Constant: '<S228>/Constant5'
   *  Delay: '<S231>/Delay'
   */
  if (rtb_FixPtRelationalOperator_mk) {
    /* MultiPortSwitch: '<S235>/Multiport Switch' incorporates:
     *  Delay: '<S235>/Delay'
     */
    switch (ME11_ARID_DEF.Delay_DSTATE_o3) {
     case 0:
      /* Switch: '<S239>/Switch' */
      if (rtb_Delay_j3) {
        /* Switch: '<S236>/Switch2' incorporates:
         *  Delay: '<S231>/Delay'
         *  Sum: '<S239>/Add'
         *  Switch: '<S239>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_m += rtb_Merge1;
      } else {
        /* Switch: '<S236>/Switch2' incorporates:
         *  Delay: '<S231>/Delay'
         *  Sum: '<S239>/Add1'
         *  Switch: '<S239>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_m -= rtb_Merge1;
      }

      /* End of Switch: '<S239>/Switch' */
      break;

     case 1:
      /* Switch: '<S240>/Switch' */
      if (!rtb_Delay_j3) {
        /* Switch: '<S236>/Switch2' incorporates:
         *  Delay: '<S231>/Delay'
         *  Sum: '<S240>/Add1'
         *  Switch: '<S240>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_m -= rtb_Merge1;
      }

      /* End of Switch: '<S240>/Switch' */
      break;

     case 2:
      /* Switch: '<S237>/Switch' */
      if (rtb_Delay_j3) {
        /* Switch: '<S236>/Switch2' incorporates:
         *  Delay: '<S231>/Delay'
         *  Sum: '<S237>/Add'
         *  Switch: '<S237>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_m += rtb_Merge1;
      }

      /* End of Switch: '<S237>/Switch' */
      break;

     case 3:
      break;
    }

    /* End of MultiPortSwitch: '<S235>/Multiport Switch' */

    /* Switch: '<S236>/Switch2' incorporates:
     *  Constant: '<S228>/Constant5'
     *  Constant: '<S228>/Kp13'
     *  Constant: '<S228>/Kp8'
     *  RelationalOperator: '<S236>/LowerRelop1'
     *  RelationalOperator: '<S236>/UpperRelop'
     *  Sum: '<S231>/Add'
     *  Switch: '<S236>/Switch'
     */
    if ((ME11_ARID_DEF.Delay_DSTATE_m - 8000.0F) + 8000.0F >
        cal_DcutTempPid_IsumMax) {
      /* Delay: '<S231>/Delay' incorporates:
       *  Switch: '<S236>/Switch2'
       */
      ME11_ARID_DEF.Delay_DSTATE_m = cal_DcutTempPid_IsumMax;
    } else if ((ME11_ARID_DEF.Delay_DSTATE_m - 8000.0F) + 8000.0F <
               cal_DcutTempPid_IsumMin) {
      /* Switch: '<S236>/Switch' incorporates:
       *  Constant: '<S228>/Kp13'
       *  Delay: '<S231>/Delay'
       *  Switch: '<S236>/Switch2'
       */
      ME11_ARID_DEF.Delay_DSTATE_m = cal_DcutTempPid_IsumMin;
    } else {
      /* Delay: '<S231>/Delay' incorporates:
       *  Switch: '<S236>/Switch2'
       */
      ME11_ARID_DEF.Delay_DSTATE_m = (ME11_ARID_DEF.Delay_DSTATE_m - 8000.0F) +
        8000.0F;
    }

    /* End of Switch: '<S236>/Switch2' */
  } else {
    ME11_ARID_DEF.Delay_DSTATE_m = 0.0F;
  }

  /* End of Switch: '<S231>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S233>/PI_Controller1' */
  /* Logic: '<S233>/Logical Operator' incorporates:
   *  Constant: '<S175>/Constant2'
   */
  ME11_PI_Controller1(!rtb_FixPtRelationalOperator_mk, 0.0F, &rtb_Merge1,
                      &rtb_IFreezFlag);

  /* End of Outputs for SubSystem: '<S233>/PI_Controller1' */

  /* Outputs for Enabled SubSystem: '<S234>/P_NEG' */
  /* Logic: '<S234>/Logical Operator' incorporates:
   *  Constant: '<S228>/Kp'
   *  Constant: '<S228>/Kp1'
   *  Constant: '<S228>/Kp4'
   */
  ME11_P_NEG_h(!rtb_Delay_j3, rtb_Delay, cal_DcutTempPid_pWinNeg,
               cal_DcutTempPid_KpNeg, cal_DcutTempPid_Kp, &rtb_Merge);

  /* End of Outputs for SubSystem: '<S234>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S234>/P_POS' */
  /* Constant: '<S228>/Kp3' incorporates:
   *  Constant: '<S228>/Kp'
   *  Constant: '<S228>/Kp2'
   */
  ME11_P_POS_c(rtb_Delay_j3, rtb_Delay, cal_DcutTempPid_pWinPos,
               cal_DcutTempPid_KpPos, cal_DcutTempPid_Kp, &rtb_Merge);

  /* End of Outputs for SubSystem: '<S234>/P_POS' */

  /* Outputs for Enabled SubSystem: '<S233>/PI_Controller' */
  /* Constant: '<S175>/Constant5' incorporates:
   *  Constant: '<S228>/Kp5'
   *  Constant: '<S228>/Kp6'
   *  Delay: '<S231>/Delay'
   */
  ME11_PI_Controller(rtb_FixPtRelationalOperator_mk, rtb_Delay_j3, 0.0F,
                     rtb_Merge, ME11_ARID_DEF.Delay_DSTATE_m, cal_DcutTempPidUL,
                     cal_DcutTempPidLL, &rtb_Merge1, &rtb_IFreezFlag);

  /* End of Outputs for SubSystem: '<S233>/PI_Controller' */

  /* Logic: '<S229>/Logical Operator5' */
  rtb_Delay1_ag = (FixPtRelationalOperator && rtb_AND1_hh);

  /* Delay: '<S230>/Delay1' */
  rtb_Switch1_l2 = ME11_ARID_DEF.Delay1_DSTATE_e0;

  /* Switch: '<S175>/Switch1' */
  if (rtb_FixPtRelationalOperator_a0) {
    /* Switch: '<S175>/Switch1' incorporates:
     *  Constant: '<S175>/cal_PsDuctSensorFailDefault'
     */
    ACCtl_tRightDuct = cal_PsDuctSensorFailDeflt;
  } else {
    /* MultiPortSwitch: '<S227>/Multiport Switch2' incorporates:
     *  Delay: '<S4>/Delay'
     */
    switch (ME11_ARID_DEF.Delay_DSTATE_fl) {
     case BlowerModes_FaceMode:
      /* Switch: '<S175>/Switch1' incorporates:
       *  MultiPortSwitch: '<S227>/Multiport Switch2'
       */
      ACCtl_tRightDuct = ACSen_sFaceDuctTempFilter;
      break;

     case BlowerModes_FaceHeaterMode:
      /* Switch: '<S175>/Switch1' incorporates:
       *  Constant: '<S227>/Constant3'
       *  Constant: '<S227>/Constant4'
       *  MultiPortSwitch: '<S227>/Multiport Switch2'
       *  Product: '<S227>/Product'
       *  Product: '<S227>/Product1'
       *  Sum: '<S227>/Add'
       */
      ACCtl_tRightDuct = ACSen_sFaceDuctTempFilter * cal_PsDuctFaceFloorFaFactor
        + ACSen_sFootDuctTempFilter * cal_PsDuctFaceFloorFoFactor;
      break;

     case BlowerModes_HeaterMode:
      /* Switch: '<S175>/Switch1' incorporates:
       *  MultiPortSwitch: '<S227>/Multiport Switch2'
       */
      ACCtl_tRightDuct = ACSen_sFootDuctTempFilter;
      break;

     case BlowerModes_HeaterDeforstMode:
      /* Switch: '<S175>/Switch1' incorporates:
       *  MultiPortSwitch: '<S227>/Multiport Switch2'
       */
      ACCtl_tRightDuct = ACSen_sFootDuctTempFilter;
      break;

     case BlowerModes_DeforstMode:
      /* Switch: '<S175>/Switch1' incorporates:
       *  Constant: '<S227>/Constant1'
       *  MultiPortSwitch: '<S227>/Multiport Switch2'
       */
      ACCtl_tRightDuct = 0.0F;
      break;

     default:
      /* Switch: '<S175>/Switch1' incorporates:
       *  Constant: '<S227>/Constant1'
       *  MultiPortSwitch: '<S227>/Multiport Switch2'
       */
      ACCtl_tRightDuct = 0.0F;
      break;
    }

    /* End of MultiPortSwitch: '<S227>/Multiport Switch2' */
  }

  /* End of Switch: '<S175>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S336>/CalAirCondPTCAimTemp_LeftDes' incorporates:
   *  EnablePort: '<S364>/Enable'
   */
  /* Outputs for Enabled SubSystem: '<S276>/CalAirCondEvapAimTemp_RightDes' incorporates:
   *  EnablePort: '<S306>/Enable'
   */
  /* Sum: '<S251>/Sum' incorporates:
   *  Sum: '<S311>/Sum'
   *  Sum: '<S367>/Sum'
   */
  rtb_Delay = ACCtl_tPsDVT - ACCtl_tRightDuct;

  /* End of Outputs for SubSystem: '<S276>/CalAirCondEvapAimTemp_RightDes' */
  /* End of Outputs for SubSystem: '<S336>/CalAirCondPTCAimTemp_LeftDes' */

  /* Chart: '<S251>/deadzone' incorporates:
   *  Constant: '<S230>/Constant'
   *  Sum: '<S251>/Sum'
   */
  ME11_deadzone_h(rtb_Delay, 0.5, &rtb_flag_g4);

  /* RelationalOperator: '<S251>/Relational Operator' */
  FixPtRelationalOperator = (ACCtl_tPsDVT >= ACCtl_tRightDuct);

  /* Switch: '<S251>/Switch1' incorporates:
   *  Switch: '<S251>/Switch'
   */
  if (rtb_flag_g4) {
    /* Switch: '<S251>/Switch1' incorporates:
     *  Constant: '<S251>/Constant'
     */
    rtb_Merge = 0.0F;
  } else if (FixPtRelationalOperator) {
    /* Switch: '<S251>/Switch' incorporates:
     *  Sum: '<S251>/Sum'
     *  Switch: '<S251>/Switch1'
     */
    rtb_Merge = rtb_Delay;
  } else {
    /* Switch: '<S251>/Switch1' incorporates:
     *  Sum: '<S251>/Sum1'
     *  Switch: '<S251>/Switch'
     */
    rtb_Merge = ACCtl_tRightDuct - ACCtl_tPsDVT;
  }

  /* End of Switch: '<S251>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S254>/P_NEG' */
  /* Logic: '<S254>/Logical Operator' incorporates:
   *  Constant: '<S230>/Kp11'
   *  Constant: '<S230>/Kp7'
   *  Constant: '<S230>/Kp9'
   */
  ME11_P_NEG(!FixPtRelationalOperator, rtb_Merge, cal_DcutTPidDeadBand,
             cal_DcutTempPid_KiNeg, cal_DcutTempPid_Ki, &rtb_Merge1_m);

  /* End of Outputs for SubSystem: '<S254>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S254>/P_POS' */
  /* Constant: '<S230>/Kp11' incorporates:
   *  Constant: '<S230>/Kp10'
   *  Constant: '<S230>/Kp7'
   */
  ME11_P_POS(FixPtRelationalOperator, rtb_Merge, cal_DcutTPidDeadBand,
             cal_DcutTempPid_KiPos, cal_DcutTempPid_Ki, &rtb_Merge1_m);

  /* End of Outputs for SubSystem: '<S254>/P_POS' */

  /* Switch: '<S250>/Switch1' incorporates:
   *  Constant: '<S230>/Constant5'
   *  Delay: '<S250>/Delay'
   */
  if (rtb_Delay1_ag) {
    /* MultiPortSwitch: '<S254>/Multiport Switch' incorporates:
     *  Delay: '<S254>/Delay'
     */
    switch (ME11_ARID_DEF.Delay_DSTATE_bf) {
     case 0:
      /* Switch: '<S258>/Switch' */
      if (FixPtRelationalOperator) {
        /* Switch: '<S255>/Switch2' incorporates:
         *  Delay: '<S250>/Delay'
         *  Sum: '<S258>/Add'
         *  Switch: '<S258>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_mf += rtb_Merge1_m;
      } else {
        /* Switch: '<S255>/Switch2' incorporates:
         *  Delay: '<S250>/Delay'
         *  Sum: '<S258>/Add1'
         *  Switch: '<S258>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_mf -= rtb_Merge1_m;
      }

      /* End of Switch: '<S258>/Switch' */
      break;

     case 1:
      /* Switch: '<S259>/Switch' */
      if (!FixPtRelationalOperator) {
        /* Switch: '<S255>/Switch2' incorporates:
         *  Delay: '<S250>/Delay'
         *  Sum: '<S259>/Add1'
         *  Switch: '<S259>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_mf -= rtb_Merge1_m;
      }

      /* End of Switch: '<S259>/Switch' */
      break;

     case 2:
      /* Switch: '<S256>/Switch' */
      if (FixPtRelationalOperator) {
        /* Switch: '<S255>/Switch2' incorporates:
         *  Delay: '<S250>/Delay'
         *  Sum: '<S256>/Add'
         *  Switch: '<S256>/Switch'
         */
        ME11_ARID_DEF.Delay_DSTATE_mf += rtb_Merge1_m;
      }

      /* End of Switch: '<S256>/Switch' */
      break;

     case 3:
      break;
    }

    /* End of MultiPortSwitch: '<S254>/Multiport Switch' */

    /* Switch: '<S255>/Switch2' incorporates:
     *  Constant: '<S230>/Constant5'
     *  Constant: '<S230>/Kp13'
     *  Constant: '<S230>/Kp8'
     *  RelationalOperator: '<S255>/LowerRelop1'
     *  RelationalOperator: '<S255>/UpperRelop'
     *  Sum: '<S250>/Add'
     *  Switch: '<S255>/Switch'
     */
    if ((ME11_ARID_DEF.Delay_DSTATE_mf - 8000.0F) + 8000.0F >
        cal_DcutTempPid_IsumMax) {
      /* Delay: '<S250>/Delay' incorporates:
       *  Switch: '<S255>/Switch2'
       */
      ME11_ARID_DEF.Delay_DSTATE_mf = cal_DcutTempPid_IsumMax;
    } else if ((ME11_ARID_DEF.Delay_DSTATE_mf - 8000.0F) + 8000.0F <
               cal_DcutTempPid_IsumMin) {
      /* Switch: '<S255>/Switch' incorporates:
       *  Constant: '<S230>/Kp13'
       *  Delay: '<S250>/Delay'
       *  Switch: '<S255>/Switch2'
       */
      ME11_ARID_DEF.Delay_DSTATE_mf = cal_DcutTempPid_IsumMin;
    } else {
      /* Delay: '<S250>/Delay' incorporates:
       *  Switch: '<S255>/Switch2'
       */
      ME11_ARID_DEF.Delay_DSTATE_mf = (ME11_ARID_DEF.Delay_DSTATE_mf - 8000.0F)
        + 8000.0F;
    }

    /* End of Switch: '<S255>/Switch2' */
  } else {
    ME11_ARID_DEF.Delay_DSTATE_mf = 0.0F;
  }

  /* End of Switch: '<S250>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S252>/PI_Controller1' */
  /* Logic: '<S252>/Logical Operator' incorporates:
   *  Constant: '<S175>/Constant3'
   */
  ME11_PI_Controller1(!rtb_Delay1_ag, 0.0F, &rtb_Merge1_m, &rtb_IFreezFlag_d);

  /* End of Outputs for SubSystem: '<S252>/PI_Controller1' */

  /* Outputs for Enabled SubSystem: '<S253>/P_NEG' */
  /* Logic: '<S253>/Logical Operator' incorporates:
   *  Constant: '<S230>/Kp'
   *  Constant: '<S230>/Kp1'
   *  Constant: '<S230>/Kp4'
   */
  ME11_P_NEG_h(!FixPtRelationalOperator, rtb_Merge, cal_DcutTempPid_pWinNeg,
               cal_DcutTempPid_KpNeg, cal_DcutTempPid_Kp, &rtb_Merge_g);

  /* End of Outputs for SubSystem: '<S253>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S253>/P_POS' */
  /* Constant: '<S230>/Kp3' incorporates:
   *  Constant: '<S230>/Kp'
   *  Constant: '<S230>/Kp2'
   */
  ME11_P_POS_c(FixPtRelationalOperator, rtb_Merge, cal_DcutTempPid_pWinPos,
               cal_DcutTempPid_KpPos, cal_DcutTempPid_Kp, &rtb_Merge_g);

  /* End of Outputs for SubSystem: '<S253>/P_POS' */

  /* Outputs for Enabled SubSystem: '<S252>/PI_Controller' */
  /* Constant: '<S175>/Constant1' incorporates:
   *  Constant: '<S230>/Kp5'
   *  Constant: '<S230>/Kp6'
   *  Delay: '<S250>/Delay'
   */
  ME11_PI_Controller(rtb_Delay1_ag, FixPtRelationalOperator, 0.0F, rtb_Merge_g,
                     ME11_ARID_DEF.Delay_DSTATE_mf, cal_DcutTempPidUL,
                     cal_DcutTempPidLL, &rtb_Merge1_m, &rtb_IFreezFlag_d);

  /* End of Outputs for SubSystem: '<S252>/PI_Controller' */

  /* Switch: '<S274>/Reset' */
  if (rtb_AND_b3z) {
    /* Switch: '<S274>/Init' incorporates:
     *  UnitDelay: '<S274>/FixPt Unit Delay1'
     */
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_m = ACSen_sCabinTempFilter;
  } else {
    /* Switch: '<S274>/Init' incorporates:
     *  UnitDelay: '<S274>/FixPt Unit Delay1'
     */
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_m = rtb_Delay1_ie;
  }

  /* End of Switch: '<S274>/Reset' */

  /* Sum: '<S178>/Add' incorporates:
   *  Constant: '<S178>/Constant2'
   */
  Eva_CoolingCond1 = ACSen_sEvapTempFilter - cal_TevapLoStepMin;

  /* Sum: '<S178>/Add1' incorporates:
   *  Constant: '<S178>/Constant3'
   */
  Eva_CoolingCond2 = ACSen_sEnvTempCor + cal_ErrAmbTDvtForEvaUL;

  /* Sum: '<S178>/Add2' incorporates:
   *  Constant: '<S178>/Constant4'
   */
  Eva_CloseCond1 = ACSen_sEnvTempCor + cal_ErrAmbTDvtForEvaLL;

  /* Sum: '<S178>/Add3' incorporates:
   *  Constant: '<S178>/Constant5'
   *  Delay: '<S178>/Delay'
   */
  Eva_CooledCond1 = ME11_ARID_DEF.Delay_DSTATE_n + cal_TevapLoStepMin;

  /* Lookup_n-D: '<S282>/cal_EvapDesTempFanCor_CUR' incorporates:
   *  Delay: '<S35>/Delay'
   */
  EvapDesTempDrFanCor = look1_iu8lftf_binlca(ME11_ARID_DEF.Delay_DSTATE_hr, (
    const uint8 *)&cal_EvapDesTempFanCor_1X[0], (const float32 *)
    &cal_EvapDesTempFanCor_CUR[0], 3U);

  /* Lookup_n-D: '<S282>/cal_EvapDesTempEnvCor_MAP' incorporates:
   *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
   *  Switch: '<S1085>/Switch'
   */
  EvapDesTempDrEnvCor = look2_iflf_binlca(ACSen_sEnvTempCor,
    (Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA())
    ->VIPM_ESCVehSpd_kph, (const float32 *)&cal_EvapDesTempEnvCor_2X[0], (const
    float32 *)&cal_EvapDesTempEnvCor_2Y[0], (const float32 *)
    &cal_EvapDesTempEnvCor_MAP[0], ME11_ConstP.pooled38, 6U);

  /* Lookup_n-D: '<S282>/cal_EvapDesTempCabinCor_CUR' incorporates:
   *  Switch: '<S176>/Switch2'
   */
  EvapDesTempDrCabinCor = look1_iflf_binlca(GlbDa_tCabinInvent, (const float32 *)
    &cal_EvapDesTempCabinCor_1X[0], (const float32 *)
    &cal_EvapDesTempCabinCor_CUR[0], 5U);

  /* MultiPortSwitch: '<S282>/Multiport Switch1' incorporates:
   *  Delay: '<S4>/Delay'
   */
  switch (ME11_ARID_DEF.Delay_DSTATE_fl) {
   case BlowerModes_FaceMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S282>/cal_EvapBacTempDesAC_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_EvapBacTempDesAC_1X[0], (const float32 *)&cal_EvapBacTempDesAC_CUR[0],
      5U);
    break;

   case BlowerModes_FaceHeaterMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S282>/cal_EvapBacTempDesACBi_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_EvapBacTempDesACBi_1X[0], (const float32 *)
      &cal_EvapBacTempDesACBi_CUR[0], 5U);
    break;

   case BlowerModes_HeaterMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S282>/cal_EvapBacTempDesFoot_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_EvapBacTempDesFoot_1X[0], (const float32 *)
      &cal_EvapBacTempDesFoot_CUR[0], 5U);
    break;

   case BlowerModes_HeaterDeforstMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S282>/cal_EvapBacTempDesFootDe_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_EvapBacTempDesFootDe_1X[0], (const float32 *)
      &cal_EvapBacTempDesFootDe_CUR[0], 5U);
    break;

   case BlowerModes_DeforstMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S282>/cal_EvapBacTempDesDefog_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_EvapBacTempDesDefog_1X[0], (const float32 *)
      &cal_EvapBacTempDesDefog_CUR[0], 5U);
    break;

   default:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S282>/cal_EvapBacTempDesACBi_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_EvapBacTempDesACBi_1X[0], (const float32 *)
      &cal_EvapBacTempDesACBi_CUR[0], 5U);
    break;
  }

  /* End of MultiPortSwitch: '<S282>/Multiport Switch1' */

  /* Switch: '<S282>/Switch' incorporates:
   *  Constant: '<S282>/Constant2'
   *  RelationalOperator: '<S282>/Relational Operator2'
   */
  if (ACSen_eAirInletPer < cal_ACRecirRatioLmt) {
    rtb_Add_ok = EvapDesTempDrEnvCor;
  } else {
    rtb_Add_ok = EvapDesTempDrCabinCor;
  }

  /* Sum: '<S282>/Add1' incorporates:
   *  Sum: '<S282>/Add'
   *  Switch: '<S282>/Switch'
   */
  ACCtl_tDrSetBasicEvap = (EvapDesTempDrFanCor + rtb_Add_ok) + rtb_Delay1_ie;

  /* Switch: '<S305>/Switch2' incorporates:
   *  Constant: '<S282>/Constant'
   *  Constant: '<S282>/Constant1'
   *  RelationalOperator: '<S305>/LowerRelop1'
   *  RelationalOperator: '<S305>/UpperRelop'
   *  Switch: '<S305>/Switch'
   */
  if (ACCtl_tDrSetBasicEvap > cal_DrEvaDesValPIDUL) {
    /* Switch: '<S305>/Switch2' */
    ACCtl_tDrSetBasicEvap = cal_DrEvaDesValPIDUL;
  } else if (ACCtl_tDrSetBasicEvap < cal_DrEvaDesValPIDLL) {
    /* Switch: '<S305>/Switch' incorporates:
     *  Constant: '<S282>/Constant1'
     *  Switch: '<S305>/Switch2'
     */
    ACCtl_tDrSetBasicEvap = cal_DrEvaDesValPIDLL;
  }

  /* End of Switch: '<S305>/Switch2' */

  /* Outputs for Enabled SubSystem: '<S275>/CalAirCondEvapAimTemp_FIXPID' incorporates:
   *  EnablePort: '<S281>/Enable'
   */
  /* Constant: '<S275>/Constant' */
  if (cal_FixPIDSecletFlag) {
    /* Chart: '<S285>/deadzone' incorporates:
     *  Constant: '<S281>/Constant'
     */
    ME11_deadzone(rtb_Gain6, 0.5F, &rtb_flag_a);

    /* RelationalOperator: '<S285>/Relational Operator' */
    rtb_AND_b3z = (ACCtl_tDrDVT >= ACCtl_tLeftDuct);

    /* Switch: '<S285>/Switch1' incorporates:
     *  Switch: '<S285>/Switch'
     */
    if (rtb_flag_a) {
      /* Switch: '<S285>/Switch1' incorporates:
       *  Constant: '<S285>/Constant'
       */
      ACCtl_tErrDrDVT2Duct = 0.0F;
    } else if (rtb_AND_b3z) {
      /* Switch: '<S285>/Switch' incorporates:
       *  Switch: '<S285>/Switch1'
       */
      ACCtl_tErrDrDVT2Duct = rtb_Gain6;
    } else {
      /* Switch: '<S285>/Switch1' incorporates:
       *  Sum: '<S285>/Sum1'
       *  Switch: '<S285>/Switch'
       */
      ACCtl_tErrDrDVT2Duct = ACCtl_tLeftDuct - ACCtl_tDrDVT;
    }

    /* End of Switch: '<S285>/Switch1' */

    /* Outputs for Enabled SubSystem: '<S289>/P_NEG' */
    /* Logic: '<S289>/Logical Operator' incorporates:
     *  Constant: '<S281>/Kp12'
     *  Constant: '<S281>/Kp7'
     *  Constant: '<S281>/Kp9'
     */
    ME11_P_NEG(!rtb_AND_b3z, ACCtl_tErrDrDVT2Duct,
               cal_DrEvaDesValPIDIntegDeadBandNeg, cal_DrEvaDesValPIDKiNeg,
               cal_DrEvaDesValPIDKi, (float32 *)&ACCtl_tDrEvapICor);

    /* End of Outputs for SubSystem: '<S289>/P_NEG' */

    /* Outputs for Enabled SubSystem: '<S289>/P_POS' */
    /* Constant: '<S281>/Kp11' incorporates:
     *  Constant: '<S281>/Kp10'
     *  Constant: '<S281>/Kp7'
     */
    ME11_P_POS(rtb_AND_b3z, ACCtl_tErrDrDVT2Duct,
               cal_DrEvaDesValPIDIntegDeadBandPos, cal_DrEvaDesValPIDKiPos,
               cal_DrEvaDesValPIDKi, (float32 *)&ACCtl_tDrEvapICor);

    /* End of Outputs for SubSystem: '<S289>/P_POS' */

    /* Switch: '<S284>/Switch1' */
    if (rtb_FixPtRelationalOperator_mk) {
      /* MultiPortSwitch: '<S289>/Multiport Switch' incorporates:
       *  Delay: '<S289>/Delay'
       */
      switch (ME11_ARID_DEF.Delay_DSTATE_opd) {
       case 0:
        /* Switch: '<S293>/Switch' */
        if (rtb_AND_b3z) {
          /* Switch: '<S290>/Switch2' incorporates:
           *  Delay: '<S284>/Delay'
           *  Sum: '<S293>/Add'
           *  Switch: '<S293>/Switch'
           */
          ACCtl_tDrEvapISum = ACCtl_tDrEvapISum + ACCtl_tDrEvapICor;
        } else {
          /* Switch: '<S290>/Switch2' incorporates:
           *  Delay: '<S284>/Delay'
           *  Sum: '<S293>/Add1'
           *  Switch: '<S293>/Switch'
           */
          ACCtl_tDrEvapISum = ACCtl_tDrEvapISum - ACCtl_tDrEvapICor;
        }

        /* End of Switch: '<S293>/Switch' */
        break;

       case 1:
        /* Switch: '<S294>/Switch' */
        if (!rtb_AND_b3z) {
          /* Switch: '<S290>/Switch2' incorporates:
           *  Delay: '<S284>/Delay'
           *  Sum: '<S294>/Add1'
           *  Switch: '<S294>/Switch'
           */
          ACCtl_tDrEvapISum = ACCtl_tDrEvapISum - ACCtl_tDrEvapICor;
        }

        /* End of Switch: '<S294>/Switch' */
        break;

       case 2:
        /* Switch: '<S291>/Switch' */
        if (rtb_AND_b3z) {
          /* Switch: '<S290>/Switch2' incorporates:
           *  Delay: '<S284>/Delay'
           *  Sum: '<S291>/Add'
           *  Switch: '<S291>/Switch'
           */
          ACCtl_tDrEvapISum = ACCtl_tDrEvapISum + ACCtl_tDrEvapICor;
        }

        /* End of Switch: '<S291>/Switch' */
        break;

       case 3:
        break;
      }

      /* End of MultiPortSwitch: '<S289>/Multiport Switch' */

      /* Switch: '<S290>/Switch2' incorporates:
       *  Constant: '<S281>/Constant1'
       *  Constant: '<S281>/Kp13'
       *  Constant: '<S281>/Kp8'
       *  RelationalOperator: '<S290>/LowerRelop1'
       *  RelationalOperator: '<S290>/UpperRelop'
       *  Sum: '<S284>/Add'
       *  Switch: '<S290>/Switch'
       */
      if ((ACCtl_tDrEvapISum - 8000.0F) + 8000.0F > cal_DrEvaDesValPID_IsumMax)
      {
        /* Switch: '<S284>/Switch1' incorporates:
         *  Switch: '<S290>/Switch2'
         */
        ACCtl_tDrEvapISum = cal_DrEvaDesValPID_IsumMax;
      } else if ((ACCtl_tDrEvapISum - 8000.0F) + 8000.0F <
                 cal_DrEvaDesValPID_IsumMin) {
        /* Switch: '<S290>/Switch' incorporates:
         *  Constant: '<S281>/Kp13'
         *  Switch: '<S284>/Switch1'
         *  Switch: '<S290>/Switch2'
         */
        ACCtl_tDrEvapISum = cal_DrEvaDesValPID_IsumMin;
      } else {
        /* Switch: '<S284>/Switch1' incorporates:
         *  Switch: '<S290>/Switch2'
         */
        ACCtl_tDrEvapISum = (ACCtl_tDrEvapISum - 8000.0F) + 8000.0F;
      }

      /* End of Switch: '<S290>/Switch2' */
    } else {
      /* Switch: '<S284>/Switch1' incorporates:
       *  Constant: '<S281>/Constant5'
       */
      ACCtl_tDrEvapISum = 0.0F;
    }

    /* End of Switch: '<S284>/Switch1' */

    /* Outputs for Enabled SubSystem: '<S286>/PI_Controller1' */
    /* Update for Delay: '<S289>/Delay' incorporates:
     *  Logic: '<S286>/Logical Operator'
     */
    ME11_PI_Controller1(!rtb_FixPtRelationalOperator_mk, ACCtl_tDrSetBasicEvap,
                        (float32 *)&ACCtl_tDrEvapDesPI,
                        &ME11_ARID_DEF.Delay_DSTATE_opd);

    /* End of Outputs for SubSystem: '<S286>/PI_Controller1' */

    /* Outputs for Enabled SubSystem: '<S288>/P_NEG' */
    /* Logic: '<S288>/Logical Operator' incorporates:
     *  Constant: '<S281>/Kp'
     *  Constant: '<S281>/Kp1'
     *  Constant: '<S281>/Kp4'
     */
    ME11_P_NEG_h(!rtb_AND_b3z, ACCtl_tErrDrDVT2Duct, cal_DrEvaDesValPID_pWinNeg,
                 cal_DrEvaDesValPIDKpNeg, cal_DrEvaDesValPIDKp, (float32 *)
                 &ACCtl_tDrEvapPCor);

    /* End of Outputs for SubSystem: '<S288>/P_NEG' */

    /* Outputs for Enabled SubSystem: '<S288>/P_POS' */
    /* Constant: '<S281>/Kp3' incorporates:
     *  Constant: '<S281>/Kp'
     *  Constant: '<S281>/Kp2'
     */
    ME11_P_POS_c(rtb_AND_b3z, ACCtl_tErrDrDVT2Duct, cal_DrEvaDesValPID_pWinPos,
                 cal_DrEvaDesValPIDKpPos, cal_DrEvaDesValPIDKp, (float32 *)
                 &ACCtl_tDrEvapPCor);

    /* End of Outputs for SubSystem: '<S288>/P_POS' */

    /* Outputs for Enabled SubSystem: '<S286>/PI_Controller' */
    /* Update for Delay: '<S289>/Delay' incorporates:
     *  Constant: '<S281>/Kp5'
     *  Constant: '<S281>/Kp6'
     */
    ME11_PI_Controller(rtb_FixPtRelationalOperator_mk, rtb_AND_b3z,
                       ACCtl_tDrSetBasicEvap, ACCtl_tDrEvapPCor,
                       ACCtl_tDrEvapISum, cal_DrEvaDesValPIDUL,
                       cal_DrEvaDesValPIDLL, (float32 *)&ACCtl_tDrEvapDesPI,
                       &ME11_ARID_DEF.Delay_DSTATE_opd);

    /* End of Outputs for SubSystem: '<S286>/PI_Controller' */

    /* Lookup_n-D: '<S281>/cal_DrEvapDesFilterByDvt_CUR' incorporates:
     *  Switch: '<S285>/Switch1'
     */
    AC_DrEvapDesFilter = look1_iflf_binlca(ACCtl_tErrDrDVT2Duct, (const float32 *)
      &cal_DrEvapDesFilterByDvt_1X[0], (const float32 *)
      &cal_DrEvapDesFilterByDvt_CUR[0], 3U);

    /* Switch: '<S302>/Init' incorporates:
     *  Constant: '<S287>/Constant'
     *  Product: '<S287>/Product'
     *  Product: '<S287>/Product1'
     *  Sum: '<S287>/Sum'
     *  Sum: '<S287>/Sum1'
     *  UnitDelay: '<S302>/FixPt Unit Delay1'
     *  UnitDelay: '<S302>/FixPt Unit Delay2'
     */
    if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_ar != 0) {
      ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_bl = ACCtl_tDrEvapDesPI;
    }

    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_bl = (1.0F - AC_DrEvapDesFilter) *
      ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_bl + ACCtl_tDrEvapDesPI *
      AC_DrEvapDesFilter;

    /* End of Switch: '<S302>/Init' */

    /* Update for UnitDelay: '<S302>/FixPt Unit Delay2' incorporates:
     *  Constant: '<S302>/FixPt Constant'
     */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_ar = 0U;
  }

  /* End of Constant: '<S275>/Constant' */
  /* End of Outputs for SubSystem: '<S275>/CalAirCondEvapAimTemp_FIXPID' */

  /* Switch: '<S275>/Switch2' */
  if (HMICtl_bLeftSetLow) {
    /* Switch: '<S275>/Switch2' incorporates:
     *  Constant: '<S275>/Constant8'
     */
    ACCtl_tDrEvapDes = cal_EvaDesLLMin;
  } else {
    /* Switch: '<S275>/Switch2' incorporates:
     *  UnitDelay: '<S302>/FixPt Unit Delay1'
     */
    ACCtl_tDrEvapDes = ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_bl;
  }

  /* End of Switch: '<S275>/Switch2' */

  /* Switch: '<S283>/Switch2' incorporates:
   *  Constant: '<S275>/Constant1'
   *  RelationalOperator: '<S283>/LowerRelop1'
   */
  if (ACCtl_tDrEvapDes > cal_EvaDesLLMax) {
    /* Switch: '<S283>/Switch2' */
    ACCtl_tDrEvapDes = cal_EvaDesLLMax;
  } else {
    /* Lookup_n-D: '<S275>/cal_DrEvaDesValPIDLL_MAP' incorporates:
     *  Delay: '<S35>/Delay'
     *  Switch: '<S1165>/Switch'
     */
    rtb_Merge_g = look2_iu8flftf_binlca(ME11_ARID_DEF.Delay_DSTATE_hr,
      HMICtl_sLeftSetPoint, (const uint8 *)&cal_DrEvaDesValPIDLL_2X[0], (const
      float32 *)&cal_DrEvaDesValPIDLL_2Y[0], (const float32 *)
      &cal_DrEvaDesValPIDLL_MAP[0], ME11_ConstP.pooled37, 4U);

    /* Switch: '<S283>/Switch' incorporates:
     *  RelationalOperator: '<S283>/UpperRelop'
     */
    if (ACCtl_tDrEvapDes < rtb_Merge_g) {
      /* Switch: '<S283>/Switch2' */
      ACCtl_tDrEvapDes = rtb_Merge_g;
    }

    /* End of Switch: '<S283>/Switch' */
  }

  /* End of Switch: '<S283>/Switch2' */

  /* Lookup_n-D: '<S307>/cal_EvapDesTempPsFanCor_CUR' incorporates:
   *  Delay: '<S35>/Delay'
   */
  EvapDesTempPsFanCor = look1_iu8lftf_binlca(ME11_ARID_DEF.Delay_DSTATE_hr, (
    const uint8 *)&cal_EvapDesTempPsFanCor_1X[0], (const float32 *)
    &cal_EvapDesTempPsFanCor_CUR[0], 3U);

  /* Lookup_n-D: '<S307>/cal_EvapDesTempPsEnvCor_MAP' incorporates:
   *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
   *  Switch: '<S1085>/Switch'
   */
  EvapDesTempPsEnvCor = look2_iflf_binlca(ACSen_sEnvTempCor,
    (Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA())
    ->VIPM_ESCVehSpd_kph, (const float32 *)&cal_EvapDesTempPsEnvCor_2X[0], (
    const float32 *)&cal_EvapDesTempPsEnvCor_2Y[0], (const float32 *)
    &cal_EvapDesTempPsEnvCor_MAP[0], ME11_ConstP.pooled38, 6U);

  /* Lookup_n-D: '<S307>/cal_EvapDesTempPsCabinCor_CUR' incorporates:
   *  Switch: '<S176>/Switch2'
   */
  EvapDesTempPsCabinCor = look1_iflf_binlca(GlbDa_tCabinInvent, (const float32 *)
    &cal_EvapDesTempPsCabinCor_1X[0], (const float32 *)
    &cal_EvapDesTempPsCabinCor_CUR[0], 5U);

  /* MultiPortSwitch: '<S307>/Multiport Switch1' incorporates:
   *  Delay: '<S4>/Delay'
   */
  switch (ME11_ARID_DEF.Delay_DSTATE_fl) {
   case BlowerModes_FaceMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S307>/cal_EvapBacTempPsDesAC_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_EvapBacTempPsDesAC_1X[0], (const float32 *)
      &cal_EvapBacTempPsDesAC_CUR[0], 5U);
    break;

   case BlowerModes_FaceHeaterMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S307>/cal_EvapBacTempPsDesACBi_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_EvapBacTempPsDesACBi_1X[0], (const float32 *)
      &cal_EvapBacTempPsDesACBi_CUR[0], 5U);
    break;

   case BlowerModes_HeaterMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S307>/cal_EvapBacTempPsDesFoot_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_EvapBacTempPsDesFoot_1X[0], (const float32 *)
      &cal_EvapBacTempPsDesFoot_CUR[0], 5U);
    break;

   case BlowerModes_HeaterDeforstMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S307>/cal_EvapBacTempPsDesFootDe_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_EvapBacTempPsDesFootDe_1X[0], (const float32 *)
      &cal_EvapBacTempPsDesFootDe_CUR[0], 5U);
    break;

   case BlowerModes_DeforstMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S307>/cal_EvapBacTempPsDesDefog_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_EvapBacTempPsDesDefog_1X[0], (const float32 *)
      &cal_EvapBacTempPsDesDefog_CUR[0], 5U);
    break;

   default:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S307>/cal_EvapBacTempPsDesACBi_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_EvapBacTempPsDesACBi_1X[0], (const float32 *)
      &cal_EvapBacTempPsDesACBi_CUR[0], 5U);
    break;
  }

  /* End of MultiPortSwitch: '<S307>/Multiport Switch1' */

  /* Switch: '<S307>/Switch' incorporates:
   *  Constant: '<S307>/Constant2'
   *  RelationalOperator: '<S307>/Relational Operator2'
   */
  if (ACSen_eAirInletPer < cal_ACRecirRatioLmt) {
    rtb_Add_ok = EvapDesTempPsEnvCor;
  } else {
    rtb_Add_ok = EvapDesTempPsCabinCor;
  }

  /* Sum: '<S307>/Add1' incorporates:
   *  Sum: '<S307>/Add'
   *  Switch: '<S307>/Switch'
   */
  ACCtl_tPsSetBasicEvap = (EvapDesTempPsFanCor + rtb_Add_ok) + rtb_Delay1_ie;

  /* Switch: '<S330>/Switch2' incorporates:
   *  Constant: '<S307>/Constant3'
   *  Constant: '<S307>/Constant4'
   *  RelationalOperator: '<S330>/LowerRelop1'
   *  RelationalOperator: '<S330>/UpperRelop'
   *  Switch: '<S330>/Switch'
   */
  if (ACCtl_tPsSetBasicEvap > cal_DrEvaDesValPIDUL) {
    /* Switch: '<S330>/Switch2' */
    ACCtl_tPsSetBasicEvap = cal_DrEvaDesValPIDUL;
  } else if (ACCtl_tPsSetBasicEvap < cal_DrEvaDesValPIDLL) {
    /* Switch: '<S330>/Switch' incorporates:
     *  Constant: '<S307>/Constant4'
     *  Switch: '<S330>/Switch2'
     */
    ACCtl_tPsSetBasicEvap = cal_DrEvaDesValPIDLL;
  }

  /* End of Switch: '<S330>/Switch2' */

  /* Outputs for Enabled SubSystem: '<S276>/CalAirCondEvapAimTemp_RightDes' incorporates:
   *  EnablePort: '<S306>/Enable'
   */
  /* Constant: '<S276>/Constant' */
  if (cal_FixPIDSecletFlag) {
    /* Outputs for Enabled SubSystem: '<S312>/PI_Controller1' */
    /* Logic: '<S312>/Logical Operator' */
    ME11_PI_Controller1(!rtb_Delay1_ag, ACCtl_tPsSetBasicEvap, (float32 *)
                        &ACCtl_tPsEvapDesPI, &rtb_IFreezFlag_k);

    /* End of Outputs for SubSystem: '<S312>/PI_Controller1' */

    /* RelationalOperator: '<S311>/Relational Operator' */
    rtb_AND_b3z = (ACCtl_tPsDVT >= ACCtl_tRightDuct);

    /* Chart: '<S311>/deadzone' incorporates:
     *  Constant: '<S306>/Constant'
     */
    ME11_deadzone(rtb_Delay, 0.5F, &rtb_flag_d);

    /* Switch: '<S311>/Switch1' incorporates:
     *  Switch: '<S311>/Switch'
     */
    if (rtb_flag_d) {
      /* Switch: '<S311>/Switch1' incorporates:
       *  Constant: '<S311>/Constant'
       */
      ACCtl_tErrPsDVT2Duct = 0.0F;
    } else if (rtb_AND_b3z) {
      /* Switch: '<S311>/Switch' incorporates:
       *  Switch: '<S311>/Switch1'
       */
      ACCtl_tErrPsDVT2Duct = rtb_Delay;
    } else {
      /* Switch: '<S311>/Switch1' incorporates:
       *  Sum: '<S311>/Sum1'
       *  Switch: '<S311>/Switch'
       */
      ACCtl_tErrPsDVT2Duct = ACCtl_tRightDuct - ACCtl_tPsDVT;
    }

    /* End of Switch: '<S311>/Switch1' */

    /* Outputs for Enabled SubSystem: '<S313>/P_NEG' */
    /* Logic: '<S313>/Logical Operator' incorporates:
     *  Constant: '<S306>/Kp'
     *  Constant: '<S306>/Kp1'
     *  Constant: '<S306>/Kp4'
     */
    ME11_P_NEG_h(!rtb_AND_b3z, ACCtl_tErrPsDVT2Duct, cal_PsEvaDesValPID_pWinNeg,
                 cal_PsEvaDesValPIDKpNeg, cal_PsEvaDesValPIDKp, (float32 *)
                 &ACCtl_tPsEvapPCor);

    /* End of Outputs for SubSystem: '<S313>/P_NEG' */

    /* Outputs for Enabled SubSystem: '<S313>/P_POS' */
    /* Constant: '<S306>/Kp3' incorporates:
     *  Constant: '<S306>/Kp'
     *  Constant: '<S306>/Kp2'
     */
    ME11_P_POS_c(rtb_AND_b3z, ACCtl_tErrPsDVT2Duct, cal_PsEvaDesValPID_pWinPos,
                 cal_PsEvaDesValPIDKpPos, cal_PsEvaDesValPIDKp, (float32 *)
                 &ACCtl_tPsEvapPCor);

    /* End of Outputs for SubSystem: '<S313>/P_POS' */

    /* Outputs for Enabled SubSystem: '<S315>/P_NEG' */
    /* Logic: '<S315>/Logical Operator' incorporates:
     *  Constant: '<S306>/Kp12'
     *  Constant: '<S306>/Kp7'
     *  Constant: '<S306>/Kp9'
     */
    ME11_P_NEG(!rtb_AND_b3z, ACCtl_tErrPsDVT2Duct,
               cal_PsEvaDesValPIDIntegDeadBandNeg, cal_PsEvaDesValPIDKiNeg,
               cal_PsEvaDesValPIDKi, (float32 *)&ACCtl_tPsEvapICor);

    /* End of Outputs for SubSystem: '<S315>/P_NEG' */

    /* Outputs for Enabled SubSystem: '<S315>/P_POS' */
    /* Constant: '<S306>/Kp11' incorporates:
     *  Constant: '<S306>/Kp10'
     *  Constant: '<S306>/Kp7'
     */
    ME11_P_POS(rtb_AND_b3z, ACCtl_tErrPsDVT2Duct,
               cal_PsEvaDesValPIDIntegDeadBandPos, cal_PsEvaDesValPIDKiPos,
               cal_PsEvaDesValPIDKi, (float32 *)&ACCtl_tPsEvapICor);

    /* End of Outputs for SubSystem: '<S315>/P_POS' */

    /* Switch: '<S310>/Switch1' */
    if (rtb_Delay1_ag) {
      /* MultiPortSwitch: '<S315>/Multiport Switch' incorporates:
       *  Delay: '<S315>/Delay'
       */
      switch (ME11_ARID_DEF.Delay_DSTATE_fe) {
       case 0:
        /* Switch: '<S319>/Switch' */
        if (rtb_AND_b3z) {
          /* Switch: '<S316>/Switch2' incorporates:
           *  Delay: '<S310>/Delay'
           *  Sum: '<S319>/Add'
           *  Switch: '<S319>/Switch'
           */
          ACCtl_tPsEvapISum = ACCtl_tPsEvapISum + ACCtl_tPsEvapICor;
        } else {
          /* Switch: '<S316>/Switch2' incorporates:
           *  Delay: '<S310>/Delay'
           *  Sum: '<S319>/Add1'
           *  Switch: '<S319>/Switch'
           */
          ACCtl_tPsEvapISum = ACCtl_tPsEvapISum - ACCtl_tPsEvapICor;
        }

        /* End of Switch: '<S319>/Switch' */
        break;

       case 1:
        /* Switch: '<S320>/Switch' */
        if (!rtb_AND_b3z) {
          /* Switch: '<S316>/Switch2' incorporates:
           *  Delay: '<S310>/Delay'
           *  Sum: '<S320>/Add1'
           *  Switch: '<S320>/Switch'
           */
          ACCtl_tPsEvapISum = ACCtl_tPsEvapISum - ACCtl_tPsEvapICor;
        }

        /* End of Switch: '<S320>/Switch' */
        break;

       case 2:
        /* Switch: '<S317>/Switch' */
        if (rtb_AND_b3z) {
          /* Switch: '<S316>/Switch2' incorporates:
           *  Delay: '<S310>/Delay'
           *  Sum: '<S317>/Add'
           *  Switch: '<S317>/Switch'
           */
          ACCtl_tPsEvapISum = ACCtl_tPsEvapISum + ACCtl_tPsEvapICor;
        }

        /* End of Switch: '<S317>/Switch' */
        break;

       case 3:
        break;
      }

      /* End of MultiPortSwitch: '<S315>/Multiport Switch' */

      /* Switch: '<S316>/Switch2' incorporates:
       *  Constant: '<S306>/Constant1'
       *  Constant: '<S306>/Kp13'
       *  Constant: '<S306>/Kp8'
       *  RelationalOperator: '<S316>/LowerRelop1'
       *  RelationalOperator: '<S316>/UpperRelop'
       *  Sum: '<S310>/Add'
       *  Switch: '<S316>/Switch'
       */
      if ((ACCtl_tPsEvapISum - 8000.0F) + 8000.0F > cal_PsEvaDesValPID_IsumMax)
      {
        /* Switch: '<S310>/Switch1' incorporates:
         *  Switch: '<S316>/Switch2'
         */
        ACCtl_tPsEvapISum = cal_PsEvaDesValPID_IsumMax;
      } else if ((ACCtl_tPsEvapISum - 8000.0F) + 8000.0F <
                 cal_PsEvaDesValPID_IsumMin) {
        /* Switch: '<S316>/Switch' incorporates:
         *  Constant: '<S306>/Kp13'
         *  Switch: '<S310>/Switch1'
         *  Switch: '<S316>/Switch2'
         */
        ACCtl_tPsEvapISum = cal_PsEvaDesValPID_IsumMin;
      } else {
        /* Switch: '<S310>/Switch1' incorporates:
         *  Switch: '<S316>/Switch2'
         */
        ACCtl_tPsEvapISum = (ACCtl_tPsEvapISum - 8000.0F) + 8000.0F;
      }

      /* End of Switch: '<S316>/Switch2' */
    } else {
      /* Switch: '<S310>/Switch1' incorporates:
       *  Constant: '<S306>/Constant5'
       */
      ACCtl_tPsEvapISum = 0.0F;
    }

    /* End of Switch: '<S310>/Switch1' */

    /* Outputs for Enabled SubSystem: '<S312>/PI_Controller' */
    /* Constant: '<S306>/Kp5' incorporates:
     *  Constant: '<S306>/Kp6'
     */
    ME11_PI_Controller(rtb_Delay1_ag, rtb_AND_b3z, ACCtl_tPsSetBasicEvap,
                       ACCtl_tPsEvapPCor, ACCtl_tPsEvapISum,
                       cal_PsEvaDesValPIDUL, cal_PsEvaDesValPIDLL, (float32 *)
                       &ACCtl_tPsEvapDesPI, &rtb_IFreezFlag_k);

    /* End of Outputs for SubSystem: '<S312>/PI_Controller' */

    /* Lookup_n-D: '<S306>/cal_PsEvapDesFilterByDvt_CUR' incorporates:
     *  Switch: '<S311>/Switch1'
     */
    AC_PsEvapDesFilter = look1_iflf_binlca(ACCtl_tErrPsDVT2Duct, (const float32 *)
      &cal_PsEvapDesFilterByDvt_1X[0], (const float32 *)
      &cal_PsEvapDesFilterByDvt_CUR[0], 3U);

    /* Switch: '<S314>/Init' incorporates:
     *  Constant: '<S309>/Constant'
     *  Product: '<S309>/Product'
     *  Product: '<S309>/Product1'
     *  Sum: '<S309>/Sum'
     *  Sum: '<S309>/Sum1'
     *  UnitDelay: '<S314>/FixPt Unit Delay1'
     *  UnitDelay: '<S314>/FixPt Unit Delay2'
     */
    if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_i != 0) {
      ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_he = ACCtl_tPsEvapDesPI;
    }

    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_he = (1.0F - AC_PsEvapDesFilter) *
      ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_he + ACCtl_tPsEvapDesPI *
      AC_PsEvapDesFilter;

    /* End of Switch: '<S314>/Init' */

    /* Update for Delay: '<S315>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_fe = rtb_IFreezFlag_k;

    /* Update for UnitDelay: '<S314>/FixPt Unit Delay2' incorporates:
     *  Constant: '<S314>/FixPt Constant'
     */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_i = 0U;
  }

  /* End of Constant: '<S276>/Constant' */
  /* End of Outputs for SubSystem: '<S276>/CalAirCondEvapAimTemp_RightDes' */

  /* Switch: '<S276>/Switch2' */
  if (HMICtl_bLeftSetLow) {
    /* Switch: '<S276>/Switch2' incorporates:
     *  Constant: '<S276>/Constant8'
     */
    ACCtl_tPsEvapDes = cal_EvaDesLLMin;
  } else {
    /* Switch: '<S276>/Switch2' incorporates:
     *  UnitDelay: '<S314>/FixPt Unit Delay1'
     */
    ACCtl_tPsEvapDes = ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_he;
  }

  /* End of Switch: '<S276>/Switch2' */

  /* Switch: '<S308>/Switch2' incorporates:
   *  Constant: '<S276>/Constant1'
   *  RelationalOperator: '<S308>/LowerRelop1'
   */
  if (ACCtl_tPsEvapDes > cal_EvaDesLLMax) {
    /* Switch: '<S308>/Switch2' */
    ACCtl_tPsEvapDes = cal_EvaDesLLMax;
  } else {
    /* Lookup_n-D: '<S276>/cal_PsEvaDesValPIDLL_MAP' incorporates:
     *  Delay: '<S35>/Delay'
     *  Switch: '<S1165>/Switch'
     */
    rtb_Merge_g = look2_iu8flftf_binlca(ME11_ARID_DEF.Delay_DSTATE_hr,
      HMICtl_sLeftSetPoint, (const uint8 *)&cal_PsEvaDesValPIDLL_2X[0], (const
      float32 *)&cal_PsEvaDesValPIDLL_2Y[0], (const float32 *)
      &cal_PsEvaDesValPIDLL_MAP[0], ME11_ConstP.pooled37, 4U);

    /* Switch: '<S308>/Switch' incorporates:
     *  RelationalOperator: '<S308>/UpperRelop'
     */
    if (ACCtl_tPsEvapDes < rtb_Merge_g) {
      /* Switch: '<S308>/Switch2' */
      ACCtl_tPsEvapDes = rtb_Merge_g;
    }

    /* End of Switch: '<S308>/Switch' */
  }

  /* End of Switch: '<S308>/Switch2' */

  /* If: '<S277>/If' incorporates:
   *  DataTypeConversion: '<S277>/Data Type Conversion1'
   */
  if (HMICtl_bACDefrost) {
    /* Outputs for IfAction SubSystem: '<S277>/DefogAimEvapTempCal' incorporates:
     *  ActionPort: '<S331>/Action Port'
     */
    /* Merge: '<S277>/Merge' incorporates:
     *  DataTypeConversion: '<S331>/Data Type Conversion'
     *  Lookup_n-D: '<S331>/1-D Lookup Table'
     */
    rtb_Merge1_m = look1_iflf_binlca(0.0F, ME11_ConstP.uDLookupTable_bp01Data,
      ME11_ConstP.uDLookupTable_tableData, 4U);

    /* End of Outputs for SubSystem: '<S277>/DefogAimEvapTempCal' */
  } else {
    /* Outputs for IfAction SubSystem: '<S277>/ShutOffDefog' incorporates:
     *  ActionPort: '<S332>/Action Port'
     */
    /* Merge: '<S277>/Merge' incorporates:
     *  Constant: '<S332>/Constant'
     *  SignalConversion generated from: '<S332>/ACCtl_tAimEvapDefog'
     */
    rtb_Merge1_m = 80.0F;

    /* End of Outputs for SubSystem: '<S277>/ShutOffDefog' */
  }

  /* End of If: '<S277>/If' */

  /* MinMax: '<S178>/MinMax3' */
  if (ACCtl_tPsDVT <= ACCtl_tDrDVT) {
    /* MinMax: '<S178>/MinMax3' */
    rtb_Merge_g = ACCtl_tPsDVT;
  } else {
    /* MinMax: '<S178>/MinMax3' */
    rtb_Merge_g = ACCtl_tDrDVT;
  }

  /* End of MinMax: '<S178>/MinMax3' */

  /* Chart: '<S178>/EvaCooledCheck' incorporates:
   *  Constant: '<S178>/Constant6'
   */
  if (ME11_ARID_DEF.is_active_c49_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c49_ME11 = 1U;
    ME11_ARID_DEF.is_c49_ME11 = ME11_IN_Eva_cooling;
    ACCtl_stEvaCooledFlag = false;
  } else {
    switch (ME11_ARID_DEF.is_c49_ME11) {
     case ME11_IN_Eva_Stop:
      ACCtl_stEvaCooledFlag = true;
      if (rtb_Merge_g < Eva_CloseCond1) {
        ME11_ARID_DEF.is_c49_ME11 = ME11_IN_Eva_cooling;
        ACCtl_stEvaCooledFlag = false;
      }
      break;

     case ME11_IN_Eva_Stoping:
      ACCtl_stEvaCooledFlag = false;
      if ((ME11_ARID_DEF.EvapTempLoWaiteTime > cal_TevapLoTime) || (rtb_Merge_g <
           Eva_CloseCond1)) {
        ME11_ARID_DEF.EvapTempLoWaiteTime = 0U;
        ME11_ARID_DEF.is_c49_ME11 = ME11_IN_Eva_cooling;
        ACCtl_stEvaCooledFlag = false;
      } else if (ACSen_sEvapTempFilter < Eva_CooledCond1) {
        ME11_ARID_DEF.EvapTempLoWaiteTime = 0U;
        ME11_ARID_DEF.is_c49_ME11 = ME11_IN_Eva_Stop;
        ACCtl_stEvaCooledFlag = true;
      } else {
        b_previousEvent = ME11_ARID_DEF.EvapTempLoWaiteTime + 1;
        if (ME11_ARID_DEF.EvapTempLoWaiteTime + 1 > 65535) {
          b_previousEvent = 65535;
        }

        ME11_ARID_DEF.EvapTempLoWaiteTime = (uint16)b_previousEvent;
      }
      break;

     default:
      /* case IN_Eva_cooling: */
      ACCtl_stEvaCooledFlag = false;
      if ((rtb_Merge_g < Eva_CoolingCond1) && (rtb_Merge_g > Eva_CoolingCond2))
      {
        ME11_ARID_DEF.is_c49_ME11 = ME11_IN_Eva_Stoping;
        ME11_ARID_DEF.RecordInitialEvapTemp_o = ACSen_sEvapTempFilter;
        ACCtl_stEvaCooledFlag = false;
        ME11_ARID_DEF.EvapTempLoWaiteTime = 0U;
      }
      break;
    }
  }

  /* End of Chart: '<S178>/EvaCooledCheck' */

  /* MinMax: '<S279>/Max1' */
  GlbDa_Solar = AC_rSolarRight;

  /* DataTypeConversion: '<S39>/Data Type Conversion' */
  rtb_DataTypeConversion_dt = (sint16)(float32)floor(ACSen_sEvapTempFilter);

  /* SignalConversion: '<S2>/Signal Copy142' incorporates:
   *  Inport: '<Root>/IPM_HVCH_Status1_BOD'
   */
  rtb_Merge_g = (Rte_IRead_Task_100ms_IPM_HVCH_Status1_BOD_IPM_HVCH_Status1_BOD())
    ->VIPM_HVCHOutlTemp_C;

  /* Outputs for Enabled SubSystem: '<S41>/CalDrMixDoorDesRatio' incorporates:
   *  EnablePort: '<S386>/Enable'
   */
  /* Sum: '<S39>/Sum' incorporates:
   *  Sum: '<S389>/Subtract1'
   *  Sum: '<S50>/Add'
   */
  AC_DVT2PTCErr = ACCtl_tDrDVT - rtb_Merge_g;

  /* End of Outputs for SubSystem: '<S41>/CalDrMixDoorDesRatio' */

  /* Switch: '<S173>/Switch2' incorporates:
   *  Constant: '<S39>/Constant'
   *  Constant: '<S39>/Constant1'
   *  RelationalOperator: '<S173>/LowerRelop1'
   *  RelationalOperator: '<S173>/UpperRelop'
   *  Sum: '<S39>/Sum'
   *  Switch: '<S173>/Switch'
   */
  if (AC_DVT2PTCErr > 80.0F) {
    rtb_Add_ok = 80.0F;
  } else if (AC_DVT2PTCErr < -40.0F) {
    /* Switch: '<S173>/Switch' incorporates:
     *  Constant: '<S39>/Constant1'
     */
    rtb_Add_ok = -40.0F;
  } else {
    rtb_Add_ok = AC_DVT2PTCErr;
  }

  /* DataTypeConversion: '<S39>/Data Type Conversion1' incorporates:
   *  Switch: '<S173>/Switch2'
   */
  rtb_DataTypeConversion1_i = (sint16)(float32)floor(rtb_Add_ok);

  /* DataTypeConversion: '<S39>/Data Type Conversion2' */
  rtb_DataTypeConversion2 = (sint16)(float32)floor(ACCtl_tDrDVT);

  /* Logic: '<S39>/Logical Operator2' incorporates:
   *  Constant: '<S39>/ACModes.BlowerModeManual'
   *  Logic: '<S39>/Logical Operator1'
   *  RelationalOperator: '<S39>/Relational Operator'
   *  RelationalOperator: '<S39>/Relational Operator1'
   *  S-Function (sfix_bitop): '<S39>/Bitwise Operator'
   *  S-Function (sfix_bitop): '<S39>/Bitwise Operator1'
   */
  rtb_AND_b3z = (((ME11_ARID_DEF.Switch1_nv & 1U) != 0U) &&
                 ((ME11_ARID_DEF.Switch1_nv & 2U) != 0U));

  /* DataTypeConversion: '<S39>/Data Type Conversion4' */
  rtb_DataTypeConversion4 = (sint16)(float32)floor(rtb_Merge_g);

  /* DataTypeConversion: '<S39>/Data Type Conversion3' */
  rtb_DataTypeConversion3 = (sint16)(float32)floor(ACSen_sEnvTempCor);

  /* Gain: '<S39>/Gain' incorporates:
   *  Constant: '<S39>/Constant2'
   */
  rtb_Divide_ox = (uint16)((uint32)cal_tiColdStartTimeMax >> 1);

  /* Chart: '<S39>/AirConditionStartState' incorporates:
   *  Constant: '<S39>/Constant2'
   *  Delay: '<S35>/Delay'
   */
  if (ME11_ARID_DEF.is_active_c28_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c28_ME11 = 1U;
    ME11_ARID_DEF.is_FanWorkTimeMng = ME11_IN_IGN_OFF;
    ME11_ARID_DEF.BlowerFanRunTime = 0U;
    ME11_ARID_DEF.IGN_ONTime = 0U;
    rtb_Compare_fx = !HMICtl_bACDefrost;
    if ((rtb_DataTypeConversion4 < cal_CAPStartCoolantMin) && rtb_Compare_fx &&
        (rtb_DataTypeConversion1_i > 8) && rtb_AND_b3z &&
        (rtb_DataTypeConversion3 < 15)) {
      ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Cold_Air_Protection;
      ACCtl_stStartState = ME11_ColdStart;
      ME11_ARID_DEF.time = 0U;
    } else if (rtb_AND_b3z && rtb_Compare_fx && (rtb_DataTypeConversion2 <
                rtb_DataTypeConversion_dt) && (rtb_DataTypeConversion3 > 30) &&
               (rtb_DataTypeConversion_dt > cal_HAPevap_min) && (AC_tiAfterRun >=
                cal_HAPparkdly_time) && (ME11_ARID_DEF.IGN_ONTime <
                cal_HAPtimelim2activtic) && (ME11_ARID_DEF.BlowerFanRunTime <
                cal_HAPpurge_time)) {
      ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Hot_Air_Protection;
      ACCtl_stStartState = ME11_HotStart;
    } else {
      ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Normal_Op;
      ACCtl_stStartState = ME11_NormalStart;
    }
  } else {
    if (ME11_ARID_DEF.is_FanWorkTimeMng == ME11_IN_IGN_OFF) {
      if (CoAC_stwork == 2) {
        ME11_ARID_DEF.is_FanWorkTimeMng = ME11_IN_IGN_ON;
        ME11_ARID_DEF.IGN_ONTime = 0U;
        ME11_ARID_DEF.is_BlowerFanTime = ME11_IN_BlowerFan_On;
        if (ME11_ARID_DEF.BlowerFanRunTime >= cal_tiColdStartTimeMax) {
          ME11_ARID_DEF.is_BlowerFan_On = ME11_IN_BlowerFanWorkTimeKeep;
          ME11_ARID_DEF.BlowerFanRunTime = cal_tiColdStartTimeMax;
        } else {
          ME11_ARID_DEF.is_BlowerFan_On = ME11_IN_BlowerFanWorkTimeAdd;
          ME11_ARID_DEF.BlowerFanRunTime = 0U;
        }
      }

      /* case IN_IGN_ON: */
    } else if (CoAC_stwork != 2) {
      if (ME11_ARID_DEF.is_BlowerFanTime == ME11_IN_BlowerFan_Off) {
        ME11_ARID_DEF.is_BlowerFanTime = ME11_IN_NO_ACTIVE_CHILD_gl;
      } else {
        ME11_ARID_DEF.is_BlowerFan_On = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_BlowerFanTime = ME11_IN_NO_ACTIVE_CHILD_gl;
      }

      ME11_ARID_DEF.is_FanWorkTimeMng = ME11_IN_IGN_OFF;
      ME11_ARID_DEF.BlowerFanRunTime = 0U;
      ME11_ARID_DEF.IGN_ONTime = 0U;
    } else {
      if (ME11_ARID_DEF.is_BlowerFanTime == ME11_IN_BlowerFan_Off) {
        if (ME11_ARID_DEF.Delay_DSTATE_hr > 0) {
          ME11_ARID_DEF.BlowerFanRunTime = 0U;
          ME11_ARID_DEF.is_BlowerFanTime = ME11_IN_BlowerFan_On;
          if (ME11_ARID_DEF.BlowerFanRunTime >= cal_tiColdStartTimeMax) {
            ME11_ARID_DEF.is_BlowerFan_On = ME11_IN_BlowerFanWorkTimeKeep;
            ME11_ARID_DEF.BlowerFanRunTime = cal_tiColdStartTimeMax;
          } else {
            ME11_ARID_DEF.is_BlowerFan_On = ME11_IN_BlowerFanWorkTimeAdd;
            ME11_ARID_DEF.BlowerFanRunTime = 0U;
          }
        }

        /* case IN_BlowerFan_On: */
      } else if (ME11_ARID_DEF.Delay_DSTATE_hr == 0) {
        ME11_ARID_DEF.is_BlowerFan_On = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_BlowerFanTime = ME11_IN_BlowerFan_Off;
      } else if (ME11_ARID_DEF.is_BlowerFan_On == ME11_IN_BlowerFanWorkTimeAdd)
      {
        if (ME11_ARID_DEF.BlowerFanRunTime >= cal_tiColdStartTimeMax) {
          ME11_ARID_DEF.is_BlowerFan_On = ME11_IN_BlowerFanWorkTimeKeep;
          ME11_ARID_DEF.BlowerFanRunTime = cal_tiColdStartTimeMax;
        } else {
          rtb_Divide1_f = ME11_ARID_DEF.BlowerFanRunTime + 1U;
          if (ME11_ARID_DEF.BlowerFanRunTime + 1U > 65535U) {
            rtb_Divide1_f = 65535U;
          }

          ME11_ARID_DEF.BlowerFanRunTime = (uint16)rtb_Divide1_f;
        }
      } else {
        /* case IN_BlowerFanWorkTimeKeep: */
      }

      rtb_Divide1_f = ME11_ARID_DEF.IGN_ONTime + 1U;
      if (ME11_ARID_DEF.IGN_ONTime + 1U > 65535U) {
        rtb_Divide1_f = 65535U;
      }

      ME11_ARID_DEF.IGN_ONTime = (uint16)rtb_Divide1_f;
    }

    switch (ME11_ARID_DEF.is_ACStartModeMng) {
     case ME11_IN_Cold_Air_Protection:
      ACCtl_stStartState = ME11_ColdStart;
      if (HMICtl_bACDefrost || (rtb_DataTypeConversion1_i < 2) || (!rtb_AND_b3z))
      {
        ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Normal_Op;
        ACCtl_stStartState = ME11_NormalStart;
      } else if ((rtb_DataTypeConversion4 > cal_CAPStartCoolantMin + 3) ||
                 (ME11_ARID_DEF.time >= rtb_Divide_ox)) {
        ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Normal_LittleCold;
        ACCtl_stStartState = ME11_LittleCold;
        ME11_ARID_DEF.time = 0U;
      } else {
        rtb_Divide1_f = ME11_ARID_DEF.time + 1U;
        if (ME11_ARID_DEF.time + 1U > 65535U) {
          rtb_Divide1_f = 65535U;
        }

        ME11_ARID_DEF.time = (uint16)rtb_Divide1_f;
      }
      break;

     case ME11_IN_Hot_Air_Protection:
      ACCtl_stStartState = ME11_HotStart;
      if ((ME11_ARID_DEF.BlowerFanRunTime >= cal_HAPpurge_time) ||
          HMICtl_bACDefrost || (!rtb_AND_b3z)) {
        ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Normal_Op;
        ACCtl_stStartState = ME11_NormalStart;
      }
      break;

     case ME11_IN_Normal_LittleCold:
      ACCtl_stStartState = ME11_LittleCold;
      if ((rtb_DataTypeConversion4 < cal_CAPStartCoolantMin) &&
          (!HMICtl_bACDefrost) && (rtb_DataTypeConversion1_i > 8) && rtb_AND_b3z
          && (rtb_DataTypeConversion3 < 15) && (ME11_ARID_DEF.BlowerFanRunTime <
           cal_tiColdStartTimeMax) && (ME11_ARID_DEF.time >= rtb_Divide_ox)) {
        ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Cold_Air_Protection;
        ACCtl_stStartState = ME11_ColdStart;
        ME11_ARID_DEF.time = 0U;
      } else if ((rtb_DataTypeConversion4 > cal_CAPStartCoolantMin + 8) ||
                 HMICtl_bACDefrost || (rtb_DataTypeConversion1_i < 2) ||
                 (!rtb_AND_b3z) || (ME11_ARID_DEF.time >= rtb_Divide_ox)) {
        ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Normal_Op;
        ACCtl_stStartState = ME11_NormalStart;
      } else {
        rtb_Divide1_f = ME11_ARID_DEF.time + 1U;
        if (ME11_ARID_DEF.time + 1U > 65535U) {
          rtb_Divide1_f = 65535U;
        }

        ME11_ARID_DEF.time = (uint16)rtb_Divide1_f;
      }
      break;

     default:
      /* case IN_Normal_Op: */
      ACCtl_stStartState = ME11_NormalStart;
      if (rtb_AND_b3z && (!HMICtl_bACDefrost) && (rtb_DataTypeConversion2 <
           rtb_DataTypeConversion_dt) && (rtb_DataTypeConversion3 > 30) &&
          (rtb_DataTypeConversion_dt > cal_HAPevap_min) &&
          (ME11_ARID_DEF.BlowerFanRunTime < cal_HAPpurge_time)) {
        ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Hot_Air_Protection;
        ACCtl_stStartState = ME11_HotStart;
      } else {
        rtb_Compare_fx = !HMICtl_bACDefrost;
        if ((rtb_DataTypeConversion4 < cal_CAPStartCoolantMin) && rtb_Compare_fx
            && (rtb_DataTypeConversion1_i > 8) && rtb_AND_b3z &&
            (rtb_DataTypeConversion3 < 15) && (ME11_ARID_DEF.BlowerFanRunTime <
             cal_tiColdStartTimeMax)) {
          ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Cold_Air_Protection;
          ACCtl_stStartState = ME11_ColdStart;
          ME11_ARID_DEF.time = 0U;
        } else if ((rtb_DataTypeConversion4 < cal_CAPStartCoolantMin + 5) &&
                   rtb_Compare_fx && (rtb_DataTypeConversion1_i > 8) &&
                   rtb_AND_b3z && (rtb_DataTypeConversion3 < 15) &&
                   (ME11_ARID_DEF.BlowerFanRunTime < cal_tiColdStartTimeMax)) {
          ME11_ARID_DEF.is_ACStartModeMng = ME11_IN_Normal_LittleCold;
          ACCtl_stStartState = ME11_LittleCold;
          ME11_ARID_DEF.time = 0U;
        }
      }
      break;
    }
  }

  /* End of Chart: '<S39>/AirConditionStartState' */

  /* Lookup_n-D: '<S178>/cal_ECOEvaDesValLL_MAP' incorporates:
   *  Switch: '<S1085>/Switch'
   *  Switch: '<S1165>/Switch'
   */
  ACCtl_sECOEvaDesValLL = look2_iflf_binlca(ACSen_sEnvTempCor,
    HMICtl_sLeftSetPoint, (const float32 *)&cal_ECOEvaDesValLL_2X[0], (const
    float32 *)&cal_ECOEvaDesValLL_2Y[0], (const float32 *)
    &cal_ECOEvaDesValLL_MAP[0], ME11_ConstP.cal_ECOEvaDesValLL_MAP_maxIndex, 6U);

  /* Switch: '<S178>/Switch1' incorporates:
   *  Constant: '<S178>/Constant7'
   *  Logic: '<S178>/AND1'
   *  Logic: '<S178>/NOT'
   *  MinMax: '<S178>/MinMax1'
   *  RelationalOperator: '<S178>/Relational Operator1'
   *  Switch: '<S178>/Switch'
   */
  if ((rtb_DataTypeConversion_f == ACEconMode_Economy) && (!HMICtl_bACDefrost))
  {
    /* MinMax: '<S178>/Max' */
    if (ACCtl_tDrEvapDes >= ACCtl_sECOEvaDesValLL) {
      /* Switch: '<S178>/Switch1' */
      ACCtl_tSetPointEvap = ACCtl_tDrEvapDes;
    } else {
      /* Switch: '<S178>/Switch1' */
      ACCtl_tSetPointEvap = ACCtl_sECOEvaDesValLL;
    }

    /* End of MinMax: '<S178>/Max' */
  } else {
    if (ACCtl_stEvaCooledFlag) {
      /* MinMax: '<S178>/MinMax' incorporates:
       *  Switch: '<S178>/Switch'
       */
      if (ACSen_sEvapTempFilter >= 25.0F) {
        /* Switch: '<S178>/Switch' */
        ACCtl_tSetPointEvap = ACSen_sEvapTempFilter;
      } else {
        /* Switch: '<S178>/Switch' */
        ACCtl_tSetPointEvap = 25.0F;
      }

      /* End of MinMax: '<S178>/MinMax' */
    } else if (ACCtl_tDrEvapDes <= ACCtl_tPsEvapDes) {
      /* MinMax: '<S178>/MinMax1' incorporates:
       *  Switch: '<S178>/Switch'
       */
      ACCtl_tSetPointEvap = ACCtl_tDrEvapDes;
    } else {
      /* Switch: '<S178>/Switch' incorporates:
       *  MinMax: '<S178>/MinMax1'
       */
      ACCtl_tSetPointEvap = ACCtl_tPsEvapDes;
    }

    /* Switch: '<S280>/Switch2' incorporates:
     *  Constant: '<S178>/Constant1'
     *  Constant: '<S279>/Constant'
     *  Constant: '<S333>/Constant'
     *  Logic: '<S279>/Logical Operator1'
     *  MinMax: '<S178>/MinMax1'
     *  RelationalOperator: '<S280>/LowerRelop1'
     *  RelationalOperator: '<S333>/Compare'
     *  Switch: '<S178>/Switch'
     *  Switch: '<S279>/Switch1'
     *  Switch: '<S279>/Switch5'
     */
    if (ACCtl_tSetPointEvap > cal_EvaDesLLMax) {
      /* Switch: '<S280>/Switch2' */
      ACCtl_tSetPointEvap = cal_EvaDesLLMax;
    } else {
      if (HMICtl_bLeftSetLow || cal_EvaDesLLSelect) {
        /* Switch: '<S279>/Switch1' incorporates:
         *  Constant: '<S279>/Constant2'
         */
        rtb_Delay1_ie = cal_EvaDesLLMin;
      } else {
        if (ACCtl_stStartState == 2) {
          /* Switch: '<S279>/Switch5' incorporates:
           *  Constant: '<S279>/Constant8'
           *  Switch: '<S279>/Switch1'
           */
          rtb_Merge = cal_CoolStartCompensate;
        } else {
          /* Switch: '<S279>/Switch5' incorporates:
           *  Constant: '<S279>/Constant9'
           *  Switch: '<S279>/Switch1'
           */
          rtb_Merge = 0.0F;
        }

        /* Lookup_n-D: '<S279>/cal_EvapDesLoLimBySolarCor_CUR' incorporates:
         *  MinMax: '<S279>/Max1'
         *  Switch: '<S279>/Switch1'
         */
        rtb_Delay1_ie = look1_iu16lftf_binlca(GlbDa_Solar, (const uint16 *)
          &cal_EvapDesLoLimBySolarCor_1X[0], (const float32 *)
          &cal_EvapDesLoLimBySolarCor_CUR[0], 1U);

        /* MinMax: '<S279>/Max' incorporates:
         *  Switch: '<S279>/Switch1'
         *  Switch: '<S279>/Switch5'
         */
        if (rtb_Delay1_ie <= rtb_Merge) {
          rtb_Merge = rtb_Delay1_ie;
        }

        /* Sum: '<S279>/Add' incorporates:
         *  Lookup_n-D: '<S279>/cal_EvapDesLoLimByEnv_CUR'
         *  MinMax: '<S279>/Max'
         *  Switch: '<S1085>/Switch'
         *  Switch: '<S279>/Switch1'
         */
        rtb_Delay1_ie = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
          &cal_EvapDesLoLimByEnv_1X[0], (const float32 *)
          &cal_EvapDesLoLimByEnv_CUR[0], 7U) + rtb_Merge;

        /* Switch: '<S334>/Switch2' incorporates:
         *  Constant: '<S279>/Constant4'
         *  Constant: '<S279>/Constant6'
         *  RelationalOperator: '<S334>/LowerRelop1'
         *  RelationalOperator: '<S334>/UpperRelop'
         *  Switch: '<S279>/Switch1'
         *  Switch: '<S334>/Switch'
         */
        if (rtb_Delay1_ie > cal_EvaDesLLMax) {
          /* Switch: '<S279>/Switch1' incorporates:
           *  Switch: '<S334>/Switch2'
           */
          rtb_Delay1_ie = cal_EvaDesLLMax;
        } else if (rtb_Delay1_ie < cal_EvaDesLLMin) {
          /* Switch: '<S334>/Switch' incorporates:
           *  Constant: '<S279>/Constant6'
           *  Switch: '<S279>/Switch1'
           *  Switch: '<S334>/Switch2'
           */
          rtb_Delay1_ie = cal_EvaDesLLMin;
        }

        /* End of Switch: '<S334>/Switch2' */
      }

      /* Switch: '<S280>/Switch' incorporates:
       *  Constant: '<S333>/Constant'
       *  RelationalOperator: '<S280>/UpperRelop'
       *  RelationalOperator: '<S333>/Compare'
       *  Switch: '<S279>/Switch1'
       *  Switch: '<S279>/Switch5'
       */
      if (ACCtl_tSetPointEvap < rtb_Delay1_ie) {
        /* Switch: '<S280>/Switch2' */
        ACCtl_tSetPointEvap = rtb_Delay1_ie;
      }

      /* End of Switch: '<S280>/Switch' */
    }

    /* End of Switch: '<S280>/Switch2' */

    /* Switch: '<S277>/Switch' incorporates:
     *  Constant: '<S277>/ACCtl_tAimEvapForceDefog'
     */
    if (HMICtl_bACDefrost) {
      rtb_Merge1_m = 0.5F;
    }

    /* MinMax: '<S178>/MinMax2' incorporates:
     *  Switch: '<S277>/Switch'
     */
    if (rtb_Merge1_m <= ACCtl_tSetPointEvap) {
      /* Switch: '<S178>/Switch1' */
      ACCtl_tSetPointEvap = rtb_Merge1_m;
    }

    /* End of MinMax: '<S178>/MinMax2' */
  }

  /* End of Switch: '<S178>/Switch1' */

  /* Sum: '<S179>/Add' incorporates:
   *  Constant: '<S179>/Constant'
   */
  ACPTC_HeatingCond1 = ACSen_sEvapTempFilter + cal_TevapUpStepMin;

  /* Sum: '<S179>/Add1' incorporates:
   *  Constant: '<S179>/Constant1'
   */
  ACPTC_HeatingCond2 = ACSen_sEnvTempCor - cal_ErrAmbTDvtForPtcUL;

  /* Sum: '<S179>/Add2' incorporates:
   *  Constant: '<S179>/Constant2'
   */
  ACPtc_CloseCond1 = ACSen_sEnvTempCor + cal_ErrAmbTDvtForPtcLL;

  /* Sum: '<S179>/Add3' incorporates:
   *  Constant: '<S179>/Constant3'
   *  Delay: '<S179>/Delay'
   */
  ACPTC_HeatedCond1 = ME11_ARID_DEF.Delay_DSTATE_e + cal_TevapUpStepMin;

  /* Lookup_n-D: '<S341>/cal_ACPTCDesFanCor_CUR' incorporates:
   *  Delay: '<S35>/Delay'
   */
  ACPTCDrDesFanCor = look1_iu8lftf_binlca(ME11_ARID_DEF.Delay_DSTATE_hr, (const
    uint8 *)&cal_ACPTCDesFanCor_1X[0], (const float32 *)&cal_ACPTCDesFanCor_CUR
    [0], 3U);

  /* Lookup_n-D: '<S341>/cal_ACPTCDesEnvCor_MAP' incorporates:
   *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
   *  Switch: '<S1085>/Switch'
   */
  ACPTCDrDesEnvCor = look2_iflf_binlca(ACSen_sEnvTempCor,
    (Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA())
    ->VIPM_ESCVehSpd_kph, (const float32 *)&cal_ACPTCDesEnvCor_2X[0], (const
    float32 *)&cal_ACPTCDesEnvCor_2Y[0], (const float32 *)
    &cal_ACPTCDesEnvCor_MAP[0], ME11_ConstP.pooled38, 6U);

  /* Lookup_n-D: '<S341>/cal_ACPTCDesCabinCor_CUR' incorporates:
   *  Switch: '<S176>/Switch2'
   */
  ACPTCDrDesCabinCor = look1_iflf_binlca(GlbDa_tCabinInvent, (const float32 *)
    &cal_ACPTCDesCabinCor_1X[0], (const float32 *)&cal_ACPTCDesCabinCor_CUR[0],
    7U);

  /* MultiPortSwitch: '<S341>/Multiport Switch1' incorporates:
   *  Delay: '<S4>/Delay'
   */
  switch (ME11_ARID_DEF.Delay_DSTATE_fl) {
   case BlowerModes_FaceMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S341>/cal_ACPTCDesBacAC_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_ACPTCDesBacAC_1X[0], (const float32 *)&cal_ACPTCDesBacAC_CUR[0], 11U);
    break;

   case BlowerModes_FaceHeaterMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S341>/cal_ACPTCDesBacBi_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_ACPTCDesBacBi_1X[0], (const float32 *)&cal_ACPTCDesBacBi_CUR[0], 11U);
    break;

   case BlowerModes_HeaterMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S341>/cal_ACPTCDesBacFoot_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_ACPTCDesBacFoot_1X[0], (const float32 *)&cal_ACPTCDesBacFoot_CUR[0],
      11U);
    break;

   case BlowerModes_HeaterDeforstMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S341>/cal_ACPTCDesBacFootDe_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_ACPTCDesBacFootDe_1X[0], (const float32 *)&cal_ACPTCDesBacFootDe_CUR
      [0], 11U);
    break;

   case BlowerModes_DeforstMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S341>/cal_ACPTCDesBacDefog_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_ACPTCDesBacDefog_1X[0], (const float32 *)&cal_ACPTCDesBacDefog_CUR[0],
      11U);
    break;

   default:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S341>/cal_ACPTCDesBacBi_CUR'
     *  Switch: '<S181>/Switch3'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
      &cal_ACPTCDesBacBi_1X[0], (const float32 *)&cal_ACPTCDesBacBi_CUR[0], 11U);
    break;
  }

  /* End of MultiPortSwitch: '<S341>/Multiport Switch1' */

  /* Switch: '<S341>/Switch' incorporates:
   *  Constant: '<S341>/Constant2'
   *  RelationalOperator: '<S341>/Relational Operator2'
   */
  if (ACSen_eAirInletPer < cal_ACRecirRatioLmt) {
    rtb_Add_ok = ACPTCDrDesEnvCor;
  } else {
    rtb_Add_ok = ACPTCDrDesCabinCor;
  }

  /* Sum: '<S341>/Add1' incorporates:
   *  Sum: '<S341>/Add'
   *  Switch: '<S341>/Switch'
   */
  ACCtl_tDrSetBasicPTC = (ACPTCDrDesFanCor + rtb_Add_ok) + rtb_Delay1_ie;

  /* Switch: '<S343>/Switch2' incorporates:
   *  Constant: '<S341>/Constant'
   *  Constant: '<S341>/Constant1'
   *  RelationalOperator: '<S343>/LowerRelop1'
   *  RelationalOperator: '<S343>/UpperRelop'
   *  Switch: '<S343>/Switch'
   */
  if (ACCtl_tDrSetBasicPTC > 80.0F) {
    /* Switch: '<S343>/Switch2' */
    ACCtl_tDrSetBasicPTC = 80.0F;
  } else if (ACCtl_tDrSetBasicPTC < -40.0F) {
    /* Switch: '<S343>/Switch' incorporates:
     *  Constant: '<S341>/Constant1'
     *  Switch: '<S343>/Switch2'
     */
    ACCtl_tDrSetBasicPTC = -40.0F;
  }

  /* End of Switch: '<S343>/Switch2' */

  /* Outputs for Enabled SubSystem: '<S335>/CalAirCondPTCAimTemp_FIXPID' incorporates:
   *  EnablePort: '<S342>/Enable'
   */
  /* Constant: '<S335>/Constant' */
  if (cal_FixPIDSecletFlag) {
    /* Chart: '<S345>/deadzone' incorporates:
     *  Constant: '<S342>/Constant6'
     */
    ME11_deadzone_h(rtb_Gain6, 0.5, &rtb_flag_nk);

    /* RelationalOperator: '<S345>/Relational Operator' */
    rtb_AND_b3z = (ACCtl_tDrDVT >= ACCtl_tLeftDuct);

    /* Switch: '<S345>/Switch1' incorporates:
     *  Switch: '<S345>/Switch'
     */
    if (rtb_flag_nk) {
      /* Switch: '<S345>/Switch1' incorporates:
       *  Constant: '<S345>/Constant'
       */
      rtb_Gain6 = 0.0F;
    } else if (!rtb_AND_b3z) {
      /* Switch: '<S345>/Switch1' incorporates:
       *  Sum: '<S345>/Sum1'
       *  Switch: '<S345>/Switch'
       */
      rtb_Gain6 = ACCtl_tLeftDuct - ACCtl_tDrDVT;
    }

    /* End of Switch: '<S345>/Switch1' */

    /* Switch: '<S342>/Switch3' */
    if (rtb_AND_b3z) {
      /* Switch: '<S342>/Switch3' incorporates:
       *  Constant: '<S342>/Kp16'
       */
      rtb_Merge1_m = cal_DrPtcDesValPIDIntegDeadBand4InHeat;
    } else {
      /* Switch: '<S342>/Switch3' incorporates:
       *  Constant: '<S342>/Kp26'
       */
      rtb_Merge1_m = cal_DrPtcDesValPIDIntegDeadBand4OutHeat;
    }

    /* End of Switch: '<S342>/Switch3' */

    /* Outputs for Enabled SubSystem: '<S348>/P_NEG' */
    /* Logic: '<S348>/Logical Operator' incorporates:
     *  Constant: '<S342>/Kp7'
     *  Constant: '<S342>/Kp9'
     */
    ME11_P_NEG(!rtb_AND_b3z, rtb_Gain6, rtb_Merge1_m, cal_DrPtcDesValPIDKiNeg,
               cal_DrPtcDesValPIDKi, (float32 *)&ACCtl_tDrPTCICor);

    /* End of Outputs for SubSystem: '<S348>/P_NEG' */

    /* Outputs for Enabled SubSystem: '<S348>/P_POS' */
    /* Constant: '<S342>/Kp10' incorporates:
     *  Constant: '<S342>/Kp7'
     */
    ME11_P_POS(rtb_AND_b3z, rtb_Gain6, rtb_Merge1_m, cal_DrPtcDesValPIDKiPos,
               cal_DrPtcDesValPIDKi, (float32 *)&ACCtl_tDrPTCICor);

    /* End of Outputs for SubSystem: '<S348>/P_POS' */

    /* Switch: '<S344>/Switch1' */
    if (rtb_FixPtRelationalOperator_mk) {
      /* MultiPortSwitch: '<S348>/Multiport Switch' incorporates:
       *  Delay: '<S348>/Delay'
       */
      switch (ME11_ARID_DEF.Delay_DSTATE_b4) {
       case 0:
        /* Switch: '<S352>/Switch' */
        if (rtb_AND_b3z) {
          /* Switch: '<S349>/Switch2' incorporates:
           *  Delay: '<S344>/Delay'
           *  Sum: '<S352>/Add'
           *  Switch: '<S352>/Switch'
           */
          ACCtl_tDrPTCISum = ACCtl_tDrPTCISum + ACCtl_tDrPTCICor;
        } else {
          /* Switch: '<S349>/Switch2' incorporates:
           *  Delay: '<S344>/Delay'
           *  Sum: '<S352>/Add1'
           *  Switch: '<S352>/Switch'
           */
          ACCtl_tDrPTCISum = ACCtl_tDrPTCISum - ACCtl_tDrPTCICor;
        }

        /* End of Switch: '<S352>/Switch' */
        break;

       case 1:
        /* Switch: '<S353>/Switch' */
        if (!rtb_AND_b3z) {
          /* Switch: '<S349>/Switch2' incorporates:
           *  Delay: '<S344>/Delay'
           *  Sum: '<S353>/Add1'
           *  Switch: '<S353>/Switch'
           */
          ACCtl_tDrPTCISum = ACCtl_tDrPTCISum - ACCtl_tDrPTCICor;
        }

        /* End of Switch: '<S353>/Switch' */
        break;

       case 2:
        /* Switch: '<S350>/Switch' */
        if (rtb_AND_b3z) {
          /* Switch: '<S349>/Switch2' incorporates:
           *  Delay: '<S344>/Delay'
           *  Sum: '<S350>/Add'
           *  Switch: '<S350>/Switch'
           */
          ACCtl_tDrPTCISum = ACCtl_tDrPTCISum + ACCtl_tDrPTCICor;
        }

        /* End of Switch: '<S350>/Switch' */
        break;

       case 3:
        break;
      }

      /* End of MultiPortSwitch: '<S348>/Multiport Switch' */

      /* Switch: '<S349>/Switch2' incorporates:
       *  Constant: '<S342>/Constant1'
       *  Constant: '<S342>/Kp13'
       *  Constant: '<S342>/Kp8'
       *  RelationalOperator: '<S349>/LowerRelop1'
       *  RelationalOperator: '<S349>/UpperRelop'
       *  Sum: '<S344>/Add'
       *  Switch: '<S349>/Switch'
       */
      if ((ACCtl_tDrPTCISum - 8000.0F) + 8000.0F > cal_DrPtcDesValPID_IsumMax) {
        /* Switch: '<S344>/Switch1' incorporates:
         *  Switch: '<S349>/Switch2'
         */
        ACCtl_tDrPTCISum = cal_DrPtcDesValPID_IsumMax;
      } else if ((ACCtl_tDrPTCISum - 8000.0F) + 8000.0F <
                 cal_DrPtcDesValPID_IsumMin) {
        /* Switch: '<S349>/Switch' incorporates:
         *  Constant: '<S342>/Kp13'
         *  Switch: '<S344>/Switch1'
         *  Switch: '<S349>/Switch2'
         */
        ACCtl_tDrPTCISum = cal_DrPtcDesValPID_IsumMin;
      } else {
        /* Switch: '<S344>/Switch1' incorporates:
         *  Switch: '<S349>/Switch2'
         */
        ACCtl_tDrPTCISum = (ACCtl_tDrPTCISum - 8000.0F) + 8000.0F;
      }

      /* End of Switch: '<S349>/Switch2' */
    } else {
      /* Switch: '<S344>/Switch1' incorporates:
       *  Constant: '<S342>/Constant5'
       */
      ACCtl_tDrPTCISum = 0.0F;
    }

    /* End of Switch: '<S344>/Switch1' */

    /* Outputs for Enabled SubSystem: '<S346>/PI_Controller1' */
    /* Update for Delay: '<S348>/Delay' incorporates:
     *  Logic: '<S346>/Logical Operator'
     */
    ME11_PI_Controller1(!rtb_FixPtRelationalOperator_mk, ACCtl_tDrSetBasicPTC,
                        &ME11_ARID_DEF.PI_Cor_p, &ME11_ARID_DEF.Delay_DSTATE_b4);

    /* End of Outputs for SubSystem: '<S346>/PI_Controller1' */

    /* Outputs for Enabled SubSystem: '<S347>/P_NEG' */
    /* Logic: '<S347>/Logical Operator' incorporates:
     *  Constant: '<S342>/Kp'
     *  Constant: '<S342>/Kp1'
     *  Constant: '<S342>/Kp4'
     */
    ME11_P_NEG_h(!rtb_AND_b3z, rtb_Gain6, cal_DrPtcDesValPID_pWinNeg,
                 cal_DrPtcDesValPIDKpNeg, cal_DrPtcDesValPIDKp, (float32 *)
                 &ACCtl_tDrPTCPCor);

    /* End of Outputs for SubSystem: '<S347>/P_NEG' */

    /* Outputs for Enabled SubSystem: '<S347>/P_POS' */
    /* Constant: '<S342>/Kp3' incorporates:
     *  Constant: '<S342>/Kp'
     *  Constant: '<S342>/Kp2'
     */
    ME11_P_POS_c(rtb_AND_b3z, rtb_Gain6, cal_DrPtcDesValPID_pWinPos,
                 cal_DrPtcDesValPIDKpPos, cal_DrPtcDesValPIDKp, (float32 *)
                 &ACCtl_tDrPTCPCor);

    /* End of Outputs for SubSystem: '<S347>/P_POS' */

    /* Outputs for Enabled SubSystem: '<S346>/PI_Controller' */
    /* Update for Delay: '<S348>/Delay' incorporates:
     *  Constant: '<S342>/Kp5'
     *  Constant: '<S342>/Kp6'
     */
    ME11_PI_Controller(rtb_FixPtRelationalOperator_mk, rtb_AND_b3z,
                       ACCtl_tDrSetBasicPTC, ACCtl_tDrPTCPCor, ACCtl_tDrPTCISum,
                       cal_DrPtcDesValPIDUL, cal_DrPtcDesValPIDLL,
                       &ME11_ARID_DEF.PI_Cor_p, &ME11_ARID_DEF.Delay_DSTATE_b4);

    /* End of Outputs for SubSystem: '<S346>/PI_Controller' */
  }

  /* End of Constant: '<S335>/Constant' */
  /* End of Outputs for SubSystem: '<S335>/CalAirCondPTCAimTemp_FIXPID' */

  /* Lookup_n-D: '<S363>/cal_ACPTCPsDesFanCor_CUR' incorporates:
   *  Delay: '<S35>/Delay'
   */
  ACPTCPsDesFanCor = look1_iu8lftf_binlca(ME11_ARID_DEF.Delay_DSTATE_hr, (const
    uint8 *)&cal_ACPTCPsDesFanCor_1X[0], (const float32 *)
    &cal_ACPTCPsDesFanCor_CUR[0], 3U);

  /* Lookup_n-D: '<S363>/cal_ACPTCPsDesEnvCor_MAP' incorporates:
   *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
   *  Switch: '<S1085>/Switch'
   */
  ACPTCPsDesEnvCor = look2_iflf_binlca(ACSen_sEnvTempCor,
    (Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA())
    ->VIPM_ESCVehSpd_kph, (const float32 *)&cal_ACPTCPsDesEnvCor_2X[0], (const
    float32 *)&cal_ACPTCPsDesEnvCor_2Y[0], (const float32 *)
    &cal_ACPTCPsDesEnvCor_MAP[0], ME11_ConstP.pooled38, 6U);

  /* Lookup_n-D: '<S363>/cal_ACPTCPsDesCabinCor_CUR' incorporates:
   *  Switch: '<S176>/Switch2'
   */
  ACPTCPsDesCabinCor = look1_iflf_binlca(GlbDa_tCabinInvent, (const float32 *)
    &cal_ACPTCPsDesCabinCor_1X[0], (const float32 *)&cal_ACPTCPsDesCabinCor_CUR
    [0], 7U);

  /* MultiPortSwitch: '<S363>/Multiport Switch1' incorporates:
   *  Delay: '<S4>/Delay'
   */
  switch (ME11_ARID_DEF.Delay_DSTATE_fl) {
   case BlowerModes_FaceMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S363>/cal_ACPTCPsDesBacAC_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_ACPTCPsDesBacAC_1X[0], (const float32 *)&cal_ACPTCPsDesBacAC_CUR[0],
      11U);
    break;

   case BlowerModes_FaceHeaterMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S363>/cal_ACPTCPsDesBacBi_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_ACPTCPsDesBacBi_1X[0], (const float32 *)&cal_ACPTCPsDesBacBi_CUR[0],
      11U);
    break;

   case BlowerModes_HeaterMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S363>/cal_ACPTCPsDesBacFoot_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_ACPTCPsDesBacFoot_1X[0], (const float32 *)&cal_ACPTCPsDesBacFoot_CUR
      [0], 11U);
    break;

   case BlowerModes_HeaterDeforstMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S363>/cal_ACPTCPsDesBacFootDe_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_ACPTCPsDesBacFootDe_1X[0], (const float32 *)
      &cal_ACPTCPsDesBacFootDe_CUR[0], 11U);
    break;

   case BlowerModes_DeforstMode:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S363>/cal_ACPTCPsDesBacDefog_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_ACPTCPsDesBacDefog_1X[0], (const float32 *)
      &cal_ACPTCPsDesBacDefog_CUR[0], 11U);
    break;

   default:
    /* Gain: '<S8>/Gain8' incorporates:
     *  Lookup_n-D: '<S363>/cal_ACPTCPsDesBacBi_CUR'
     *  Switch: '<S182>/Switch1'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
      &cal_ACPTCPsDesBacBi_1X[0], (const float32 *)&cal_ACPTCPsDesBacBi_CUR[0],
      11U);
    break;
  }

  /* End of MultiPortSwitch: '<S363>/Multiport Switch1' */

  /* Switch: '<S363>/Switch' incorporates:
   *  Constant: '<S363>/Constant2'
   *  RelationalOperator: '<S363>/Relational Operator2'
   */
  if (ACSen_eAirInletPer < cal_ACRecirRatioLmt) {
    rtb_Add_ok = ACPTCPsDesEnvCor;
  } else {
    rtb_Add_ok = ACPTCPsDesCabinCor;
  }

  /* Sum: '<S363>/Add1' incorporates:
   *  Sum: '<S363>/Add'
   *  Switch: '<S363>/Switch'
   */
  ACCtl_tPsSetBasicPTC = (ACPTCPsDesFanCor + rtb_Add_ok) + rtb_Delay1_ie;

  /* Switch: '<S365>/Switch2' incorporates:
   *  Constant: '<S363>/Constant'
   *  Constant: '<S363>/Constant1'
   *  RelationalOperator: '<S365>/LowerRelop1'
   *  RelationalOperator: '<S365>/UpperRelop'
   *  Switch: '<S365>/Switch'
   */
  if (ACCtl_tPsSetBasicPTC > 80.0F) {
    /* Switch: '<S365>/Switch2' */
    ACCtl_tPsSetBasicPTC = 80.0F;
  } else if (ACCtl_tPsSetBasicPTC < -40.0F) {
    /* Switch: '<S365>/Switch' incorporates:
     *  Constant: '<S363>/Constant1'
     *  Switch: '<S365>/Switch2'
     */
    ACCtl_tPsSetBasicPTC = -40.0F;
  }

  /* End of Switch: '<S365>/Switch2' */

  /* Outputs for Enabled SubSystem: '<S336>/CalAirCondPTCAimTemp_LeftDes' incorporates:
   *  EnablePort: '<S364>/Enable'
   */
  /* Constant: '<S336>/Constant' */
  if (cal_FixPIDSecletFlag) {
    /* Chart: '<S367>/deadzone' incorporates:
     *  Constant: '<S364>/Constant6'
     */
    ME11_deadzone_h(rtb_Delay, 0.5, &rtb_flag_n);

    /* RelationalOperator: '<S367>/Relational Operator' */
    rtb_AND_b3z = (ACCtl_tPsDVT >= ACCtl_tRightDuct);

    /* Switch: '<S367>/Switch1' incorporates:
     *  Switch: '<S367>/Switch'
     */
    if (rtb_flag_n) {
      /* Switch: '<S367>/Switch1' incorporates:
       *  Constant: '<S367>/Constant'
       */
      rtb_Delay = 0.0F;
    } else if (!rtb_AND_b3z) {
      /* Switch: '<S367>/Switch1' incorporates:
       *  Sum: '<S367>/Sum1'
       *  Switch: '<S367>/Switch'
       */
      rtb_Delay = ACCtl_tRightDuct - ACCtl_tPsDVT;
    }

    /* End of Switch: '<S367>/Switch1' */

    /* Switch: '<S364>/Switch3' */
    if (rtb_AND_b3z) {
      /* Switch: '<S364>/Switch3' incorporates:
       *  Constant: '<S364>/Kp16'
       */
      rtb_Merge1_m = cal_PsPtcDesValPIDIntegDeadBand4InHeat;
    } else {
      /* Switch: '<S364>/Switch3' incorporates:
       *  Constant: '<S364>/Kp24'
       */
      rtb_Merge1_m = cal_PsPtcDesValPIDIntegDeadBand4OutHeat;
    }

    /* End of Switch: '<S364>/Switch3' */

    /* Outputs for Enabled SubSystem: '<S370>/P_NEG' */
    /* Logic: '<S370>/Logical Operator' incorporates:
     *  Constant: '<S364>/Kp7'
     *  Constant: '<S364>/Kp9'
     */
    ME11_P_NEG(!rtb_AND_b3z, rtb_Delay, rtb_Merge1_m, cal_PsPtcDesValPIDKiNeg,
               cal_PsPtcDesValPIDKi, (float32 *)&ACCtl_tPsPTCICor);

    /* End of Outputs for SubSystem: '<S370>/P_NEG' */

    /* Outputs for Enabled SubSystem: '<S370>/P_POS' */
    /* Constant: '<S364>/Kp10' incorporates:
     *  Constant: '<S364>/Kp7'
     */
    ME11_P_POS(rtb_AND_b3z, rtb_Delay, rtb_Merge1_m, cal_PsPtcDesValPIDKiPos,
               cal_PsPtcDesValPIDKi, (float32 *)&ACCtl_tPsPTCICor);

    /* End of Outputs for SubSystem: '<S370>/P_POS' */

    /* Switch: '<S366>/Switch1' */
    if (rtb_Delay1_ag) {
      /* MultiPortSwitch: '<S370>/Multiport Switch' incorporates:
       *  Delay: '<S370>/Delay'
       */
      switch (ME11_ARID_DEF.Delay_DSTATE_ou) {
       case 0:
        /* Switch: '<S374>/Switch' */
        if (rtb_AND_b3z) {
          /* Switch: '<S371>/Switch2' incorporates:
           *  Delay: '<S366>/Delay'
           *  Sum: '<S374>/Add'
           *  Switch: '<S374>/Switch'
           */
          ACCtl_tPsPTCISum = ACCtl_tPsPTCISum + ACCtl_tPsPTCICor;
        } else {
          /* Switch: '<S371>/Switch2' incorporates:
           *  Delay: '<S366>/Delay'
           *  Sum: '<S374>/Add1'
           *  Switch: '<S374>/Switch'
           */
          ACCtl_tPsPTCISum = ACCtl_tPsPTCISum - ACCtl_tPsPTCICor;
        }

        /* End of Switch: '<S374>/Switch' */
        break;

       case 1:
        /* Switch: '<S375>/Switch' */
        if (!rtb_AND_b3z) {
          /* Switch: '<S371>/Switch2' incorporates:
           *  Delay: '<S366>/Delay'
           *  Sum: '<S375>/Add1'
           *  Switch: '<S375>/Switch'
           */
          ACCtl_tPsPTCISum = ACCtl_tPsPTCISum - ACCtl_tPsPTCICor;
        }

        /* End of Switch: '<S375>/Switch' */
        break;

       case 2:
        /* Switch: '<S372>/Switch' */
        if (rtb_AND_b3z) {
          /* Switch: '<S371>/Switch2' incorporates:
           *  Delay: '<S366>/Delay'
           *  Sum: '<S372>/Add'
           *  Switch: '<S372>/Switch'
           */
          ACCtl_tPsPTCISum = ACCtl_tPsPTCISum + ACCtl_tPsPTCICor;
        }

        /* End of Switch: '<S372>/Switch' */
        break;

       case 3:
        break;
      }

      /* End of MultiPortSwitch: '<S370>/Multiport Switch' */

      /* Switch: '<S371>/Switch2' incorporates:
       *  Constant: '<S364>/Constant2'
       *  Constant: '<S364>/Kp13'
       *  Constant: '<S364>/Kp8'
       *  RelationalOperator: '<S371>/LowerRelop1'
       *  RelationalOperator: '<S371>/UpperRelop'
       *  Sum: '<S366>/Add'
       *  Switch: '<S371>/Switch'
       */
      if ((ACCtl_tPsPTCISum - 8000.0F) + 8000.0F > cal_PsPtcDesValPID_IsumMax) {
        /* Switch: '<S366>/Switch1' incorporates:
         *  Switch: '<S371>/Switch2'
         */
        ACCtl_tPsPTCISum = cal_PsPtcDesValPID_IsumMax;
      } else if ((ACCtl_tPsPTCISum - 8000.0F) + 8000.0F <
                 cal_PsPtcDesValPID_IsumMin) {
        /* Switch: '<S371>/Switch' incorporates:
         *  Constant: '<S364>/Kp13'
         *  Switch: '<S366>/Switch1'
         *  Switch: '<S371>/Switch2'
         */
        ACCtl_tPsPTCISum = cal_PsPtcDesValPID_IsumMin;
      } else {
        /* Switch: '<S366>/Switch1' incorporates:
         *  Switch: '<S371>/Switch2'
         */
        ACCtl_tPsPTCISum = (ACCtl_tPsPTCISum - 8000.0F) + 8000.0F;
      }

      /* End of Switch: '<S371>/Switch2' */
    } else {
      /* Switch: '<S366>/Switch1' incorporates:
       *  Constant: '<S364>/Constant4'
       */
      ACCtl_tPsPTCISum = 0.0F;
    }

    /* End of Switch: '<S366>/Switch1' */

    /* Outputs for Enabled SubSystem: '<S368>/PI_Controller1' */
    /* Update for Delay: '<S370>/Delay' incorporates:
     *  Logic: '<S368>/Logical Operator'
     */
    ME11_PI_Controller1(!rtb_Delay1_ag, ACCtl_tPsSetBasicPTC,
                        &ME11_ARID_DEF.PI_Cor, &ME11_ARID_DEF.Delay_DSTATE_ou);

    /* End of Outputs for SubSystem: '<S368>/PI_Controller1' */

    /* Outputs for Enabled SubSystem: '<S369>/P_NEG' */
    /* Logic: '<S369>/Logical Operator' incorporates:
     *  Constant: '<S364>/Kp'
     *  Constant: '<S364>/Kp1'
     *  Constant: '<S364>/Kp4'
     */
    ME11_P_NEG_h(!rtb_AND_b3z, rtb_Delay, cal_PsPtcDesValPID_pWinNeg,
                 cal_PsPtcDesValPIDKpNeg, cal_PsPtcDesValPIDKp, (float32 *)
                 &ACCtl_tPsPTCPCor);

    /* End of Outputs for SubSystem: '<S369>/P_NEG' */

    /* Outputs for Enabled SubSystem: '<S369>/P_POS' */
    /* Constant: '<S364>/Kp3' incorporates:
     *  Constant: '<S364>/Kp'
     *  Constant: '<S364>/Kp2'
     */
    ME11_P_POS_c(rtb_AND_b3z, rtb_Delay, cal_PsPtcDesValPID_pWinPos,
                 cal_PsPtcDesValPIDKpPos, cal_PsPtcDesValPIDKp, (float32 *)
                 &ACCtl_tPsPTCPCor);

    /* End of Outputs for SubSystem: '<S369>/P_POS' */

    /* Outputs for Enabled SubSystem: '<S368>/PI_Controller' */
    /* Update for Delay: '<S370>/Delay' incorporates:
     *  Constant: '<S364>/Kp5'
     *  Constant: '<S364>/Kp6'
     */
    ME11_PI_Controller(rtb_Delay1_ag, rtb_AND_b3z, ACCtl_tPsSetBasicPTC,
                       ACCtl_tPsPTCPCor, ACCtl_tPsPTCISum, cal_PsPtcDesValPIDUL,
                       cal_PsPtcDesValPIDLL, &ME11_ARID_DEF.PI_Cor,
                       &ME11_ARID_DEF.Delay_DSTATE_ou);

    /* End of Outputs for SubSystem: '<S368>/PI_Controller' */
  }

  /* End of Constant: '<S336>/Constant' */
  /* End of Outputs for SubSystem: '<S336>/CalAirCondPTCAimTemp_LeftDes' */

  /* MinMax: '<S179>/MinMax1' */
  if (ACCtl_tPsDVT >= ACCtl_tDrDVT) {
    /* MinMax: '<S179>/MinMax1' */
    rtb_Merge1_m = ACCtl_tPsDVT;
  } else {
    /* MinMax: '<S179>/MinMax1' */
    rtb_Merge1_m = ACCtl_tDrDVT;
  }

  /* End of MinMax: '<S179>/MinMax1' */

  /* Chart: '<S179>/PTCHeatedCheck' */
  if (ME11_ARID_DEF.is_active_c53_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c53_ME11 = 1U;
    ME11_ARID_DEF.is_c53_ME11 = ME11_IN_PTC_Heating;
    ACCtl_stACPTCHeated = false;
  } else {
    switch (ME11_ARID_DEF.is_c53_ME11) {
     case ME11_IN_PTC_Heating:
      ACCtl_stACPTCHeated = false;
      if ((rtb_Merge1_m > ACPTC_HeatingCond1) && (rtb_Merge1_m <
           ACPTC_HeatingCond2)) {
        ME11_ARID_DEF.is_c53_ME11 = ME11_IN_PTC_Stoping;
        ME11_ARID_DEF.RecordInitialEvapTemp = ACSen_sEvapTempFilter;
        ACCtl_stACPTCHeated = false;
        ME11_ARID_DEF.EvapTempUpWaiteTime = 0U;
      }
      break;

     case ME11_IN_PTC_Stop:
      ACCtl_stACPTCHeated = true;
      if (rtb_Merge1_m > ACPtc_CloseCond1) {
        ME11_ARID_DEF.is_c53_ME11 = ME11_IN_PTC_Heating;
        ACCtl_stACPTCHeated = false;
      }
      break;

     default:
      /* case IN_PTC_Stoping: */
      ACCtl_stACPTCHeated = false;
      if ((ME11_ARID_DEF.EvapTempUpWaiteTime > cal_TevapUpTime) || (rtb_Merge1_m
           > ACPtc_CloseCond1)) {
        ME11_ARID_DEF.EvapTempUpWaiteTime = 0U;
        ME11_ARID_DEF.is_c53_ME11 = ME11_IN_PTC_Heating;
        ACCtl_stACPTCHeated = false;
      } else if (ACSen_sEvapTempFilter > ACPTC_HeatedCond1) {
        ME11_ARID_DEF.EvapTempUpWaiteTime = 0U;
        ME11_ARID_DEF.is_c53_ME11 = ME11_IN_PTC_Stop;
        ACCtl_stACPTCHeated = true;
      } else {
        b_previousEvent = ME11_ARID_DEF.EvapTempUpWaiteTime + 1;
        if (ME11_ARID_DEF.EvapTempUpWaiteTime + 1 > 65535) {
          b_previousEvent = 65535;
        }

        ME11_ARID_DEF.EvapTempUpWaiteTime = (uint16)b_previousEvent;
      }
      break;
    }
  }

  /* End of Chart: '<S179>/PTCHeatedCheck' */

  /* Switch: '<S179>/Switch3' incorporates:
   *  Constant: '<S179>/Constant7'
   *  MinMax: '<S179>/MinMax'
   *  RelationalOperator: '<S179>/Relational Operator1'
   *  Switch: '<S179>/Switch1'
   */
  if (ACCtl_stACPTCHeated) {
    /* MinMax: '<S179>/MinMax2' */
    if (rtb_Merge_g <= 0.0F) {
      /* Switch: '<S179>/Switch3' */
      rtb_Merge1_m = rtb_Merge_g;
    } else {
      /* Switch: '<S179>/Switch3' */
      rtb_Merge1_m = 0.0F;
    }

    /* End of MinMax: '<S179>/MinMax2' */
  } else if (rtb_DataTypeConversion_f == ACEconMode_Economy) {
    /* Switch: '<S179>/Switch3' incorporates:
     *  Switch: '<S179>/Switch1'
     */
    rtb_Merge1_m = ME11_ARID_DEF.PI_Cor_p;
  } else if (ME11_ARID_DEF.PI_Cor >= ME11_ARID_DEF.PI_Cor_p) {
    /* MinMax: '<S179>/MinMax' incorporates:
     *  Switch: '<S179>/Switch1'
     *  Switch: '<S179>/Switch3'
     */
    rtb_Merge1_m = ME11_ARID_DEF.PI_Cor;
  } else {
    /* Switch: '<S179>/Switch3' incorporates:
     *  MinMax: '<S179>/MinMax'
     *  Switch: '<S179>/Switch1'
     */
    rtb_Merge1_m = ME11_ARID_DEF.PI_Cor_p;
  }

  /* End of Switch: '<S179>/Switch3' */

  /* Switch: '<S385>/Init' incorporates:
   *  Constant: '<S179>/Constant5'
   *  Constant: '<S339>/Constant'
   *  Product: '<S339>/Product'
   *  Product: '<S339>/Product1'
   *  Sum: '<S339>/Sum'
   *  Sum: '<S339>/Sum1'
   *  UnitDelay: '<S385>/FixPt Unit Delay1'
   *  UnitDelay: '<S385>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_g != 0) {
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_b = rtb_Merge1_m;
  }

  ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_b = (1.0F - cal_SetPtcDesCoff) *
    ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_b + rtb_Merge1_m * cal_SetPtcDesCoff;

  /* End of Switch: '<S385>/Init' */

  /* Switch: '<S179>/Switch2' incorporates:
   *  Constant: '<S179>/Constant9'
   */
  if (cal_CabinSetPTCSwitch) {
    /* Switch: '<S179>/Switch2' incorporates:
     *  Constant: '<S340>/Constant'
     *  Delay: '<S340>/Delay'
     *  Delay: '<S340>/Delay1'
     *  Delay: '<S340>/Delay2'
     *  Delay: '<S340>/Delay3'
     *  Product: '<S340>/Divide'
     *  Sum: '<S340>/Add'
     */
    ACCtl_tSetPointPTC = ((((rtb_Merge1_m + ME11_ARID_DEF.Delay1_DSTATE_f) +
      ME11_ARID_DEF.Delay_DSTATE_k[0]) + ME11_ARID_DEF.Delay2_DSTATE[0]) +
                          ME11_ARID_DEF.Delay3_DSTATE[0]) / 5.0F;
  } else {
    /* Switch: '<S179>/Switch2' incorporates:
     *  UnitDelay: '<S385>/FixPt Unit Delay1'
     */
    ACCtl_tSetPointPTC = ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_b;
  }

  /* End of Switch: '<S179>/Switch2' */

  /* Lookup_n-D: '<S179>/cal_SetPtcDesTempMax_MAP' incorporates:
   *  Delay: '<S179>/Delay1'
   *  Switch: '<S1085>/Switch'
   */
  ACCCtl_sSetPtcDesTempMax = look2_ifu8lftf_binlca(ACSen_sEnvTempCor,
    ME11_ARID_DEF.Delay1_DSTATE_o, (const float32 *)&cal_SetPtcDesTempMax_2X[0],
    (const uint8 *)&cal_SetPtcDesTempMax_2Y[0], (const float32 *)
    &cal_SetPtcDesTempMax_MAP[0], ME11_ConstP.pooled36, 10U);

  /* Switch: '<S338>/Switch2' incorporates:
   *  Constant: '<S179>/Constant8'
   *  RelationalOperator: '<S338>/LowerRelop1'
   *  RelationalOperator: '<S338>/UpperRelop'
   *  Switch: '<S338>/Switch'
   */
  if (ACCtl_tSetPointPTC > ACCCtl_sSetPtcDesTempMax) {
    /* Switch: '<S338>/Switch2' */
    ACCtl_tSetPointPTC = ACCCtl_sSetPtcDesTempMax;
  } else if (ACCtl_tSetPointPTC < cal_SetPtcDesTempMin) {
    /* Switch: '<S338>/Switch' incorporates:
     *  Constant: '<S179>/Constant8'
     *  Switch: '<S338>/Switch2'
     */
    ACCtl_tSetPointPTC = cal_SetPtcDesTempMin;
  }

  /* End of Switch: '<S338>/Switch2' */

  /* RelationalOperator: '<S42>/Relational Operator1' incorporates:
   *  Constant: '<S42>/Constant'
   */
  rtb_Delay_j3 = (ME11_ARID_DEF.Switch1_nv != ACOff);

  /* Outputs for Enabled SubSystem: '<S42>/BlowerFanShutOff' incorporates:
   *  EnablePort: '<S48>/Enable'
   */
  /* Logic: '<S42>/Logical Operator' */
  if (!rtb_Delay_j3) {
    /* SignalConversion generated from: '<S48>/ACCtl_BloweFanSpeed' incorporates:
     *  Constant: '<S48>/Constant'
     */
    ACCtl_BloweFanSpeed = 0U;

    /* Merge generated from: '<S42>/Merge' incorporates:
     *  Constant: '<S48>/Constant1'
     *  SignalConversion generated from: '<S48>/AC_FanLevel_mp'
     */
    AC_FanLevelAct = 0U;

    /* Merge generated from: '<S42>/Merge' incorporates:
     *  SignalConversion generated from: '<S48>/AC_AutoFanLeVelCur'
     */
    AC_FanLeVel = HMICtl_eBlwSts;
  }

  /* End of Logic: '<S42>/Logical Operator' */
  /* End of Outputs for SubSystem: '<S42>/BlowerFanShutOff' */

  /* Logic: '<S35>/OR' */
  ACCtl_stRecTempLowEna = HMICtl_bLeftSetLow;

  /* Switch: '<S128>/Switch1' incorporates:
   *  Constant: '<S128>/Constant8'
   *  Constant: '<S128>/Constant9'
   *  Delay: '<S128>/Delay2'
   *  RelationalOperator: '<S128>/Relational Operator7'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForForceChange) {
    /* MinMax: '<S128>/MinMax1' incorporates:
     *  Constant: '<S128>/Constant10'
     *  Delay: '<S128>/Delay2'
     *  Sum: '<S128>/Subtract1'
     */
    if ((uint16)(ME11_ARID_DEF.Delay2_DSTATE_l + 1U) <= 50000) {
      ME11_ARID_DEF.Delay2_DSTATE_l++;
    } else {
      ME11_ARID_DEF.Delay2_DSTATE_l = 50000U;
    }

    /* End of MinMax: '<S128>/MinMax1' */
  } else {
    ME11_ARID_DEF.Delay2_DSTATE_l = 0U;
  }

  /* End of Switch: '<S128>/Switch1' */

  /* Switch: '<S128>/Switch2' incorporates:
   *  Constant: '<S128>/Constant1'
   *  Constant: '<S128>/Constant4'
   *  Delay: '<S128>/Delay1'
   *  Delay: '<S38>/Delay1'
   *  RelationalOperator: '<S128>/Relational Operator5'
   */
  if (ME11_ARID_DEF.Delay1_DSTATE_dt == 100) {
    /* MinMax: '<S128>/MinMax2' incorporates:
     *  Constant: '<S128>/Constant6'
     *  Delay: '<S128>/Delay1'
     *  Sum: '<S128>/Subtract2'
     */
    if ((uint16)(ME11_ARID_DEF.Delay1_DSTATE_m + 1U) <= 50000) {
      ME11_ARID_DEF.Delay1_DSTATE_m++;
    } else {
      ME11_ARID_DEF.Delay1_DSTATE_m = 50000U;
    }

    /* End of MinMax: '<S128>/MinMax2' */
  } else {
    ME11_ARID_DEF.Delay1_DSTATE_m = 0U;
  }

  /* End of Switch: '<S128>/Switch2' */

  /* Switch: '<S128>/Switch3' incorporates:
   *  Constant: '<S128>/Constant11'
   *  Constant: '<S128>/Constant5'
   *  Delay: '<S128>/Delay1'
   *  Logic: '<S128>/Logical Operator'
   *  RelationalOperator: '<S128>/Relational Operator1'
   *  RelationalOperator: '<S128>/Relational Operator6'
   */
  if ((ME11_ARID_DEF.Delay1_DSTATE_m >= cal_tiCO2Recirc2FreshMax) ||
      (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForForceChange)) {
    /* Switch: '<S128>/Switch3' incorporates:
     *  Constant: '<S128>/Constant12'
     *  Delay: '<S128>/Delay2'
     *  RelationalOperator: '<S128>/Relational Operator8'
     */
    ACCtl_stRecForceChangeEna = (ME11_ARID_DEF.Delay2_DSTATE_l <=
      cal_tiCO2Fresh2RecircMax);
  } else {
    /* Switch: '<S128>/Switch3' incorporates:
     *  Constant: '<S128>/Constant14'
     */
    ACCtl_stRecForceChangeEna = false;
  }

  /* End of Switch: '<S128>/Switch3' */

  /* RelationalOperator: '<S127>/Relational Operator6' incorporates:
   *  Constant: '<S127>/Constant4'
   */
  rtb_AND_b3z = (cal_AQS2OutRecThreVal > 0);

  /* Chart: '<S127>/Recirc_AQS' incorporates:
   *  Constant: '<S127>/Constant11'
   *  Constant: '<S127>/Constant5'
   */
  if (ME11_ARID_DEF.is_active_c27_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c27_ME11 = 1U;
    ME11_ARID_DEF.is_c27_ME11 = ME11_IN_Initi;
    ACCtl_stRecAQSEna = false;
    ME11_ARID_DEF.is_Initi = ME11_IN_ACCtl_tiAQSHi_cntClear;
    ME11_ARID_DEF.ACCtl_tiAQSHi = 0U;
  } else if (ME11_ARID_DEF.is_c27_ME11 == ME11_IN_Initi) {
    ACCtl_stRecAQSEna = false;
    if (ME11_ARID_DEF.ACCtl_tiAQSHi >= cal_tiAQSFresh2RecircDelay) {
      ME11_ARID_DEF.is_Initi = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_ARID_DEF.is_c27_ME11 = ME11_IN_Recirc_AQS;
      ACCtl_stRecAQSEna = true;
      ME11_ARID_DEF.ACCtl_tiAQSLo = 0U;
      if (rtb_AND_b3z) {
        ME11_ARID_DEF.is_Recirc_AQS = ME11_IN_ACCtl_tiAQSLo_cnt;
        rtb_Divide1_f = ME11_ARID_DEF.ACCtl_tiAQSLo + 1U;
        if (ME11_ARID_DEF.ACCtl_tiAQSLo + 1U > 65535U) {
          rtb_Divide1_f = 65535U;
        }

        ME11_ARID_DEF.ACCtl_tiAQSLo = (uint16)rtb_Divide1_f;
      } else {
        ME11_ARID_DEF.is_Recirc_AQS = ME11_IN_ACCtl_tiAQSLo_cntClear;
        ME11_ARID_DEF.ACCtl_tiAQSLo = 0U;
      }
    } else if (ME11_ARID_DEF.is_Initi == ME11_IN_ACCtl_tiAQSHi_cnt) {
      ME11_ARID_DEF.is_Initi = ME11_IN_ACCtl_tiAQSHi_cntClear;
      ME11_ARID_DEF.ACCtl_tiAQSHi = 0U;
    } else {
      /* case IN_ACCtl_tiAQSHi_cntClear: */
      ME11_ARID_DEF.is_Initi = ME11_IN_ACCtl_tiAQSHi_cntClear;
      ME11_ARID_DEF.ACCtl_tiAQSHi = 0U;
    }
  } else {
    /* case IN_Recirc_AQS: */
    ACCtl_stRecAQSEna = true;
    if (ME11_ARID_DEF.ACCtl_tiAQSLo >= cal_tiAQSRecirc2FreshDelay) {
      ME11_ARID_DEF.is_Recirc_AQS = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_ARID_DEF.is_c27_ME11 = ME11_IN_Initi;
      ACCtl_stRecAQSEna = false;
      ME11_ARID_DEF.is_Initi = ME11_IN_ACCtl_tiAQSHi_cntClear;
      ME11_ARID_DEF.ACCtl_tiAQSHi = 0U;
    } else if (ME11_ARID_DEF.is_Recirc_AQS == ME11_IN_ACCtl_tiAQSLo_cnt) {
      if (rtb_AND_b3z) {
        ME11_ARID_DEF.is_Recirc_AQS = ME11_IN_ACCtl_tiAQSLo_cnt;
        rtb_Divide1_f = ME11_ARID_DEF.ACCtl_tiAQSLo + 1U;
        if (ME11_ARID_DEF.ACCtl_tiAQSLo + 1U > 65535U) {
          rtb_Divide1_f = 65535U;
        }

        ME11_ARID_DEF.ACCtl_tiAQSLo = (uint16)rtb_Divide1_f;
      } else {
        ME11_ARID_DEF.is_Recirc_AQS = ME11_IN_ACCtl_tiAQSLo_cntClear;
        ME11_ARID_DEF.ACCtl_tiAQSLo = 0U;
      }

      /* case IN_ACCtl_tiAQSLo_cntClear: */
    } else if (rtb_AND_b3z) {
      ME11_ARID_DEF.is_Recirc_AQS = ME11_IN_ACCtl_tiAQSLo_cnt;
      rtb_Divide1_f = ME11_ARID_DEF.ACCtl_tiAQSLo + 1U;
      if (ME11_ARID_DEF.ACCtl_tiAQSLo + 1U > 65535U) {
        rtb_Divide1_f = 65535U;
      }

      ME11_ARID_DEF.ACCtl_tiAQSLo = (uint16)rtb_Divide1_f;
    } else {
      ME11_ARID_DEF.is_Recirc_AQS = ME11_IN_ACCtl_tiAQSLo_cntClear;
      ME11_ARID_DEF.ACCtl_tiAQSLo = 0U;
    }
  }

  /* End of Chart: '<S127>/Recirc_AQS' */

  /* Logic: '<S130>/Logical Operator' incorporates:
   *  Constant: '<S130>/Constant12'
   *  Constant: '<S130>/Constant29'
   *  RelationalOperator: '<S130>/Relational Operator2'
   *  RelationalOperator: '<S130>/Relational Operator3'
   */
  ACCtl_stRecNormalDefogEna = ((ACSen_sEnvTempCor < 30.0F) && (ACSen_sEnvTempCor
    > 5.0F));

  /* RelationalOperator: '<S136>/Relational Operator1' incorporates:
   *  Constant: '<S136>/Constant'
   */
  rtb_AND_b3z = (ME11_ARID_DEF.Switch1_nv != ACOff);

  /* Switch: '<S136>/Switch1' incorporates:
   *  Delay: '<S136>/Delay1'
   */
  ACCtl_stRecTargetOutTempEna = (((!rtb_AND_b3z) ||
    (ME11_ARID_DEF.Delay1_Reset_ZCE == POS_ZCSIG)) &&
    ACCtl_stRecTargetOutTempEna);

  /* Delay: '<S136>/Delay1' */
  ME11_ARID_DEF.Delay1_Reset_ZCE = rtb_AND_b3z;

  /* Switch: '<S136>/Switch1' incorporates:
   *  Constant: '<S136>/Constant5'
   *  RelationalOperator: '<S136>/Relational Operator4'
   */
  if (ACCtl_tDrDVT < cal_REC_DVTRecirc) {
    /* Switch: '<S136>/Switch1' incorporates:
     *  Constant: '<S136>/Constant7'
     */
    ACCtl_stRecTargetOutTempEna = true;
  } else {
    /* Switch: '<S136>/Switch1' incorporates:
     *  Constant: '<S136>/Constant6'
     *  Delay: '<S136>/Delay1'
     *  RelationalOperator: '<S136>/Relational Operator5'
     */
    ACCtl_stRecTargetOutTempEna = ((ACCtl_tDrDVT <= cal_REC_DVTFresh) &&
      ACCtl_stRecTargetOutTempEna);
  }

  /* End of Switch: '<S136>/Switch1' */

  /* Logic: '<S138>/Logical Operator2' */
  ACCtl_stRecVentEna = (ACCtl_stACPTCHeated || ACCtl_stEvaCooledFlag);

  /* RelationalOperator: '<S139>/Relational Operator4' incorporates:
   *  Constant: '<S139>/Constant18'
   */
  ACCtl_stRecWinterCondEna = (ACSen_sEnvTempCor <= 5.0F);

  /* RelationalOperator: '<S135>/Relational Operator4' incorporates:
   *  Constant: '<S135>/Constant18'
   */
  ACCtl_stRecSummerCondEna = (ACSen_sEnvTempCor >= 30.0F);

  /* RelationalOperator: '<S132>/Relational Operator2' incorporates:
   *  Constant: '<S132>/Constant1'
   */
  rtb_AND_b3z = (ME11_ARID_DEF.Switch1_nv != ACOff);

  /* Switch: '<S132>/Switch1' incorporates:
   *  Delay: '<S132>/Delay1'
   */
  ACCtl_stRecPTCDvtEna = (((!rtb_AND_b3z) || (ME11_ARID_DEF.Delay1_Reset_ZCE_a ==
    POS_ZCSIG)) && ACCtl_stRecPTCDvtEna);

  /* Delay: '<S132>/Delay1' */
  ME11_ARID_DEF.Delay1_Reset_ZCE_a = rtb_AND_b3z;

  /* RelationalOperator: '<S132>/Relational Operator5' incorporates:
   *  RelationalOperator: '<S132>/Relational Operator4'
   *  Sum: '<S132>/Add'
   *  Switch: '<S132>/Switch1'
   */
  rtb_Add_ok = (float32)(uint16)((ACCtl_tSetPointPTC - rtb_Merge_g) * 2.0F +
    400.0F) * 0.5F - 200.0F;

  /* Switch: '<S132>/Switch1' incorporates:
   *  Constant: '<S132>/Constant6'
   *  RelationalOperator: '<S132>/Relational Operator5'
   */
  if (rtb_Add_ok >= cal_PTCTempRecircOn) {
    /* Switch: '<S132>/Switch1' incorporates:
     *  Constant: '<S132>/Constant7'
     */
    ACCtl_stRecPTCDvtEna = true;
  } else {
    /* Switch: '<S132>/Switch1' incorporates:
     *  Constant: '<S132>/Constant5'
     *  Delay: '<S132>/Delay1'
     *  RelationalOperator: '<S132>/Relational Operator4'
     */
    ACCtl_stRecPTCDvtEna = ((rtb_Add_ok > cal_PTCTempRecircOff) &&
      ACCtl_stRecPTCDvtEna);
  }

  /* RelationalOperator: '<S126>/Relational Operator5' incorporates:
   *  Constant: '<S126>/Constant26'
   */
  ACCtl_stRecACHotStartEna = (ACCtl_stStartState == AC_HotStart);

  /* RelationalOperator: '<S129>/Relational Operator' */
  ACCtl_stRecForceDefogEna = HMICtl_bACDefrost;

  /* Logic: '<S125>/Logical Operator' incorporates:
   *  Constant: '<S125>/ACModes.RecircIncManual'
   *  Constant: '<S125>/Constant'
   *  RelationalOperator: '<S125>/Relational Operator1'
   *  RelationalOperator: '<S125>/Relational Operator2'
   *  S-Function (sfix_bitop): '<S125>/Bitwise Operator'
   */
  ACCtl_stRecManualEna = (((ME11_ARID_DEF.Switch1_nv & 4U) == 0U) ||
    (ME11_ARID_DEF.Switch1_nv == ACOff));

  /* RelationalOperator: '<S134>/Relational Operator3' incorporates:
   *  Constant: '<S134>/Constant5'
   *  Delay: '<S134>/Delay'
   */
  ACCtl_stRecRemoteACEna = false;

  /* RelationalOperator: '<S133>/Relational Operator' incorporates:
   *  Constant: '<S133>/Constant14'
   *  Inport: '<Root>/IPM_BMS_10_DC_ChargeStates_EPT'
   */
  rtb_AND1_hh =
    ((Rte_IRead_Task_100ms_IPM_BMS_10_DC_ChargeStates_EPT_IPM_BMS_10_DC_ChargeStates_EPT
      ())->VIPM_BMSDCSActOprtMode_enum == 5);

  /* SignalConversion: '<S2>/Signal Copy160' incorporates:
   *  Inport: '<Root>/IPM_BMS_5_BatTemp_EPT'
   */
  BMS_HVBatCellTempMax =
    (Rte_IRead_Task_100ms_IPM_BMS_5_BatTemp_EPT_IPM_BMS_5_BatTemp_EPT())
    ->VIPM_BMSHVBatCellTempMax_C;

  /* SignalConversion: '<S15>/Signal Copy96' incorporates:
   *  Inport: '<Root>/EXV_ResponseError'
   *
   * Block description for '<Root>/EXV_ResponseError':
   *  Response Error
   */
  EXV_ResponseError = Rte_IRead_Task_100ms_EXV_ResponseError_EXV_ResponseError();

  /* SignalConversion: '<S15>/Signal Copy99' incorporates:
   *  Inport: '<Root>/EXV_FaultState'
   *
   * Block description for '<Root>/EXV_FaultState':
   *  Fault State
   */
  EXV_FaultState = Rte_IRead_Task_100ms_EXV_FaultState_EXV_FaultState();

  /* SignalConversion: '<S15>/Signal Copy100' incorporates:
   *  Inport: '<Root>/EXV_VoltageState'
   *
   * Block description for '<Root>/EXV_VoltageState':
   *  Voltage State
   */
  EXV_VoltageState = Rte_IRead_Task_100ms_EXV_VoltageState_EXV_VoltageState();

  /* SignalConversion: '<S15>/Signal Copy101' incorporates:
   *  Inport: '<Root>/EXV_TemperatureWarn'
   *
   * Block description for '<Root>/EXV_TemperatureWarn':
   *  Temperature Warn
   */
  EXV_TemperatureWarn =
    Rte_IRead_Task_100ms_EXV_TemperatureWarn_EXV_TemperatureWarn();

  /* Logic: '<S678>/OR' incorporates:
   *  Constant: '<S688>/Constant'
   *  Constant: '<S689>/Constant'
   *  Constant: '<S690>/Constant'
   *  RelationalOperator: '<S687>/Compare'
   *  RelationalOperator: '<S688>/Compare'
   *  RelationalOperator: '<S689>/Compare'
   *  RelationalOperator: '<S690>/Compare'
   */
  ACTCtl_bAEXVFaultFlg = (EXV_ResponseError || (EXV_FaultState != 0) ||
    (EXV_VoltageState != 0) || (EXV_TemperatureWarn == 1));

  /* SignalConversion: '<S18>/Signal Copy34' incorporates:
   *  Inport: '<Root>/BAT_EXV_ResponseError_B'
   *
   * Block description for '<Root>/BAT_EXV_ResponseError_B':
   *  Response Error
   */
  BAT_EXV_ResponseError_B =
    Rte_IRead_Task_100ms_BAT_EXV_ResponseError_B_BAT_EXV_ResponseError_B();

  /* SignalConversion: '<S18>/Signal Copy37' incorporates:
   *  Inport: '<Root>/BAT_EXV_FaultState_B'
   *
   * Block description for '<Root>/BAT_EXV_FaultState_B':
   *  Fault State
   */
  BAT_EXV_FaultState_B =
    Rte_IRead_Task_100ms_BAT_EXV_FaultState_B_BAT_EXV_FaultState_B();

  /* SignalConversion: '<S18>/Signal Copy38' incorporates:
   *  Inport: '<Root>/BAT_EXV_VoltageState_B'
   *
   * Block description for '<Root>/BAT_EXV_VoltageState_B':
   *  Voltage State
   */
  BAT_EXV_VoltageState_B =
    Rte_IRead_Task_100ms_BAT_EXV_VoltageState_B_BAT_EXV_VoltageState_B();

  /* DataTypeConversion: '<S1283>/Data Type Conversion' incorporates:
   *  Inport: '<Root>/BAT_EXV_Warning_OverTemp'
   *
   * Block description for '<Root>/BAT_EXV_Warning_OverTemp':
   *  EXV over temperature warning.(HP_EXV_TemperatureWarn_B)
   */
  BAT_EXV_TemperatureWarn_B = (uint8)
    Rte_IRead_Task_100ms_BAT_EXV_Warning_OverTemp_BAT_EXV_Warning_OverTemp();

  /* Logic: '<S748>/OR' incorporates:
   *  Constant: '<S756>/Constant'
   *  Constant: '<S757>/Constant'
   *  Constant: '<S758>/Constant'
   *  RelationalOperator: '<S755>/Compare'
   *  RelationalOperator: '<S756>/Compare'
   *  RelationalOperator: '<S757>/Compare'
   *  RelationalOperator: '<S758>/Compare'
   */
  ACTCtl_bBEXVFaultFlg = (BAT_EXV_ResponseError_B || (BAT_EXV_FaultState_B != 0)
    || (BAT_EXV_VoltageState_B != 0) || (BAT_EXV_TemperatureWarn_B == 1));

  /* SignalConversion: '<S22>/Signal Copy20' incorporates:
   *  Inport: '<Root>/HP_EXV_Warning_OverTemp'
   *
   * Block description for '<Root>/HP_EXV_Warning_OverTemp':
   *  EXV over temperature warning.(HP_EXV_TemperatureWarn_B)
   */
  HP_EXV_Warning_OverTemp =
    Rte_IRead_Task_100ms_HP_EXV_Warning_OverTemp_HP_EXV_Warning_OverTemp();

  /* SignalConversion: '<S22>/Signal Copy21' incorporates:
   *  Inport: '<Root>/HP_EXV_ResponseError_B'
   *
   * Block description for '<Root>/HP_EXV_ResponseError_B':
   *  Response Error
   */
  HP_EXV_ResponseError_B =
    Rte_IRead_Task_100ms_HP_EXV_ResponseError_B_HP_EXV_ResponseError_B();

  /* SignalConversion: '<S22>/Signal Copy23' incorporates:
   *  Inport: '<Root>/HP_EXV_FaultState_B'
   *
   * Block description for '<Root>/HP_EXV_FaultState_B':
   *  Fault State
   */
  HP_EXV_FaultState_B =
    Rte_IRead_Task_100ms_HP_EXV_FaultState_B_HP_EXV_FaultState_B();

  /* SignalConversion: '<S22>/Signal Copy24' incorporates:
   *  Inport: '<Root>/HP_EXV_VoltageState_B'
   *
   * Block description for '<Root>/HP_EXV_VoltageState_B':
   *  Voltage State
   */
  HP_EXV_VoltageState_B =
    Rte_IRead_Task_100ms_HP_EXV_VoltageState_B_HP_EXV_VoltageState_B();

  /* Logic: '<S820>/OR' incorporates:
   *  Constant: '<S839>/Constant'
   *  Constant: '<S840>/Constant'
   *  RelationalOperator: '<S837>/Compare'
   *  RelationalOperator: '<S838>/Compare'
   *  RelationalOperator: '<S839>/Compare'
   *  RelationalOperator: '<S840>/Compare'
   */
  ACTCtl_bHPEXVFaultFlg = (HP_EXV_Warning_OverTemp || HP_EXV_ResponseError_B ||
    (HP_EXV_FaultState_B != 0) || (HP_EXV_VoltageState_B != 0));

  /* SignalConversion: '<S20>/Signal Copy89' incorporates:
   *  Inport: '<Root>/BatPMP_RESP_ERROR'
   *
   * Block description for '<Root>/BatPMP_RESP_ERROR':
   *  LIN
   */
  BatPMP_RESP_ERROR = Rte_IRead_Task_100ms_BatPMP_RESP_ERROR_BatPMP_RESP_ERROR();

  /* SignalConversion: '<S20>/Signal Copy90' incorporates:
   *  Inport: '<Root>/BatPMP_PumpMotorSta'
   *
   * Block description for '<Root>/BatPMP_PumpMotorSta':
   *  
   */
  BatPMP_PumpMotorSta =
    Rte_IRead_Task_100ms_BatPMP_PumpMotorSta_BatPMP_PumpMotorSta();

  /* SignalConversion: '<S20>/Signal Copy91' incorporates:
   *  Inport: '<Root>/BatPMP_PumpDryRunningSta'
   *
   * Block description for '<Root>/BatPMP_PumpDryRunningSta':
   *  
   */
  BatPMP_PumpDryRunningSta =
    Rte_IRead_Task_100ms_BatPMP_PumpDryRunningSta_BatPMP_PumpDryRunningSta();

  /* SignalConversion: '<S20>/Signal Copy92' incorporates:
   *  Inport: '<Root>/BatPMP_PumpPowerSta'
   *
   * Block description for '<Root>/BatPMP_PumpPowerSta':
   *  
   */
  BatPMP_PumpPowerSta =
    Rte_IRead_Task_100ms_BatPMP_PumpPowerSta_BatPMP_PumpPowerSta();

  /* SignalConversion: '<S20>/Signal Copy93' incorporates:
   *  Inport: '<Root>/BatPMP_PumpTempSta'
   *
   * Block description for '<Root>/BatPMP_PumpTempSta':
   *  
   */
  BatPMP_PumpTempSta =
    Rte_IRead_Task_100ms_BatPMP_PumpTempSta_BatPMP_PumpTempSta();

  /* Logic: '<S1023>/OR' incorporates:
   *  Constant: '<S1043>/Constant'
   *  Constant: '<S1045>/Constant'
   *  Constant: '<S1046>/Constant'
   *  RelationalOperator: '<S1042>/Compare'
   *  RelationalOperator: '<S1043>/Compare'
   *  RelationalOperator: '<S1044>/Compare'
   *  RelationalOperator: '<S1045>/Compare'
   *  RelationalOperator: '<S1046>/Compare'
   */
  rtb_AND_b3z = (BatPMP_RESP_ERROR || (BatPMP_PumpMotorSta != 0) ||
                 BatPMP_PumpDryRunningSta || (BatPMP_PumpPowerSta != 0) ||
                 (BatPMP_PumpTempSta != 0));

  /* Chart: '<S1023>/AcPMPFaultJudge' */
  if (ME11_ARID_DEF.temporalCounter_i1_fo < 127U) {
    ME11_ARID_DEF.temporalCounter_i1_fo++;
  }

  if (ME11_ARID_DEF.is_active_c124_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c124_ME11 = 1U;
    ME11_ARID_DEF.is_c124_ME11 = ME11_IN_Normal_k;
    ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_m = false;
  } else {
    switch (ME11_ARID_DEF.is_c124_ME11) {
     case ME11_IN_Fault_ax:
      ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_m = true;
      if (!rtb_AND_b3z) {
        ME11_ARID_DEF.is_c124_ME11 = ME11_IN_Normal_k;
        ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_m = false;
      }
      break;

     case ME11_IN_Normal_k:
      ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_m = false;
      if (rtb_AND_b3z) {
        ME11_ARID_DEF.is_c124_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_fo = 0U;
      }
      break;

     default:
      /* case IN_wait: */
      if (!rtb_AND_b3z) {
        ME11_ARID_DEF.is_c124_ME11 = ME11_IN_Normal_k;
        ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_m = false;
      } else if (ME11_ARID_DEF.temporalCounter_i1_fo >= 100U) {
        ME11_ARID_DEF.is_c124_ME11 = ME11_IN_Fault_ax;
        ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_m = true;
      }
      break;
    }
  }

  /* End of Chart: '<S1023>/AcPMPFaultJudge' */

  /* Switch: '<S1052>/Switch' incorporates:
   *  Constant: '<S1052>/Constant1'
   */
  if (cal_BatPMPFaultFlgDataEnb) {
    /* Switch: '<S1052>/Switch' incorporates:
     *  Constant: '<S1052>/Constant'
     */
    ACTCtl_bBatPMPFaultFlg = cal_BatPMPFaultFlgData;
  } else {
    /* Switch: '<S1052>/Switch' */
    ACTCtl_bBatPMPFaultFlg = ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_m;
  }

  /* End of Switch: '<S1052>/Switch' */

  /* SignalConversion: '<S2>/Signal Copy161' incorporates:
   *  Inport: '<Root>/IPM_BMS_5_BatTemp_EPT'
   */
  BMS_HVBatCellTempMin =
    (Rte_IRead_Task_100ms_IPM_BMS_5_BatTemp_EPT_IPM_BMS_5_BatTemp_EPT())
    ->VIPM_BMSHVBatCellTempMin_C;

  /* Logic: '<S1338>/E' incorporates:
   *  Constant: '<S1418>/Constant'
   *  Inport: '<Root>/Vcu2BcmTms_outputs'
   *  RelationalOperator: '<S1418>/Relational Operator'
   */
  FixPtRelationalOperator =
    ((Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs())
     ->VEMS_HeatCoolMaxPwrCmsp_kW <= cal_BatHeatPwrLoLmt);

  /* Outputs for Enabled SubSystem: '<S1325>/B1_B31_AC' incorporates:
   *  EnablePort: '<S1574>/Enable'
   */
  /* Outputs for Enabled SubSystem: '<S1325>/B1_B31_PT' incorporates:
   *  EnablePort: '<S1575>/Enable'
   */
  /* Outputs for Enabled SubSystem: '<S1326>/Enter_AC' incorporates:
   *  EnablePort: '<S1610>/Enable'
   */
  /* Outputs for Enabled SubSystem: '<S1326>/Enter_PT' incorporates:
   *  EnablePort: '<S1611>/Enable'
   */
  /* Sum: '<S1416>/Add' incorporates:
   *  Sum: '<S1023>/Add'
   *  Sum: '<S1333>/Add4'
   *  Sum: '<S1336>/Add3'
   *  Sum: '<S1338>/Add3'
   *  Sum: '<S1358>/Add3'
   *  Sum: '<S1359>/Add3'
   *  Sum: '<S1446>/Add2'
   *  Sum: '<S1464>/Add2'
   *  Sum: '<S1566>/Add2'
   *  Sum: '<S1573>/Add2'
   *  Sum: '<S1574>/Add2'
   *  Sum: '<S1575>/Add2'
   *  Sum: '<S1576>/Add2'
   *  Sum: '<S1610>/Add2'
   *  Sum: '<S1611>/Add2'
   *  Sum: '<S1612>/Add2'
   *  Sum: '<S1633>/Add3'
   */
  rtb_Delay = BMS_HVBatCellTempMax - BMS_HVBatCellTempMin;

  /* End of Outputs for SubSystem: '<S1326>/Enter_PT' */
  /* End of Outputs for SubSystem: '<S1326>/Enter_AC' */
  /* End of Outputs for SubSystem: '<S1325>/B1_B31_PT' */
  /* End of Outputs for SubSystem: '<S1325>/B1_B31_AC' */

  /* Abs: '<S1416>/Abs' incorporates:
   *  Abs: '<S1399>/Abs'
   *  Abs: '<S1410>/Abs'
   *  Abs: '<S1482>/Abs'
   *  Abs: '<S1495>/Abs'
   *  Abs: '<S1502>/Abs'
   *  Abs: '<S1573>/Abs'
   *  Sum: '<S1416>/Add'
   */
  rtb_Merge = (float32)fabs(rtb_Delay);

  /* Logic: '<S1417>/OR' incorporates:
   *  Logic: '<S1504>/OR'
   *  Logic: '<S499>/OR'
   */
  rtb_FixPtRelationalOperator_i1 = (ACTCtl_bAEXVFaultFlg || ACTCtl_bBEXVFaultFlg
    || ACTCtl_bHPEXVFaultFlg);

  /* Sum: '<S1421>/Add' incorporates:
   *  Abs: '<S1416>/Abs'
   *  Constant: '<S1422>/Constant'
   *  Constant: '<S1423>/Constant'
   *  Constant: '<S1424>/Constant'
   *  Constant: '<S1425>/Constant'
   *  Constant: '<S1426>/Constant'
   *  Constant: '<S1427>/Constant'
   *  Constant: '<S1428>/Constant'
   *  Constant: '<S1429>/Constant'
   *  Constant: '<S1430>/Constant'
   *  Constant: '<S1431>/Constant'
   *  Constant: '<S1432>/Constant'
   *  Constant: '<S1433>/Constant'
   *  Constant: '<S1434>/Constant'
   *  Constant: '<S1435>/Constant'
   *  Constant: '<S1436>/Constant'
   *  Delay: '<S1419>/Delay'
   *  Delay: '<S1419>/Delay1'
   *  Gain: '<S1421>/Gain1'
   *  Gain: '<S1421>/Gain2'
   *  Gain: '<S1421>/Gain3'
   *  Gain: '<S1421>/Gain4'
   *  Logic: '<S1417>/OR'
   *  Logic: '<S1417>/OR2'
   *  Logic: '<S1419>/AND'
   *  Logic: '<S1419>/AND1'
   *  Logic: '<S1419>/AND2'
   *  Logic: '<S1419>/AND3'
   *  Logic: '<S1419>/AND4'
   *  Logic: '<S1420>/AND'
   *  Logic: '<S1420>/AND1'
   *  Logic: '<S1420>/AND2'
   *  Logic: '<S1420>/AND3'
   *  Logic: '<S1420>/OR'
   *  RelationalOperator: '<S1422>/Compare'
   *  RelationalOperator: '<S1423>/Compare'
   *  RelationalOperator: '<S1424>/Compare'
   *  RelationalOperator: '<S1425>/Compare'
   *  RelationalOperator: '<S1426>/Compare'
   *  RelationalOperator: '<S1427>/Compare'
   *  RelationalOperator: '<S1428>/Compare'
   *  RelationalOperator: '<S1429>/Compare'
   *  RelationalOperator: '<S1430>/Compare'
   *  RelationalOperator: '<S1431>/Compare'
   *  RelationalOperator: '<S1432>/Compare'
   *  RelationalOperator: '<S1433>/Compare'
   *  RelationalOperator: '<S1434>/Compare'
   *  RelationalOperator: '<S1435>/Compare'
   *  RelationalOperator: '<S1436>/Compare'
   */
  SOMCtl_eBatCoolB2tB1 = (uint8)(((((uint32)(((ME11_ARID_DEF.Delay_DSTATE_h0r ==
    3) && (ME11_ARID_DEF.DataTypeConversion1 != 3)) ||
    ((ME11_ARID_DEF.Delay_DSTATE_h0r == 4) && (ME11_ARID_DEF.DataTypeConversion1
    != 4)) || ((ME11_ARID_DEF.Delay_DSTATE_h0r == 5) &&
               (ME11_ARID_DEF.DataTypeConversion1 != 5)) ||
    ((ME11_ARID_DEF.Delay1_DSTATE_gb == 2) && (ME11_ARID_DEF.DataTypeConversion1
    != 2))) + (uint32)((((BMS_HVBatCellTempMax <= cal_tBatCoolDCChrgCellTempOff)
    && (ME11_ARID_DEF.DataTypeConversion1 == 4)) || ((BMS_HVBatCellTempMax <=
    cal_tBatCoolACChrgCellTempOff) && (ME11_ARID_DEF.DataTypeConversion1 == 3)) ||
                        ((BMS_HVBatCellTempMax <=
    cal_tBatCoolVehReadyCellTempOff) && ((ME11_ARID_DEF.DataTypeConversion1 == 2)
    || (ME11_ARID_DEF.DataTypeConversion1 == 5)))) << 1)) + (uint32)
    ((rtb_FixPtRelationalOperator_i1 || ACTCtl_bBatPMPFaultFlg ||
      ACTCtl_bCOMPForbidFlg) << 2)) + (uint32)((rtb_Merge >=
    cal_tBatHeatExitMaxToMinCellDiff) << 3)) + (uint32)(FixPtRelationalOperator <<
    4));

  /* Logic: '<S1338>/E' incorporates:
   *  Constant: '<S1398>/Constant'
   *  Inport: '<Root>/Vcu2BcmTms_outputs'
   *  RelationalOperator: '<S1398>/Relational Operator'
   */
  FixPtRelationalOperator =
    ((Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs())
     ->VEMS_HeatCoolMaxPwrCmsp_kW >= cal_HeatPwrOn);

  /* Logic: '<S1397>/OR2' incorporates:
   *  Logic: '<S1481>/OR1'
   *  Logic: '<S1633>/AND2'
   */
  rtb_RelationalOperator_nf = !ACTCtl_bBatPMPFaultFlg;

  /* Logic: '<S1397>/OR' incorporates:
   *  Logic: '<S1481>/OR'
   */
  rtb_Compare_dy = ((!ACTCtl_bAEXVFaultFlg) && (!ACTCtl_bBEXVFaultFlg) &&
                    (!ACTCtl_bHPEXVFaultFlg));

  /* Logic: '<S1397>/OR2' incorporates:
   *  Logic: '<S1481>/OR2'
   */
  rtb_OR_k0 = !ACTCtl_bCOMPForbidFlg;

  /* Gain: '<S1400>/Gain1' incorporates:
   *  Gain: '<S1411>/Gain2'
   *  Logic: '<S1397>/NOT'
   *  Logic: '<S1397>/OR'
   *  Logic: '<S1397>/OR2'
   */
  b_previousEvent = (rtb_Compare_dy && rtb_RelationalOperator_nf && rtb_OR_k0);

  /* Sum: '<S1400>/Add' incorporates:
   *  Constant: '<S1401>/Constant'
   *  Constant: '<S1402>/Constant'
   *  Constant: '<S1403>/Constant'
   *  Constant: '<S1404>/Constant'
   *  Constant: '<S1405>/Constant'
   *  Gain: '<S1400>/Gain1'
   *  Gain: '<S1400>/Gain2'
   *  Gain: '<S1400>/Gain3'
   *  Logic: '<S1396>/AND'
   *  Logic: '<S1396>/AND1'
   *  Logic: '<S1396>/AND2'
   *  RelationalOperator: '<S1401>/Compare'
   *  RelationalOperator: '<S1402>/Compare'
   *  RelationalOperator: '<S1403>/Compare'
   *  RelationalOperator: '<S1404>/Compare'
   *  RelationalOperator: '<S1405>/Compare'
   */
  SOMCtl_eBatCoolB1tB21 = (uint8)((((uint32)(((BMS_HVBatCellTempMax >=
    cal_tDCBatCoolCellTempOn) && (ME11_ARID_DEF.DataTypeConversion1 == 4)) ||
    ((ME11_ARID_DEF.DataTypeConversion1 == 3) && (BMS_HVBatCellTempMax >=
    cal_tACBatCoolCellTempOn))) + (uint32)(b_previousEvent << 1)) + (uint32)
    (FixPtRelationalOperator << 2)) + (uint32)((rtb_Merge <
    cal_tBatHeatExitMaxToMinCellDiff) << 3));

  /* Logic: '<S1338>/E' incorporates:
   *  Constant: '<S1409>/Constant'
   *  Inport: '<Root>/Vcu2BcmTms_outputs'
   *  RelationalOperator: '<S1409>/Relational Operator'
   */
  FixPtRelationalOperator =
    ((Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs())
     ->VEMS_HeatCoolMaxPwrCmsp_kW >= cal_HeatPwrOn);

  /* Sum: '<S1411>/Add' incorporates:
   *  Constant: '<S1412>/Constant'
   *  Constant: '<S1413>/Constant'
   *  Constant: '<S1414>/Constant'
   *  Constant: '<S1415>/Constant'
   *  Gain: '<S1411>/Gain1'
   *  Gain: '<S1411>/Gain2'
   *  Gain: '<S1411>/Gain3'
   *  Gain: '<S1411>/Gain4'
   *  Logic: '<S1406>/AND'
   *  RelationalOperator: '<S1412>/Compare'
   *  RelationalOperator: '<S1413>/Compare'
   *  RelationalOperator: '<S1414>/Compare'
   *  RelationalOperator: '<S1415>/Compare'
   */
  SOMCtl_eBatCoolB1tB22 = (uint8)(((((uint32)((ME11_ARID_DEF.DataTypeConversion1
    == 5) || (ME11_ARID_DEF.DataTypeConversion1 == 2)) + (uint32)
    (b_previousEvent << 2)) + (uint32)((BMS_HVBatCellTempMax >=
    cal_tBatCoolCellTempOn) << 1)) + (uint32)((rtb_Merge <
    cal_tBatHeatExitMaxToMinCellDiff) << 3)) + (uint32)(FixPtRelationalOperator <<
    4));

  /* Chart: '<S1319>/Cool' incorporates:
   *  RelationalOperator: '<S1400>/Relational Operator'
   *  RelationalOperator: '<S1411>/Relational Operator'
   *  RelationalOperator: '<S1421>/Relational Operator'
   */
  if (ME11_ARID_DEF.is_active_c70_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c70_ME11 = 1U;
    ME11_ARID_DEF.is_c70_ME11 = ME11_IN_Off_a;
    rtb_AND_b3z = false;
  } else if (ME11_ARID_DEF.is_c70_ME11 == ME11_IN_Off_a) {
    rtb_AND_b3z = false;
    if ((SOMCtl_eBatCoolB1tB21 == 15) || (SOMCtl_eBatCoolB1tB22 == 31)) {
      ME11_ARID_DEF.is_c70_ME11 = ME11_IN_On_li;
      rtb_AND_b3z = true;
    }
  } else {
    /* case IN_On: */
    rtb_AND_b3z = true;
    if (SOMCtl_eBatCoolB2tB1 != 0) {
      ME11_ARID_DEF.is_c70_ME11 = ME11_IN_Off_a;
      rtb_AND_b3z = false;
    }
  }

  /* End of Chart: '<S1319>/Cool' */

  /* SignalConversion: '<S2>/Signal Copy147' incorporates:
   *  Inport: '<Root>/IPM_BMS_4_AC_ChargeState_EPT'
   */
  BMS_InletCooltActlTemp =
    (Rte_IRead_Task_100ms_IPM_BMS_4_AC_ChargeState_EPT_IPM_BMS_4_AC_ChargeState_EPT
     ())->VIPM_BMSInletCooltActlTemp_C;

  /* Chart: '<S1319>/CloseOfTemp' incorporates:
   *  Constant: '<S1319>/Constant'
   *  Constant: '<S1319>/Constant1'
   *  Constant: '<S1319>/Constant2'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_l < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i1_l++;
  }

  if (ME11_ARID_DEF.is_active_c8_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c8_ME11 = 1U;
    ME11_ARID_DEF.is_c8_ME11 = ME11_IN_Open;
    ME11_ARID_DEF.SOMCtl_bCoolInletTempSts = true;
  } else {
    switch (ME11_ARID_DEF.is_c8_ME11) {
     case ME11_IN_Close:
      ME11_ARID_DEF.SOMCtl_bCoolInletTempSts = false;
      if (BMS_InletCooltActlTemp > cal_OpenCoolInletTemp) {
        ME11_ARID_DEF.is_c8_ME11 = ME11_IN_Open;
        ME11_ARID_DEF.SOMCtl_bCoolInletTempSts = true;
      }
      break;

     case ME11_IN_Open:
      ME11_ARID_DEF.SOMCtl_bCoolInletTempSts = true;
      if (BMS_InletCooltActlTemp < cal_ClsCoolInletTemp) {
        ME11_ARID_DEF.is_c8_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_l = 0U;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_l >= cal_ClsCoolInletTempTime * 10.0F)
      {
        ME11_ARID_DEF.is_c8_ME11 = ME11_IN_Close;
        ME11_ARID_DEF.SOMCtl_bCoolInletTempSts = false;
      } else if (BMS_InletCooltActlTemp >= cal_ClsCoolInletTemp) {
        ME11_ARID_DEF.is_c8_ME11 = ME11_IN_Open;
        ME11_ARID_DEF.SOMCtl_bCoolInletTempSts = true;
      }
      break;
    }
  }

  /* End of Chart: '<S1319>/CloseOfTemp' */

  /* Switch: '<S1395>/Switch' incorporates:
   *  Constant: '<S1395>/Constant1'
   */
  if (cal_BatCoolOverEnb) {
    /* Switch: '<S1395>/Switch' incorporates:
     *  Constant: '<S1395>/Constant'
     */
    SOMCtl_bBatCoolFlg = cal_BatCoolOverData;
  } else {
    /* Switch: '<S1395>/Switch' incorporates:
     *  Switch: '<S1319>/Switch'
     */
    SOMCtl_bBatCoolFlg = (ME11_ARID_DEF.SOMCtl_bCoolInletTempSts && rtb_AND_b3z);
  }

  /* End of Switch: '<S1395>/Switch' */

  /* SignalConversion: '<S2>/Signal Copy1' incorporates:
   *  Inport: '<Root>/IPM_BMS_2_BatState_EPT'
   */
  BMS_BatSOCAct_pct =
    (Rte_IRead_Task_100ms_IPM_BMS_2_BatState_EPT_IPM_BMS_2_BatState_EPT())
    ->VIPM_BMSBatSOCAct_pct;

  /* Sum: '<S1633>/Add' incorporates:
   *  Constant: '<S1651>/Constant'
   *  Constant: '<S1651>/Constant4'
   *  Constant: '<S1652>/Constant'
   *  Constant: '<S1652>/Constant4'
   *  Constant: '<S1653>/Constant'
   *  Constant: '<S1653>/Constant4'
   *  Constant: '<S1655>/Constant'
   *  Constant: '<S1655>/Constant4'
   *  Constant: '<S1656>/Constant'
   *  Constant: '<S1657>/Constant'
   *  Constant: '<S1658>/Constant'
   *  Constant: '<S1659>/Constant'
   *  Constant: '<S1660>/Constant'
   *  Constant: '<S1661>/Constant'
   *  Constant: '<S1662>/Constant'
   *  Constant: '<S1663>/Constant'
   *  Gain: '<S1633>/Gain1'
   *  Gain: '<S1633>/Gain2'
   *  Gain: '<S1633>/Gain3'
   *  Logic: '<S1651>/AndA'
   *  Logic: '<S1652>/AndA'
   *  Logic: '<S1653>/AndA'
   *  Logic: '<S1655>/AndA'
   *  Logic: '<S1655>/AndA1'
   *  RelationalOperator: '<S1651>/Relational Operator1'
   *  RelationalOperator: '<S1651>/Relational Operator5'
   *  RelationalOperator: '<S1652>/Relational Operator1'
   *  RelationalOperator: '<S1652>/Relational Operator5'
   *  RelationalOperator: '<S1653>/Relational Operator1'
   *  RelationalOperator: '<S1653>/Relational Operator5'
   *  RelationalOperator: '<S1655>/Relational Operator1'
   *  RelationalOperator: '<S1655>/Relational Operator5'
   *  RelationalOperator: '<S1656>/Compare'
   *  RelationalOperator: '<S1657>/Compare'
   *  RelationalOperator: '<S1658>/Compare'
   *  RelationalOperator: '<S1659>/Compare'
   *  RelationalOperator: '<S1660>/Compare'
   *  RelationalOperator: '<S1661>/Compare'
   *  RelationalOperator: '<S1662>/Compare'
   *  RelationalOperator: '<S1663>/Compare'
   */
  SOMCtl_eBatBalEntBFlg = (uint8)((((uint32)(((cal_TSACBatMinEntTempB <=
    BMS_HVBatCellTempMin) && (BMS_HVBatCellTempMax < cal_BatBalCellTemp2) &&
    (ME11_ARID_DEF.DataTypeConversion1 == 3) && (BMS_BatSOCAct_pct >=
    cal_ACChgBatHighSOCHeat)) << 1) + (uint32)((cal_TSACBatMinEntTempA <=
    BMS_HVBatCellTempMin) && (BMS_HVBatCellTempMax <= cal_BatBalCellTemp2) &&
    (ME11_ARID_DEF.DataTypeConversion1 == 3) && (BMS_BatSOCAct_pct <=
    cal_ACChgBatLowSOCHeat))) + (uint32)(((cal_TSDCBatMinEntTempC <=
    BMS_HVBatCellTempMin) && (BMS_HVBatCellTempMax < cal_BatBalCellTemp2) &&
    (ME11_ARID_DEF.DataTypeConversion1 == 4) && (BMS_BatSOCAct_pct >=
    cal_ACChgBatHighSOCHeat)) << 2)) + (uint32)(((cal_BatBalCellTemp1 <
    BMS_HVBatCellTempMin) && (BMS_HVBatCellTempMax < cal_BatBalCellTemp2) &&
    ((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
     (ME11_ARID_DEF.DataTypeConversion1 == 5)) && (BMS_BatSOCAct_pct >=
    cal_ACChgBatHighSOCHeat)) << 3));

  /* SignalConversion: '<S25>/Signal Copy82' incorporates:
   *  Inport: '<Root>/MotPMP_RESP_ERROR'
   *
   * Block description for '<Root>/MotPMP_RESP_ERROR':
   *  LIN
   */
  MotPMP_RESP_ERROR = Rte_IRead_Task_100ms_MotPMP_RESP_ERROR_MotPMP_RESP_ERROR();

  /* SignalConversion: '<S25>/Signal Copy83' incorporates:
   *  Inport: '<Root>/MotPMP_PumpMotorSta'
   *
   * Block description for '<Root>/MotPMP_PumpMotorSta':
   *  
   */
  MotPMP_PumpMotorSta =
    Rte_IRead_Task_100ms_MotPMP_PumpMotorSta_MotPMP_PumpMotorSta();

  /* SignalConversion: '<S25>/Signal Copy84' incorporates:
   *  Inport: '<Root>/MotPMP_PumpDryRunningSta'
   *
   * Block description for '<Root>/MotPMP_PumpDryRunningSta':
   *  
   */
  MotPMP_PumpDryRunningSta =
    Rte_IRead_Task_100ms_MotPMP_PumpDryRunningSta_MotPMP_PumpDryRunningSta();

  /* SignalConversion: '<S25>/Signal Copy85' incorporates:
   *  Inport: '<Root>/MotPMP_PumpPowerSta'
   *
   * Block description for '<Root>/MotPMP_PumpPowerSta':
   *  
   */
  MotPMP_PumpPowerSta =
    Rte_IRead_Task_100ms_MotPMP_PumpPowerSta_MotPMP_PumpPowerSta();

  /* SignalConversion: '<S25>/Signal Copy86' incorporates:
   *  Inport: '<Root>/MotPMP_PumpTempSta'
   *
   * Block description for '<Root>/MotPMP_PumpTempSta':
   *  
   */
  MotPMP_PumpTempSta =
    Rte_IRead_Task_100ms_MotPMP_PumpTempSta_MotPMP_PumpTempSta();

  /* Chart: '<S1024>/AcPMPFaultJudge' incorporates:
   *  Constant: '<S1057>/Constant'
   *  Constant: '<S1059>/Constant'
   *  Constant: '<S1060>/Constant'
   *  Logic: '<S1024>/OR'
   *  RelationalOperator: '<S1056>/Compare'
   *  RelationalOperator: '<S1057>/Compare'
   *  RelationalOperator: '<S1058>/Compare'
   *  RelationalOperator: '<S1059>/Compare'
   *  RelationalOperator: '<S1060>/Compare'
   */
  ME11_AcPMPFaultJudge(MotPMP_RESP_ERROR || (MotPMP_PumpMotorSta != 0) ||
                       MotPMP_PumpDryRunningSta || (MotPMP_PumpPowerSta != 0) ||
                       (MotPMP_PumpTempSta != 0),
                       &ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_e,
                       &ME11_ARID_DEF.ARID_DEF_AcPMPFaultJudge);

  /* Switch: '<S1066>/Switch' incorporates:
   *  Constant: '<S1066>/Constant1'
   */
  if (cal_MotPMPFaultFlgDataEnb) {
    /* Switch: '<S1066>/Switch' incorporates:
     *  Constant: '<S1066>/Constant'
     */
    ACTCtl_bMotPMPFaultFlg = cal_MotPMPFaultFlgData;
  } else {
    /* Switch: '<S1066>/Switch' */
    ACTCtl_bMotPMPFaultFlg = ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_e;
  }

  /* End of Switch: '<S1066>/Switch' */

  /* Outputs for Enabled SubSystem: '<S1325>/B1_B31_AC' incorporates:
   *  EnablePort: '<S1574>/Enable'
   */
  /* Outputs for Enabled SubSystem: '<S1325>/B1_B31_PT' incorporates:
   *  EnablePort: '<S1575>/Enable'
   */
  /* Logic: '<S1633>/NOT' incorporates:
   *  Logic: '<S1332>/AND3'
   *  Logic: '<S1332>/NOT'
   *  Logic: '<S1336>/AND2'
   *  Logic: '<S1336>/NOT'
   *  Logic: '<S1358>/AND2'
   *  Logic: '<S1358>/NOT'
   *  Logic: '<S1359>/AND2'
   *  Logic: '<S1359>/NOT'
   *  Logic: '<S1447>/AND5'
   *  Logic: '<S1447>/NOT1'
   *  Logic: '<S1574>/AND2'
   *  Logic: '<S1574>/NOT'
   *  Logic: '<S1575>/AND2'
   *  Logic: '<S1575>/NOT'
   *  Logic: '<S1633>/AND2'
   *  Logic: '<S1669>/AND5'
   *  Logic: '<S1669>/NOT1'
   */
  rtb_Compare_mgx = (rtb_RelationalOperator_nf && (!ACTCtl_bMotPMPFaultFlg));

  /* End of Outputs for SubSystem: '<S1325>/B1_B31_PT' */
  /* End of Outputs for SubSystem: '<S1325>/B1_B31_AC' */

  /* Logic: '<S1633>/AND1' incorporates:
   *  Constant: '<S1633>/Constant'
   *  Constant: '<S1654>/Constant'
   *  Logic: '<S1633>/AND2'
   *  Logic: '<S1633>/NOT'
   *  RelationalOperator: '<S1633>/Relational Operator'
   *  RelationalOperator: '<S1654>/Compare'
   */
  SOMCtl_bBatBalEntBFlg = ((SOMCtl_eBatBalEntBFlg != 0) && (rtb_Delay <
    cal_tBatHeatExitMaxToMinCellDiff) && rtb_Compare_mgx);

  /* Logic: '<S1338>/E' incorporates:
   *  Constant: '<S1666>/Constant'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   *  RelationalOperator: '<S1666>/Compare'
   */
  FixPtRelationalOperator =
    ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
     ->VIPM_INV2IgbtMaxTemp_C >= cal_tLTROnMotTemp);

  /* RelationalOperator: '<S1371>/Relational Operator5' incorporates:
   *  Constant: '<S1667>/Constant'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   *  RelationalOperator: '<S1667>/Compare'
   */
  rtb_AND_b3z = ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
                 ->VIPM_INV2MotorMaxTemp_C >= cal_LTRMotorMaxEntTemp);

  /* Outputs for Enabled SubSystem: '<S1326>/Enter_AC' incorporates:
   *  EnablePort: '<S1610>/Enable'
   */
  /* Outputs for Enabled SubSystem: '<S1326>/Enter_PT' incorporates:
   *  EnablePort: '<S1611>/Enable'
   */
  /* Sum: '<S1636>/Add' incorporates:
   *  Gain: '<S1636>/Gain3'
   *  Sum: '<S1610>/Add'
   *  Sum: '<S1611>/Add'
   */
  rtb_Divide1_f = (uint32)(rtb_Compare_mgx << 3);

  /* End of Outputs for SubSystem: '<S1326>/Enter_PT' */
  /* End of Outputs for SubSystem: '<S1326>/Enter_AC' */

  /* Sum: '<S1636>/Add' incorporates:
   *  Constant: '<S1665>/Constant'
   *  Constant: '<S1670>/Constant'
   *  Constant: '<S1671>/Constant'
   *  Gain: '<S1636>/Gain1'
   *  Gain: '<S1636>/Gain2'
   *  Logic: '<S1636>/AND1'
   *  RelationalOperator: '<S1665>/Compare'
   *  RelationalOperator: '<S1670>/Compare'
   *  RelationalOperator: '<S1671>/Compare'
   */
  SOMCtl_eBatLTROnFlg = (uint8)((((uint32)(((ACSen_sMotTempFilter >=
    cal_tLTROnMotTemp) || FixPtRelationalOperator || rtb_AND_b3z) << 2) +
    (uint32)((BMS_HVBatCellTempMax < cal_BatBalCellTemp2) << 1)) + (uint32)
    (ME11_ARID_DEF.DataTypeConversion1 >= 2)) + rtb_Divide1_f);

  /* Logic: '<S1338>/E' incorporates:
   *  Constant: '<S1640>/Constant'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   *  RelationalOperator: '<S1640>/Compare'
   */
  FixPtRelationalOperator =
    ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
     ->VIPM_INV2MotorMaxTemp_C <= cal_LTRMotorMaxExitTemp);

  /* RelationalOperator: '<S1371>/Relational Operator5' incorporates:
   *  Constant: '<S1638>/Constant'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   *  RelationalOperator: '<S1638>/Compare'
   */
  rtb_AND_b3z = ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
                 ->VIPM_INV2IgbtMaxTemp_C <= cal_LTRIGBTMaxExitTempB);

  /* RelationalOperator: '<S1644>/Relational Operator3' incorporates:
   *  Constant: '<S1644>/Constant'
   *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
   */
  rtb_AND2_of =
    ((Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT())
     ->VIPM_IPUDeviceIntTemp_C >= cal_TSIPUExitTempI);

  /* Chart: '<S1644>/Chart' */
  ME11_Delay_m(rtb_AND2_of, &ME11_ARID_DEF.B_b, &ME11_ARID_DEF.ARID_DEF_Chart);

  /* Logic: '<S1632>/AND3' incorporates:
   *  Logic: '<S1333>/AND2'
   *  Logic: '<S1465>/AND5'
   *  Logic: '<S1567>/AND5'
   *  Logic: '<S1573>/AND2'
   *  Logic: '<S1576>/AND2'
   */
  rtb_AND2_of = (ACTCtl_bBatPMPFaultFlg || ACTCtl_bMotPMPFaultFlg);

  /* Sum: '<S1632>/Add' incorporates:
   *  Constant: '<S1637>/Constant'
   *  Constant: '<S1639>/Constant'
   *  Constant: '<S1641>/Constant4'
   *  Constant: '<S1642>/Constant4'
   *  Constant: '<S1643>/Constant4'
   *  Constant: '<S1645>/Constant'
   *  Constant: '<S1646>/Constant'
   *  Constant: '<S1647>/Constant'
   *  Constant: '<S1648>/Constant'
   *  Constant: '<S1649>/Constant'
   *  Gain: '<S1632>/Gain1'
   *  Gain: '<S1632>/Gain2'
   *  Gain: '<S1632>/Gain3'
   *  Gain: '<S1632>/Gain4'
   *  Gain: '<S1632>/Gain5'
   *  Gain: '<S1632>/Gain6'
   *  Logic: '<S1632>/AND3'
   *  Logic: '<S1632>/AND7'
   *  Logic: '<S1641>/AndK'
   *  Logic: '<S1642>/AndM'
   *  Logic: '<S1643>/AndN'
   *  RelationalOperator: '<S1637>/Compare'
   *  RelationalOperator: '<S1639>/Compare'
   *  RelationalOperator: '<S1641>/Relational Operator5'
   *  RelationalOperator: '<S1642>/Relational Operator5'
   *  RelationalOperator: '<S1643>/Relational Operator5'
   *  RelationalOperator: '<S1645>/Compare'
   *  RelationalOperator: '<S1646>/Compare'
   *  RelationalOperator: '<S1647>/Compare'
   *  RelationalOperator: '<S1648>/Compare'
   *  RelationalOperator: '<S1649>/Compare'
   */
  SOMCtl_eMotLTRAndBatBalOffFlg = (uint8)(((((((uint32)(FixPtRelationalOperator &&
    (ACSen_sMotTempFilter <= cal_LTRMotorInletMaxExitTempA) && rtb_AND_b3z) +
    (uint32)(((BMS_HVBatCellTempMin <= cal_TSDCBatMinExitTempK) &&
              (ME11_ARID_DEF.DataTypeConversion1 == 4)) << 1)) + (uint32)
    (((BMS_HVBatCellTempMin <= cal_TSACBatMinExitTempM) &&
      (ME11_ARID_DEF.DataTypeConversion1 == 3) && (BMS_BatSOCAct_pct >=
    cal_ACChgBatHighSOCHeat)) << 2)) + (uint32)(((BMS_HVBatCellTempMin <=
    cal_TSACBatMinExitTempN) && (ME11_ARID_DEF.DataTypeConversion1 == 3) &&
    (BMS_BatSOCAct_pct <= cal_ACChgBatLowSOCHeat)) << 3)) + (uint32)
    ((BMS_HVBatCellTempMax >= cal_BatBalCellTemp2) << 4)) + (uint32)
    (ME11_ARID_DEF.B_b << 5)) + (uint32)(rtb_AND2_of << 6));

  /* RelationalOperator: '<S1632>/Relational Operator' incorporates:
   *  Constant: '<S1632>/Constant'
   */
  SOMCtl_bMotLTRAndBatBalOffFlg = (SOMCtl_eMotLTRAndBatBalOffFlg != 0);

  /* Chart: '<S1327>/Chart' incorporates:
   *  Constant: '<S1636>/Constant'
   *  Gain: '<S1327>/Gain'
   *  RelationalOperator: '<S1636>/Relational Operator'
   *  Sum: '<S1327>/Add'
   */
  if (ME11_ARID_DEF.is_active_c142_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c142_ME11 = 1U;
    ME11_ARID_DEF.is_c142_ME11 = ME11_IN_Off_a;
    rtb_AND_b3z = false;
  } else if (ME11_ARID_DEF.is_c142_ME11 == ME11_IN_Off_a) {
    rtb_AND_b3z = false;
    if ((sint32)((uint32)((SOMCtl_eBatLTROnFlg == 15) << 1) +
                 SOMCtl_bBatBalEntBFlg) >= 1) {
      ME11_ARID_DEF.is_c142_ME11 = ME11_IN_On_li;
      rtb_AND_b3z = true;
    }
  } else {
    /* case IN_On: */
    rtb_AND_b3z = true;
    if (SOMCtl_bMotLTRAndBatBalOffFlg) {
      ME11_ARID_DEF.is_c142_ME11 = ME11_IN_Off_a;
      rtb_AND_b3z = false;
    }
  }

  /* End of Chart: '<S1327>/Chart' */

  /* Logic: '<S1327>/AND1' incorporates:
   *  Logic: '<S1320>/AND1'
   *  Logic: '<S1324>/AND1'
   */
  rtb_FixPtRelationalOperator_fk = !SOMCtl_bBatCoolFlg;

  /* Switch: '<S1327>/Switch' incorporates:
   *  Constant: '<S1635>/Constant'
   *  Logic: '<S1327>/AND1'
   *  Logic: '<S1327>/AND4'
   *  Logic: '<S1327>/AND7'
   *  RelationalOperator: '<S1635>/Compare'
   */
  SOMCtl_bMotorLTRAndBatBalFlg = (rtb_FixPtRelationalOperator_fk &&
    (((ME11_ARID_DEF.DataTypeConversion1 != 3) &&
      (ME11_ARID_DEF.DataTypeConversion1 != 4)) || (!SOMCtl_bBatHeatFlg)) &&
    rtb_AND_b3z);

  /* Sum: '<S1547>/Add' incorporates:
   *  Sum: '<S1445>/Add'
   *  Sum: '<S1548>/Add'
   */
  rtb_Merge1 = BMS_HVBatCellTempMax - ACSen_sMotTempFilter;

  /* Sum: '<S1539>/Add' incorporates:
   *  Constant: '<S1553>/Constant'
   *  Constant: '<S1555>/Constant'
   *  Constant: '<S1559>/Constant'
   *  Gain: '<S1539>/Gain1'
   *  Gain: '<S1539>/Gain2'
   *  Logic: '<S1542>/OR'
   *  Logic: '<S1544>/AND'
   *  Lookup_n-D: '<S1544>/cal_DLTRBatMaxEntTempB_CUR'
   *  RelationalOperator: '<S1544>/Relational Operator3'
   *  RelationalOperator: '<S1553>/Compare'
   *  RelationalOperator: '<S1555>/Compare'
   *  RelationalOperator: '<S1559>/Compare'
   *  Sum: '<S1547>/Add'
   *  Switch: '<S1085>/Switch'
   */
  SOMCtl_eMotLTRAndBatBalOn1Flg = (uint8)(((uint32)(((BMS_HVBatCellTempMax >=
    cal_BatBalCellTemp2) && (BMS_HVBatCellTempMax <= look1_iflf_binlca
    (ACSen_sEnvTempCor, (const float32 *)&cal_DLTRBatMaxEntTempB_1X[0], (const
    float32 *)&cal_DLTRBatMaxEntTempB_CUR[0], 4U))) << 1) + (uint32)
    ((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
     (ME11_ARID_DEF.DataTypeConversion1 == 5))) + (uint32)((rtb_Merge1 >=
    cal_tLTROnMaxCellToMotDiff) << 2));

  /* RelationalOperator: '<S1539>/Relational Operator' incorporates:
   *  Constant: '<S1539>/Constant'
   */
  SOMCtl_bMotLTRAndBatBalOn1Flg = (SOMCtl_eMotLTRAndBatBalOn1Flg == 7);

  /* Logic: '<S1338>/E' incorporates:
   *  Constant: '<S1551>/Constant'
   *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
   *  RelationalOperator: '<S1551>/Compare'
   */
  FixPtRelationalOperator =
    ((Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT())
     ->VIPM_IPUDeviceIntTemp_C >= cal_tLTROnIPUTemp);

  /* Lookup_n-D: '<S1543>/cal_DLTRDCBatMaxEntTempB_CUR' incorporates:
   *  Lookup_n-D: '<S1545>/cal_DLTRDCBatMaxEntTempB_CUR'
   *  Switch: '<S1085>/Switch'
   */
  rtb_Delay1_ie = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
    &cal_DLTRDCBatMaxEntTempB_1X[0], (const float32 *)
    &cal_DLTRDCBatMaxEntTempB_CUR[0], 4U);

  /* Sum: '<S1539>/Add1' incorporates:
   *  Constant: '<S1554>/Constant'
   *  Constant: '<S1556>/Constant'
   *  Constant: '<S1557>/Constant'
   *  Constant: '<S1558>/Constant'
   *  Constant: '<S1560>/Constant'
   *  Gain: '<S1539>/Gain4'
   *  Gain: '<S1539>/Gain5'
   *  Logic: '<S1539>/AND7'
   *  Logic: '<S1543>/AND'
   *  Logic: '<S1545>/AND'
   *  Logic: '<S1546>/AND5'
   *  Lookup_n-D: '<S1543>/cal_DLTRDCBatMaxEntTempB_CUR'
   *  RelationalOperator: '<S1543>/Relational Operator3'
   *  RelationalOperator: '<S1545>/Relational Operator3'
   *  RelationalOperator: '<S1554>/Compare'
   *  RelationalOperator: '<S1556>/Compare'
   *  RelationalOperator: '<S1557>/Compare'
   *  RelationalOperator: '<S1558>/Compare'
   *  RelationalOperator: '<S1560>/Compare'
   */
  SOMCtl_eMotLTRAndBatBalOn2Flg = (uint8)(((uint32)
    (((ME11_ARID_DEF.DataTypeConversion1 == 4) && (BMS_HVBatCellTempMax <=
    rtb_Delay1_ie)) || ((ME11_ARID_DEF.DataTypeConversion1 == 3) &&
                        (BMS_HVBatCellTempMax <= rtb_Delay1_ie))) + (uint32)
    ((rtb_Merge1 >= cal_tLTROnMaxCellToMotDiff) << 1)) + (uint32)
    (((BMS_HVBatCellTempMax <= cal_tLTROnDCChrgMaxCellTemp) &&
      (BMS_HVBatCellTempMin >= cal_tLTROnDCChrgMinCellTemp)) << 2));

  /* RelationalOperator: '<S1539>/Relational Operator1' incorporates:
   *  Constant: '<S1539>/Constant1'
   */
  SOMCtl_bMotLTRAndBatBalOn2Flg = (SOMCtl_eMotLTRAndBatBalOn2Flg == 7);

  /* Logic: '<S1539>/AND2' incorporates:
   *  Constant: '<S1552>/Constant'
   *  Logic: '<S1539>/AND3'
   *  RelationalOperator: '<S1552>/Compare'
   */
  rtb_AND_b3z = (SOMCtl_bMotLTRAndBatBalOn1Flg || (FixPtRelationalOperator &&
    (ME11_ARID_DEF.DataTypeConversion1 >= 2)) || SOMCtl_bMotLTRAndBatBalOn2Flg);

  /* Logic: '<S1338>/E' incorporates:
   *  Constant: '<S1564>/Constant'
   *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
   *  RelationalOperator: '<S1564>/Compare'
   */
  FixPtRelationalOperator =
    ((Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT())
     ->VIPM_IPUDeviceIntTemp_C <= cal_DLTRIPUTempExitVal);

  /* Sum: '<S1562>/Add' incorporates:
   *  Constant: '<S1562>/Constant'
   *  Sum: '<S1461>/Add'
   */
  rtb_Add_ok = cal_BatBalCellTemp2 - BMS_HVBatCellTempMax;

  /* Logic: '<S1540>/AND7' incorporates:
   *  Constant: '<S1568>/Constant'
   *  Constant: '<S1569>/Constant'
   *  Constant: '<S1570>/Constant'
   *  Constant: '<S1571>/Constant'
   *  Constant: '<S1572>/Constant'
   *  Logic: '<S1540>/AND1'
   *  Logic: '<S1540>/AND2'
   *  Logic: '<S1540>/AND6'
   *  Logic: '<S1563>/AND1'
   *  Logic: '<S1563>/AND2'
   *  Logic: '<S1563>/AND3'
   *  Logic: '<S1563>/AND4'
   *  Lookup_n-D: '<S1563>/cal_DLTRDCBatMaxExitTempB_CUR'
   *  Lookup_n-D: '<S1563>/cal_DLTRNotDCBatMaxExitTempC_CUR'
   *  RelationalOperator: '<S1563>/Relational Operator3'
   *  RelationalOperator: '<S1568>/Compare'
   *  RelationalOperator: '<S1569>/Compare'
   *  RelationalOperator: '<S1570>/Compare'
   *  RelationalOperator: '<S1571>/Compare'
   *  RelationalOperator: '<S1572>/Compare'
   *  SignalConversion: '<S2>/Signal Copy160'
   *  Sum: '<S1562>/Add'
   *  Sum: '<S1565>/Add2'
   *  Switch: '<S1085>/Switch'
   */
  SOMCtl_bDBatLTROffFlg = ((FixPtRelationalOperator && ((BMS_InletCooltActlTemp
    - BMS_HVBatCellTempMax >= cal_DLTRBatInlet2MaxTempDiff) || (rtb_Add_ok >=
    cal_tLTROffBatBal2ToMaxCellDiff))) || (((ME11_ARID_DEF.DataTypeConversion1 ==
    4) && (look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
    &cal_DLTRDCBatMaxExitTempB_1X[0], (const float32 *)
    &cal_DLTRDCBatMaxExitTempB_CUR[0], 4U) <= BMS_HVBatCellTempMax)) ||
    ((look1_iflf_binlca(BMS_HVBatCellTempMax, (const float32 *)
                        &cal_DLTRNotDCBatMaxExitTempC_1X[0], (const float32 *)
                        &cal_DLTRNotDCBatMaxExitTempC_CUR[0], 4U) != 0.0F) &&
     ((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
      (ME11_ARID_DEF.DataTypeConversion1 == 3) ||
      (ME11_ARID_DEF.DataTypeConversion1 == 5))) || (rtb_Delay >=
    cal_tBatHeatExitMaxToMinCellDiff) || rtb_AND2_of));

  /* Chart: '<S1324>/Chart' incorporates:
   *  Constant: '<S1561>/Constant'
   *  Logic: '<S1539>/AND4'
   *  Logic: '<S1550>/AND5'
   *  Logic: '<S1550>/NOT1'
   *  RelationalOperator: '<S1561>/Compare'
   *  Sum: '<S1549>/Add2'
   */
  ME11_Chart_i(rtb_AND_b3z && ((!ACTCtl_bBatPMPFaultFlg) &&
    (!ACTCtl_bMotPMPFaultFlg)) && (BMS_HVBatCellTempMax - BMS_HVBatCellTempMin <
    cal_tBatHeatExitMaxToMinCellDiff), SOMCtl_bDBatLTROffFlg,
               &rtb_SOMCtl_bBatLTRFlg_k, &ME11_ARID_DEF.ARID_DEF_Chart_f);

  /* Switch: '<S1324>/Switch' incorporates:
   *  Constant: '<S1541>/Constant'
   *  Delay: '<S1324>/Delay'
   *  Logic: '<S1324>/AND1'
   *  Logic: '<S1324>/AND4'
   *  Logic: '<S1324>/AND7'
   *  RelationalOperator: '<S1541>/Compare'
   */
  SOMCtl_bMotAndBatLTRFlg = (rtb_FixPtRelationalOperator_fk &&
    (((ME11_ARID_DEF.DataTypeConversion1 != 3) &&
      (ME11_ARID_DEF.DataTypeConversion1 != 4)) ||
     (!ME11_ARID_DEF.Delay_DSTATE_me)) && rtb_SOMCtl_bBatLTRFlg_k);

  /* Relay: '<S1480>/Relay' */
  ME11_ARID_DEF.Relay_Mode = ((BMS_BatSOCAct_pct >= cal_ACChgBatHighSOCHeat) ||
    ((BMS_BatSOCAct_pct > cal_ACChgBatLowSOCHeat) && ME11_ARID_DEF.Relay_Mode));

  /* Switch: '<S1480>/Switch' incorporates:
   *  Constant: '<S1486>/Constant'
   *  Constant: '<S1489>/Constant'
   *  RelationalOperator: '<S1486>/Compare'
   *  RelationalOperator: '<S1489>/Compare'
   *  Relay: '<S1480>/Relay'
   */
  if (ME11_ARID_DEF.Relay_Mode) {
    rtb_Compare_fx = (BMS_HVBatCellTempMin <= cal_tBatHeatACChrgSOCHighTempOn);
  } else {
    rtb_Compare_fx = (BMS_HVBatCellTempMin <= cal_tBatHeatACChrgCellTempOn);
  }

  /* Logic: '<S1480>/AND2' incorporates:
   *  Constant: '<S1485>/Constant'
   *  Constant: '<S1487>/Constant'
   *  Constant: '<S1488>/Constant'
   *  Logic: '<S1480>/AND'
   *  Logic: '<S1480>/AND1'
   *  RelationalOperator: '<S1485>/Compare'
   *  RelationalOperator: '<S1487>/Compare'
   *  RelationalOperator: '<S1488>/Compare'
   *  Switch: '<S1480>/Switch'
   */
  SOMCtl_bBatHeatChrgFlgAB = (((BMS_HVBatCellTempMin <=
    cal_tBatHeatDCChrgCellTempOn) && (ME11_ARID_DEF.DataTypeConversion1 == 4)) ||
    ((ME11_ARID_DEF.DataTypeConversion1 == 3) && rtb_Compare_fx));

  /* SignalConversion: '<S16>/Signal Copy103' incorporates:
   *  Inport: '<Root>/AcPMP_RESP_ERROR'
   *
   * Block description for '<Root>/AcPMP_RESP_ERROR':
   *  LIN
   */
  AcPMP_RESP_ERROR = Rte_IRead_Task_100ms_AcPMP_RESP_ERROR_AcPMP_RESP_ERROR();

  /* SignalConversion: '<S16>/Signal Copy104' incorporates:
   *  Inport: '<Root>/AcPMP_PumpMotorSta'
   *
   * Block description for '<Root>/AcPMP_PumpMotorSta':
   *  
   */
  AcPMP_PumpMotorSta =
    Rte_IRead_Task_100ms_AcPMP_PumpMotorSta_AcPMP_PumpMotorSta();

  /* SignalConversion: '<S16>/Signal Copy105' incorporates:
   *  Inport: '<Root>/AcPMP_PumpDryRunningSta'
   *
   * Block description for '<Root>/AcPMP_PumpDryRunningSta':
   *  
   */
  AcPMP_PumpDryRunningSta =
    Rte_IRead_Task_100ms_AcPMP_PumpDryRunningSta_AcPMP_PumpDryRunningSta();

  /* SignalConversion: '<S16>/Signal Copy106' incorporates:
   *  Inport: '<Root>/AcPMP_PumpPowerSta'
   *
   * Block description for '<Root>/AcPMP_PumpPowerSta':
   *  
   */
  AcPMP_PumpPowerSta =
    Rte_IRead_Task_100ms_AcPMP_PumpPowerSta_AcPMP_PumpPowerSta();

  /* SignalConversion: '<S16>/Signal Copy107' incorporates:
   *  Inport: '<Root>/AcPMP_PumpTempSta'
   *
   * Block description for '<Root>/AcPMP_PumpTempSta':
   *  
   */
  AcPMP_PumpTempSta = Rte_IRead_Task_100ms_AcPMP_PumpTempSta_AcPMP_PumpTempSta();

  /* Chart: '<S1022>/AcPMPFaultJudge' incorporates:
   *  Constant: '<S1028>/Constant'
   *  Constant: '<S1030>/Constant'
   *  Constant: '<S1031>/Constant'
   *  Logic: '<S1022>/OR'
   *  RelationalOperator: '<S1027>/Compare'
   *  RelationalOperator: '<S1028>/Compare'
   *  RelationalOperator: '<S1029>/Compare'
   *  RelationalOperator: '<S1030>/Compare'
   *  RelationalOperator: '<S1031>/Compare'
   */
  ME11_AcPMPFaultJudge(AcPMP_RESP_ERROR || (AcPMP_PumpMotorSta != 0) ||
                       AcPMP_PumpDryRunningSta || (AcPMP_PumpPowerSta != 0) ||
                       (AcPMP_PumpTempSta != 0),
                       &ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_c,
                       &ME11_ARID_DEF.ARID_DEF_AcPMPFaultJudge_p);

  /* Switch: '<S1036>/Switch' incorporates:
   *  Constant: '<S1036>/Constant1'
   */
  if (cal_AcPMPFaultFlgDataEnb) {
    /* Switch: '<S1036>/Switch' incorporates:
     *  Constant: '<S1036>/Constant'
     */
    ACTCtl_bAcPMPFaultFlg = cal_AcPMPFaultFlgData;
  } else {
    /* Switch: '<S1036>/Switch' */
    ACTCtl_bAcPMPFaultFlg = ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_c;
  }

  /* End of Switch: '<S1036>/Switch' */

  /* Logic: '<S946>/OR' incorporates:
   *  Logic: '<S1504>/OR1'
   */
  rtb_FixPtRelationalOperator_a0 = (ACTCtl_bAcPMPFaultFlg ||
    ACTCtl_bBatPMPFaultFlg);

  /* Logic: '<S1481>/NOT' incorporates:
   *  Logic: '<S1481>/OR1'
   *  Logic: '<S1481>/OR2'
   *  Logic: '<S1481>/OR3'
   *  Logic: '<S1493>/NOT'
   *  Logic: '<S1493>/OR3'
   *  Logic: '<S946>/OR'
   */
  SOMCtl_bBatHeatChrgFlgCD = ((rtb_Compare_dy && ((!ACTCtl_bAcPMPFaultFlg) &&
    rtb_RelationalOperator_nf) && rtb_OR_k0) || (!rtb_FixPtRelationalOperator_a0));

  /* RelationalOperator: '<S1490>/Compare' incorporates:
   *  Constant: '<S1490>/Constant'
   */
  SOMCtl_bBatHeatTempDiffE = (rtb_Merge < cal_tBatHeatExitMaxToMinCellDiff);

  /* Gain: '<S8>/Gain8' incorporates:
   *  Inport: '<Root>/Vcu2BcmTms_outputs'
   *  Sum: '<S1483>/Add'
   */
  rtb_Delay1_ie = (Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs()
    )->VEMS_HeatCoolMaxPwrCmsp_kW +
    (Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs())
    ->VEMS_HeatCoolMaxPwrCmsp_kW;

  /* RelationalOperator: '<S1483>/Relational Operator' incorporates:
   *  Constant: '<S1483>/Constant'
   */
  SOMCtl_bBatHeatPwrLmtF = (rtb_Delay1_ie >= cal_HeatPwrOn);

  /* Logic: '<S1484>/OR2' */
  SOMCtl_bBatB1TB41Flg = (SOMCtl_bBatHeatChrgFlgAB && SOMCtl_bBatHeatChrgFlgCD &&
    SOMCtl_bBatHeatTempDiffE && SOMCtl_bBatHeatPwrLmtF);

  /* Relay: '<S1507>/Relay' */
  ME11_ARID_DEF.Relay_Mode_l = ((BMS_BatSOCAct_pct >= cal_ACChgBatHighSOCHeat) ||
    ((BMS_BatSOCAct_pct > cal_ACChgBatLowSOCHeat) && ME11_ARID_DEF.Relay_Mode_l));

  /* Gain: '<S8>/Gain8' incorporates:
   *  Inport: '<Root>/Vcu2BcmTms_outputs'
   *  Sum: '<S1503>/Add'
   */
  rtb_Delay1_ie = (Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs()
    )->VEMS_HeatCoolMaxPwrCmsp_kW +
    (Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs())
    ->VEMS_HeatCoolMaxPwrCmsp_kW;

  /* Switch: '<S1507>/Switch' incorporates:
   *  Constant: '<S1522>/Constant'
   *  Constant: '<S1525>/Constant'
   *  RelationalOperator: '<S1522>/Compare'
   *  RelationalOperator: '<S1525>/Compare'
   *  Relay: '<S1507>/Relay'
   */
  if (ME11_ARID_DEF.Relay_Mode_l) {
    rtb_Compare_fx = (BMS_HVBatCellTempMin >= cal_tBatHeatACChrgSOCHighTempOff);
  } else {
    rtb_Compare_fx = (BMS_HVBatCellTempMin >= cal_tBatHeatACChrgCellTempOff);
  }

  /* Switch: '<S1505>/Switch' incorporates:
   *  Constant: '<S1505>/Constant'
   *  Constant: '<S1510>/Constant'
   *  Constant: '<S1511>/Constant'
   *  Constant: '<S1512>/Constant'
   *  Logic: '<S1505>/OR'
   *  RelationalOperator: '<S1510>/Compare'
   *  RelationalOperator: '<S1511>/Compare'
   *  RelationalOperator: '<S1512>/Compare'
   */
  if ((ME11_ARID_DEF.DataTypeConversion1 == 3) ||
      (ME11_ARID_DEF.DataTypeConversion1 == 4)) {
    rtb_AND_b3z = false;
  } else {
    rtb_AND_b3z = (BMS_BatSOCAct_pct <= cal_VehHeatSOCOff);
  }

  /* Sum: '<S1508>/Add' incorporates:
   *  Constant: '<S1503>/Constant'
   *  Constant: '<S1509>/Constant'
   *  Constant: '<S1513>/Constant'
   *  Constant: '<S1514>/Constant'
   *  Constant: '<S1515>/Constant'
   *  Constant: '<S1516>/Constant'
   *  Constant: '<S1517>/Constant'
   *  Constant: '<S1518>/Constant'
   *  Constant: '<S1519>/Constant'
   *  Constant: '<S1520>/Constant'
   *  Constant: '<S1521>/Constant'
   *  Constant: '<S1523>/Constant'
   *  Constant: '<S1524>/Constant'
   *  Delay: '<S1322>/Delay'
   *  Delay: '<S1506>/Delay'
   *  Gain: '<S1508>/Gain1'
   *  Gain: '<S1508>/Gain2'
   *  Gain: '<S1508>/Gain3'
   *  Gain: '<S1508>/Gain4'
   *  Gain: '<S1508>/Gain5'
   *  Logic: '<S1504>/OR2'
   *  Logic: '<S1504>/OR3'
   *  Logic: '<S1506>/AND'
   *  Logic: '<S1506>/AND1'
   *  Logic: '<S1506>/AND2'
   *  Logic: '<S1506>/AND3'
   *  Logic: '<S1506>/AND4'
   *  Logic: '<S1507>/Logical Operator'
   *  Logic: '<S1507>/Logical Operator1'
   *  Logic: '<S1507>/Logical Operator2'
   *  Logic: '<S1507>/Logical Operator3'
   *  Logic: '<S946>/OR'
   *  RelationalOperator: '<S1503>/Relational Operator'
   *  RelationalOperator: '<S1509>/Compare'
   *  RelationalOperator: '<S1513>/Compare'
   *  RelationalOperator: '<S1514>/Compare'
   *  RelationalOperator: '<S1515>/Compare'
   *  RelationalOperator: '<S1516>/Compare'
   *  RelationalOperator: '<S1517>/Compare'
   *  RelationalOperator: '<S1518>/Compare'
   *  RelationalOperator: '<S1519>/Compare'
   *  RelationalOperator: '<S1520>/Compare'
   *  RelationalOperator: '<S1521>/Compare'
   *  RelationalOperator: '<S1523>/Compare'
   *  RelationalOperator: '<S1524>/Compare'
   *  Switch: '<S1505>/Switch'
   *  Switch: '<S1507>/Switch'
   */
  SOMCtl_eBatHeatOffVal = (uint8)((((((uint32)(((((ME11_ARID_DEF.Delay_DSTATE_nl
    == 3) && (ME11_ARID_DEF.DataTypeConversion1 != 3)) ||
    ((ME11_ARID_DEF.Delay_DSTATE_nl == 4) && (ME11_ARID_DEF.DataTypeConversion1
    != 4)) || ((ME11_ARID_DEF.Delay_DSTATE_nl == 5) &&
               (ME11_ARID_DEF.DataTypeConversion1 != 5))) &&
    ME11_ARID_DEF.Delay_DSTATE_mq) << 4) + (uint32)
    ((((ME11_ARID_DEF.DataTypeConversion1 == 4) && (BMS_HVBatCellTempMin >=
    cal_tBatHeatDCChrgCellTempOff)) || ((ME11_ARID_DEF.DataTypeConversion1 == 3)
    && rtb_Compare_fx) || ((ME11_ARID_DEF.DataTypeConversion1 == 5) &&
    (BMS_HVBatCellTempMin >= cal_tBatHeatVehReadyCellTempOff))) << 5)) + (uint32)
    (((rtb_FixPtRelationalOperator_i1 || rtb_FixPtRelationalOperator_a0 ||
       ACTCtl_bCOMPForbidFlg) && rtb_FixPtRelationalOperator_a0) << 2)) +
    (uint32)(rtb_AND_b3z << 3)) + (uint32)(rtb_Merge >=
    cal_tBatHeatExitMaxToMinCellDiff)) + (uint32)((rtb_Delay1_ie <=
    cal_BatHeatPwrLoLmt) << 1));

  /* RelationalOperator: '<S1508>/Relational Operator' incorporates:
   *  Constant: '<S1508>/Constant'
   */
  SOMCtl_bBatHeatOffFlg = (SOMCtl_eBatHeatOffVal != 0);

  /* Gain: '<S8>/Gain8' incorporates:
   *  Inport: '<Root>/Vcu2BcmTms_outputs'
   *  Sum: '<S1496>/Add'
   */
  rtb_Delay1_ie = (Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs()
    )->VEMS_HeatCoolMaxPwrCmsp_kW +
    (Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs())
    ->VEMS_HeatCoolMaxPwrCmsp_kW;

  /* Logic: '<S1497>/OR2' incorporates:
   *  Constant: '<S1496>/Constant'
   *  Constant: '<S1498>/Constant'
   *  Constant: '<S1499>/Constant'
   *  Constant: '<S1500>/Constant'
   *  Constant: '<S1501>/Constant'
   *  RelationalOperator: '<S1496>/Relational Operator'
   *  RelationalOperator: '<S1498>/Compare'
   *  RelationalOperator: '<S1499>/Compare'
   *  RelationalOperator: '<S1500>/Compare'
   *  RelationalOperator: '<S1501>/Compare'
   */
  SOMCtl_bBatB1TB42Flg = ((ME11_ARID_DEF.DataTypeConversion1 == 5) &&
    (BMS_HVBatCellTempMin <= cal_tBatHeatVehReadyCellTempOn) &&
    SOMCtl_bBatHeatChrgFlgCD && (BMS_BatSOCAct_pct >= cal_VehHeatSOCOn) &&
    (rtb_Merge < cal_tBatHeatExitMaxToMinCellDiff) && (rtb_Delay1_ie >=
    cal_HeatPwrOn));

  /* Chart: '<S1322>/Heat' */
  if (ME11_ARID_DEF.is_active_c71_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c71_ME11 = 1U;
    ME11_ARID_DEF.is_c71_ME11 = ME11_IN_Off_a;
    SOMCtl_bBatHeatFlg = false;
  } else if (ME11_ARID_DEF.is_c71_ME11 == ME11_IN_Off_a) {
    SOMCtl_bBatHeatFlg = false;
    if (SOMCtl_bBatB1TB41Flg || SOMCtl_bBatB1TB42Flg) {
      ME11_ARID_DEF.is_c71_ME11 = ME11_IN_On_li;
      SOMCtl_bBatHeatFlg = true;
    }
  } else {
    /* case IN_On: */
    SOMCtl_bBatHeatFlg = true;
    if (SOMCtl_bBatHeatOffFlg) {
      ME11_ARID_DEF.is_c71_ME11 = ME11_IN_Off_a;
      SOMCtl_bBatHeatFlg = false;
    }
  }

  /* End of Chart: '<S1322>/Heat' */

  /* Switch: '<S1478>/Switch' incorporates:
   *  Constant: '<S1478>/Constant1'
   */
  if (cal_BatHeatOverEnb) {
    /* Switch: '<S1478>/Switch' incorporates:
     *  Constant: '<S1478>/Constant'
     */
    SOMCtl_bBatHeatFlg = cal_BatHeatOverData;
  }

  /* End of Switch: '<S1478>/Switch' */

  /* Logic: '<S1338>/E' incorporates:
   *  Constant: '<S1358>/Constant'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   *  RelationalOperator: '<S1358>/Relational Operator3'
   */
  FixPtRelationalOperator =
    ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
     ->VIPM_INV2MotorMaxTemp_C <= cal_TSMotorMinTempEntC);

  /* RelationalOperator: '<S1371>/Relational Operator5' incorporates:
   *  Constant: '<S1358>/Constant3'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   *  RelationalOperator: '<S1358>/Relational Operator4'
   */
  rtb_AND_b3z = ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
                 ->VIPM_INV2IgbtMaxTemp_C <= cal_TSIGBTMinTempEntC);

  /* Logic: '<S1358>/AND1' incorporates:
   *  Constant: '<S1358>/Constant1'
   *  Constant: '<S1358>/Constant2'
   *  Constant: '<S1360>/Constant'
   *  Constant: '<S1361>/Constant'
   *  Logic: '<S1358>/AND3'
   *  Logic: '<S1358>/AND4'
   *  RelationalOperator: '<S1358>/Relational Operator1'
   *  RelationalOperator: '<S1358>/Relational Operator2'
   *  RelationalOperator: '<S1360>/Compare'
   *  RelationalOperator: '<S1361>/Compare'
   */
  SOMCtl_bBatTSEntAFlg = (((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
    (ME11_ARID_DEF.DataTypeConversion1 == 5)) && (rtb_Delay <
    cal_tBatHeatExitMaxToMinCellDiff) && rtb_Compare_mgx &&
    (cal_TSBatMinTemplowValB <= BMS_HVBatCellTempMin) && (BMS_HVBatCellTempMin <=
    cal_BatBalCellTemp1) && (FixPtRelationalOperator || rtb_AND_b3z));

  /* Logic: '<S1359>/AND1' incorporates:
   *  Constant: '<S1362>/Constant'
   *  Constant: '<S1362>/Constant4'
   *  Constant: '<S1363>/Constant'
   *  Constant: '<S1363>/Constant4'
   *  Constant: '<S1364>/Constant'
   *  Constant: '<S1364>/Constant4'
   *  Constant: '<S1365>/Constant'
   *  Constant: '<S1366>/Constant'
   *  Constant: '<S1367>/Constant'
   *  Constant: '<S1368>/Constant'
   *  Constant: '<S1369>/Constant'
   *  Constant: '<S1370>/Constant'
   *  Logic: '<S1359>/AND3'
   *  Logic: '<S1362>/AndA'
   *  Logic: '<S1363>/AndA'
   *  Logic: '<S1364>/AndA'
   *  RelationalOperator: '<S1362>/Relational Operator1'
   *  RelationalOperator: '<S1362>/Relational Operator5'
   *  RelationalOperator: '<S1363>/Relational Operator1'
   *  RelationalOperator: '<S1363>/Relational Operator5'
   *  RelationalOperator: '<S1364>/Relational Operator1'
   *  RelationalOperator: '<S1364>/Relational Operator5'
   *  RelationalOperator: '<S1365>/Compare'
   *  RelationalOperator: '<S1366>/Compare'
   *  RelationalOperator: '<S1367>/Compare'
   *  RelationalOperator: '<S1368>/Compare'
   *  RelationalOperator: '<S1369>/Compare'
   *  RelationalOperator: '<S1370>/Compare'
   */
  SOMCtl_bBatTSEntBFlg = ((((cal_TSACBatMinEntTempA <= BMS_HVBatCellTempMin) &&
    (BMS_HVBatCellTempMax < cal_BatBalCellTemp2) &&
    (ME11_ARID_DEF.DataTypeConversion1 == 3) && (BMS_BatSOCAct_pct <=
    cal_ACChgBatLowSOCHeat)) || ((cal_TSACBatMinEntTempB <= BMS_HVBatCellTempMin)
    && (BMS_HVBatCellTempMax < cal_BatBalCellTemp2) &&
    (ME11_ARID_DEF.DataTypeConversion1 == 3) && (BMS_BatSOCAct_pct >=
    cal_ACChgBatHighSOCHeat)) || ((cal_TSDCBatMinEntTempC <=
    BMS_HVBatCellTempMin) && (BMS_HVBatCellTempMax < cal_BatBalCellTemp2) &&
    (ME11_ARID_DEF.DataTypeConversion1 == 4))) && (rtb_Delay <
    cal_tBatHeatExitMaxToMinCellDiff) && rtb_Compare_mgx);

  /* Chart: '<S1373>/Chart' incorporates:
   *  Constant: '<S1373>/Constant5'
   *  RelationalOperator: '<S1373>/Relational Operator5'
   *  Sum: '<S1373>/Add1'
   */
  ME11_Delay_m(ACSen_sMotTempFilter >= BMS_HVBatCellTempMin +
               cal_TSBatMinTempOffsetD, &ME11_ARID_DEF.B_ms,
               &ME11_ARID_DEF.ARID_DEF_Chart_me);

  /* RelationalOperator: '<S1374>/Relational Operator4' incorporates:
   *  Constant: '<S1374>/Constant3'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   */
  rtb_AND_b3z = ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
                 ->VIPM_INV2IgbtMaxTemp_C >= cal_TSIGBTMinTempExitG);

  /* RelationalOperator: '<S1375>/Relational Operator3' incorporates:
   *  Constant: '<S1375>/Constant'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   */
  FixPtRelationalOperator =
    ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
     ->VIPM_INV2MotorMaxTemp_C >= cal_TSMotorMinTempExitH);

  /* RelationalOperator: '<S96>/Relational Operator1' incorporates:
   *  Constant: '<S1376>/Constant'
   *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
   *  RelationalOperator: '<S1376>/Relational Operator3'
   */
  rtb_FixPtRelationalOperator_a0 =
    ((Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT())
     ->VIPM_IPUDeviceIntTemp_C >= cal_TSIPUExitTempI);

  /* Chart: '<S1382>/Chart' incorporates:
   *  Constant: '<S1382>/Constant5'
   *  RelationalOperator: '<S1382>/Relational Operator5'
   *  Sum: '<S1382>/Add1'
   */
  ME11_Delay_m(ACSen_sMotTempFilter >= BMS_InletCooltActlTemp +
               cal_TSBatInletTempOffsetP, &ME11_ARID_DEF.B_cv,
               &ME11_ARID_DEF.ARID_DEF_Chart_g1);

  /* Logic: '<S1338>/AND1' incorporates:
   *  Constant: '<S1371>/Constant4'
   *  Constant: '<S1371>/Constant5'
   *  Constant: '<S1377>/Constant4'
   *  Constant: '<S1378>/Constant4'
   *  Constant: '<S1379>/Constant4'
   *  Constant: '<S1380>/Constant4'
   *  Constant: '<S1381>/Constant'
   *  Constant: '<S1384>/Constant'
   *  Constant: '<S1385>/Constant'
   *  Constant: '<S1386>/Constant'
   *  Constant: '<S1387>/Constant'
   *  Constant: '<S1388>/Constant'
   *  Logic: '<S1338>/E'
   *  Logic: '<S1378>/AndK'
   *  Logic: '<S1379>/AndM'
   *  Logic: '<S1380>/AndN'
   *  Lookup_n-D: '<S1372>/cal_TSBatMaxTempForEnvExitC_CUR'
   *  RelationalOperator: '<S1371>/Relational Operator5'
   *  RelationalOperator: '<S1372>/Relational Operator3'
   *  RelationalOperator: '<S1377>/Relational Operator5'
   *  RelationalOperator: '<S1378>/Relational Operator5'
   *  RelationalOperator: '<S1379>/Relational Operator5'
   *  RelationalOperator: '<S1380>/Relational Operator5'
   *  RelationalOperator: '<S1381>/Compare'
   *  RelationalOperator: '<S1384>/Compare'
   *  RelationalOperator: '<S1385>/Compare'
   *  RelationalOperator: '<S1386>/Compare'
   *  RelationalOperator: '<S1387>/Compare'
   *  RelationalOperator: '<S1388>/Compare'
   *  Sum: '<S1371>/Add1'
   *  Switch: '<S1085>/Switch'
   */
  SOMCtl_bBatTSExitFlg = ((rtb_Delay >= cal_tBatHeatExitMaxToMinCellDiff) ||
    (ACTCtl_bBatPMPFaultFlg && ACTCtl_bMotPMPFaultFlg) || (BMS_HVBatCellTempMin >=
    cal_BatBalCellTemp1 + 2.0F) || (BMS_HVBatCellTempMax >= look1_iflf_binlca
    (ACSen_sEnvTempCor, (const float32 *)&cal_TSBatMaxTempForEnvExitC_1X[0], (
    const float32 *)&cal_TSBatMaxTempForEnvExitC_CUR[0], 4U)) ||
    ME11_ARID_DEF.B_ms || rtb_AND_b3z || FixPtRelationalOperator ||
    rtb_FixPtRelationalOperator_a0 || (BMS_HVBatCellTempMin <=
    cal_TSBatMinExitTempJ) || ((BMS_HVBatCellTempMin <= cal_TSDCBatMinExitTempK)
    && (ME11_ARID_DEF.DataTypeConversion1 == 4)) || ((BMS_HVBatCellTempMin <=
    cal_TSACBatMinExitTempM) && (ME11_ARID_DEF.DataTypeConversion1 == 3) &&
    (BMS_BatSOCAct_pct >= cal_ACChgBatHighSOCHeat)) || ((BMS_HVBatCellTempMin <=
    cal_TSACBatMinExitTempN) && (ME11_ARID_DEF.DataTypeConversion1 == 3) &&
    (BMS_BatSOCAct_pct <= cal_ACChgBatLowSOCHeat)) || ME11_ARID_DEF.B_cv);

  /* Chart: '<S1318>/Judge1' incorporates:
   *  Gain: '<S1337>/Gain'
   *  Sum: '<S1337>/Add'
   */
  if (ME11_ARID_DEF.is_active_c132_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c132_ME11 = 1U;
    ME11_ARID_DEF.is_c132_ME11 = ME11_IN_Off_a;
    rtb_SOMCtl_bBatTSFlg = 0;
  } else if (ME11_ARID_DEF.is_c132_ME11 == ME11_IN_Off_a) {
    rtb_SOMCtl_bBatTSFlg = 0;
    if ((sint32)((uint32)(SOMCtl_bBatTSEntBFlg << 1) + SOMCtl_bBatTSEntAFlg) >=
        1) {
      ME11_ARID_DEF.is_c132_ME11 = ME11_IN_On_li;
      rtb_SOMCtl_bBatTSFlg = 1;
    }
  } else {
    /* case IN_On: */
    rtb_SOMCtl_bBatTSFlg = 1;
    if (SOMCtl_bBatTSExitFlg) {
      ME11_ARID_DEF.is_c132_ME11 = ME11_IN_Off_a;
      rtb_SOMCtl_bBatTSFlg = 0;
    }
  }

  /* End of Chart: '<S1318>/Judge1' */

  /* Outputs for Enabled SubSystem: '<S1326>/Enter_PT' incorporates:
   *  EnablePort: '<S1611>/Enable'
   */
  /* Logic: '<S1326>/OR' incorporates:
   *  Constant: '<S1326>/Constant'
   *  RelationalOperator: '<S1326>/Relational Operator'
   */
  if ((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
      (ME11_ARID_DEF.DataTypeConversion1 == 5)) {
    ME11_ARID_DEF.Enter_PT_MODE = true;

    /* Chart: '<S1611>/Chart' incorporates:
     *  Constant: '<S1611>/Constant1'
     *  RelationalOperator: '<S1611>/Relational Operator'
     *  Sum: '<S1611>/Add1'
     */
    ME11_Chart_l(BMS_HVBatCellTempMin + cal_tMotHeatOnMotToMinCellDiff <=
                 ACSen_sMotTempFilter, &ME11_ARID_DEF.B_p,
                 &ME11_ARID_DEF.ARID_DEF_Chart_m);

    /* Sum: '<S1611>/Add' incorporates:
     *  Constant: '<S1619>/Constant'
     *  Constant: '<S1620>/Constant'
     *  Constant: '<S1621>/Constant'
     *  Gain: '<S1611>/Gain1'
     *  Gain: '<S1611>/Gain2'
     *  Logic: '<S1611>/AND1'
     *  RelationalOperator: '<S1619>/Compare'
     *  RelationalOperator: '<S1620>/Compare'
     *  RelationalOperator: '<S1621>/Compare'
     */
    SOMCtl_eMotorHeatBatFlg = (uint8)((((uint32)(((BMS_HVBatCellTempMin <=
      cal_BatBalCellTemp1) && (BMS_HVBatCellTempMin >
      cal_tMotHeatBatMinCellTempLow)) << 1) + (uint32)(rtb_Delay <
      cal_tBatHeatExitMaxToMinCellDiff)) + (uint32)(ME11_ARID_DEF.B_p << 2)) +
      rtb_Divide1_f);

    /* Merge: '<S1326>/Merge' incorporates:
     *  RelationalOperator: '<S1611>/Relational Operator1'
     */
    ME11_ARID_DEF.Merge_c = (SOMCtl_eMotorHeatBatFlg == 15);
  } else {
    ME11_ARID_DEF.Enter_PT_MODE = false;
  }

  /* End of Logic: '<S1326>/OR' */
  /* End of Outputs for SubSystem: '<S1326>/Enter_PT' */

  /* Outputs for Enabled SubSystem: '<S1326>/Enter_AC' incorporates:
   *  EnablePort: '<S1610>/Enable'
   */
  /* RelationalOperator: '<S1608>/Compare' incorporates:
   *  Constant: '<S1608>/Constant'
   */
  if (ME11_ARID_DEF.DataTypeConversion1 == 3) {
    ME11_ARID_DEF.Enter_AC_MODE = true;

    /* Chart: '<S1610>/Chart' incorporates:
     *  Constant: '<S1610>/Constant1'
     *  RelationalOperator: '<S1610>/Relational Operator'
     *  Sum: '<S1610>/Add1'
     */
    ME11_Chart_l(BMS_HVBatCellTempMin + cal_tMotHeatOnMotToMinCellDiff <=
                 ACSen_sMotTempFilter, &ME11_ARID_DEF.B_e,
                 &ME11_ARID_DEF.ARID_DEF_Chart_c);

    /* Sum: '<S1610>/Add' incorporates:
     *  Constant: '<S1615>/Constant'
     *  Constant: '<S1616>/Constant'
     *  Constant: '<S1617>/Constant'
     *  Gain: '<S1610>/Gain1'
     *  Gain: '<S1610>/Gain2'
     *  Logic: '<S1610>/AND1'
     *  RelationalOperator: '<S1615>/Compare'
     *  RelationalOperator: '<S1616>/Compare'
     *  RelationalOperator: '<S1617>/Compare'
     */
    SOMCtl_eMotorHeatBat2Flg = (uint8)((((uint32)(((BMS_HVBatCellTempMin <=
      cal_BatBalCellTemp1) && (BMS_HVBatCellTempMin >
      cal_tMotHeatBatACChrgMinCellTempLow)) << 1) + (uint32)(rtb_Delay <
      cal_tBatHeatExitMaxToMinCellDiff)) + (uint32)(ME11_ARID_DEF.B_e << 2)) +
      rtb_Divide1_f);

    /* Merge: '<S1326>/Merge' incorporates:
     *  Constant: '<S1610>/Constant2'
     *  RelationalOperator: '<S1610>/Relational Operator1'
     */
    ME11_ARID_DEF.Merge_c = (SOMCtl_eMotorHeatBat2Flg == 15);
  } else {
    ME11_ARID_DEF.Enter_AC_MODE = false;
  }

  /* End of RelationalOperator: '<S1608>/Compare' */
  /* End of Outputs for SubSystem: '<S1326>/Enter_AC' */

  /* Switch: '<S1326>/Switch1' incorporates:
   *  Constant: '<S1609>/Constant'
   *  Logic: '<S1326>/OR1'
   *  RelationalOperator: '<S1609>/Compare'
   */
  SOMCtl_bMotorHeatBatOnFlg = ((ME11_ARID_DEF.DataTypeConversion1 == 2) &&
    (ME11_ARID_DEF.DataTypeConversion1 == 3) &&
    (ME11_ARID_DEF.DataTypeConversion1 == 5) && ME11_ARID_DEF.Merge_c);

  /* Chart: '<S1612>/Chart1' incorporates:
   *  Constant: '<S1612>/Constant2'
   *  RelationalOperator: '<S1612>/Relational Operator2'
   *  Sum: '<S1612>/Add3'
   */
  ME11_Delay_m(BMS_HVBatCellTempMin + cal_tMotHeatExitMinCellToMotTempDiff >
               ACSen_sMotTempFilter, &ME11_ARID_DEF.B_k,
               &ME11_ARID_DEF.ARID_DEF_Chart1);

  /* RelationalOperator: '<S1627>/Compare' incorporates:
   *  Constant: '<S1627>/Constant'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   */
  rtb_AND_b3z = ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
                 ->VIPM_INV2IgbtMaxTemp_C >= cal_MBIGBTHighExitTempG);

  /* Chart: '<S1612>/Chart2' */
  ME11_Delay_m(rtb_AND_b3z, &ME11_ARID_DEF.B_c, &ME11_ARID_DEF.ARID_DEF_Chart2);

  /* Chart: '<S1612>/Chart3' incorporates:
   *  Constant: '<S1628>/Constant'
   *  RelationalOperator: '<S1628>/Compare'
   */
  ME11_Delay_m(ACSen_sMotTempFilter >= cal_MBMotorInletHighExitTempH,
               &ME11_ARID_DEF.B_o, &ME11_ARID_DEF.ARID_DEF_Chart3);

  /* RelationalOperator: '<S1631>/Compare' incorporates:
   *  Constant: '<S1631>/Constant'
   *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
   */
  rtb_AND_b3z =
    ((Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT())
     ->VIPM_IPUDeviceIntTemp_C >= cal_MBIPUDevHighExitTempI);

  /* Chart: '<S1612>/Chart4' */
  ME11_Delay_m(rtb_AND_b3z, &ME11_ARID_DEF.B_f, &ME11_ARID_DEF.ARID_DEF_Chart4);

  /* Sum: '<S1612>/Add1' incorporates:
   *  Constant: '<S1612>/Constant'
   *  Constant: '<S1612>/Constant1'
   *  Sum: '<S1576>/Add1'
   */
  rtb_Delay1_ie = cal_BatBalCellTemp1 + cal_tMotHeatExitMinCellToBal1Diff;

  /* Sum: '<S1612>/Add' incorporates:
   *  Constant: '<S1626>/Constant'
   *  Constant: '<S1629>/Constant'
   *  Constant: '<S1630>/Constant'
   *  Gain: '<S1612>/Gain1'
   *  Gain: '<S1612>/Gain2'
   *  Gain: '<S1612>/Gain3'
   *  Gain: '<S1612>/Gain4'
   *  Gain: '<S1612>/Gain5'
   *  Gain: '<S1612>/Gain6'
   *  Gain: '<S1612>/Gain7'
   *  Gain: '<S1612>/Gain8'
   *  Gain: '<S1632>/Gain6'
   *  Logic: '<S1632>/AND3'
   *  RelationalOperator: '<S1612>/Relational Operator1'
   *  RelationalOperator: '<S1626>/Compare'
   *  RelationalOperator: '<S1629>/Compare'
   *  RelationalOperator: '<S1630>/Compare'
   *  Sum: '<S1612>/Add1'
   */
  SOMCtl_eMotorHeatBatOffFlg = (uint16)(((((((((uint32)((BMS_HVBatCellTempMin >
    rtb_Delay1_ie) << 1) + (uint32)(ME11_ARID_DEF.DataTypeConversion1 == 4)) +
    (uint32)((BMS_HVBatCellTempMax >= cal_tMotStorExitMaxCellTemp) << 2)) +
    (uint32)(ME11_ARID_DEF.B_k << 3)) + (uint32)((rtb_Delay >=
    cal_tBatHeatExitMaxToMinCellDiff) << 4)) + (uint32)(rtb_AND2_of << 5)) +
    (uint32)(ME11_ARID_DEF.B_c << 6)) + (uint32)(ME11_ARID_DEF.B_o << 7)) +
    (uint32)(ME11_ARID_DEF.B_f << 8));

  /* RelationalOperator: '<S1612>/Relational Operator' incorporates:
   *  Constant: '<S1612>/Constant3'
   */
  SOMCtl_bMotorHeatBatOffFlg = (SOMCtl_eMotorHeatBatOffFlg > 0);

  /* Chart: '<S1326>/Chart' */
  ME11_Chart_n(SOMCtl_bMotorHeatBatOnFlg, SOMCtl_bMotorHeatBatOffFlg,
               &rtb_SOMCtl_bBatHeatB3tB1Flg, &ME11_ARID_DEF.ARID_DEF_Chart_k);

  /* Switch: '<S1326>/Switch' incorporates:
   *  Constant: '<S1613>/Constant'
   *  Delay: '<S1326>/Delay'
   *  Logic: '<S1326>/AND4'
   *  Logic: '<S1326>/AND7'
   *  RelationalOperator: '<S1613>/Compare'
   */
  SOMCtl_bMotHeatBatFlg = ((((ME11_ARID_DEF.DataTypeConversion1 != 3) &&
    (ME11_ARID_DEF.DataTypeConversion1 != 4)) || (!ME11_ARID_DEF.Delay_DSTATE_ma))
    && rtb_SOMCtl_bBatHeatB3tB1Flg);

  /* Chart: '<S1311>/OTS_BatModeJudge' */
  if (ME11_ARID_DEF.is_active_c133_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c133_ME11 = 1U;

    /* /_
       0x0:OFF
       0x1:Cool
       0x2:thermal storage
       0x3:motor heat battary
       0x4:Balancec
       0x5:LTR
       0x6:Heat
       _/ */
    ME11_ARID_DEF.is_BatMode = ME11_IN_Off_nh;
    rtb_IFreezFlag_k = 0U;
  } else {
    switch (ME11_ARID_DEF.is_BatMode) {
     case ME11_IN_Balance:
      rtb_IFreezFlag_k = 4U;
      if (!SOMCtl_bMotorLTRAndBatBalFlg) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_Off_nh;
        rtb_IFreezFlag_k = 0U;
      }
      break;

     case ME11_IN_Cool_o:
      rtb_IFreezFlag_k = 1U;
      if (!SOMCtl_bBatCoolFlg) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_Off_nh;
        rtb_IFreezFlag_k = 0U;
      }
      break;

     case ME11_IN_HStr:
      rtb_IFreezFlag_k = 2U;
      if (rtb_SOMCtl_bBatTSFlg == 0) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_Off_nh;
        rtb_IFreezFlag_k = 0U;
      }
      break;

     case ME11_IN_Heat:
      rtb_IFreezFlag_k = 6U;
      if (!SOMCtl_bBatHeatFlg) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_Off_nh;
        rtb_IFreezFlag_k = 0U;
      }
      break;

     case ME11_IN_LTR:
      rtb_IFreezFlag_k = 5U;
      if (!SOMCtl_bMotAndBatLTRFlg) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_Off_nh;
        rtb_IFreezFlag_k = 0U;
      }
      break;

     case ME11_IN_MotorHeatBat:
      rtb_IFreezFlag_k = 3U;
      if (!SOMCtl_bMotHeatBatFlg) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_Off_nh;
        rtb_IFreezFlag_k = 0U;
      }
      break;

     default:
      /* case IN_Off: */
      rtb_IFreezFlag_k = 0U;
      if (SOMCtl_bBatCoolFlg) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_Cool_o;
        rtb_IFreezFlag_k = 1U;
      } else if (rtb_SOMCtl_bBatTSFlg == 1) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_HStr;
        rtb_IFreezFlag_k = 2U;
      } else if (SOMCtl_bMotHeatBatFlg) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_MotorHeatBat;
        rtb_IFreezFlag_k = 3U;
      } else if (SOMCtl_bMotorLTRAndBatBalFlg) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_Balance;
        rtb_IFreezFlag_k = 4U;
      } else if (SOMCtl_bMotAndBatLTRFlg) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_LTR;
        rtb_IFreezFlag_k = 5U;
      } else if (SOMCtl_bBatHeatFlg) {
        ME11_ARID_DEF.is_BatMode = ME11_IN_Heat;
        rtb_IFreezFlag_k = 6U;
      }
      break;
    }
  }

  /* End of Chart: '<S1311>/OTS_BatModeJudge' */

  /* Sum: '<S1437>/Add' incorporates:
   *  Constant: '<S1449>/Constant'
   *  Constant: '<S1453>/Constant'
   *  Constant: '<S1455>/Constant'
   *  Constant: '<S1456>/Constant'
   *  Constant: '<S1459>/Constant'
   *  Constant: '<S1460>/Constant'
   *  Gain: '<S1437>/Gain1'
   *  Gain: '<S1437>/Gain2'
   *  Gain: '<S1437>/Gain3'
   *  Gain: '<S1437>/Gain4'
   *  Gain: '<S1437>/Gain5'
   *  Gain: '<S1636>/Gain3'
   *  Logic: '<S1443>/AND'
   *  RelationalOperator: '<S1449>/Compare'
   *  RelationalOperator: '<S1453>/Compare'
   *  RelationalOperator: '<S1455>/Compare'
   *  RelationalOperator: '<S1456>/Compare'
   *  RelationalOperator: '<S1459>/Compare'
   *  RelationalOperator: '<S1460>/Compare'
   */
  SOMCtl_eNmlBatLTROnFlg = (uint8)((((((uint32)(((BMS_HVBatCellTempMax >=
    cal_BatBalCellTemp2) && (BMS_HVBatCellTempMax < cal_tLTROnDCChrgMaxCellTemp))
    << 1) + (uint32)(ME11_ARID_DEF.DataTypeConversion1 == 5)) + (uint32)
    ((rtb_Merge1 >= cal_tLTROnMaxCellToMotDiff) << 2)) + (uint32)((rtb_Delay <
    cal_tBatHeatExitMaxToMinCellDiff) << 3)) + (uint32)(rtb_Compare_mgx << 4)) +
    (uint32)((BMS_BatSOCAct_pct >= cal_VehHeatSOCOn) << 5));

  /* RelationalOperator: '<S1437>/Relational Operator' */
  SOMCtl_bNmlBatLTROnFlg = (SOMCtl_eNmlBatLTROnFlg == 63);

  /* Logic: '<S1437>/AND3' incorporates:
   *  Constant: '<S1450>/Constant'
   *  Constant: '<S1451>/Constant'
   *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
   *  RelationalOperator: '<S1450>/Compare'
   *  RelationalOperator: '<S1451>/Compare'
   */
  rtb_AND_b3z =
    ((Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT())
     ->VIPM_IPUDeviceIntTemp_C >= cal_tLTROnIPUTemp);
  rtb_AND_b3z = (rtb_AND_b3z && (ME11_ARID_DEF.DataTypeConversion1 >= 2));

  /* Logic: '<S1437>/AND1' incorporates:
   *  Constant: '<S1454>/Constant'
   *  Constant: '<S1457>/Constant'
   *  Constant: '<S1458>/Constant'
   *  Logic: '<S1444>/AND5'
   *  RelationalOperator: '<S1454>/Compare'
   *  RelationalOperator: '<S1457>/Compare'
   *  RelationalOperator: '<S1458>/Compare'
   */
  SOMCtl_bDCBatLTROnFlg = ((ME11_ARID_DEF.DataTypeConversion1 == 4) &&
    ((BMS_HVBatCellTempMax <= cal_tLTROnDCChrgMaxCellTemp) &&
     (BMS_HVBatCellTempMin >= cal_tLTROnDCChrgMinCellTemp)) && rtb_Compare_mgx);

  /* Delay: '<S1438>/Delay' */
  SOMCtrl_bBatLTRDelayFlg = ME11_ARID_DEF.Delay_DSTATE_ha;

  /* DataTypeConversion: '<S8>/Data Type Conversion16' incorporates:
   *  Constant: '<S1463>/Constant'
   *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
   *  RelationalOperator: '<S1463>/Compare'
   */
  rtb_FixPtRelationalOperator_a0 =
    ((Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT())
     ->VIPM_IPUDeviceIntTemp_C <= cal_tLTROffIPUTemp);

  /* Logic: '<S1438>/AND2' */
  FixPtRelationalOperator = (SOMCtrl_bBatLTRDelayFlg &&
    rtb_FixPtRelationalOperator_a0);

  /* Logic: '<S1438>/AND7' incorporates:
   *  Constant: '<S1466>/Constant'
   *  Constant: '<S1467>/Constant'
   *  Constant: '<S1468>/Constant'
   *  Constant: '<S1469>/Constant'
   *  Constant: '<S1470>/Constant'
   *  Logic: '<S1438>/AND1'
   *  Logic: '<S1438>/AND6'
   *  RelationalOperator: '<S1466>/Compare'
   *  RelationalOperator: '<S1467>/Compare'
   *  RelationalOperator: '<S1468>/Compare'
   *  RelationalOperator: '<S1469>/Compare'
   *  RelationalOperator: '<S1470>/Compare'
   */
  SOMCtl_bBatLTROffFlg = ((rtb_Add_ok >= cal_tLTROffBatBal2ToMaxCellDiff) ||
    ((BMS_HVBatCellTempMax >= cal_LTRExitBatMaxCellTemp) ||
     FixPtRelationalOperator || (rtb_Delay >= cal_tBatHeatExitMaxToMinCellDiff) ||
     rtb_AND2_of || ((BMS_BatSOCAct_pct <= cal_VehHeatSOCOff) &&
                     (ME11_ARID_DEF.DataTypeConversion1 == 5))));

  /* Chart: '<S1320>/Chart' incorporates:
   *  Logic: '<S1437>/AND2'
   */
  ME11_Chart_i(SOMCtl_bNmlBatLTROnFlg || rtb_AND_b3z || SOMCtl_bDCBatLTROnFlg,
               SOMCtl_bBatLTROffFlg, &rtb_SOMCtl_bBatLTRFlg_b,
               &ME11_ARID_DEF.ARID_DEF_Chart_g);

  /* Switch: '<S1320>/Switch' incorporates:
   *  Constant: '<S1440>/Constant'
   *  Delay: '<S1320>/Delay'
   *  Logic: '<S1320>/AND1'
   *  Logic: '<S1320>/AND4'
   *  Logic: '<S1320>/AND7'
   *  RelationalOperator: '<S1440>/Compare'
   */
  SOMCtl_bBatLTRFlg = (rtb_FixPtRelationalOperator_fk &&
                       (((ME11_ARID_DEF.DataTypeConversion1 != 3) &&
    (ME11_ARID_DEF.DataTypeConversion1 != 4)) || (!ME11_ARID_DEF.Delay_DSTATE_c0))
                       && rtb_SOMCtl_bBatLTRFlg_b);

  /* Chart: '<S1333>/Delay' incorporates:
   *  Constant: '<S1351>/Constant'
   *  RelationalOperator: '<S1351>/Compare'
   *  Sum: '<S1333>/Add2'
   */
  ME11_Delay_m(BMS_HVBatCellTempMax - BMS_HVBatCellTempMin <=
               cal_tBatBalExitMaxToMinCellDiff, &ME11_ARID_DEF.B_kg,
               &ME11_ARID_DEF.ARID_DEF_Delay);

  /* Logic: '<S1333>/AND1' incorporates:
   *  Constant: '<S1333>/Constant1'
   *  Constant: '<S1333>/Constant2'
   *  Constant: '<S1343>/Constant'
   *  Constant: '<S1344>/Constant'
   *  Constant: '<S1345>/Constant'
   *  Constant: '<S1346>/Constant'
   *  Constant: '<S1347>/Constant'
   *  Constant: '<S1348>/Constant'
   *  Constant: '<S1349>/Constant'
   *  Constant: '<S1350>/Constant'
   *  Constant: '<S1352>/Constant'
   *  Constant: '<S1353>/Constant'
   *  Logic: '<S1333>/AND3'
   *  Logic: '<S1333>/AND4'
   *  Logic: '<S1333>/AND5'
   *  Logic: '<S1333>/AND6'
   *  RelationalOperator: '<S1343>/Compare'
   *  RelationalOperator: '<S1344>/Compare'
   *  RelationalOperator: '<S1345>/Compare'
   *  RelationalOperator: '<S1346>/Compare'
   *  RelationalOperator: '<S1347>/Compare'
   *  RelationalOperator: '<S1348>/Compare'
   *  RelationalOperator: '<S1349>/Compare'
   *  RelationalOperator: '<S1350>/Compare'
   *  RelationalOperator: '<S1352>/Compare'
   *  RelationalOperator: '<S1353>/Compare'
   *  Sum: '<S1333>/Add1'
   *  Sum: '<S1333>/Add3'
   */
  rtb_FixPtRelationalOperator_a0 = (((ME11_ARID_DEF.DataTypeConversion1 == 5) &&
    (cal_BatBalCellTemp1 - BMS_HVBatCellTempMin >= cal_tBatBalExitBal1ToBatDiff))
    || ((ME11_ARID_DEF.DataTypeConversion1 == 5) && (BMS_HVBatCellTempMax -
    cal_BatBalCellTemp2 >= cal_tBatBalExitBatToBal2Diff)) ||
    ((ME11_ARID_DEF.DataTypeConversion1 == 4) && (BMS_HVBatCellTempMin <=
    cal_tBatBalExitDCChrgMinCellTemp)) || ((ME11_ARID_DEF.DataTypeConversion1 ==
    3) && (BMS_HVBatCellTempMin <= cal_tBatBalExitACChrgMinCellTemp)) ||
    (rtb_Delay >= cal_tBatHeatExitMaxToMinCellDiff) || rtb_AND2_of ||
    (BMS_BatSOCAct_pct <= cal_VehHeatSOCOff) || ME11_ARID_DEF.B_kg);

  /* Chart: '<S1318>/Judge' incorporates:
   *  Constant: '<S1336>/Constant'
   *  Constant: '<S1336>/Constant1'
   *  Constant: '<S1336>/Constant2'
   *  Constant: '<S1339>/Constant'
   *  Constant: '<S1340>/Constant'
   *  Constant: '<S1341>/Constant'
   *  Constant: '<S1342>/Constant'
   *  Constant: '<S1355>/Constant'
   *  Constant: '<S1356>/Constant'
   *  Constant: '<S1357>/Constant'
   *  Logic: '<S1332>/AND'
   *  Logic: '<S1332>/AND2'
   *  Logic: '<S1336>/AND1'
   *  Logic: '<S1336>/AND3'
   *  RelationalOperator: '<S1336>/Relational Operator'
   *  RelationalOperator: '<S1336>/Relational Operator1'
   *  RelationalOperator: '<S1336>/Relational Operator2'
   *  RelationalOperator: '<S1339>/Compare'
   *  RelationalOperator: '<S1340>/Compare'
   *  RelationalOperator: '<S1341>/Compare'
   *  RelationalOperator: '<S1342>/Compare'
   *  RelationalOperator: '<S1355>/Compare'
   *  RelationalOperator: '<S1356>/Compare'
   *  RelationalOperator: '<S1357>/Compare'
   *  Sum: '<S1332>/Add1'
   */
  if (ME11_ARID_DEF.is_active_c69_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c69_ME11 = 1U;
    ME11_ARID_DEF.is_c69_ME11 = ME11_IN_Off_a;
    SOMCtl_bBatBalFlg = false;
  } else if (ME11_ARID_DEF.is_c69_ME11 == ME11_IN_Off_a) {
    SOMCtl_bBatBalFlg = false;
    if ((((rtb_Delay >= cal_MotHeatBatMinTempDiff) && (rtb_Delay <
           cal_tBatHeatExitMaxToMinCellDiff) && rtb_Compare_mgx &&
          (BMS_BatSOCAct_pct >= cal_VehHeatSOCOn) &&
          (ME11_ARID_DEF.DataTypeConversion1 == 5) && ((cal_BatBalCellTemp1 <=
            BMS_HVBatCellTempMin) && (BMS_HVBatCellTempMax <=
            cal_BatBalCellTemp2))) || ((ME11_ARID_DEF.DataTypeConversion1 == 3) &&
          (BMS_HVBatCellTempMin > cal_tBatBalONACChrgMinCellTemp) &&
          (BMS_HVBatCellTempMax < cal_BatBalCellTemp2) && (BMS_HVBatCellTempMin
           - BMS_HVBatCellTempMax < cal_tBatHeatExitMaxToMinCellDiff) &&
          rtb_Compare_mgx)) && (!rtb_FixPtRelationalOperator_a0)) {
      ME11_ARID_DEF.is_c69_ME11 = ME11_IN_On_li;
      SOMCtl_bBatBalFlg = true;
    }
  } else {
    /* case IN_On: */
    SOMCtl_bBatBalFlg = true;
    if (rtb_FixPtRelationalOperator_a0) {
      ME11_ARID_DEF.is_c69_ME11 = ME11_IN_Off_a;
      SOMCtl_bBatBalFlg = false;
    }
  }

  /* End of Chart: '<S1318>/Judge' */

  /* RelationalOperator: '<S1573>/Relational Operator2' incorporates:
   *  Constant: '<S1573>/Constant3'
   *  Sum: '<S1573>/Add4'
   */
  rtb_FixPtRelationalOperator_a0 = (ACSen_sMotTempFilter > BMS_HVBatCellTempMin
    + cal_tMotStorExitMotToMinCellDiff);

  /* Chart: '<S1573>/Chart1' */
  if (ME11_ARID_DEF.temporalCounter_i1_b < 511U) {
    ME11_ARID_DEF.temporalCounter_i1_b++;
  }

  if (ME11_ARID_DEF.is_active_c80_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c80_ME11 = 1U;
    ME11_ARID_DEF.is_c80_ME11 = ME11_IN_Off_a;
    ME11_ARID_DEF.B = 0.0;
  } else {
    switch (ME11_ARID_DEF.is_c80_ME11) {
     case ME11_IN_Off_a:
      ME11_ARID_DEF.B = 0.0;
      if (rtb_FixPtRelationalOperator_a0) {
        ME11_ARID_DEF.is_c80_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_b = 0U;
      }
      break;

     case ME11_IN_On_li:
      ME11_ARID_DEF.B = 1.0;
      if (!rtb_FixPtRelationalOperator_a0) {
        ME11_ARID_DEF.is_c80_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.B = 0.0;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_b >= 300U) {
        ME11_ARID_DEF.is_c80_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.B = 1.0;
      } else if (!rtb_FixPtRelationalOperator_a0) {
        ME11_ARID_DEF.is_c80_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.B = 0.0;
      }
      break;
    }
  }

  /* End of Chart: '<S1573>/Chart1' */

  /* Chart: '<S1573>/Chart' incorporates:
   *  Constant: '<S1573>/Constant'
   *  Constant: '<S1573>/Constant1'
   *  Constant: '<S1573>/Constant2'
   *  Constant: '<S1583>/Constant'
   *  Constant: '<S1584>/Constant'
   *  Constant: '<S1585>/Constant'
   *  Constant: '<S1586>/Constant'
   *  Constant: '<S1587>/Constant'
   *  Constant: '<S1588>/Constant'
   *  Constant: '<S1589>/Constant'
   *  Constant: '<S1590>/Constant'
   *  Constant: '<S1591>/Constant'
   *  Constant: '<S1592>/Constant'
   *  Logic: '<S1573>/AND1'
   *  Logic: '<S1573>/AND3'
   *  Logic: '<S1573>/AND4'
   *  Logic: '<S1573>/NOT'
   *  RelationalOperator: '<S1573>/Relational Operator'
   *  RelationalOperator: '<S1573>/Relational Operator1'
   *  RelationalOperator: '<S1583>/Compare'
   *  RelationalOperator: '<S1584>/Compare'
   *  RelationalOperator: '<S1585>/Compare'
   *  RelationalOperator: '<S1586>/Compare'
   *  RelationalOperator: '<S1587>/Compare'
   *  RelationalOperator: '<S1588>/Compare'
   *  RelationalOperator: '<S1589>/Compare'
   *  RelationalOperator: '<S1590>/Compare'
   *  RelationalOperator: '<S1591>/Compare'
   *  RelationalOperator: '<S1592>/Compare'
   *  Sum: '<S1573>/Add1'
   *  Sum: '<S1573>/Add3'
   */
  if (ME11_ARID_DEF.is_active_c79_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c79_ME11 = 1U;
    ME11_ARID_DEF.is_c79_ME11 = ME11_IN_Off_a;
    SOMCtl_bBatHStrFlg = false;
  } else if (ME11_ARID_DEF.is_c79_ME11 == ME11_IN_Off_a) {
    SOMCtl_bBatHStrFlg = false;
    if ((rtb_Delay < cal_tBatHeatExitMaxToMinCellDiff) && ((BMS_HVBatCellTempMin
          <= cal_BatBalCellTemp1) && (BMS_HVBatCellTempMin >
          cal_tMotStorMinCellTempLow)) && (BMS_HVBatCellTempMin +
         cal_tMotStorOnMotToMinCellDiff > ACSen_sMotTempFilter) &&
        (ME11_ARID_DEF.DataTypeConversion1 == 5) && (!rtb_AND2_of) &&
        (BMS_BatSOCAct_pct >= cal_VehHeatSOCOn)) {
      ME11_ARID_DEF.is_c79_ME11 = ME11_IN_On_li;
      SOMCtl_bBatHStrFlg = true;
    }
  } else {
    /* case IN_On: */
    SOMCtl_bBatHStrFlg = true;
    if ((ME11_ARID_DEF.DataTypeConversion1 == 3) ||
        (ME11_ARID_DEF.DataTypeConversion1 == 4) || (BMS_HVBatCellTempMin >
         cal_BatBalCellTemp1 + 2.0F) || (BMS_HVBatCellTempMax >=
         cal_tMotStorExitMaxCellTemp) || (ME11_ARID_DEF.B != 0.0) || (rtb_Merge >=
         cal_tBatHeatExitMaxToMinCellDiff) || (BMS_BatSOCAct_pct <=
         cal_VehHeatSOCOff) || rtb_AND2_of) {
      ME11_ARID_DEF.is_c79_ME11 = ME11_IN_Off_a;
      SOMCtl_bBatHStrFlg = false;
    }
  }

  /* End of Chart: '<S1573>/Chart' */

  /* Outputs for Enabled SubSystem: '<S1325>/B1_B31_PT' incorporates:
   *  EnablePort: '<S1575>/Enable'
   */
  /* RelationalOperator: '<S1325>/Relational Operator' incorporates:
   *  Constant: '<S1325>/Constant'
   */
  if (ME11_ARID_DEF.DataTypeConversion1 == 5) {
    ME11_ARID_DEF.B1_B31_PT_MODE = true;

    /* Chart: '<S1575>/Chart' incorporates:
     *  Constant: '<S1575>/Constant1'
     *  RelationalOperator: '<S1575>/Relational Operator'
     *  Sum: '<S1575>/Add1'
     */
    ME11_Chart_l(BMS_HVBatCellTempMin + cal_tMotHeatOnMotToMinCellDiff <=
                 ACSen_sMotTempFilter, &ME11_ARID_DEF.B_h,
                 &ME11_ARID_DEF.ARID_DEF_Chart_p);

    /* Merge: '<S1325>/Merge' incorporates:
     *  Constant: '<S1598>/Constant'
     *  Constant: '<S1599>/Constant'
     *  Constant: '<S1600>/Constant'
     *  Constant: '<S1601>/Constant'
     *  Logic: '<S1575>/AND1'
     *  Logic: '<S1575>/AND3'
     *  RelationalOperator: '<S1598>/Compare'
     *  RelationalOperator: '<S1599>/Compare'
     *  RelationalOperator: '<S1600>/Compare'
     *  RelationalOperator: '<S1601>/Compare'
     */
    ME11_ARID_DEF.Merge_k = ((rtb_Delay < cal_tBatHeatExitMaxToMinCellDiff) &&
      ((BMS_HVBatCellTempMin <= cal_BatBalCellTemp1) && (BMS_HVBatCellTempMin >
      cal_tMotHeatBatMinCellTempLow)) && ME11_ARID_DEF.B_h && rtb_Compare_mgx &&
      (BMS_BatSOCAct_pct >= cal_VehHeatSOCOn));
  } else {
    ME11_ARID_DEF.B1_B31_PT_MODE = false;
  }

  /* End of RelationalOperator: '<S1325>/Relational Operator' */
  /* End of Outputs for SubSystem: '<S1325>/B1_B31_PT' */

  /* Outputs for Enabled SubSystem: '<S1325>/B1_B31_AC' incorporates:
   *  EnablePort: '<S1574>/Enable'
   */
  /* RelationalOperator: '<S1578>/Compare' incorporates:
   *  Constant: '<S1578>/Constant'
   */
  if (ME11_ARID_DEF.DataTypeConversion1 == 3) {
    ME11_ARID_DEF.B1_B31_AC_MODE = true;

    /* Chart: '<S1574>/Chart' incorporates:
     *  Constant: '<S1574>/Constant1'
     *  RelationalOperator: '<S1574>/Relational Operator'
     *  Sum: '<S1574>/Add1'
     */
    ME11_Chart_l(BMS_HVBatCellTempMin + cal_tMotHeatOnMotToMinCellDiff <=
                 ACSen_sMotTempFilter, &ME11_ARID_DEF.B_m,
                 &ME11_ARID_DEF.ARID_DEF_Chart_cv);

    /* Merge: '<S1325>/Merge' incorporates:
     *  Constant: '<S1594>/Constant'
     *  Constant: '<S1595>/Constant'
     *  Constant: '<S1596>/Constant'
     *  Logic: '<S1574>/AND1'
     *  Logic: '<S1574>/AND3'
     *  RelationalOperator: '<S1594>/Compare'
     *  RelationalOperator: '<S1595>/Compare'
     *  RelationalOperator: '<S1596>/Compare'
     */
    ME11_ARID_DEF.Merge_k = ((rtb_Delay < cal_tBatHeatExitMaxToMinCellDiff) &&
      ((BMS_HVBatCellTempMin <= cal_BatBalCellTemp1) && (BMS_HVBatCellTempMin >
      cal_tMotHeatBatACChrgMinCellTempLow)) && ME11_ARID_DEF.B_m &&
      rtb_Compare_mgx);
  } else {
    ME11_ARID_DEF.B1_B31_AC_MODE = false;
  }

  /* End of RelationalOperator: '<S1578>/Compare' */
  /* End of Outputs for SubSystem: '<S1325>/B1_B31_AC' */

  /* Switch: '<S1325>/Switch1' incorporates:
   *  Constant: '<S1579>/Constant'
   *  Logic: '<S1325>/OR1'
   *  RelationalOperator: '<S1579>/Compare'
   */
  SOMCtl_bB1toB31 = ((ME11_ARID_DEF.DataTypeConversion1 == 3) &&
                     (ME11_ARID_DEF.DataTypeConversion1 == 5) &&
                     ME11_ARID_DEF.Merge_k);

  /* Chart: '<S1576>/Chart1' incorporates:
   *  Constant: '<S1576>/Constant2'
   *  RelationalOperator: '<S1576>/Relational Operator2'
   *  Sum: '<S1576>/Add3'
   */
  ME11_Delay_m(BMS_HVBatCellTempMin + cal_tMotHeatExitMinCellToMotTempDiff >
               ACSen_sMotTempFilter, &ME11_ARID_DEF.B_n,
               &ME11_ARID_DEF.ARID_DEF_Chart1_b);

  /* Logic: '<S1576>/AND3' incorporates:
   *  Constant: '<S1603>/Constant'
   *  Constant: '<S1604>/Constant'
   *  Constant: '<S1605>/Constant'
   *  Constant: '<S1606>/Constant'
   *  RelationalOperator: '<S1576>/Relational Operator1'
   *  RelationalOperator: '<S1603>/Compare'
   *  RelationalOperator: '<S1604>/Compare'
   *  RelationalOperator: '<S1605>/Compare'
   *  RelationalOperator: '<S1606>/Compare'
   */
  SOMCtl_bBatHeatB31tB1Flg = ((ME11_ARID_DEF.DataTypeConversion1 == 4) ||
    (BMS_HVBatCellTempMin > rtb_Delay1_ie) || (BMS_HVBatCellTempMax >=
    cal_tMotStorExitMaxCellTemp) || ME11_ARID_DEF.B_n || (rtb_Delay >=
    cal_tBatHeatExitMaxToMinCellDiff) || rtb_AND2_of || (BMS_BatSOCAct_pct <=
    cal_VehHeatSOCOff));

  /* Chart: '<S1325>/Chart' */
  ME11_Chart_n(SOMCtl_bB1toB31, SOMCtl_bBatHeatB31tB1Flg,
               &rtb_SOMCtl_bBatHeatB3tB1Flg_e, &ME11_ARID_DEF.ARID_DEF_Chart_cx);

  /* Switch: '<S1325>/Switch' incorporates:
   *  Constant: '<S1580>/Constant'
   *  Delay: '<S1325>/Delay'
   *  Logic: '<S1325>/AND4'
   *  Logic: '<S1325>/AND7'
   *  RelationalOperator: '<S1580>/Compare'
   */
  SOMCtl_bBatHeatB3tB1Flg = ((((ME11_ARID_DEF.DataTypeConversion1 != 3) &&
    (ME11_ARID_DEF.DataTypeConversion1 != 4)) || (!ME11_ARID_DEF.Delay_DSTATE_ef))
    && rtb_SOMCtl_bBatHeatB3tB1Flg_e);

  /* Chart: '<S1311>/Modejudge' */
  if (ME11_ARID_DEF.is_active_c76_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c76_ME11 = 1U;

    /* /_
       0x0:OFF
       0x1:Cool
       0x2:thermal storage
       0x3:motor heat battary
       0x4:Balancec
       0x5:LTR
       0x6:Heat
       _/ */
    ME11_ARID_DEF.is_BatMode_p = ME11_IN_Off_nh;
    rtb_SOMCtl_eBatModeSts_l = 0U;
  } else {
    switch (ME11_ARID_DEF.is_BatMode_p) {
     case ME11_IN_Balance:
      rtb_SOMCtl_eBatModeSts_l = 4U;
      if (!SOMCtl_bBatBalFlg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_Off_nh;
        rtb_SOMCtl_eBatModeSts_l = 0U;
      }
      break;

     case ME11_IN_Cool_o:
      rtb_SOMCtl_eBatModeSts_l = 1U;
      if (!SOMCtl_bBatCoolFlg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_Off_nh;
        rtb_SOMCtl_eBatModeSts_l = 0U;
      }
      break;

     case ME11_IN_HStr:
      rtb_SOMCtl_eBatModeSts_l = 2U;
      if (!SOMCtl_bBatHStrFlg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_Off_nh;
        rtb_SOMCtl_eBatModeSts_l = 0U;
      }
      break;

     case ME11_IN_Heat:
      rtb_SOMCtl_eBatModeSts_l = 6U;
      if (!SOMCtl_bBatHeatFlg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_Off_nh;
        rtb_SOMCtl_eBatModeSts_l = 0U;
      }
      break;

     case ME11_IN_LTR:
      rtb_SOMCtl_eBatModeSts_l = 5U;
      if (!SOMCtl_bBatLTRFlg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_Off_nh;
        rtb_SOMCtl_eBatModeSts_l = 0U;
      }
      break;

     case ME11_IN_MotorHeatBat:
      rtb_SOMCtl_eBatModeSts_l = 3U;
      if (!SOMCtl_bBatHeatB3tB1Flg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_Off_nh;
        rtb_SOMCtl_eBatModeSts_l = 0U;
      }
      break;

     default:
      /* case IN_Off: */
      rtb_SOMCtl_eBatModeSts_l = 0U;
      if (SOMCtl_bBatCoolFlg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_Cool_o;
        rtb_SOMCtl_eBatModeSts_l = 1U;
      } else if (SOMCtl_bBatHStrFlg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_HStr;
        rtb_SOMCtl_eBatModeSts_l = 2U;
      } else if (SOMCtl_bBatHeatB3tB1Flg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_MotorHeatBat;
        rtb_SOMCtl_eBatModeSts_l = 3U;
      } else if (SOMCtl_bBatBalFlg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_Balance;
        rtb_SOMCtl_eBatModeSts_l = 4U;
      } else if (SOMCtl_bBatLTRFlg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_LTR;
        rtb_SOMCtl_eBatModeSts_l = 5U;
      } else if (SOMCtl_bBatHeatFlg) {
        ME11_ARID_DEF.is_BatMode_p = ME11_IN_Heat;
        rtb_SOMCtl_eBatModeSts_l = 6U;
      }
      break;
    }
  }

  /* End of Chart: '<S1311>/Modejudge' */

  /* Switch: '<S1473>/Switch' incorporates:
   *  Constant: '<S1471>/Constant'
   *  Constant: '<S1473>/Constant1'
   *  Logic: '<S1321>/AND'
   *  RelationalOperator: '<S1471>/Compare'
   *  RelationalOperator: '<S1472>/Compare'
   *  Switch: '<S1321>/Switch'
   */
  if (cal_BatModeEnb) {
    /* Switch: '<S1473>/Switch' incorporates:
     *  Constant: '<S1473>/Constant'
     */
    SOMCtl_eBatMode = cal_BatModeData;
  } else if ((ME11_ARID_DEF.DataTypeConversion1 >= 2) && (!ACCtl_bExhFlg)) {
    /* Switch: '<S1311>/Switch' incorporates:
     *  Constant: '<S1311>/Constant'
     *  Switch: '<S1321>/Switch'
     */
    if (cal_BatModeSwitch) {
      /* Switch: '<S1473>/Switch' */
      SOMCtl_eBatMode = rtb_IFreezFlag_k;
    } else {
      /* Switch: '<S1473>/Switch' */
      SOMCtl_eBatMode = rtb_SOMCtl_eBatModeSts_l;
    }

    /* End of Switch: '<S1311>/Switch' */
  } else {
    /* Switch: '<S1473>/Switch' incorporates:
     *  Constant: '<S1321>/Constant'
     *  Switch: '<S1321>/Switch'
     */
    SOMCtl_eBatMode = 0U;
  }

  /* End of Switch: '<S1473>/Switch' */

  /* DataTypeConversion: '<S1321>/Data Type Conversion1' incorporates:
   *  Switch: '<S1473>/Switch'
   */
  rtb_SOMCtl_eBatModeSts_l = SOMCtl_eBatMode;

  /* Switch: '<S1331>/Switch' incorporates:
   *  Constant: '<S1672>/Constant'
   *  Constant: '<S1673>/Constant'
   *  DataTypeConversion: '<S1321>/Data Type Conversion1'
   *  RelationalOperator: '<S1672>/Compare'
   *  RelationalOperator: '<S1673>/Compare'
   *  Switch: '<S1331>/Switch1'
   *  Switch: '<S1473>/Switch'
   */
  if (SOMCtl_eBatMode == 1) {
    /* Switch: '<S1331>/Switch' incorporates:
     *  Constant: '<S1331>/Constant'
     */
    rtb_IFreezFlag_k = 1U;
  } else if (SOMCtl_eBatMode == 6) {
    /* Switch: '<S1331>/Switch1' incorporates:
     *  Constant: '<S1331>/Constant1'
     *  Switch: '<S1331>/Switch'
     */
    rtb_IFreezFlag_k = 2U;
  } else {
    /* Switch: '<S1331>/Switch' incorporates:
     *  Constant: '<S1331>/Constant2'
     *  Switch: '<S1331>/Switch1'
     */
    rtb_IFreezFlag_k = 0U;
  }

  /* End of Switch: '<S1331>/Switch' */

  /* Logic: '<S133>/Logical Operator' incorporates:
   *  Constant: '<S133>/Constant16'
   *  RelationalOperator: '<S133>/Relational Operator1'
   */
  ACCtl_stRecQkChargeCoolingEna = (rtb_AND1_hh && (rtb_IFreezFlag_k == 1));

  /* Switch: '<S131>/Switch' incorporates:
   *  Constant: '<S131>/Constant6'
   *  RelationalOperator: '<S131>/Relational Operator5'
   *  Switch: '<S131>/Switch13'
   */
  if (ACSen_sMotTempFilter > cal_AirInletRecInPCUTemp) {
    /* Switch: '<S131>/Switch' incorporates:
     *  Constant: '<S131>/Constant'
     */
    ACCtl_stRecPCUTempEna = true;
  } else {
    /* Switch: '<S131>/Switch' incorporates:
     *  Constant: '<S131>/Constant1'
     *  Delay: '<S131>/Delay'
     *  RelationalOperator: '<S131>/Relational Operator1'
     */
    ACCtl_stRecPCUTempEna = ((ACSen_sMotTempFilter >= cal_AirInletRecOutPCUTemp)
      && ACCtl_stRecPCUTempEna);
  }

  /* End of Switch: '<S131>/Switch' */

  /* Switch: '<S46>/Switch1' incorporates:
   *  Constant: '<S46>/Constant2'
   *  Constant: '<S46>/Kp2'
   */
  if (ACCtl_stRecTempLowEna) {
    rtb_IndexVector8_j = cal_ACCtlRecLevelForTempLow;
  } else {
    rtb_IndexVector8_j = 0U;
  }

  /* Switch: '<S46>/Switch2' incorporates:
   *  Constant: '<S46>/Constant3'
   *  Constant: '<S46>/Kp3'
   */
  if (ACCtl_stRecForceChangeEna) {
    rtb_Add7_i = cal_ACCtlRecLevelForForceChange;
  } else {
    rtb_Add7_i = 0U;
  }

  /* Switch: '<S46>/Switch3' incorporates:
   *  Constant: '<S46>/Constant4'
   *  Constant: '<S46>/Kp4'
   */
  if (ACCtl_stRecAQSEna) {
    rtb_Add4_ox = cal_ACCtlRecLevelForAQS;
  } else {
    rtb_Add4_ox = 0U;
  }

  /* Switch: '<S46>/Switch4' incorporates:
   *  Constant: '<S46>/Constant5'
   *  Constant: '<S46>/Kp5'
   */
  if (ACCtl_stRecNormalDefogEna) {
    rtb_Gain_gr = cal_ACCtlRecLevelForNormalDefog;
  } else {
    rtb_Gain_gr = 0U;
  }

  /* Switch: '<S46>/Switch5' incorporates:
   *  Constant: '<S46>/Constant6'
   *  Constant: '<S46>/Kp6'
   */
  if (ACCtl_stRecTargetOutTempEna) {
    u1 = cal_ACCtlRecLevelForTargetOutTemp;
  } else {
    u1 = 0U;
  }

  /* Switch: '<S46>/Switch6' incorporates:
   *  Constant: '<S46>/Constant7'
   *  Constant: '<S46>/Kp7'
   */
  if (ACCtl_stRecVentEna) {
    rtb_Add_b1 = cal_ACCtlRecLevelForVent;
  } else {
    rtb_Add_b1 = 0U;
  }

  /* Switch: '<S46>/Switch7' incorporates:
   *  Constant: '<S46>/Constant8'
   *  Constant: '<S46>/Kp9'
   */
  if (ACCtl_stRecWinterCondEna) {
    rtb_Add2_j5 = cal_ACCtlRecLevelForWinter;
  } else {
    rtb_Add2_j5 = 0U;
  }

  /* Switch: '<S46>/Switch8' incorporates:
   *  Constant: '<S46>/Constant9'
   *  Constant: '<S46>/Kp8'
   */
  if (ACCtl_stRecSummerCondEna) {
    rtb_Add3_do = cal_ACCtlRecLevelForSummer;
  } else {
    rtb_Add3_do = 0U;
  }

  /* Switch: '<S46>/Switch9' incorporates:
   *  Constant: '<S46>/Constant10'
   *  Constant: '<S46>/Kp10'
   */
  if (ACCtl_stRecPTCDvtEna) {
    rtb_Add6_d = cal_ACCtlRecLevelForPTCDvt;
  } else {
    rtb_Add6_d = 0U;
  }

  /* Switch: '<S46>/Switch10' incorporates:
   *  Constant: '<S46>/Constant11'
   *  Constant: '<S46>/Kp11'
   */
  if (ACCtl_stRecACHotStartEna) {
    rtb_Add5_d = cal_ACCtlRecLevelForACHotStart;
  } else {
    rtb_Add5_d = 0U;
  }

  /* Switch: '<S46>/Switch11' incorporates:
   *  Constant: '<S46>/Constant12'
   *  Constant: '<S46>/Kp12'
   */
  if (ACCtl_stRecForceDefogEna) {
    rtb_DataTypeConversion1_j0 = cal_ACCtlRecLevelForForceDefog;
  } else {
    rtb_DataTypeConversion1_j0 = 0U;
  }

  /* Switch: '<S46>/Switch' incorporates:
   *  Constant: '<S46>/Constant1'
   *  Constant: '<S46>/Kp1'
   */
  if (ACCtl_stRecManualEna) {
    rtb_Switch3_l = cal_ACCtlRecLevelForManual;
  } else {
    rtb_Switch3_l = 0U;
  }

  /* Switch: '<S46>/Switch12' incorporates:
   *  Constant: '<S46>/Constant13'
   *  Constant: '<S46>/Kp13'
   */
  if (ACCtl_stRecRemoteACEna) {
    rtb_MultiportSwitch1 = cal_ACCtlRecLevelForRemoteAC;
  } else {
    rtb_MultiportSwitch1 = 0U;
  }

  /* Switch: '<S46>/Switch14' incorporates:
   *  Constant: '<S46>/Constant17'
   *  Constant: '<S46>/Kp14'
   */
  if (ACCtl_stRecQkChargeCoolingEna) {
    rtb_DataTypeConversion_jr = cal_ACCtlRecLevelForQkChargeCooling;
  } else {
    rtb_DataTypeConversion_jr = 0U;
  }

  /* Switch: '<S46>/Switch15' incorporates:
   *  Constant: '<S46>/Constant18'
   *  Constant: '<S46>/Kp15'
   */
  if (ACCtl_stRecPCUTempEna) {
    ACCtl_stRecLevelFinal = cal_ACCtlRecLevelForPCUTemp;
  } else {
    ACCtl_stRecLevelFinal = 0U;
  }

  /* MinMax: '<S38>/Max' incorporates:
   *  Switch: '<S46>/Switch'
   *  Switch: '<S46>/Switch1'
   *  Switch: '<S46>/Switch10'
   *  Switch: '<S46>/Switch11'
   *  Switch: '<S46>/Switch12'
   *  Switch: '<S46>/Switch14'
   *  Switch: '<S46>/Switch15'
   *  Switch: '<S46>/Switch2'
   *  Switch: '<S46>/Switch3'
   *  Switch: '<S46>/Switch4'
   *  Switch: '<S46>/Switch5'
   *  Switch: '<S46>/Switch6'
   *  Switch: '<S46>/Switch7'
   *  Switch: '<S46>/Switch8'
   *  Switch: '<S46>/Switch9'
   */
  if (rtb_IndexVector8_j >= rtb_Add7_i) {
    rtb_Add7_i = rtb_IndexVector8_j;
  }

  if (rtb_Add7_i >= rtb_Add4_ox) {
    rtb_Add4_ox = rtb_Add7_i;
  }

  if (rtb_Add4_ox >= rtb_Gain_gr) {
    rtb_Gain_gr = rtb_Add4_ox;
  }

  if (rtb_Gain_gr >= u1) {
    u1 = rtb_Gain_gr;
  }

  if (u1 >= rtb_Add_b1) {
    rtb_Add_b1 = u1;
  }

  if (rtb_Add_b1 >= rtb_Add2_j5) {
    rtb_Add2_j5 = rtb_Add_b1;
  }

  if (rtb_Add2_j5 >= rtb_Add3_do) {
    rtb_Add3_do = rtb_Add2_j5;
  }

  if (rtb_Add3_do >= rtb_Add6_d) {
    rtb_Add6_d = rtb_Add3_do;
  }

  if (rtb_Add6_d >= rtb_Add5_d) {
    rtb_Add5_d = rtb_Add6_d;
  }

  if (rtb_Add5_d >= rtb_DataTypeConversion1_j0) {
    rtb_DataTypeConversion1_j0 = rtb_Add5_d;
  }

  if (rtb_DataTypeConversion1_j0 >= rtb_Switch3_l) {
    rtb_Switch3_l = rtb_DataTypeConversion1_j0;
  }

  if (rtb_Switch3_l >= rtb_MultiportSwitch1) {
    rtb_MultiportSwitch1 = rtb_Switch3_l;
  }

  if (rtb_MultiportSwitch1 >= rtb_DataTypeConversion_jr) {
    rtb_DataTypeConversion_jr = rtb_MultiportSwitch1;
  }

  if (rtb_DataTypeConversion_jr >= ACCtl_stRecLevelFinal) {
    /* MinMax: '<S38>/Max' */
    ACCtl_stRecLevelFinal = rtb_DataTypeConversion_jr;
  }

  /* End of MinMax: '<S38>/Max' */

  /* Outputs for Atomic SubSystem: '<S46>/ACCtlRecForVent1' */
  /* Switch: '<S123>/Switch1' */
  if (ACCtl_stACPTCHeated) {
    /* Switch: '<S123>/Switch1' incorporates:
     *  Lookup_n-D: '<S123>/cal_ACInletEnvPrtSetHeat_CUR'
     *  Switch: '<S1085>/Switch'
     */
    rtb_Switch1_mn = look1_iflftu8Df_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACInletEnvPrtSetHeat_1X[0], (const uint8 *)
      &cal_ACInletEnvPrtSetHeat_CUR[0], 4U);
  } else {
    /* Switch: '<S123>/Switch1' incorporates:
     *  Lookup_n-D: '<S123>/cal_ACInletEnvPrtSetCool_CUR'
     *  Switch: '<S1085>/Switch'
     */
    rtb_Switch1_mn = look1_iflftu8Df_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACInletEnvPrtSetCool_1X[0], (const uint8 *)
      &cal_ACInletEnvPrtSetCool_CUR[0], 4U);
  }

  /* End of Switch: '<S123>/Switch1' */
  /* End of Outputs for SubSystem: '<S46>/ACCtlRecForVent1' */

  /* Outputs for Atomic SubSystem: '<S46>/ACCtlRecForSummerOrWinterOrNormalDefog1' */
  /* Switch: '<S140>/Switch6' incorporates:
   *  Constant: '<S140>/Constant1'
   */
  if (cal_AutoDefogEnable) {
    /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
     *  Lookup_n-D: '<S140>/cal_ACInletAutoDefogPrtEnvCor_CUR'
     *  Switch: '<S1085>/Switch'
     */
    rtb_DataTypeConversion_jr = look1_iflftu8Df_binlca(ACSen_sEnvTempCor, (const
      float32 *)&cal_ACInletAutoDefogPrtEnvCor_1X[0], (const uint8 *)
      &cal_ACInletAutoDefogPrtEnvCor_CUR[0], 9U);
  } else {
    /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
     *  Lookup_n-D: '<S140>/cal_ACInletDefogPrtEnvCor_CUR'
     *  Switch: '<S1085>/Switch'
     */
    rtb_DataTypeConversion_jr = look1_iflftu8Df_binlca(ACSen_sEnvTempCor, (const
      float32 *)&cal_ACInletDefogPrtEnvCor_1X[0], (const uint8 *)
      &cal_ACInletDefogPrtEnvCor_CUR[0], 9U);
  }

  /* End of Switch: '<S140>/Switch6' */

  /* Lookup_n-D: '<S140>/cal_ACInletDefogRiskCor_CUR' */
  rtb_IndexVector8_j = look1_iu8lu64n56_binlcase(0U, (const uint8 *)
    &cal_ACInletDefogRiskCor_1X[0], (const uint8 *)&cal_ACInletDefogRiskCor_CUR
    [0], 1U);

  /* MinMax: '<S140>/MinMax' */
  if (rtb_IndexVector8_j <= rtb_DataTypeConversion_jr) {
    rtb_DataTypeConversion_jr = rtb_IndexVector8_j;
  }

  /* End of MinMax: '<S140>/MinMax' */

  /* Saturate: '<S140>/Saturation' incorporates:
   *  Constant: '<S140>/Constant'
   *  Sum: '<S140>/Subtract'
   */
  if ((uint8)(100 - rtb_DataTypeConversion_jr) <= 100) {
    /* Switch: '<S46>/Switch18' incorporates:
     *  Saturate: '<S140>/Saturation'
     */
    ACCtl_IntakeRatio = (uint8)(100 - rtb_DataTypeConversion_jr);
  } else {
    /* Switch: '<S46>/Switch18' incorporates:
     *  Saturate: '<S140>/Saturation'
     */
    ACCtl_IntakeRatio = 100U;
  }

  /* End of Saturate: '<S140>/Saturation' */
  /* End of Outputs for SubSystem: '<S46>/ACCtlRecForSummerOrWinterOrNormalDefog1' */

  /* RelationalOperator: '<S156>/FixPt Relational Operator' incorporates:
   *  UnitDelay: '<S156>/Delay Input1'
   *
   * Block description for '<S156>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_AND1_hh = ((sint32)HMICtl_bACDefrost > (sint32)
                 ME11_ARID_DEF.DelayInput1_DSTATE_lk);

  /* Switch: '<S46>/Switch17' */
  if (ACCtl_stRecForceDefogEna) {
    /* Outputs for Atomic SubSystem: '<S46>/ACCtlRecForForceDefog1' */
    /* Switch: '<S121>/Switch2' incorporates:
     *  RelationalOperator: '<S124>/FixPt Relational Operator'
     *  Switch: '<S121>/Switch1'
     *  UnitDelay: '<S124>/Delay Input1'
     *
     * Block description for '<S124>/Delay Input1':
     *
     *  Store in Global RAM
     */
    if ((sint32)HMICtl_bACDefrost > (sint32)ME11_ARID_DEF.DelayInput1_DSTATE_ne)
    {
      /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
       *  Constant: '<S121>/Constant3'
       *  Switch: '<S121>/Switch2'
       */
      rtb_DataTypeConversion_jr = DriveFRESH;
    } else if (HMICtl_eInner != 0) {
      /* Switch: '<S121>/Switch1' incorporates:
       *  Constant: '<S121>/Constant4'
       *  DataTypeConversion: '<S497>/Data Type Conversion'
       *  Switch: '<S121>/Switch2'
       */
      rtb_DataTypeConversion_jr = RECIRC;
    } else {
      /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
       *  Constant: '<S121>/Constant2'
       *  Switch: '<S121>/Switch1'
       *  Switch: '<S121>/Switch2'
       */
      rtb_DataTypeConversion_jr = DriveFRESH;
    }

    /* End of Switch: '<S121>/Switch2' */
    /* End of Outputs for SubSystem: '<S46>/ACCtlRecForForceDefog1' */
  } else {
    /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
     *  Constant: '<S46>/Constant16'
     */
    rtb_DataTypeConversion_jr = 100U;
  }

  /* End of Switch: '<S46>/Switch17' */

  /* Switch: '<S160>/Switch' incorporates:
   *  Constant: '<S160>/Constant'
   *  Constant: '<S160>/Constant3'
   *  Constant: '<S160>/Constant4'
   *  RelationalOperator: '<S160>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForPTCDvt) {
    rtb_Add7_i = 2U;
  } else {
    rtb_Add7_i = 0U;
  }

  /* Switch: '<S164>/Switch' incorporates:
   *  Constant: '<S164>/Constant'
   *  Constant: '<S164>/Constant3'
   *  Constant: '<S164>/Constant4'
   *  RelationalOperator: '<S164>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForACHotStart) {
    rtb_Add4_ox = 3U;
  } else {
    rtb_Add4_ox = 0U;
  }

  /* Switch: '<S165>/Switch' incorporates:
   *  Constant: '<S165>/Constant'
   *  Constant: '<S165>/Constant3'
   *  Constant: '<S165>/Constant4'
   *  RelationalOperator: '<S165>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForTargetOutTemp) {
    rtb_Gain_gr = 4U;
  } else {
    rtb_Gain_gr = 0U;
  }

  /* Switch: '<S166>/Switch' incorporates:
   *  Constant: '<S166>/Constant'
   *  Constant: '<S166>/Constant3'
   *  Constant: '<S166>/Constant4'
   *  RelationalOperator: '<S166>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForVent) {
    u1 = 5U;
  } else {
    u1 = 0U;
  }

  /* Switch: '<S167>/Switch' incorporates:
   *  Constant: '<S167>/Constant'
   *  Constant: '<S167>/Constant3'
   *  Constant: '<S167>/Constant4'
   *  RelationalOperator: '<S167>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForTempLow) {
    rtb_Add_b1 = 6U;
  } else {
    rtb_Add_b1 = 0U;
  }

  /* Switch: '<S168>/Switch' incorporates:
   *  Constant: '<S168>/Constant'
   *  Constant: '<S168>/Constant3'
   *  Constant: '<S168>/Constant4'
   *  RelationalOperator: '<S168>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForAQS) {
    rtb_Add2_j5 = 7U;
  } else {
    rtb_Add2_j5 = 0U;
  }

  /* Switch: '<S169>/Switch' incorporates:
   *  Constant: '<S169>/Constant'
   *  Constant: '<S169>/Constant3'
   *  Constant: '<S169>/Constant4'
   *  RelationalOperator: '<S169>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForPCUTemp) {
    rtb_Add3_do = 8U;
  } else {
    rtb_Add3_do = 0U;
  }

  /* Switch: '<S170>/Switch' incorporates:
   *  Constant: '<S170>/Constant'
   *  Constant: '<S170>/Constant3'
   *  Constant: '<S170>/Constant4'
   *  RelationalOperator: '<S170>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForForceDefog) {
    rtb_Add6_d = 9U;
  } else {
    rtb_Add6_d = 0U;
  }

  /* Switch: '<S171>/Switch' incorporates:
   *  Constant: '<S171>/Constant'
   *  Constant: '<S171>/Constant3'
   *  Constant: '<S171>/Constant4'
   *  RelationalOperator: '<S171>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForManual) {
    rtb_Add5_d = 10U;
  } else {
    rtb_Add5_d = 0U;
  }

  /* Switch: '<S161>/Switch' incorporates:
   *  Constant: '<S161>/Constant'
   *  Constant: '<S161>/Constant3'
   *  Constant: '<S161>/Constant4'
   *  RelationalOperator: '<S161>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForQkChargeCooling) {
    rtb_DataTypeConversion1_j0 = 11U;
  } else {
    rtb_DataTypeConversion1_j0 = 0U;
  }

  /* Switch: '<S162>/Switch' incorporates:
   *  Constant: '<S162>/Constant'
   *  Constant: '<S162>/Constant3'
   *  Constant: '<S162>/Constant4'
   *  RelationalOperator: '<S162>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForForceChange) {
    rtb_Switch3_l = 12U;
  } else {
    rtb_Switch3_l = 0U;
  }

  /* Switch: '<S163>/Switch' incorporates:
   *  Constant: '<S163>/Constant'
   *  Constant: '<S163>/Constant3'
   *  Constant: '<S163>/Constant4'
   *  RelationalOperator: '<S163>/Relational Operator'
   */
  if (ACCtl_stRecLevelFinal == cal_ACCtlRecLevelForRemoteAC) {
    rtb_MultiportSwitch1 = 13U;
  } else {
    rtb_MultiportSwitch1 = 0U;
  }

  /* Logic: '<S159>/Logical Operator' incorporates:
   *  Constant: '<S159>/Constant'
   *  Constant: '<S159>/Constant1'
   *  Constant: '<S159>/Constant2'
   *  RelationalOperator: '<S159>/Relational Operator'
   *  RelationalOperator: '<S159>/Relational Operator1'
   *  RelationalOperator: '<S159>/Relational Operator2'
   */
  rtb_IndexVector8_j = (uint8)((ACCtl_stRecLevelFinal ==
    cal_ACCtlRecLevelForSummer) || (ACCtl_stRecLevelFinal ==
    cal_ACCtlRecLevelForWinter) || (ACCtl_stRecLevelFinal ==
    cal_ACCtlRecLevelForNormalDefog));

  /* MinMax: '<S157>/Max' incorporates:
   *  Switch: '<S160>/Switch'
   *  Switch: '<S161>/Switch'
   *  Switch: '<S162>/Switch'
   *  Switch: '<S163>/Switch'
   *  Switch: '<S164>/Switch'
   *  Switch: '<S165>/Switch'
   *  Switch: '<S166>/Switch'
   *  Switch: '<S167>/Switch'
   *  Switch: '<S168>/Switch'
   *  Switch: '<S169>/Switch'
   *  Switch: '<S170>/Switch'
   *  Switch: '<S171>/Switch'
   */
  if (rtb_IndexVector8_j >= rtb_Add7_i) {
    rtb_Add7_i = rtb_IndexVector8_j;
  }

  if (rtb_Add7_i >= rtb_Add4_ox) {
    rtb_Add4_ox = rtb_Add7_i;
  }

  if (rtb_Add4_ox >= rtb_Gain_gr) {
    rtb_Gain_gr = rtb_Add4_ox;
  }

  if (rtb_Gain_gr >= u1) {
    u1 = rtb_Gain_gr;
  }

  if (u1 >= rtb_Add_b1) {
    rtb_Add_b1 = u1;
  }

  if (rtb_Add_b1 >= rtb_Add2_j5) {
    rtb_Add2_j5 = rtb_Add_b1;
  }

  if (rtb_Add2_j5 >= rtb_Add3_do) {
    rtb_Add3_do = rtb_Add2_j5;
  }

  if (rtb_Add3_do >= rtb_Add6_d) {
    rtb_Add6_d = rtb_Add3_do;
  }

  if (rtb_Add6_d >= rtb_Add5_d) {
    rtb_Add5_d = rtb_Add6_d;
  }

  if (rtb_Add5_d >= rtb_DataTypeConversion1_j0) {
    rtb_DataTypeConversion1_j0 = rtb_Add5_d;
  }

  if (rtb_DataTypeConversion1_j0 >= rtb_Switch3_l) {
    rtb_Switch3_l = rtb_DataTypeConversion1_j0;
  }

  if (rtb_Switch3_l >= rtb_MultiportSwitch1) {
    rtb_MultiportSwitch1 = rtb_Switch3_l;
  }

  /* SwitchCase: '<S47>/Switch Case' incorporates:
   *  MinMax: '<S157>/Max'
   */
  switch (rtb_MultiportSwitch1) {
   case 1:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForSummerOrWinterOrNormalDefog' incorporates:
     *  ActionPort: '<S150>/Action Port'
     */
    /* Merge generated from: '<S47>/Merge' incorporates:
     *  Constant: '<S150>/Constant'
     *  RelationalOperator: '<S150>/Relational Operator'
     *  SignalConversion generated from: '<S150>/AC_rACCtlRecForSummerOrWinterOrNormalDefog'
     *  Switch: '<S150>/Switch'
     */
    ACCtl_stRecOut = (ACCtl_IntakeRatio == 100);

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForSummerOrWinterOrNormalDefog' */
    break;

   case 2:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForPTCDvt' incorporates:
     *  ActionPort: '<S147>/Action Port'
     */
    ME11_ACCtlRecForPTCDvt((boolean *)&ACCtl_stRecOut, (uint8 *)
      &ACCtl_IntakeRatio);

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForPTCDvt' */
    break;

   case 3:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForACHotStart' incorporates:
     *  ActionPort: '<S142>/Action Port'
     */
    /* Merge generated from: '<S47>/Merge' incorporates:
     *  Constant: '<S142>/Constant'
     *  SignalConversion generated from: '<S142>/ACCtl_stRecOut'
     */
    ACCtl_stRecOut = false;

    /* Switch: '<S46>/Switch18' incorporates:
     *  Constant: '<S142>/Constant1'
     *  SignalConversion generated from: '<S142>/ACCtl_rIntakeDoor'
     */
    ACCtl_IntakeRatio = 0U;

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForACHotStart' */
    break;

   case 4:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForTargetOutTemp' incorporates:
     *  ActionPort: '<S151>/Action Port'
     */
    ME11_ACCtlRecForPTCDvt((boolean *)&ACCtl_stRecOut, (uint8 *)
      &ACCtl_IntakeRatio);

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForTargetOutTemp' */
    break;

   case 5:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForVent' incorporates:
     *  ActionPort: '<S153>/Action Port'
     */
    /* Switch: '<S46>/Switch18' incorporates:
     *  SignalConversion generated from: '<S153>/AC_rACCtlRecForVent'
     *  SignalConversion generated from: '<S153>/ACCtl_rIntakeDoor'
     */
    ACCtl_IntakeRatio = rtb_Switch1_mn;

    /* Merge generated from: '<S47>/Merge' incorporates:
     *  Constant: '<S153>/Constant'
     *  RelationalOperator: '<S153>/Relational Operator'
     *  SignalConversion generated from: '<S153>/AC_rACCtlRecForVent'
     *  Switch: '<S153>/Switch'
     */
    ACCtl_stRecOut = (rtb_Switch1_mn == 100);

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForVent' */
    break;

   case 6:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForTempLow' incorporates:
     *  ActionPort: '<S152>/Action Port'
     */
    ME11_ACCtlRecForPTCDvt((boolean *)&ACCtl_stRecOut, (uint8 *)
      &ACCtl_IntakeRatio);

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForTempLow' */
    break;

   case 7:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForAQS' incorporates:
     *  ActionPort: '<S143>/Action Port'
     */
    ME11_ACCtlRecForPTCDvt((boolean *)&ACCtl_stRecOut, (uint8 *)
      &ACCtl_IntakeRatio);

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForAQS' */
    break;

   case 8:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecLevelForPCUTemp' incorporates:
     *  ActionPort: '<S154>/Action Port'
     */
    ME11_ACCtlRecForPTCDvt((boolean *)&ACCtl_stRecOut, (uint8 *)
      &ACCtl_IntakeRatio);

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecLevelForPCUTemp' */
    break;

   case 9:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForForceDefog' incorporates:
     *  ActionPort: '<S145>/Action Port'
     */
    /* Merge generated from: '<S47>/Merge' incorporates:
     *  Switch: '<S145>/Switch'
     */
    ACCtl_stRecOut = ((!rtb_AND1_hh) && (HMICtl_eInner != 0));

    /* Switch: '<S145>/Switch2' incorporates:
     *  Switch: '<S145>/Switch1'
     */
    if (rtb_AND1_hh) {
      /* Switch: '<S46>/Switch18' incorporates:
       *  Constant: '<S145>/Constant3'
       */
      ACCtl_IntakeRatio = DriveFRESH;
    } else if (HMICtl_eInner != 0) {
      /* Switch: '<S46>/Switch18' incorporates:
       *  Constant: '<S145>/Constant4'
       *  Switch: '<S145>/Switch1'
       */
      ACCtl_IntakeRatio = RECIRC;
    } else {
      /* Switch: '<S46>/Switch18' incorporates:
       *  Constant: '<S145>/Constant2'
       *  Switch: '<S145>/Switch1'
       */
      ACCtl_IntakeRatio = DriveFRESH;
    }

    /* End of Switch: '<S145>/Switch2' */
    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForForceDefog' */
    break;

   case 10:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForManual' incorporates:
     *  ActionPort: '<S146>/Action Port'
     */
    /* RelationalOperator: '<S158>/Compare' incorporates:
     *  Constant: '<S158>/Constant'
     */
    ACCtl_stRecOut = (HMICtl_eInner == 1);

    /* Switch: '<S146>/Switch1' */
    if (ACCtl_stRecOut) {
      /* Switch: '<S46>/Switch18' incorporates:
       *  Constant: '<S146>/Constant2'
       */
      ACCtl_IntakeRatio = 100U;
    } else {
      /* Switch: '<S46>/Switch18' incorporates:
       *  Constant: '<S146>/Constant3'
       */
      ACCtl_IntakeRatio = 0U;
    }

    /* End of Switch: '<S146>/Switch1' */
    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForManual' */
    break;

   case 11:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForQkChargeCooling' incorporates:
     *  ActionPort: '<S148>/Action Port'
     */
    /* Merge generated from: '<S47>/Merge' incorporates:
     *  Switch: '<S148>/Switch2'
     */
    ACCtl_stRecOut = (HMICtl_eInner > 0);

    /* Switch: '<S46>/Switch18' incorporates:
     *  Constant: '<S148>/Constant1'
     *  SignalConversion generated from: '<S148>/ACCtl_rIntakeDoor'
     */
    ACCtl_IntakeRatio = 100U;

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForQkChargeCooling' */
    break;

   case 12:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForForceChange' incorporates:
     *  ActionPort: '<S144>/Action Port'
     */
    /* Merge generated from: '<S47>/Merge' incorporates:
     *  Switch: '<S144>/Switch2'
     */
    ACCtl_stRecOut = (HMICtl_eInner > 0);

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForForceChange' */

    /* Switch: '<S46>/Switch13' incorporates:
     *  Constant: '<S46>/Constant'
     *  Constant: '<S46>/Constant14'
     */
    if (ACCtl_stRecForceChangeEna) {
      rtb_IndexVector8_j = cal_CO2RecircRatio;
    } else {
      rtb_IndexVector8_j = 100U;
    }

    /* Switch: '<S46>/Switch16' incorporates:
     *  Constant: '<S46>/Constant15'
     */
    if (!ACCtl_stRecVentEna) {
      rtb_Switch1_mn = 100U;
    }

    /* Switch: '<S46>/Switch19' incorporates:
     *  Constant: '<S120>/Constant1'
     *  Constant: '<S46>/Constant19'
     */
    if (ACCtl_stRecACHotStartEna) {
      rtb_Add7_i = 0U;
    } else {
      rtb_Add7_i = 100U;
    }

    /* Switch: '<S46>/Switch18' incorporates:
     *  Constant: '<S46>/Constant20'
     */
    if (!ACCtl_stRecNormalDefogEna) {
      ACCtl_IntakeRatio = 100U;
    }

    /* MinMax: '<S46>/Min' incorporates:
     *  Switch: '<S46>/Switch13'
     *  Switch: '<S46>/Switch16'
     *  Switch: '<S46>/Switch18'
     *  Switch: '<S46>/Switch19'
     */
    if (rtb_IndexVector8_j <= rtb_DataTypeConversion_jr) {
      rtb_DataTypeConversion_jr = rtb_IndexVector8_j;
    }

    if (rtb_DataTypeConversion_jr <= rtb_Switch1_mn) {
      rtb_Switch1_mn = rtb_DataTypeConversion_jr;
    }

    if (rtb_Switch1_mn <= rtb_Add7_i) {
      rtb_Add7_i = rtb_Switch1_mn;
    }

    if (rtb_Add7_i <= ACCtl_IntakeRatio) {
      /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForForceChange' incorporates:
       *  ActionPort: '<S144>/Action Port'
       */
      /* SignalConversion generated from: '<S144>/AC_rRecInForceChangeMode' */
      ACCtl_IntakeRatio = rtb_Add7_i;

      /* End of Outputs for SubSystem: '<S47>/ACCtlRecForForceChange' */
    }

    /* End of MinMax: '<S46>/Min' */
    break;

   case 13:
    /* Outputs for IfAction SubSystem: '<S47>/ACCtlRecForRemoteAC' incorporates:
     *  ActionPort: '<S149>/Action Port'
     */
    ME11_ACCtlRecForPTCDvt((boolean *)&ACCtl_stRecOut, (uint8 *)
      &ACCtl_IntakeRatio);

    /* End of Outputs for SubSystem: '<S47>/ACCtlRecForRemoteAC' */
    break;

   default:
    /* Outputs for IfAction SubSystem: '<S47>/AC_RecDefault' incorporates:
     *  ActionPort: '<S155>/Action Port'
     */
    /* Merge generated from: '<S47>/Merge' incorporates:
     *  Constant: '<S155>/Constant'
     *  SignalConversion generated from: '<S155>/ACCtl_stRecOut'
     */
    ACCtl_stRecOut = true;

    /* Switch: '<S46>/Switch18' incorporates:
     *  Constant: '<S155>/Constant1'
     *  SignalConversion generated from: '<S155>/ACCtl_rIntakeDoorPosition'
     */
    ACCtl_IntakeRatio = 100U;

    /* End of Outputs for SubSystem: '<S47>/AC_RecDefault' */
    break;
  }

  /* End of SwitchCase: '<S47>/Switch Case' */

  /* Outputs for Enabled SubSystem: '<S42>/BlowerFanSpeedCalEnable' incorporates:
   *  EnablePort: '<S49>/Enable'
   */
  if (rtb_Delay_j3) {
    /* Outputs for Atomic SubSystem: '<S49>/ACFanLevelEnvCor' */
    /* Lookup_n-D: '<S52>/cal_ACFanLevel0EnvCor_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    rtb_Delay1_ie = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACFanLevel0EnvCor_1X[0], (const float32 *)&cal_ACFanLevel0EnvCor_CUR
      [0], 1U);

    /* Lookup_n-D: '<S52>/cal_ACFanLevel1EnvCor_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    rtb_Merge = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACFanLevel1EnvCor_1X[0], (const float32 *)&cal_ACFanLevel1EnvCor_CUR
      [0], 1U);

    /* Lookup_n-D: '<S52>/cal_ACFanLevel2EnvCor_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    rtb_Merge1 = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACFanLevel2EnvCor_1X[0], (const float32 *)&cal_ACFanLevel2EnvCor_CUR
      [0], 1U);

    /* Lookup_n-D: '<S52>/cal_ACFanLevel3EnvCor_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    rtb_Add_ok = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACFanLevel3EnvCor_1X[0], (const float32 *)&cal_ACFanLevel3EnvCor_CUR
      [0], 1U);

    /* Lookup_n-D: '<S52>/cal_ACFanLevel4EnvCor_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    rtb_Gain6 = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACFanLevel4EnvCor_1X[0], (const float32 *)&cal_ACFanLevel4EnvCor_CUR
      [0], 1U);

    /* Lookup_n-D: '<S52>/cal_ACFanLevel5EnvCor_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    rtb_ACFanLevel5EnvCor = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACFanLevel5EnvCor_1X[0], (const float32 *)&cal_ACFanLevel5EnvCor_CUR
      [0], 1U);

    /* Lookup_n-D: '<S52>/cal_ACFanLevel6EnvCor_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    rtb_ACFanLevel6EnvCor = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACFanLevel6EnvCor_1X[0], (const float32 *)&cal_ACFanLevel6EnvCor_CUR
      [0], 1U);

    /* Lookup_n-D: '<S52>/cal_ACFanLevel7EnvCor_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    rtb_ACFanLevel7EnvCor = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACFanLevel7EnvCor_1X[0], (const float32 *)&cal_ACFanLevel7EnvCor_CUR
      [0], 1U);

    /* Lookup_n-D: '<S52>/cal_ACFanLevel8EnvCor_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    rtb_ACFanLevel8EnvCor = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACFanLevel8EnvCor_1X[0], (const float32 *)&cal_ACFanLevel8EnvCor_CUR
      [0], 1U);

    /* End of Outputs for SubSystem: '<S49>/ACFanLevelEnvCor' */

    /* Outputs for Enabled SubSystem: '<S53>/AutoMode' incorporates:
     *  EnablePort: '<S54>/Enable'
     */
    if (ME11_ARID_DEF.Switch1_nv > 0) {
      /* Outputs for Enabled SubSystem: '<S54>/AutoModeBloweFanSpeedCal' incorporates:
       *  EnablePort: '<S56>/Enable'
       */
      /* Logic: '<S54>/Logical Operator' */
      if (!HMICtl_bACDefrost) {
        /* Sum: '<S58>/Add' incorporates:
         *  Constant: '<S58>/ACCtl_facLeftBlowerFanSpdWeight'
         *  Constant: '<S58>/Constant1'
         *  Product: '<S58>/Product'
         *  Product: '<S58>/Product1'
         *  Sum: '<S58>/Sum'
         */
        ACCtl_tDVTFlt = (1.0F - cal_PsDVTWeight) * ACCtl_tDrDVT + ACCtl_tPsDVT *
          cal_PsDVTWeight;

        /* RelationalOperator: '<S71>/LowerRelop1' incorporates:
         *  Constant: '<S56>/Constant2'
         *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
         *  Logic: '<S56>/Logical Operator'
         *  RelationalOperator: '<S56>/Relational Operator2'
         */
        rtb_Delay_j3 =
          ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA
            ())->VIPM_ESCVehSpdVld_flg && (ACSen_eAirInletPer <
            cal_ACRecirRatioLmt));

        /* Switch: '<S56>/Switch' */
        if (rtb_Delay_j3) {
          /* Saturate: '<S56>/Saturation' incorporates:
           *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
           *  Lookup_n-D: '<S56>/cal_ACFanSpdVssCor_CUR'
           */
          rtb_Saturation_ou = look1_iflf_binlca
            ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA
              ())->VIPM_ESCVehSpd_kph, (const float32 *)&cal_ACFanSpdVssCor_1X[0],
             (const float32 *)&cal_ACFanSpdVssCor_CUR[0], 2U);
        } else {
          /* Saturate: '<S56>/Saturation' incorporates:
           *  Constant: '<S56>/isRecirc'
           */
          rtb_Saturation_ou = 0.0F;
        }

        /* End of Switch: '<S56>/Switch' */

        /* DataTypeConversion: '<S56>/Data Type Conversion' */
        AC_rRecircInc = ACCtl_IntakeRatio;

        /* Sum: '<S56>/Add1' incorporates:
         *  Constant: '<S56>/Constant3'
         *  Constant: '<S56>/Constant4'
         *  Product: '<S56>/Product'
         *  Product: '<S56>/Product1'
         */
        GlbDa_LeftSolarAvr = (uint16)((uint32)(uint16)((float32)GlbDa_LeftSolar *
          0.5F) + (uint16)((float32)GlbDa_RightSolar * 0.5F));

        /* Lookup_n-D: '<S56>/cal_ACFanSpdSolarCor_MAP' incorporates:
         *  Sum: '<S56>/Add1'
         *  Sum: '<S58>/Add'
         */
        ACFanSpdSolarCor = look2_iu16flftf_binlca(GlbDa_LeftSolarAvr,
          ACCtl_tDVTFlt, (const uint16 *)&cal_ACFanSpdSolarCor_2X[0], (const
          float32 *)&cal_ACFanSpdSolarCor_2Y[0], (const float32 *)
          &cal_ACFanSpdSolarCor_MAP[0], ME11_ConstP.pooled35, 15U);

        /* Lookup_n-D: '<S56>/cal_ACFanSpdSolarCorByEnv_MAP' incorporates:
         *  Sum: '<S56>/Add1'
         *  Switch: '<S1085>/Switch'
         */
        ACFanSpdSolarCorByEnv = look2_iu16flftf_binlca(GlbDa_LeftSolarAvr,
          ACSen_sEnvTempCor, (const uint16 *)&cal_ACFanSpdSolarCorByEnv_2X[0], (
          const float32 *)&cal_ACFanSpdSolarCorByEnv_2Y[0], (const float32 *)
          &cal_ACFanSpdSolarCorByEnv_MAP[0], ME11_ConstP.pooled35, 15U);

        /* Sum: '<S56>/Add8' incorporates:
         *  Constant: '<S56>/Constant12'
         *  Constant: '<S56>/Constant18'
         *  MultiPortSwitch: '<S56>/Index Vector8'
         *  Sum: '<S59>/Add8'
         */
        rtb_MultiportSwitch2_e = (float32)cal_FanLevelToPWM[8] +
          rtb_ACFanLevel8EnvCor;

        /* Switch: '<S60>/Switch2' incorporates:
         *  Constant: '<S56>/Constant35'
         *  Constant: '<S56>/Constant36'
         *  RelationalOperator: '<S60>/LowerRelop1'
         *  RelationalOperator: '<S60>/UpperRelop'
         *  Sum: '<S56>/Add8'
         *  Switch: '<S60>/Switch'
         */
        if (rtb_MultiportSwitch2_e > 100.0F) {
          /* MultiPortSwitch: '<S59>/Index Vector8' */
          rtb_IndexVector8_j = 100U;
        } else if (rtb_MultiportSwitch2_e < 0.0F) {
          /* Switch: '<S60>/Switch' incorporates:
           *  Constant: '<S56>/Constant35'
           *  MultiPortSwitch: '<S59>/Index Vector8'
           */
          rtb_IndexVector8_j = 0U;
        } else {
          /* MultiPortSwitch: '<S59>/Index Vector8' incorporates:
           *  Switch: '<S60>/Switch'
           */
          rtb_IndexVector8_j = (uint8)rtb_MultiportSwitch2_e;
        }

        /* End of Switch: '<S60>/Switch2' */

        /* Product: '<S56>/FanPWM' incorporates:
         *  Constant: '<S2>/Constant2'
         *  DataTypeConversion: '<S56>/Data Type Conversion'
         *  Lookup_n-D: '<S56>/cal_ACFanSpdBatCor_CUR'
         *  Lookup_n-D: '<S56>/cal_ACFanSpdDvtSet_CUR '
         *  Lookup_n-D: '<S56>/cal_ACFanSpdRecircCor_CUR'
         *  Sum: '<S56>/Add'
         *  Sum: '<S58>/Add'
         *  Sum: '<S61>/Add2'
         */
        ACCCtl_sBlowerFanSpd = ((((float32)(uint8)(look1_iflf_binlca
          (ACCtl_tDVTFlt, (const float32 *)&cal_ACFanSpdDvtSet_1X[0], (const
          float32 *)&cal_ACFanSpdDvtSet_CUR[0], 13U) - rtb_Saturation_ou) +
          look1_iu8bflftf_binlca(AC_rRecircInc, (const float32 *)
          &cal_ACFanSpdRecircCor_1X[0], (const float32 *)
          &cal_ACFanSpdRecircCor_CUR[0], 3U)) + ACFanSpdSolarCor) +
          ACFanSpdSolarCorByEnv) * look1_iu16bflftf_binlca(1200U, (const float32
          *)&cal_ACFanSpdBatCor_1X[0], (const float32 *)&cal_ACFanSpdBatCor_CUR
          [0], 2U);

        /* Saturate: '<S56>/Saturation' */
        if (ACCCtl_sBlowerFanSpd > 100.0F) {
          /* Product: '<S56>/FanPWM' */
          ACCCtl_sBlowerFanSpd = 100.0F;
        } else if (ACCCtl_sBlowerFanSpd < 0.0F) {
          /* Product: '<S56>/FanPWM' */
          ACCCtl_sBlowerFanSpd = 0.0F;
        }

        /* End of Saturate: '<S56>/Saturation' */

        /* MinMax: '<S56>/MinMax' */
        if (rtb_IndexVector8_j <= ACCCtl_sBlowerFanSpd) {
          /* Product: '<S56>/FanPWM' incorporates:
           *  MinMax: '<S56>/MinMax'
           */
          ACCCtl_sBlowerFanSpd = (float32)rtb_IndexVector8_j;
        }

        /* End of MinMax: '<S56>/MinMax' */

        /* Sum: '<S59>/Add' incorporates:
         *  Constant: '<S59>/Constant2'
         *  Constant: '<S59>/Constant5'
         *  MultiPortSwitch: '<S59>/Index Vector'
         */
        rtb_Add_b1 = (uint8)(((float32)cal_FanLevelToPWM[0] + rtb_Delay1_ie) +
                             100.0F);

        /* Sum: '<S59>/Add1' incorporates:
         *  Constant: '<S59>/Constant1'
         *  Constant: '<S59>/Constant3'
         *  MultiPortSwitch: '<S59>/Index Vector1'
         */
        rtb_IndexVector8_j = (uint8)(((float32)cal_FanLevelToPWM[1] + rtb_Merge)
          + 100.0F);

        /* Sum: '<S59>/Add2' incorporates:
         *  Constant: '<S59>/Constant4'
         *  Constant: '<S59>/Constant6'
         *  MultiPortSwitch: '<S59>/Index Vector2'
         */
        rtb_Add2_j5 = (uint8)(((float32)cal_FanLevelToPWM[2] + rtb_Merge1) +
                              100.0F);

        /* Sum: '<S59>/Add3' incorporates:
         *  Constant: '<S59>/Constant7'
         *  Constant: '<S59>/Constant8'
         *  MultiPortSwitch: '<S59>/Index Vector3'
         */
        rtb_Add3_do = (uint8)(((float32)cal_FanLevelToPWM[3] + rtb_Add_ok) +
                              100.0F);

        /* Sum: '<S59>/Add4' incorporates:
         *  Constant: '<S59>/Constant10'
         *  Constant: '<S59>/Constant9'
         *  MultiPortSwitch: '<S59>/Index Vector4'
         */
        rtb_Add4_ox = (uint8)(((float32)cal_FanLevelToPWM[4] + rtb_Gain6) +
                              100.0F);

        /* Sum: '<S59>/Add5' incorporates:
         *  Constant: '<S59>/Constant11'
         *  Constant: '<S59>/Constant13'
         *  MultiPortSwitch: '<S59>/Index Vector5'
         */
        rtb_Add5_d = (uint8)(((float32)cal_FanLevelToPWM[5] +
                              rtb_ACFanLevel5EnvCor) + 100.0F);

        /* Sum: '<S59>/Add6' incorporates:
         *  Constant: '<S59>/Constant14'
         *  Constant: '<S59>/Constant15'
         *  MultiPortSwitch: '<S59>/Index Vector6'
         */
        rtb_Add6_d = (uint8)(((float32)cal_FanLevelToPWM[6] +
                              rtb_ACFanLevel6EnvCor) + 100.0F);

        /* Sum: '<S59>/Add7' incorporates:
         *  Constant: '<S59>/Constant16'
         *  Constant: '<S59>/Constant17'
         *  MultiPortSwitch: '<S59>/Index Vector7'
         */
        rtb_Add7_i = (uint8)(((float32)cal_FanLevelToPWM[7] +
                              rtb_ACFanLevel7EnvCor) + 100.0F);

        /* Switch: '<S63>/Switch2' incorporates:
         *  RelationalOperator: '<S63>/LowerRelop1'
         *  RelationalOperator: '<S63>/UpperRelop'
         *  Sum: '<S59>/Add'
         *  Switch: '<S63>/Switch'
         */
        if (rtb_Add_b1 > 200) {
          /* Switch: '<S63>/Switch2' incorporates:
           *  Constant: '<S59>/Constant20'
           */
          rtb_Add_b1 = 100U;
        } else if (rtb_Add_b1 < 100) {
          /* Switch: '<S63>/Switch' incorporates:
           *  Constant: '<S59>/Constant19'
           *  Switch: '<S63>/Switch2'
           */
          rtb_Add_b1 = 0U;
        } else {
          /* Switch: '<S63>/Switch2' incorporates:
           *  Switch: '<S63>/Switch'
           */
          rtb_Add_b1 = (uint8)(rtb_Add_b1 + -100);
        }

        /* End of Switch: '<S63>/Switch2' */

        /* Switch: '<S65>/Switch2' incorporates:
         *  RelationalOperator: '<S65>/LowerRelop1'
         *  RelationalOperator: '<S65>/UpperRelop'
         *  Sum: '<S59>/Add2'
         *  Switch: '<S65>/Switch'
         */
        if (rtb_Add2_j5 > 200) {
          /* Switch: '<S65>/Switch2' incorporates:
           *  Constant: '<S59>/Constant24'
           */
          rtb_Add2_j5 = 100U;
        } else if (rtb_Add2_j5 < 100) {
          /* Switch: '<S65>/Switch' incorporates:
           *  Constant: '<S59>/Constant23'
           *  Switch: '<S65>/Switch2'
           */
          rtb_Add2_j5 = 0U;
        } else {
          /* Switch: '<S65>/Switch2' incorporates:
           *  Switch: '<S65>/Switch'
           */
          rtb_Add2_j5 = (uint8)(rtb_Add2_j5 + -100);
        }

        /* End of Switch: '<S65>/Switch2' */

        /* Switch: '<S66>/Switch2' incorporates:
         *  RelationalOperator: '<S66>/LowerRelop1'
         *  RelationalOperator: '<S66>/UpperRelop'
         *  Sum: '<S59>/Add3'
         *  Switch: '<S66>/Switch'
         */
        if (rtb_Add3_do > 200) {
          /* Switch: '<S66>/Switch2' incorporates:
           *  Constant: '<S59>/Constant26'
           */
          rtb_Add3_do = 100U;
        } else if (rtb_Add3_do < 100) {
          /* Switch: '<S66>/Switch' incorporates:
           *  Constant: '<S59>/Constant25'
           *  Switch: '<S66>/Switch2'
           */
          rtb_Add3_do = 0U;
        } else {
          /* Switch: '<S66>/Switch2' incorporates:
           *  Switch: '<S66>/Switch'
           */
          rtb_Add3_do = (uint8)(rtb_Add3_do + -100);
        }

        /* End of Switch: '<S66>/Switch2' */

        /* Switch: '<S67>/Switch2' incorporates:
         *  RelationalOperator: '<S67>/LowerRelop1'
         *  RelationalOperator: '<S67>/UpperRelop'
         *  Sum: '<S59>/Add4'
         *  Switch: '<S67>/Switch'
         */
        if (rtb_Add4_ox > 200) {
          /* Switch: '<S67>/Switch2' incorporates:
           *  Constant: '<S59>/Constant28'
           */
          rtb_Add4_ox = 100U;
        } else if (rtb_Add4_ox < 100) {
          /* Switch: '<S67>/Switch' incorporates:
           *  Constant: '<S59>/Constant27'
           *  Switch: '<S67>/Switch2'
           */
          rtb_Add4_ox = 0U;
        } else {
          /* Switch: '<S67>/Switch2' incorporates:
           *  Switch: '<S67>/Switch'
           */
          rtb_Add4_ox = (uint8)(rtb_Add4_ox + -100);
        }

        /* End of Switch: '<S67>/Switch2' */

        /* Switch: '<S68>/Switch2' incorporates:
         *  RelationalOperator: '<S68>/LowerRelop1'
         *  RelationalOperator: '<S68>/UpperRelop'
         *  Sum: '<S59>/Add5'
         *  Switch: '<S68>/Switch'
         */
        if (rtb_Add5_d > 200) {
          /* Switch: '<S68>/Switch2' incorporates:
           *  Constant: '<S59>/Constant30'
           */
          rtb_Add5_d = 100U;
        } else if (rtb_Add5_d < 100) {
          /* Switch: '<S68>/Switch' incorporates:
           *  Constant: '<S59>/Constant29'
           *  Switch: '<S68>/Switch2'
           */
          rtb_Add5_d = 0U;
        } else {
          /* Switch: '<S68>/Switch2' incorporates:
           *  Switch: '<S68>/Switch'
           */
          rtb_Add5_d = (uint8)(rtb_Add5_d + -100);
        }

        /* End of Switch: '<S68>/Switch2' */

        /* Switch: '<S69>/Switch2' incorporates:
         *  RelationalOperator: '<S69>/LowerRelop1'
         *  RelationalOperator: '<S69>/UpperRelop'
         *  Sum: '<S59>/Add6'
         *  Switch: '<S69>/Switch'
         */
        if (rtb_Add6_d > 200) {
          /* Switch: '<S69>/Switch2' incorporates:
           *  Constant: '<S59>/Constant32'
           */
          rtb_Add6_d = 100U;
        } else if (rtb_Add6_d < 100) {
          /* Switch: '<S69>/Switch' incorporates:
           *  Constant: '<S59>/Constant31'
           *  Switch: '<S69>/Switch2'
           */
          rtb_Add6_d = 0U;
        } else {
          /* Switch: '<S69>/Switch2' incorporates:
           *  Switch: '<S69>/Switch'
           */
          rtb_Add6_d = (uint8)(rtb_Add6_d + -100);
        }

        /* End of Switch: '<S69>/Switch2' */

        /* Switch: '<S70>/Switch2' incorporates:
         *  RelationalOperator: '<S70>/LowerRelop1'
         *  RelationalOperator: '<S70>/UpperRelop'
         *  Sum: '<S59>/Add7'
         *  Switch: '<S70>/Switch'
         */
        if (rtb_Add7_i > 200) {
          /* Switch: '<S70>/Switch2' incorporates:
           *  Constant: '<S59>/Constant34'
           */
          rtb_Add7_i = 100U;
        } else if (rtb_Add7_i < 100) {
          /* Switch: '<S70>/Switch' incorporates:
           *  Constant: '<S59>/Constant33'
           *  Switch: '<S70>/Switch2'
           */
          rtb_Add7_i = 0U;
        } else {
          /* Switch: '<S70>/Switch2' incorporates:
           *  Switch: '<S70>/Switch'
           */
          rtb_Add7_i = (uint8)(rtb_Add7_i + -100);
        }

        /* End of Switch: '<S70>/Switch2' */

        /* Chart: '<S59>/PWM2FANLEVEL' incorporates:
         *  DataTypeConversion: '<S56>/Data Type Conversion1'
         *  RelationalOperator: '<S71>/LowerRelop1'
         *  RelationalOperator: '<S71>/UpperRelop'
         *  Sum: '<S59>/Add8'
         *  Switch: '<S64>/Switch2'
         *  Switch: '<S71>/Switch'
         *  Switch: '<S71>/Switch2'
         */
        if (ME11_ARID_DEF.is_active_c1_ME11 == 0U) {
          ME11_ARID_DEF.is_active_c1_ME11 = 1U;
          ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_0;

          /* Switch: '<S57>/Switch' incorporates:
           *  Merge generated from: '<S53>/Merge'
           */
          ME11_ARID_DEF.AC_FanLevel = 0U;
        } else {
          switch (ME11_ARID_DEF.is_AmbienceTempHighZero) {
           case ME11_IN_Fan_0:
            /* Switch: '<S57>/Switch' incorporates:
             *  Merge generated from: '<S53>/Merge'
             */
            ME11_ARID_DEF.AC_FanLevel = 0U;
            if ((uint8)ACCCtl_sBlowerFanSpd > (sint32)(rtb_Add_b1 + 10U)) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_01;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 1U;
            }
            break;

           case ME11_IN_Fan_01:
            /* Switch: '<S57>/Switch' incorporates:
             *  Merge generated from: '<S53>/Merge'
             */
            ME11_ARID_DEF.AC_FanLevel = 1U;
            if ((uint8)ACCCtl_sBlowerFanSpd < (sint32)(rtb_Add_b1 + 5U)) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_0;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 0U;
            } else if ((uint8)ACCCtl_sBlowerFanSpd > rtb_Add2_j5) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_02;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 2U;
            }
            break;

           case ME11_IN_Fan_02:
            /* Switch: '<S57>/Switch' incorporates:
             *  Merge generated from: '<S53>/Merge'
             */
            ME11_ARID_DEF.AC_FanLevel = 2U;

            /* Switch: '<S64>/Switch2' incorporates:
             *  Constant: '<S59>/Constant22'
             *  RelationalOperator: '<S64>/LowerRelop1'
             *  RelationalOperator: '<S64>/UpperRelop'
             *  Sum: '<S59>/Add1'
             *  Switch: '<S64>/Switch'
             */
            if (rtb_IndexVector8_j > 200) {
              rtb_Add7_i = 100U;
            } else if (rtb_IndexVector8_j < 100) {
              /* Switch: '<S64>/Switch' incorporates:
               *  Constant: '<S59>/Constant21'
               */
              rtb_Add7_i = 0U;
            } else {
              rtb_Add7_i = (uint8)(rtb_IndexVector8_j + -100);
            }

            if ((uint8)ACCCtl_sBlowerFanSpd < rtb_Add7_i) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_01;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 1U;
            } else if ((uint8)ACCCtl_sBlowerFanSpd > rtb_Add3_do) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_03;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 3U;
            }
            break;

           case ME11_IN_Fan_03:
            /* Switch: '<S57>/Switch' incorporates:
             *  Merge generated from: '<S53>/Merge'
             */
            ME11_ARID_DEF.AC_FanLevel = 3U;
            if ((uint8)ACCCtl_sBlowerFanSpd < rtb_Add2_j5) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_02;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 2U;
            } else if ((uint8)ACCCtl_sBlowerFanSpd > rtb_Add4_ox) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_04;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 4U;
            }
            break;

           case ME11_IN_Fan_04:
            /* Switch: '<S57>/Switch' incorporates:
             *  Merge generated from: '<S53>/Merge'
             */
            ME11_ARID_DEF.AC_FanLevel = 4U;
            if ((uint8)ACCCtl_sBlowerFanSpd < rtb_Add3_do) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_03;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 3U;
            } else if ((uint8)ACCCtl_sBlowerFanSpd > rtb_Add5_d) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_05;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 5U;
            }
            break;

           case ME11_IN_Fan_05:
            /* Switch: '<S57>/Switch' incorporates:
             *  Merge generated from: '<S53>/Merge'
             */
            ME11_ARID_DEF.AC_FanLevel = 5U;
            if ((uint8)ACCCtl_sBlowerFanSpd < rtb_Add4_ox) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_04;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 4U;
            } else if ((uint8)ACCCtl_sBlowerFanSpd > rtb_Add6_d) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_06;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 6U;
            }
            break;

           case ME11_IN_Fan_06:
            /* Switch: '<S57>/Switch' incorporates:
             *  Merge generated from: '<S53>/Merge'
             */
            ME11_ARID_DEF.AC_FanLevel = 6U;
            if ((uint8)ACCCtl_sBlowerFanSpd < rtb_Add5_d) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_05;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 5U;
            } else if ((uint8)ACCCtl_sBlowerFanSpd > rtb_Add7_i) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_07;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 7U;
            }
            break;

           case ME11_IN_Fan_07:
            /* Switch: '<S57>/Switch' incorporates:
             *  Merge generated from: '<S53>/Merge'
             */
            ME11_ARID_DEF.AC_FanLevel = 7U;
            if ((uint8)ACCCtl_sBlowerFanSpd < rtb_Add6_d) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_06;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 6U;
            } else {
              if ((uint8)(rtb_MultiportSwitch2_e + 100.0F) > 200) {
                /* Switch: '<S71>/Switch2' incorporates:
                 *  Constant: '<S59>/Constant36'
                 */
                rtb_Add7_i = 100U;
              } else if ((uint8)(rtb_MultiportSwitch2_e + 100.0F) < 100) {
                /* Switch: '<S71>/Switch' incorporates:
                 *  Constant: '<S59>/Constant35'
                 *  Switch: '<S71>/Switch2'
                 */
                rtb_Add7_i = 0U;
              } else {
                /* Switch: '<S71>/Switch2' incorporates:
                 *  Sum: '<S59>/Add8'
                 *  Switch: '<S71>/Switch'
                 */
                rtb_Add7_i = (uint8)((uint8)(rtb_MultiportSwitch2_e + 100.0F) +
                                     -100);
              }

              if ((uint8)ACCCtl_sBlowerFanSpd >= rtb_Add7_i) {
                ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_08;

                /* Switch: '<S57>/Switch' incorporates:
                 *  Merge generated from: '<S53>/Merge'
                 */
                ME11_ARID_DEF.AC_FanLevel = 8U;
              }
            }
            break;

           default:
            /* Switch: '<S57>/Switch' incorporates:
             *  Merge generated from: '<S53>/Merge'
             */
            /* case IN_Fan_08: */
            ME11_ARID_DEF.AC_FanLevel = 8U;
            if ((uint8)ACCCtl_sBlowerFanSpd < rtb_Add7_i) {
              ME11_ARID_DEF.is_AmbienceTempHighZero = ME11_IN_Fan_07;

              /* Switch: '<S57>/Switch' incorporates:
               *  Merge generated from: '<S53>/Merge'
               */
              ME11_ARID_DEF.AC_FanLevel = 7U;
            }
            break;
          }
        }

        /* End of Chart: '<S59>/PWM2FANLEVEL' */

        /* SignalConversion generated from: '<S56>/ACCtl_BloweFanSpeed' incorporates:
         *  DataTypeConversion: '<S56>/Data Type Conversion1'
         */
        ACCtl_BloweFanSpeed = (uint8)ACCCtl_sBlowerFanSpd;
      }

      /* End of Logic: '<S54>/Logical Operator' */
      /* End of Outputs for SubSystem: '<S54>/AutoModeBloweFanSpeedCal' */

      /* Outputs for Enabled SubSystem: '<S54>/DefogBloweFanSpeedCal' incorporates:
       *  EnablePort: '<S57>/Enable'
       */
      if (HMICtl_bACDefrost) {
        /* Switch: '<S57>/Switch2' incorporates:
         *  Constant: '<S57>/Comfort'
         *  Delay: '<S42>/Delay'
         *  RelationalOperator: '<S57>/Relational Operator'
         *  Switch: '<S57>/Switch'
         */
        if (ME11_ARID_DEF.Delay_DSTATE_fk) {
          /* Switch: '<S57>/Switch' incorporates:
           *  Switch: '<S57>/Switch2'
           */
          ME11_ARID_DEF.AC_FanLevel = HMICtl_eBlwSts;
        } else {
          if (rtb_DataTypeConversion_f == ACEconMode_Comfort) {
            /* Switch: '<S57>/Switch' incorporates:
             *  Constant: '<S57>/Comfort1'
             */
            ME11_ARID_DEF.AC_FanLevel = 6U;
          } else {
            /* Switch: '<S57>/Switch' incorporates:
             *  Constant: '<S57>/Comfort2'
             */
            ME11_ARID_DEF.AC_FanLevel = 5U;
          }

          /* MinMax: '<S57>/MinMax' incorporates:
           *  Switch: '<S57>/Switch'
           */
          if (HMICtl_eBlwSts >= ME11_ARID_DEF.AC_FanLevel) {
            /* Switch: '<S57>/Switch2' */
            ME11_ARID_DEF.AC_FanLevel = HMICtl_eBlwSts;
          }

          /* End of MinMax: '<S57>/MinMax' */
        }

        /* End of Switch: '<S57>/Switch2' */

        /* MultiPortSwitch: '<S57>/Multiport Switch2' */
        switch (ME11_ARID_DEF.AC_FanLevel) {
         case 0:
          /* MultiPortSwitch: '<S57>/Multiport Switch2' */
          rtb_MultiportSwitch2_e = rtb_Delay1_ie;
          break;

         case 1:
          /* MultiPortSwitch: '<S57>/Multiport Switch2' */
          rtb_MultiportSwitch2_e = rtb_Merge;
          break;

         case 2:
          /* MultiPortSwitch: '<S57>/Multiport Switch2' */
          rtb_MultiportSwitch2_e = rtb_Merge1;
          break;

         case 3:
          /* MultiPortSwitch: '<S57>/Multiport Switch2' */
          rtb_MultiportSwitch2_e = rtb_Add_ok;
          break;

         case 4:
          /* MultiPortSwitch: '<S57>/Multiport Switch2' */
          rtb_MultiportSwitch2_e = rtb_Gain6;
          break;

         case 5:
          /* MultiPortSwitch: '<S57>/Multiport Switch2' */
          rtb_MultiportSwitch2_e = rtb_ACFanLevel5EnvCor;
          break;

         case 6:
          /* MultiPortSwitch: '<S57>/Multiport Switch2' */
          rtb_MultiportSwitch2_e = rtb_ACFanLevel6EnvCor;
          break;

         case 7:
          /* MultiPortSwitch: '<S57>/Multiport Switch2' */
          rtb_MultiportSwitch2_e = rtb_ACFanLevel7EnvCor;
          break;

         default:
          /* MultiPortSwitch: '<S57>/Multiport Switch2' */
          rtb_MultiportSwitch2_e = rtb_ACFanLevel8EnvCor;
          break;
        }

        /* End of MultiPortSwitch: '<S57>/Multiport Switch2' */

        /* Sum: '<S57>/Add' incorporates:
         *  Constant: '<S57>/Constant2'
         *  MultiPortSwitch: '<S57>/Index Vector'
         */
        rtb_IndexVector8_j = (uint8)(((float32)
          cal_FanLevelToPWM[ME11_ARID_DEF.AC_FanLevel] + rtb_MultiportSwitch2_e)
          + 100.0F);

        /* Switch: '<S72>/Switch2' incorporates:
         *  RelationalOperator: '<S72>/LowerRelop1'
         *  RelationalOperator: '<S72>/UpperRelop'
         *  Sum: '<S57>/Add'
         *  Switch: '<S72>/Switch'
         */
        if (rtb_IndexVector8_j > 200) {
          /* SignalConversion generated from: '<S57>/ACCtl_BloweFanSpeed' incorporates:
           *  Constant: '<S57>/Constant20'
           *  Switch: '<S72>/Switch2'
           */
          ACCtl_BloweFanSpeed = 100U;
        } else if (rtb_IndexVector8_j < 100) {
          /* Switch: '<S72>/Switch' incorporates:
           *  Constant: '<S57>/Constant19'
           *  SignalConversion generated from: '<S57>/ACCtl_BloweFanSpeed'
           *  Switch: '<S72>/Switch2'
           */
          ACCtl_BloweFanSpeed = 0U;
        } else {
          /* SignalConversion generated from: '<S57>/ACCtl_BloweFanSpeed' incorporates:
           *  Switch: '<S72>/Switch'
           *  Switch: '<S72>/Switch2'
           */
          ACCtl_BloweFanSpeed = (uint8)(rtb_IndexVector8_j + -100);
        }

        /* End of Switch: '<S72>/Switch2' */
      }

      /* End of Outputs for SubSystem: '<S54>/DefogBloweFanSpeedCal' */
    }

    /* End of Outputs for SubSystem: '<S53>/AutoMode' */

    /* Outputs for Enabled SubSystem: '<S53>/ManualMode' incorporates:
     *  EnablePort: '<S55>/Enable'
     */
    /* Logic: '<S53>/NOT' */
    if (ME11_ARID_DEF.Switch1_nv == 0) {
      /* MultiPortSwitch: '<S55>/Multiport Switch2' incorporates:
       *  SignalConversion generated from: '<S55>/ACCtl_BloweFanSpdManual'
       */
      switch (HMICtl_eBlwSts) {
       case 0:
        /* MultiPortSwitch: '<S55>/Multiport Switch2' */
        rtb_ACFanLevel8EnvCor = rtb_Delay1_ie;
        break;

       case 1:
        /* MultiPortSwitch: '<S55>/Multiport Switch2' */
        rtb_ACFanLevel8EnvCor = rtb_Merge;
        break;

       case 2:
        /* MultiPortSwitch: '<S55>/Multiport Switch2' */
        rtb_ACFanLevel8EnvCor = rtb_Merge1;
        break;

       case 3:
        /* MultiPortSwitch: '<S55>/Multiport Switch2' */
        rtb_ACFanLevel8EnvCor = rtb_Add_ok;
        break;

       case 4:
        /* MultiPortSwitch: '<S55>/Multiport Switch2' */
        rtb_ACFanLevel8EnvCor = rtb_Gain6;
        break;

       case 5:
        /* MultiPortSwitch: '<S55>/Multiport Switch2' */
        rtb_ACFanLevel8EnvCor = rtb_ACFanLevel5EnvCor;
        break;

       case 6:
        /* MultiPortSwitch: '<S55>/Multiport Switch2' */
        rtb_ACFanLevel8EnvCor = rtb_ACFanLevel6EnvCor;
        break;

       case 7:
        /* MultiPortSwitch: '<S55>/Multiport Switch2' */
        rtb_ACFanLevel8EnvCor = rtb_ACFanLevel7EnvCor;
        break;
      }

      /* End of MultiPortSwitch: '<S55>/Multiport Switch2' */

      /* Sum: '<S55>/Add' incorporates:
       *  Constant: '<S55>/Constant2'
       *  MultiPortSwitch: '<S55>/Index Vector'
       *  SignalConversion generated from: '<S55>/ACCtl_BloweFanSpdManual'
       */
      rtb_IndexVector8_j = (uint8)(((float32)cal_FanLevelToPWM[HMICtl_eBlwSts] +
        rtb_ACFanLevel8EnvCor) + 100.0F);

      /* Switch: '<S73>/Switch2' incorporates:
       *  RelationalOperator: '<S73>/LowerRelop1'
       *  RelationalOperator: '<S73>/UpperRelop'
       *  Sum: '<S55>/Add'
       *  Switch: '<S73>/Switch'
       */
      if (rtb_IndexVector8_j > 200) {
        /* SignalConversion generated from: '<S55>/ACCtl_BloweFanSpeed' incorporates:
         *  Constant: '<S55>/Constant20'
         *  Switch: '<S73>/Switch2'
         */
        ACCtl_BloweFanSpeed = 100U;
      } else if (rtb_IndexVector8_j < 100) {
        /* Switch: '<S73>/Switch' incorporates:
         *  Constant: '<S55>/Constant19'
         *  SignalConversion generated from: '<S55>/ACCtl_BloweFanSpeed'
         *  Switch: '<S73>/Switch2'
         */
        ACCtl_BloweFanSpeed = 0U;
      } else {
        /* SignalConversion generated from: '<S55>/ACCtl_BloweFanSpeed' incorporates:
         *  Switch: '<S73>/Switch'
         *  Switch: '<S73>/Switch2'
         */
        ACCtl_BloweFanSpeed = (uint8)(rtb_IndexVector8_j + -100);
      }

      /* End of Switch: '<S73>/Switch2' */

      /* Switch: '<S57>/Switch' incorporates:
       *  Merge generated from: '<S53>/Merge'
       *  SignalConversion generated from: '<S55>/ACCtl_BloweFanSpdManual'
       *  SignalConversion generated from: '<S55>/ACCtl_FanLevel'
       */
      ME11_ARID_DEF.AC_FanLevel = HMICtl_eBlwSts;
    }

    /* End of Logic: '<S53>/NOT' */
    /* End of Outputs for SubSystem: '<S53>/ManualMode' */

    /* Merge generated from: '<S42>/Merge' incorporates:
     *  SignalConversion generated from: '<S49>/AC_AutoFanLeVel'
     */
    AC_FanLeVel = ME11_ARID_DEF.AC_FanLevel;

    /* Merge generated from: '<S42>/Merge' incorporates:
     *  SignalConversion generated from: '<S49>/AC_FanLeVel_mp'
     */
    AC_FanLevelAct = ME11_ARID_DEF.AC_FanLevel;
  }

  /* End of Outputs for SubSystem: '<S42>/BlowerFanSpeedCalEnable' */

  /* Switch: '<S926>/Switch' incorporates:
   *  Constant: '<S926>/Constant1'
   *  Constant: '<S926>/Constant2'
   *  Constant: '<S926>/Constant3'
   *  Constant: '<S926>/Constant8'
   *  MultiPortSwitch: '<S926>/Index Vector1'
   *  MultiPortSwitch: '<S926>/Index Vector2'
   *  RelationalOperator: '<S926>/Relational Operator'
   *  RelationalOperator: '<S926>/Relational Operator1'
   *  Switch: '<S926>/Switch1'
   */
  if (cal_LTRFanCtrl_1X[0] > ACSen_sMotTempFilter) {
    /* Switch: '<S926>/Switch' incorporates:
     *  Constant: '<S926>/Constant4'
     *  Constant: '<S926>/Constant5'
     *  MultiPortSwitch: '<S926>/Index Vector3'
     */
    rtb_Add4_ox = cal_LTRFanCtrl_1Y[0];
  } else if (ACSen_sMotTempFilter >= cal_LTRFanCtrl_1X[1]) {
    /* Switch: '<S926>/Switch1' incorporates:
     *  Constant: '<S926>/Constant6'
     *  Constant: '<S926>/Constant7'
     *  MultiPortSwitch: '<S926>/Index Vector4'
     *  Switch: '<S926>/Switch'
     */
    rtb_Add4_ox = cal_LTRFanCtrl_1Y[2];
  } else {
    /* Switch: '<S926>/Switch' incorporates:
     *  Constant: '<S926>/Constant10'
     *  Constant: '<S926>/Constant9'
     *  MultiPortSwitch: '<S926>/Index Vector5'
     *  Switch: '<S926>/Switch1'
     */
    rtb_Add4_ox = cal_LTRFanCtrl_1Y[1];
  }

  /* End of Switch: '<S926>/Switch' */

  /* Sum: '<S1675>/Add' incorporates:
   *  Constant: '<S1675>/Constant2'
   *  Constant: '<S1675>/Constant3'
   *  Product: '<S1675>/Divide'
   */
  SOMCtl_sF1Value = ACSen_sEnvTempCor * cal_CabinModeTransF1Slope +
    cal_CabinModeTransF1Constant;

  /* Chart: '<S1677>/Chart' incorporates:
   *  Constant: '<S1677>/Constant'
   *  Constant: '<S1677>/Constant1'
   *  Constant: '<S1677>/Constant2'
   *  Constant: '<S1677>/Constant7'
   *  Constant: '<S1677>/Constant8'
   *  Constant: '<S1677>/Constant9'
   *  Logic: '<S1677>/AND'
   *  Logic: '<S1677>/AND1'
   *  Logic: '<S1677>/AND2'
   *  Logic: '<S1677>/AND3'
   *  Logic: '<S1677>/AND4'
   *  Logic: '<S1677>/AND5'
   *  RelationalOperator: '<S1677>/Relational Operator'
   *  RelationalOperator: '<S1677>/Relational Operator1'
   *  RelationalOperator: '<S1677>/Relational Operator2'
   *  RelationalOperator: '<S1677>/Relational Operator3'
   *  RelationalOperator: '<S1677>/Relational Operator4'
   *  RelationalOperator: '<S1677>/Relational Operator5'
   *  RelationalOperator: '<S1677>/Relational Operator6'
   *  RelationalOperator: '<S1677>/Relational Operator7'
   *  Sum: '<S1677>/Add'
   *  Sum: '<S1677>/Add2'
   *  Sum: '<S1677>/Add3'
   *  UnitDelay: '<S225>/FixPt Unit Delay1'
   */
  if (ME11_ARID_DEF.is_active_c14_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c14_ME11 = 1U;
    ME11_ARID_DEF.is_c14_ME11 = ME11_IN_Off_a;
    SOMCtl_bMD1CLMSts = false;
  } else if (ME11_ARID_DEF.is_c14_ME11 == ME11_IN_Off_a) {
    SOMCtl_bMD1CLMSts = false;
    if (((cal_tCabinCoolEnvTempLow <= ACSen_sEnvTempCor) && (ACSen_sEnvTempCor <
          cal_tCabinCoolEnvTempHigh) && (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn
          < SOMCtl_sF1Value)) || (cal_tCabinCoolEnvTempHigh <= ACSen_sEnvTempCor))
    {
      ME11_ARID_DEF.is_c14_ME11 = ME11_IN_On_li;
      SOMCtl_bMD1CLMSts = true;
    }
  } else {
    /* case IN_On: */
    SOMCtl_bMD1CLMSts = true;

    /* Sum: '<S1677>/Add' incorporates:
     *  Constant: '<S1677>/Constant3'
     *  Constant: '<S1677>/Constant4'
     *  Sum: '<S1677>/Add1'
     */
    rtb_Add_ok = cal_tCabinCoolEnvTempLow - cal_CabinHys1TempOffset;
    if ((rtb_Add_ok > ACSen_sEnvTempCor) || ((rtb_Add_ok <= ACSen_sEnvTempCor) &&
         (ACSen_sEnvTempCor < cal_tCabinCoolEnvTempHigh -
          cal_CabinHys1TempOffset) && (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn >=
          SOMCtl_sF1Value + cal_CabinHys2TempOffset))) {
      ME11_ARID_DEF.is_c14_ME11 = ME11_IN_Off_a;
      SOMCtl_bMD1CLMSts = false;
    }
  }

  /* End of Chart: '<S1677>/Chart' */

  /* Sum: '<S1675>/Add1' incorporates:
   *  Constant: '<S1675>/Constant1'
   *  Constant: '<S1675>/Constant4'
   *  Product: '<S1675>/Divide1'
   */
  SOMCtl_sF2Value = ACSen_sEnvTempCor * cal_CabinModeTransF2Slope +
    cal_CabinModeTransF2Constant;

  /* Chart: '<S1678>/MD2_DHMD1' incorporates:
   *  Constant: '<S1697>/Constant'
   *  Constant: '<S1697>/Constant1'
   *  Constant: '<S1698>/Constant10'
   *  Constant: '<S1698>/Constant9'
   *  Constant: '<S1699>/Constant8'
   *  Constant: '<S1700>/Constant11'
   *  Constant: '<S1700>/Constant12'
   *  Constant: '<S1700>/Constant15'
   *  Logic: '<S1694>/AND8'
   *  Logic: '<S1695>/AND1'
   *  Logic: '<S1697>/AND'
   *  Logic: '<S1697>/AND1'
   *  Logic: '<S1697>/AND5'
   *  Logic: '<S1698>/AND6'
   *  Logic: '<S1698>/AND7'
   *  Logic: '<S1699>/AND2'
   *  Logic: '<S1699>/AND3'
   *  Logic: '<S1699>/AND4'
   *  Logic: '<S1700>/AND10'
   *  Logic: '<S1700>/AND9'
   *  RelationalOperator: '<S1697>/Relational Operator'
   *  RelationalOperator: '<S1697>/Relational Operator1'
   *  RelationalOperator: '<S1697>/Relational Operator2'
   *  RelationalOperator: '<S1697>/Relational Operator7'
   *  RelationalOperator: '<S1698>/Relational Operator10'
   *  RelationalOperator: '<S1698>/Relational Operator8'
   *  RelationalOperator: '<S1698>/Relational Operator9'
   *  RelationalOperator: '<S1699>/Relational Operator3'
   *  RelationalOperator: '<S1699>/Relational Operator4'
   *  RelationalOperator: '<S1699>/Relational Operator5'
   *  RelationalOperator: '<S1699>/Relational Operator6'
   *  RelationalOperator: '<S1700>/Relational Operator11'
   *  RelationalOperator: '<S1700>/Relational Operator12'
   *  RelationalOperator: '<S1700>/Relational Operator13'
   *  RelationalOperator: '<S1701>/Relational Operator11'
   *  Sum: '<S1699>/Add'
   *  Sum: '<S1699>/Add1'
   *  Sum: '<S1699>/Add3'
   *  Sum: '<S1700>/Add5'
   *  Sum: '<S1700>/Add6'
   *  UnitDelay: '<S225>/FixPt Unit Delay1'
   */
  if (ME11_ARID_DEF.is_active_c15_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c15_ME11 = 1U;
    ME11_ARID_DEF.is_c15_ME11 = ME11_IN_Off_a;
    SOMCtl_bMD2DHMD1Flg = false;
  } else if (ME11_ARID_DEF.is_c15_ME11 == ME11_IN_Off_a) {
    SOMCtl_bMD2DHMD1Flg = false;
    if (((cal_tCabinCoolEnvTempLow <= ACSen_sEnvTempCor) && (ACSen_sEnvTempCor <
          cal_CabinMD2F2MaxEnvTemp) && ((SOMCtl_sF2Value >=
           ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn) &&
          (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn >= SOMCtl_sF1Value))) ||
        ((cal_tCabinCoolEnvTempHigh > ACSen_sEnvTempCor) && (ACSen_sEnvTempCor >=
          cal_CabinMD2F2MaxEnvTemp) && (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn <=
          SOMCtl_sF1Value))) {
      ME11_ARID_DEF.is_c15_ME11 = ME11_IN_On_li;
      SOMCtl_bMD2DHMD1Flg = true;
    }
  } else {
    /* case IN_On: */
    SOMCtl_bMD2DHMD1Flg = true;

    /* Sum: '<S1699>/Add' incorporates:
     *  Constant: '<S1699>/Constant2'
     *  Constant: '<S1699>/Constant4'
     *  Sum: '<S1699>/Add2'
     */
    rtb_Add_ok = cal_tCabinCoolEnvTempHigh + cal_CabinHys1TempOffset;

    /* Sum: '<S1699>/Add1' incorporates:
     *  Constant: '<S1699>/Constant5'
     *  Constant: '<S1699>/Constant6'
     *  Sum: '<S1700>/Add4'
     *  Sum: '<S1701>/Add4'
     */
    rtb_Delay1_ie = cal_tCabinCoolEnvTempLow - cal_CabinHys1TempOffset;
    if ((rtb_Add_ok <= ACSen_sEnvTempCor) || ((rtb_Delay1_ie <=
          ACSen_sEnvTempCor) && (ACSen_sEnvTempCor < rtb_Add_ok) &&
         (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn < SOMCtl_sF1Value -
          cal_CabinHys2TempOffset)) || ((rtb_Delay1_ie <= ACSen_sEnvTempCor) &&
         (ACSen_sEnvTempCor < cal_CabinMD2F2MaxEnvTemp - cal_CabinHys1TempOffset)
         && (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn >= SOMCtl_sF2Value +
             cal_CabinHys2TempOffset)) || (rtb_Delay1_ie > ACSen_sEnvTempCor)) {
      ME11_ARID_DEF.is_c15_ME11 = ME11_IN_Off_a;
      SOMCtl_bMD2DHMD1Flg = false;
    }
  }

  /* End of Chart: '<S1678>/MD2_DHMD1' */

  /* Chart: '<S1680>/MD3_DHMD2' incorporates:
   *  Constant: '<S1709>/Constant'
   *  Constant: '<S1709>/Constant1'
   *  Constant: '<S1713>/Constant12'
   *  Logic: '<S1709>/AND'
   *  Logic: '<S1709>/AND1'
   *  Logic: '<S1710>/AND1'
   *  Logic: '<S1713>/AND10'
   *  Logic: '<S1713>/AND9'
   *  RelationalOperator: '<S1709>/Relational Operator'
   *  RelationalOperator: '<S1709>/Relational Operator1'
   *  RelationalOperator: '<S1709>/Relational Operator2'
   *  RelationalOperator: '<S1712>/Relational Operator4'
   *  RelationalOperator: '<S1713>/Relational Operator11'
   *  RelationalOperator: '<S1713>/Relational Operator12'
   *  RelationalOperator: '<S1713>/Relational Operator13'
   *  RelationalOperator: '<S1714>/Relational Operator11'
   *  Sum: '<S1712>/Add1'
   *  Sum: '<S1713>/Add5'
   *  Sum: '<S1713>/Add6'
   *  UnitDelay: '<S225>/FixPt Unit Delay1'
   */
  if (ME11_ARID_DEF.is_active_c16_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c16_ME11 = 1U;
    ME11_ARID_DEF.is_c16_ME11 = ME11_IN_Off_a;
    SOMCtl_bMD3DHMD2Flg = false;
  } else if (ME11_ARID_DEF.is_c16_ME11 == ME11_IN_Off_a) {
    SOMCtl_bMD3DHMD2Flg = false;
    if ((cal_tCabinCoolEnvTempLow <= ACSen_sEnvTempCor) && (ACSen_sEnvTempCor <
         cal_CabinMD2F2MaxEnvTemp) && (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn >=
         SOMCtl_sF2Value)) {
      ME11_ARID_DEF.is_c16_ME11 = ME11_IN_On_li;
      SOMCtl_bMD3DHMD2Flg = true;
    }
  } else {
    /* case IN_On: */
    SOMCtl_bMD3DHMD2Flg = true;

    /* Sum: '<S1712>/Add1' incorporates:
     *  Constant: '<S1712>/Constant5'
     *  Constant: '<S1712>/Constant6'
     *  Sum: '<S1713>/Add4'
     */
    rtb_Add_ok = cal_tCabinCoolEnvTempLow - cal_CabinHys1TempOffset;

    /* Sum: '<S1713>/Add5' incorporates:
     *  Constant: '<S1713>/Constant11'
     *  Constant: '<S1713>/Constant15'
     *  Sum: '<S1714>/Add4'
     */
    rtb_Delay1_ie = cal_CabinMD2F2MaxEnvTemp + cal_CabinHys1TempOffset;
    if ((rtb_Add_ok > ACSen_sEnvTempCor) || ((rtb_Add_ok <= ACSen_sEnvTempCor) &&
         (ACSen_sEnvTempCor < rtb_Delay1_ie) &&
         (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn < SOMCtl_sF2Value -
          cal_CabinHys2TempOffset)) || (rtb_Delay1_ie <= ACSen_sEnvTempCor)) {
      ME11_ARID_DEF.is_c16_ME11 = ME11_IN_Off_a;
      SOMCtl_bMD3DHMD2Flg = false;
    }
  }

  /* End of Chart: '<S1680>/MD3_DHMD2' */

  /* Chart: '<S1682>/MD2_DHMD1' incorporates:
   *  Constant: '<S1682>/Constant1'
   *  Constant: '<S1682>/Constant5'
   *  Constant: '<S1682>/Constant6'
   *  RelationalOperator: '<S1682>/Relational Operator1'
   *  RelationalOperator: '<S1682>/Relational Operator4'
   *  Sum: '<S1682>/Add1'
   */
  if (ME11_ARID_DEF.is_active_c17_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c17_ME11 = 1U;
    ME11_ARID_DEF.is_c17_ME11 = ME11_IN_Off_a;
    rtb_AND1_hh = false;
  } else if (ME11_ARID_DEF.is_c17_ME11 == ME11_IN_Off_a) {
    rtb_AND1_hh = false;
    if (cal_tCabinCoolEnvTempLow > ACSen_sEnvTempCor) {
      ME11_ARID_DEF.is_c17_ME11 = ME11_IN_On_li;
      rtb_AND1_hh = true;
    }
  } else {
    /* case IN_On: */
    rtb_AND1_hh = true;
    if (cal_tCabinCoolEnvTempLow + cal_CabinHys1TempOffset <= ACSen_sEnvTempCor)
    {
      ME11_ARID_DEF.is_c17_ME11 = ME11_IN_Off_a;
      rtb_AND1_hh = false;
    }
  }

  /* End of Chart: '<S1682>/MD2_DHMD1' */

  /* Gain: '<S8>/Gain8' incorporates:
   *  Sum: '<S1676>/Add2'
   *  UnitDelay: '<S225>/FixPt Unit Delay1'
   */
  rtb_Delay1_ie = ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn - ACCtl_tLeftDuct;

  /* DataTypeConversion: '<S8>/Data Type Conversion16' incorporates:
   *  Constant: '<S1687>/Constant'
   *  RelationalOperator: '<S1687>/Compare'
   */
  rtb_FixPtRelationalOperator_a0 = (rtb_Delay1_ie < cal_tCabinCondToCoolDvtDiff);

  /* Delay: '<S1676>/Delay1' */
  rtb_Delay_j3 = ME11_ARID_DEF.Delay1_DSTATE_b;

  /* Gain: '<S1285>/Gain' incorporates:
   *  ArithShift: '<S22>/Shift Arithmetic'
   *  DataTypeConversion: '<S22>/Data Type Conversion'
   *  Inport: '<Root>/HP_EXV_CurrentPosition_B'
   *
   * Block description for '<Root>/HP_EXV_CurrentPosition_B':
   *  CurrentPosition
   */
  rtb_Divide_ox =
    Rte_IRead_Task_100ms_HP_EXV_CurrentPosition_B_HP_EXV_CurrentPosition_B();

  /* Gain: '<S1285>/Gain' incorporates:
   *  Inport: '<Root>/HP_EXV_CurrentPosition_B'
   *
   * Block description for '<Root>/HP_EXV_CurrentPosition_B':
   *  CurrentPosition
   */
  HP_EXV_CurrentPosition_B = 0.15625F * (float32)rtb_Divide_ox;

  /* Logic: '<S1676>/OR3' incorporates:
   *  Constant: '<S1688>/Constant'
   *  Delay: '<S1676>/Delay1'
   *  Logic: '<S1676>/OR1'
   *  Logic: '<S1676>/OR2'
   *  RelationalOperator: '<S1688>/Compare'
   */
  rtb_Compare_mgx = (rtb_FixPtRelationalOperator_a0 &&
                     (ME11_ARID_DEF.Delay1_DSTATE_b && SOMCtl_bMD1CLMSts &&
                      (HP_EXV_CurrentPosition_B >= cal_CabinCondToCoolHPEXVPos1)));

  /* Chart: '<S1676>/A' */
  if (ME11_ARID_DEF.temporalCounter_i1_dt < 1023U) {
    ME11_ARID_DEF.temporalCounter_i1_dt++;
  }

  if (ME11_ARID_DEF.is_active_c19_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c19_ME11 = 1U;
    ME11_ARID_DEF.is_c19_ME11 = ME11_IN_Off_a;
    ME11_ARID_DEF.SOMCtl_Two2OneA = false;
  } else {
    switch (ME11_ARID_DEF.is_c19_ME11) {
     case ME11_IN_Off_a:
      ME11_ARID_DEF.SOMCtl_Two2OneA = false;
      if (rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c19_ME11 = ME11_IN_Wait_c;
        ME11_ARID_DEF.temporalCounter_i1_dt = 0U;
      }
      break;

     case ME11_IN_On_li:
      ME11_ARID_DEF.SOMCtl_Two2OneA = true;
      if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c19_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.SOMCtl_Two2OneA = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_dt >= 600U) {
        ME11_ARID_DEF.is_c19_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.SOMCtl_Two2OneA = true;
      } else if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c19_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.SOMCtl_Two2OneA = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1676>/A' */

  /* Logic: '<S1676>/OR6' incorporates:
   *  Constant: '<S1689>/Constant'
   *  Constant: '<S1690>/Constant'
   *  Logic: '<S1676>/OR4'
   *  Logic: '<S1676>/OR5'
   *  RelationalOperator: '<S1689>/Compare'
   *  RelationalOperator: '<S1690>/Compare'
   */
  rtb_Compare_mgx = ((HP_EXV_CurrentPosition_B <= cal_CabinCondToCoolHPEXVPos2) &&
                     rtb_FixPtRelationalOperator_a0 && (SOMCtl_bMD1CLMSts &&
    (ACSen_sEvapSurTemp <= cal_tCabinCondToCoolEvapTemp)));

  /* Chart: '<S1676>/B' */
  if (ME11_ARID_DEF.temporalCounter_i1_h2 < 511U) {
    ME11_ARID_DEF.temporalCounter_i1_h2++;
  }

  if (ME11_ARID_DEF.is_active_c20_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c20_ME11 = 1U;
    ME11_ARID_DEF.is_c20_ME11 = ME11_IN_Off_a;
    ME11_ARID_DEF.SOMCtl_Two2OneB = false;
  } else {
    switch (ME11_ARID_DEF.is_c20_ME11) {
     case ME11_IN_Off_a:
      ME11_ARID_DEF.SOMCtl_Two2OneB = false;
      if (rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c20_ME11 = ME11_IN_Wait_c;
        ME11_ARID_DEF.temporalCounter_i1_h2 = 0U;
      }
      break;

     case ME11_IN_On_li:
      ME11_ARID_DEF.SOMCtl_Two2OneB = true;
      if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c20_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.SOMCtl_Two2OneB = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_h2 >= 300U) {
        ME11_ARID_DEF.is_c20_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.SOMCtl_Two2OneB = true;
      } else if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c20_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.SOMCtl_Two2OneB = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1676>/B' */

  /* Logic: '<S1676>/OR7' */
  SOMCtl_bMD2ToMD1Flg = (ME11_ARID_DEF.SOMCtl_Two2OneA ||
    ME11_ARID_DEF.SOMCtl_Two2OneB);

  /* Logic: '<S1676>/OR11' incorporates:
   *  Constant: '<S1691>/Constant'
   *  Constant: '<S1692>/Constant'
   *  Delay: '<S1676>/Delay'
   *  Logic: '<S1676>/NOT1'
   *  Logic: '<S1676>/OR10'
   *  Logic: '<S1676>/OR9'
   *  RelationalOperator: '<S1691>/Compare'
   *  RelationalOperator: '<S1692>/Compare'
   */
  rtb_Compare_mgx = (ME11_ARID_DEF.Delay_DSTATE_he && (rtb_Delay1_ie >
    cal_tCabinCoolToCondDvtDiff) && ((ACSen_sMixDoorPerc >
    cal_rCabinCoolToCondMixDoor) && (!SOMCtl_bMD2DHMD1Flg)));

  /* Chart: '<S1676>/C' */
  if (ME11_ARID_DEF.temporalCounter_i1_en < 1023U) {
    ME11_ARID_DEF.temporalCounter_i1_en++;
  }

  if (ME11_ARID_DEF.is_active_c21_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c21_ME11 = 1U;
    ME11_ARID_DEF.is_c21_ME11 = ME11_IN_Off_a;
    SOMCtl_bMD1ToMD2Flg = false;
  } else {
    switch (ME11_ARID_DEF.is_c21_ME11) {
     case ME11_IN_Off_a:
      SOMCtl_bMD1ToMD2Flg = false;
      if (rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c21_ME11 = ME11_IN_Wait_c;
        ME11_ARID_DEF.temporalCounter_i1_en = 0U;
      }
      break;

     case ME11_IN_On_li:
      SOMCtl_bMD1ToMD2Flg = true;
      if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c21_ME11 = ME11_IN_Off_a;
        SOMCtl_bMD1ToMD2Flg = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_en >= 600U) {
        ME11_ARID_DEF.is_c21_ME11 = ME11_IN_On_li;
        SOMCtl_bMD1ToMD2Flg = true;
      } else if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c21_ME11 = ME11_IN_Off_a;
        SOMCtl_bMD1ToMD2Flg = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1676>/C' */

  /* SignalConversion: '<S2>/Signal Copy122' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_EcompActSpd = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPEcompActSpd_rpm;

  /* DataTypeConversion: '<S8>/Data Type Conversion16' incorporates:
   *  Constant: '<S1706>/Constant'
   *  RelationalOperator: '<S1706>/Compare'
   */
  rtb_FixPtRelationalOperator_a0 = (COMP_EcompActSpd < cal_CabinEvpToCondCompLmt);

  /* Logic: '<S1679>/OR3' incorporates:
   *  Constant: '<S1704>/Constant'
   *  Constant: '<S1705>/Constant'
   *  Delay: '<S1679>/Delay'
   *  Logic: '<S1679>/OR'
   *  Logic: '<S1679>/OR1'
   *  Logic: '<S1679>/OR2'
   *  RelationalOperator: '<S1704>/Compare'
   *  RelationalOperator: '<S1705>/Compare'
   *  Sum: '<S1679>/Add1'
   *  Sum: '<S1679>/Add2'
   *  UnitDelay: '<S225>/FixPt Unit Delay1'
   */
  rtb_Compare_mgx = (((ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn -
                       ACSen_sFaceDuctTempFilter < cal_tCabinEvpToCondDvtDiff) ||
                      (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn -
                       ACSen_sFootDuctTempFilter < cal_tCabinEvpToCondDvtDiff)) &&
                     (ME11_ARID_DEF.Delay_DSTATE_d2 && SOMCtl_bMD2DHMD1Flg &&
                      rtb_FixPtRelationalOperator_a0));

  /* Chart: '<S1679>/A' */
  if (ME11_ARID_DEF.temporalCounter_i1_e < 511U) {
    ME11_ARID_DEF.temporalCounter_i1_e++;
  }

  if (ME11_ARID_DEF.is_active_c22_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c22_ME11 = 1U;
    ME11_ARID_DEF.is_c22_ME11 = ME11_IN_Off_a;
    SOMCtl_bMD3ToMD2Flg = false;
  } else {
    switch (ME11_ARID_DEF.is_c22_ME11) {
     case ME11_IN_Off_a:
      SOMCtl_bMD3ToMD2Flg = false;
      if (rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c22_ME11 = ME11_IN_Wait_c;
        ME11_ARID_DEF.temporalCounter_i1_e = 0U;
      }
      break;

     case ME11_IN_On_li:
      SOMCtl_bMD3ToMD2Flg = true;
      if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c22_ME11 = ME11_IN_Off_a;
        SOMCtl_bMD3ToMD2Flg = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_e >= 300U) {
        ME11_ARID_DEF.is_c22_ME11 = ME11_IN_On_li;
        SOMCtl_bMD3ToMD2Flg = true;
      } else if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c22_ME11 = ME11_IN_Off_a;
        SOMCtl_bMD3ToMD2Flg = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1679>/A' */

  /* Logic: '<S1679>/OR6' incorporates:
   *  Constant: '<S1707>/Constant'
   *  Constant: '<S1708>/Constant'
   *  Logic: '<S1679>/OR4'
   *  Logic: '<S1679>/OR5'
   *  RelationalOperator: '<S1707>/Compare'
   *  RelationalOperator: '<S1708>/Compare'
   */
  rtb_Compare_mgx = (rtb_FixPtRelationalOperator_a0 && SOMCtl_bMD3DHMD2Flg &&
                     ((HP_EXV_CurrentPosition_B > cal_CabinCondToEvpHPEXVPos) &&
                      (ACSen_sEvapSurTemp <= cal_tCabinCondToEvpEvapTemp)));

  /* Chart: '<S1679>/B' */
  if (ME11_ARID_DEF.temporalCounter_i1_dj < 511U) {
    ME11_ARID_DEF.temporalCounter_i1_dj++;
  }

  if (ME11_ARID_DEF.is_active_c23_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c23_ME11 = 1U;
    ME11_ARID_DEF.is_c23_ME11 = ME11_IN_Off_a;
    SOMCtl_bMD2ToMD3Flg = false;
  } else {
    switch (ME11_ARID_DEF.is_c23_ME11) {
     case ME11_IN_Off_a:
      SOMCtl_bMD2ToMD3Flg = false;
      if (rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c23_ME11 = ME11_IN_Wait_c;
        ME11_ARID_DEF.temporalCounter_i1_dj = 0U;
      }
      break;

     case ME11_IN_On_li:
      SOMCtl_bMD2ToMD3Flg = true;
      if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c23_ME11 = ME11_IN_Off_a;
        SOMCtl_bMD2ToMD3Flg = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_dj >= 300U) {
        ME11_ARID_DEF.is_c23_ME11 = ME11_IN_On_li;
        SOMCtl_bMD2ToMD3Flg = true;
      } else if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c23_ME11 = ME11_IN_Off_a;
        SOMCtl_bMD2ToMD3Flg = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1679>/B' */

  /* Logic: '<S1681>/OR3' incorporates:
   *  Constant: '<S1717>/Constant'
   *  Constant: '<S1718>/Constant'
   *  Logic: '<S1681>/OR2'
   *  RelationalOperator: '<S1717>/Compare'
   *  RelationalOperator: '<S1718>/Compare'
   */
  rtb_Compare_mgx = ((ACSen_sEnvTempCor > cal_tCabinHPToEvpEnvTemp) &&
                     ((ACSen_eAirInletPer > cal_rCabinHPToEvpInnRatio) &&
                      SOMCtl_bMD3DHMD2Flg));

  /* Chart: '<S1681>/A' */
  if (ME11_ARID_DEF.temporalCounter_i1_ng < 511U) {
    ME11_ARID_DEF.temporalCounter_i1_ng++;
  }

  if (ME11_ARID_DEF.is_active_c24_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c24_ME11 = 1U;
    ME11_ARID_DEF.is_c24_ME11 = ME11_IN_Off_a;
    SOMCtl_bMD4ToMD3Flg = false;
  } else {
    switch (ME11_ARID_DEF.is_c24_ME11) {
     case ME11_IN_Off_a:
      SOMCtl_bMD4ToMD3Flg = false;
      if (rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c24_ME11 = ME11_IN_Wait_c;
        ME11_ARID_DEF.temporalCounter_i1_ng = 0U;
      }
      break;

     case ME11_IN_On_li:
      SOMCtl_bMD4ToMD3Flg = true;
      if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c24_ME11 = ME11_IN_Off_a;
        SOMCtl_bMD4ToMD3Flg = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_ng >= 300U) {
        ME11_ARID_DEF.is_c24_ME11 = ME11_IN_On_li;
        SOMCtl_bMD4ToMD3Flg = true;
      } else if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c24_ME11 = ME11_IN_Off_a;
        SOMCtl_bMD4ToMD3Flg = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1681>/A' */

  /* Logic: '<S1681>/OR6' incorporates:
   *  Constant: '<S1719>/Constant'
   *  Constant: '<S1720>/Constant'
   *  Logic: '<S1681>/OR5'
   *  RelationalOperator: '<S1719>/Compare'
   *  RelationalOperator: '<S1720>/Compare'
   */
  rtb_Compare_mgx = ((ACSen_eAirInletPer < cal_rCabinEvpToHPInnRatio) &&
                     (rtb_AND1_hh && (ACSen_sEnvTempCor <
    cal_CabinEvpToHPEnvTemp)));

  /* Chart: '<S1681>/B' */
  if (ME11_ARID_DEF.temporalCounter_i1_p < 511U) {
    ME11_ARID_DEF.temporalCounter_i1_p++;
  }

  if (ME11_ARID_DEF.is_active_c25_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c25_ME11 = 1U;
    ME11_ARID_DEF.is_c25_ME11 = ME11_IN_Off_a;
    SOMCtl_bMD3ToMD4Flg = false;
  } else {
    switch (ME11_ARID_DEF.is_c25_ME11) {
     case ME11_IN_Off_a:
      SOMCtl_bMD3ToMD4Flg = false;
      if (rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c25_ME11 = ME11_IN_Wait_c;
        ME11_ARID_DEF.temporalCounter_i1_p = 0U;
      }
      break;

     case ME11_IN_On_li:
      SOMCtl_bMD3ToMD4Flg = true;
      if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c25_ME11 = ME11_IN_Off_a;
        SOMCtl_bMD3ToMD4Flg = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_p >= 300U) {
        ME11_ARID_DEF.is_c25_ME11 = ME11_IN_On_li;
        SOMCtl_bMD3ToMD4Flg = true;
      } else if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c25_ME11 = ME11_IN_Off_a;
        SOMCtl_bMD3ToMD4Flg = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1681>/B' */

  /* Switch: '<S32>/Switch' incorporates:
   *  Inport: '<Root>/Bcm2VcuTms_outputs'
   */
  if ((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
      ->BCM_SysPwrModeV > 0) {
    /* Switch: '<S32>/Switch' */
    rtb_Add_b1 = (Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs()
      )->BCM_SysPwrMode;
  } else {
    /* Switch: '<S32>/Switch' incorporates:
     *  Constant: '<S32>/Constant'
     */
    rtb_Add_b1 = 0U;
  }

  /* End of Switch: '<S32>/Switch' */

  /* Chart: '<S1312>/CabinMode' */
  if (ME11_ARID_DEF.is_active_c18_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c18_ME11 = 1U;

    /*
       0:Off
       1:Cool
       2:
       3:
       4:
       6:
       7:Standby
     */
    ME11_ARID_DEF.is_c18_ME11 = ME11_IN_Off_a;
    rtb_IndexVector8_j = 0U;
  } else if (ME11_ARID_DEF.is_c18_ME11 == ME11_IN_Off_a) {
    rtb_IndexVector8_j = 0U;
    if (ME11_ARID_DEF.Switch_c && (ME11_ARID_DEF.DataTypeConversion1 >= 2) &&
        (rtb_Add_b1 == 2)) {
      ME11_ARID_DEF.is_c18_ME11 = ME11_IN_On_li;
      ME11_ARID_DEF.is_On = ME11_IN_Standby;
      rtb_IndexVector8_j = 7U;
    }

    /* case IN_On: */
  } else if ((!ME11_ARID_DEF.Switch_c) || (ME11_ARID_DEF.DataTypeConversion1 <=
              1) || (rtb_Add_b1 != 2)) {
    ME11_ARID_DEF.is_Work = ME11_IN_NO_ACTIVE_CHILD_gl;
    ME11_ARID_DEF.is_On = ME11_IN_NO_ACTIVE_CHILD_gl;
    ME11_ARID_DEF.is_c18_ME11 = ME11_IN_Off_a;
    rtb_IndexVector8_j = 0U;
  } else {
    switch (ME11_ARID_DEF.is_On) {
     case ME11_IN_MD5:
      rtb_IndexVector8_j = 6U;
      if (HMICtl_eACSts != 3) {
        ME11_ARID_DEF.is_On = ME11_IN_Standby;
        rtb_IndexVector8_j = 7U;
      }
      break;

     case ME11_IN_Standby:
      rtb_IndexVector8_j = 7U;
      if (HMICtl_eACSts == 3) {
        ME11_ARID_DEF.is_On = ME11_IN_MD5;
        rtb_IndexVector8_j = 6U;
      } else if (SOMCtl_bMD1CLMSts) {
        ME11_ARID_DEF.is_On = ME11_IN_Work;
        ME11_ARID_DEF.is_Work = ME11_IN_MD1;
        rtb_IndexVector8_j = 1U;
      } else if (SOMCtl_bMD2DHMD1Flg) {
        ME11_ARID_DEF.is_On = ME11_IN_Work;
        ME11_ARID_DEF.is_Work = ME11_IN_MD2;
        rtb_IndexVector8_j = 2U;
      } else if (SOMCtl_bMD3DHMD2Flg) {
        ME11_ARID_DEF.is_On = ME11_IN_Work;
        ME11_ARID_DEF.is_Work = ME11_IN_MD3;
        rtb_IndexVector8_j = 3U;
      } else if (rtb_AND1_hh) {
        ME11_ARID_DEF.is_On = ME11_IN_Work;
        ME11_ARID_DEF.is_Work = ME11_IN_MD4;
        rtb_IndexVector8_j = 4U;
      }
      break;

     default:
      /* case IN_Work: */
      if (HMICtl_eACSts == 3) {
        ME11_ARID_DEF.is_Work = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_On = ME11_IN_MD5;
        rtb_IndexVector8_j = 6U;
      } else {
        switch (ME11_ARID_DEF.is_Work) {
         case ME11_IN_MD1:
          rtb_IndexVector8_j = 1U;
          if (!SOMCtl_bMD1CLMSts) {
            ME11_ARID_DEF.is_Work = ME11_IN_NO_ACTIVE_CHILD_gl;
            ME11_ARID_DEF.is_On = ME11_IN_Standby;
            rtb_IndexVector8_j = 7U;
          } else if (SOMCtl_bMD1ToMD2Flg) {
            ME11_ARID_DEF.is_Work = ME11_IN_MD2;
            rtb_IndexVector8_j = 2U;
          }
          break;

         case ME11_IN_MD2:
          rtb_IndexVector8_j = 2U;
          if (SOMCtl_bMD2ToMD1Flg) {
            ME11_ARID_DEF.is_Work = ME11_IN_MD1;
            rtb_IndexVector8_j = 1U;
          } else if (SOMCtl_bMD2ToMD3Flg) {
            ME11_ARID_DEF.is_Work = ME11_IN_MD3;
            rtb_IndexVector8_j = 3U;
          } else if (!SOMCtl_bMD2DHMD1Flg) {
            ME11_ARID_DEF.is_Work = ME11_IN_NO_ACTIVE_CHILD_gl;
            ME11_ARID_DEF.is_On = ME11_IN_Standby;
            rtb_IndexVector8_j = 7U;
          }
          break;

         case ME11_IN_MD3:
          rtb_IndexVector8_j = 3U;
          if (SOMCtl_bMD3ToMD2Flg) {
            ME11_ARID_DEF.is_Work = ME11_IN_MD2;
            rtb_IndexVector8_j = 2U;
          } else if (SOMCtl_bMD3ToMD4Flg) {
            ME11_ARID_DEF.is_Work = ME11_IN_MD4;
            rtb_IndexVector8_j = 4U;
          } else if (!SOMCtl_bMD3DHMD2Flg) {
            ME11_ARID_DEF.is_Work = ME11_IN_NO_ACTIVE_CHILD_gl;
            ME11_ARID_DEF.is_On = ME11_IN_Standby;
            rtb_IndexVector8_j = 7U;
          }
          break;

         default:
          /* case IN_MD4: */
          rtb_IndexVector8_j = 4U;
          if (SOMCtl_bMD4ToMD3Flg) {
            ME11_ARID_DEF.is_Work = ME11_IN_MD3;
            rtb_IndexVector8_j = 3U;
          } else if (!rtb_AND1_hh) {
            ME11_ARID_DEF.is_Work = ME11_IN_NO_ACTIVE_CHILD_gl;
            ME11_ARID_DEF.is_On = ME11_IN_Standby;
            rtb_IndexVector8_j = 7U;
          }
          break;
        }
      }
      break;
    }
  }

  /* End of Chart: '<S1312>/CabinMode' */

  /* Chart: '<S1683>/KeepStandby' incorporates:
   *  Constant: '<S1683>/Constant2'
   *  Constant: '<S1683>/Constant3'
   *  Constant: '<S1723>/Constant'
   *  Logic: '<S1683>/AND1'
   *  Logic: '<S1683>/AND2'
   *  Product: '<S1683>/Divide'
   *  RelationalOperator: '<S1723>/Compare'
   *  RelationalOperator: '<S1724>/FixPt Relational Operator'
   *  UnitDelay: '<S1724>/Delay Input1'
   *
   * Block description for '<S1724>/Delay Input1':
   *
   *  Store in Global RAM
   */
  if (ME11_ARID_DEF.is_active_c38_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c38_ME11 = 1U;
    ME11_ARID_DEF.is_c38_ME11 = ME11_IN_Init_i;
    ME11_ARID_DEF.ModeSts = rtb_IndexVector8_j;
  } else if (ME11_ARID_DEF.is_c38_ME11 == ME11_IN_Init_i) {
    if ((rtb_IndexVector8_j != ME11_ARID_DEF.DelayInput1_DSTATE_h) &&
        ((rtb_IndexVector8_j != 0) || (rtb_IndexVector8_j != 7))) {
      ME11_ARID_DEF.is_c38_ME11 = ME11_IN_Wait_o;
      ME11_ARID_DEF.ModeSts = 7U;
      ME11_ARID_DEF.Counter_b = 0U;
    } else {
      ME11_ARID_DEF.ModeSts = rtb_IndexVector8_j;
    }

    /* case IN_Wait: */
  } else if (ME11_ARID_DEF.Counter_b >= (uint32)(cal_CabinModeKeepStandbyTime *
              600.0F)) {
    ME11_ARID_DEF.is_c38_ME11 = ME11_IN_Init_i;
    ME11_ARID_DEF.ModeSts = rtb_IndexVector8_j;
  } else {
    rtb_Divide1_f = ME11_ARID_DEF.Counter_b + /*MW:OvSatOk*/ 1U;
    if (ME11_ARID_DEF.Counter_b + 1U < ME11_ARID_DEF.Counter_b) {
      rtb_Divide1_f = MAX_uint32_T;
    }

    ME11_ARID_DEF.Counter_b = rtb_Divide1_f;
  }

  /* End of Chart: '<S1683>/KeepStandby' */

  /* Switch: '<S1726>/Switch' incorporates:
   *  Constant: '<S1683>/Constant'
   *  Constant: '<S1726>/Constant1'
   *  Logic: '<S1683>/AND'
   *  RelationalOperator: '<S1722>/Compare'
   *  Switch: '<S1683>/Switch'
   */
  if (cal_CabinModeEnb) {
    /* Switch: '<S1726>/Switch' incorporates:
     *  Constant: '<S1726>/Constant'
     */
    SOMCtl_eCabinMode = cal_CabinModeData;
  } else if (ME11_ARID_DEF.OutportBufferForHMICtl_bPTCOnReq &&
             (!cal_ACCMForbidCtrl)) {
    /* Switch: '<S1683>/Switch' incorporates:
     *  DataTypeConversion: '<S1683>/Data Type Conversion'
     *  Switch: '<S1726>/Switch'
     */
    SOMCtl_eCabinMode = 4U;
  } else {
    /* Switch: '<S1726>/Switch' incorporates:
     *  Switch: '<S1683>/Switch'
     */
    SOMCtl_eCabinMode = ME11_ARID_DEF.ModeSts;
  }

  /* End of Switch: '<S1726>/Switch' */

  /* DataTypeConversion: '<S1683>/Data Type Conversion1' incorporates:
   *  Switch: '<S1726>/Switch'
   */
  rtb_Add2_j5 = SOMCtl_eCabinMode;

  /* Relay: '<S917>/Relay' */
  ME11_ARID_DEF.Relay_Mode_k = ((ACSen_sACCMHiTempFilter >= cal_ACCMHiTempFanOn)
    || ((ACSen_sACCMHiTempFilter > cal_ACCMHiTempFanOff) &&
        ME11_ARID_DEF.Relay_Mode_k));

  /* Chart: '<S917>/Chart' incorporates:
   *  Relay: '<S917>/Relay'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_gg < 255U) {
    ME11_ARID_DEF.temporalCounter_i1_gg++;
  }

  if (ME11_ARID_DEF.is_active_c11_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c11_ME11 = 1U;
    ME11_ARID_DEF.is_c11_ME11 = ME11_IN_Off_a;
    ME11_ARID_DEF.B_a = false;
  } else {
    switch (ME11_ARID_DEF.is_c11_ME11) {
     case ME11_IN_Off_a:
      ME11_ARID_DEF.B_a = false;
      if (ME11_ARID_DEF.Relay_Mode_k) {
        ME11_ARID_DEF.is_c11_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_gg = 0U;
      }
      break;

     case ME11_IN_On_li:
      ME11_ARID_DEF.B_a = true;
      if (!ME11_ARID_DEF.Relay_Mode_k) {
        ME11_ARID_DEF.is_c11_ME11 = ME11_IN_wait1_o;
        ME11_ARID_DEF.temporalCounter_i1_gg = 0U;
      }
      break;

     case ME11_IN_wait_k:
      if (ME11_ARID_DEF.temporalCounter_i1_gg >= 200U) {
        ME11_ARID_DEF.is_c11_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.B_a = true;
      } else if (!ME11_ARID_DEF.Relay_Mode_k) {
        ME11_ARID_DEF.is_c11_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.B_a = false;
      }
      break;

     default:
      /* case IN_wait1: */
      if (ME11_ARID_DEF.Relay_Mode_k) {
        ME11_ARID_DEF.is_c11_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.B_a = true;
      } else if (ME11_ARID_DEF.temporalCounter_i1_gg >= 200U) {
        ME11_ARID_DEF.is_c11_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.B_a = false;
      }
      break;
    }
  }

  /* End of Chart: '<S917>/Chart' */

  /* Relay: '<S1315>/Relay' */
  ME11_ARID_DEF.Relay_Mode_j = ((ACSen_sMotTempFilter >= cal_MotTempUpLmt) ||
    ((ACSen_sMotTempFilter > cal_MotTempDownLmt) && ME11_ARID_DEF.Relay_Mode_j));

  /* Relay: '<S1315>/Relay1' incorporates:
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   */
  ME11_ARID_DEF.Relay1_Mode =
    (((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
      ->VIPM_INV2IgbtMaxTemp_C >= cal_IGBTUpLmtTemp) ||
     (((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
       ->VIPM_INV2IgbtMaxTemp_C > cal_IGBTDownLmtTemp) &&
      ME11_ARID_DEF.Relay1_Mode));

  /* Switch: '<S1734>/Switch' incorporates:
   *  Constant: '<S1734>/Constant1'
   *  MinMax: '<S1315>/Max'
   *  Relay: '<S1315>/Relay'
   *  Relay: '<S1315>/Relay1'
   */
  if (cal_HVPartModeEnb) {
    /* Switch: '<S1734>/Switch' incorporates:
     *  Constant: '<S1734>/Constant'
     */
    SOMCtl_eHVPartMode = cal_HVPartModeData;
  } else if ((sint32)ME11_ARID_DEF.Relay_Mode_j >= (sint32)
             ME11_ARID_DEF.Relay1_Mode) {
    /* MinMax: '<S1315>/Max' incorporates:
     *  Relay: '<S1315>/Relay'
     *  Switch: '<S1734>/Switch'
     */
    SOMCtl_eHVPartMode = (uint8)ME11_ARID_DEF.Relay_Mode_j;
  } else {
    /* Switch: '<S1734>/Switch' incorporates:
     *  MinMax: '<S1315>/Max'
     */
    SOMCtl_eHVPartMode = 1U;
  }

  /* End of Switch: '<S1734>/Switch' */

  /* Sum: '<S1728>/Add' incorporates:
   *  Sum: '<S918>/Add'
   */
  rtb_Merge = ACSen_sEnvTempCor - ACSen_sOHXTempFilter;

  /* Logic: '<S1728>/AND' incorporates:
   *  Constant: '<S1728>/Constant'
   *  Constant: '<S1728>/Constant1'
   *  Constant: '<S1728>/Constant2'
   *  Constant: '<S1732>/Constant'
   *  Logic: '<S1728>/AND1'
   *  RelationalOperator: '<S1728>/Relational Operator'
   *  RelationalOperator: '<S1728>/Relational Operator1'
   *  RelationalOperator: '<S1728>/Relational Operator2'
   *  RelationalOperator: '<S1732>/Compare'
   *  Sum: '<S1728>/Add'
   */
  SOMCtl_bEntExtDefFlg = ((ACSen_sOHXTempFilter <= cal_ExtDefOHXOnTemp) &&
    ((cal_ExtDefEnvMinTemp <= ACSen_sEnvTempCor) && (ACSen_sEnvTempCor <=
    cal_ExtDefEnvMaxTemp)) && (rtb_Merge >= cal_ExtDefTempDiff));

  /* RelationalOperator: '<S1733>/Compare' incorporates:
   *  Constant: '<S1733>/Constant'
   */
  SOMCtl_bExitExtDefTempFlg = (ACSen_sOHXTempFilter >= cal_ExtDefOHXOffTemp);

  /* Chart: '<S1314>/ExtDefJudge' incorporates:
   *  Constant: '<S1728>/Constant3'
   *  Constant: '<S1728>/Constant4'
   *  Constant: '<S1729>/Constant'
   *  Constant: '<S1729>/Constant1'
   *  Product: '<S1728>/Divide'
   *  Product: '<S1729>/Divide'
   */
  if (ME11_ARID_DEF.temporalCounter_i1 < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i1++;
  }

  if (ME11_ARID_DEF.is_active_c95_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c95_ME11 = 1U;
    ME11_ARID_DEF.is_c95_ME11 = ME11_IN_Off_a;
    ME11_ARID_DEF.SOMCtl_bExtDefFlg_m = false;
  } else {
    switch (ME11_ARID_DEF.is_c95_ME11) {
     case ME11_IN_Off_a:
      ME11_ARID_DEF.SOMCtl_bExtDefFlg_m = false;
      if (SOMCtl_bEntExtDefFlg) {
        ME11_ARID_DEF.is_c95_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1 = 0U;
      }
      break;

     case ME11_IN_On_li:
      ME11_ARID_DEF.SOMCtl_bExtDefFlg_m = true;
      if ((ME11_ARID_DEF.temporalCounter_i1 >= cal_ExitExtDefTime * 60.0F *
           10.0F) || SOMCtl_bExitExtDefTempFlg) {
        ME11_ARID_DEF.is_c95_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.SOMCtl_bExtDefFlg_m = false;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1 >= cal_EntExtDefTime * 60.0F * 10.0F)
      {
        ME11_ARID_DEF.is_c95_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.temporalCounter_i1 = 0U;
        ME11_ARID_DEF.SOMCtl_bExtDefFlg_m = true;
      } else if (!SOMCtl_bEntExtDefFlg) {
        ME11_ARID_DEF.is_c95_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.SOMCtl_bExtDefFlg_m = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1314>/ExtDefJudge' */

  /* Delay: '<S32>/Delay1' incorporates:
   *  Delay: '<S1679>/Delay'
   */
  ME11_ARID_DEF.Delay_DSTATE_d2 = ME11_ARID_DEF.Delay1_DSTATE_bs;

  /* Switch: '<S1731>/Switch' incorporates:
   *  Constant: '<S1731>/Constant1'
   */
  if (cal_ExtDefFlgDataEnb) {
    /* Switch: '<S1731>/Switch' incorporates:
     *  Constant: '<S1731>/Constant'
     */
    SOMCtl_bExtDefFlg = cal_ExtDefFlgData;
  } else {
    /* Switch: '<S1731>/Switch' incorporates:
     *  Delay: '<S1679>/Delay'
     *  Switch: '<S1314>/Switch'
     */
    SOMCtl_bExtDefFlg = (ME11_ARID_DEF.Delay_DSTATE_d2 &&
                         ME11_ARID_DEF.SOMCtl_bExtDefFlg_m);
  }

  /* End of Switch: '<S1731>/Switch' */

  /* Chart: '<S1316>/RefModes' incorporates:
   *  DataTypeConversion: '<S1321>/Data Type Conversion1'
   *  DataTypeConversion: '<S1683>/Data Type Conversion1'
   *  Switch: '<S1473>/Switch'
   *  Switch: '<S1726>/Switch'
   */
  if (ME11_ARID_DEF.is_active_c103_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c103_ME11 = 1U;
    ME11_ARID_DEF.is_c103_ME11 = ME11_IN_Nml_d;
  } else if (ME11_ARID_DEF.is_c103_ME11 == ME11_IN_ExhDef) {
    if (!SOMCtl_bExtDefFlg) {
      ME11_ARID_DEF.is_c103_ME11 = ME11_IN_Nml_d;
    }

    /* case IN_Nml: */
  } else if (SOMCtl_bExtDefFlg) {
    ME11_ARID_DEF.is_c103_ME11 = ME11_IN_ExhDef;
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_Def;

    /*
       0OFF
       1
       2
       3
       4
       5
       6
       7ohx
       8ohx
       9
       10
       11
       14+DehAndBatCool
     */
  } else if ((SOMCtl_eCabinMode == CabinMode_MD4_HP) && (SOMCtl_eBatMode == 1))
  {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_CoolBatAHeatCabin;
  } else if ((SOMCtl_eCabinMode == CabinMode_MD1_CLM) && (SOMCtl_eBatMode == 6))
  {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_CoolCabinAHeatBat;
  } else if ((SOMCtl_eCabinMode == CabinMode_MD1_CLM) && ((SOMCtl_eBatMode != 1)
              && (SOMCtl_eBatMode != 6))) {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_CoolCabin;
  } else if (((SOMCtl_eCabinMode == CabinMode_MD_Off) || (SOMCtl_eCabinMode ==
               CabinMode_VENT) || (SOMCtl_eCabinMode == CabinMode_STANDBY)) &&
             (SOMCtl_eBatMode == 1)) {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_CoolBat;
  } else if ((SOMCtl_eCabinMode == CabinMode_MD1_CLM) && (SOMCtl_eBatMode == 1))
  {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_CoolDouble;
  } else if ((SOMCtl_eCabinMode == CabinMode_MD4_HP) && ((SOMCtl_eBatMode != 1) &&
              (SOMCtl_eBatMode != 6))) {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_HeatCabin;
  } else if ((SOMCtl_eCabinMode == CabinMode_MD2_DHMD1) && (SOMCtl_eBatMode != 1))
  {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_SerDeh_LCC;
  } else if ((SOMCtl_eCabinMode == CabinMode_MD3_DHMD2) && (SOMCtl_eBatMode != 1))
  {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_SerDeh_EVAP;
  } else if ((SOMCtl_eCabinMode != CabinMode_MD1_CLM) && (SOMCtl_eCabinMode !=
              CabinMode_MD4_HP) && (SOMCtl_eBatMode == 6)) {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_HeatBat;
  } else if ((SOMCtl_eCabinMode == CabinMode_MD4_HP) && (SOMCtl_eBatMode == 6))
  {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_HeatDouble;
  } else if (((SOMCtl_eCabinMode == CabinMode_MD2_DHMD1) || (SOMCtl_eCabinMode ==
    CabinMode_MD3_DHMD2)) && (SOMCtl_eBatMode == 1)) {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_DehAndBatCool;
  } else {
    ME11_ARID_DEF.ACSOM_eRefModes = RefModes_Ref_Off;
  }

  /* End of Chart: '<S1316>/RefModes' */

  /* Switch: '<S1735>/Switch' incorporates:
   *  Constant: '<S1735>/Constant1'
   */
  if (cal_RefModeEnb) {
    /* Switch: '<S1735>/Switch' incorporates:
     *  Constant: '<S1735>/Constant'
     */
    SOMCtl_eRefModes = cal_RefModeData;
  } else {
    /* Switch: '<S1735>/Switch' */
    SOMCtl_eRefModes = ME11_ARID_DEF.ACSOM_eRefModes;
  }

  /* End of Switch: '<S1735>/Switch' */

  /* DataTypeConversion: '<S1316>/Data Type Conversion' incorporates:
   *  Switch: '<S1735>/Switch'
   */
  rtb_Add_b1 = SOMCtl_eRefModes;

  /* Switch: '<S915>/Switch' incorporates:
   *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
   */
  if ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA()
      )->VIPM_ESCVehSpdVld_flg) {
    /* Gain: '<S8>/Gain8' */
    rtb_Delay1_ie =
      (Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA()
      )->VIPM_ESCVehSpd_kph;
  } else {
    /* Gain: '<S8>/Gain8' incorporates:
     *  Constant: '<S915>/Constant1'
     */
    rtb_Delay1_ie = 0.0F;
  }

  /* End of Switch: '<S915>/Switch' */

  /* Lookup_n-D: '<S915>/cal_CoolFanCtrl_MAP' incorporates:
   *  Gain: '<S8>/Gain8'
   *  Switch: '<S1864>/Switch'
   */
  ACTCtl_eCoolFanCtrl = look2_iflftu8Dfdf_binlca(rtb_Delay1_ie,
    ACSen_sHiPressFilter, (const float32 *)&cal_CoolFanCtrl_2X[0], (const
    float32 *)&cal_CoolFanCtrl_2Y[0], (const uint8 *)&cal_CoolFanCtrl_MAP[0],
    ME11_ConstP.pooled41, 4U);

  /* Logic: '<S462>/OR1' incorporates:
   *  Constant: '<S469>/Constant'
   *  Constant: '<S471>/Constant'
   *  DataTypeConversion: '<S1683>/Data Type Conversion1'
   *  RelationalOperator: '<S469>/Compare'
   *  RelationalOperator: '<S471>/Compare'
   *  Switch: '<S1726>/Switch'
   */
  rtb_AND1_hh = ((SOMCtl_eCabinMode >= 1) && (SOMCtl_eCabinMode <= 4));

  /* Chart: '<S462>/delay' */
  if (ME11_ARID_DEF.temporalCounter_i1_bc < 31U) {
    ME11_ARID_DEF.temporalCounter_i1_bc++;
  }

  if (ME11_ARID_DEF.is_active_c26_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c26_ME11 = 1U;
    ME11_ARID_DEF.is_c26_ME11 = ME11_IN_Off_a;
    ME11_ARID_DEF.ACTCtl_eACCMCtlEnb_a = false;
  } else {
    switch (ME11_ARID_DEF.is_c26_ME11) {
     case ME11_IN_Off_a:
      ME11_ARID_DEF.ACTCtl_eACCMCtlEnb_a = false;
      if (rtb_AND1_hh) {
        ME11_ARID_DEF.is_c26_ME11 = ME11_IN_Wait_c;
        ME11_ARID_DEF.temporalCounter_i1_bc = 0U;
      }
      break;

     case ME11_IN_On_li:
      ME11_ARID_DEF.ACTCtl_eACCMCtlEnb_a = true;
      if (!rtb_AND1_hh) {
        ME11_ARID_DEF.is_c26_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.ACTCtl_eACCMCtlEnb_a = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_bc >= 30U) {
        ME11_ARID_DEF.is_c26_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.ACTCtl_eACCMCtlEnb_a = true;
      } else if (!rtb_AND1_hh) {
        ME11_ARID_DEF.is_c26_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.ACTCtl_eACCMCtlEnb_a = false;
      }
      break;
    }
  }

  /* End of Chart: '<S462>/delay' */

  /* Switch: '<S462>/Switch' incorporates:
   *  Constant: '<S462>/Constant1'
   */
  if (cal_BatHeatACCMEnb) {
    /* DataTypeConversion: '<S8>/Data Type Conversion16' incorporates:
     *  Constant: '<S467>/Constant'
     *  Constant: '<S468>/Constant'
     *  Constant: '<S470>/Constant'
     *  DataTypeConversion: '<S1321>/Data Type Conversion1'
     *  Logic: '<S462>/OR'
     *  Logic: '<S462>/OR11'
     *  Logic: '<S462>/OR2'
     *  Logic: '<S462>/OR4'
     *  Logic: '<S462>/OR5'
     *  RelationalOperator: '<S467>/Compare'
     *  RelationalOperator: '<S468>/Compare'
     *  RelationalOperator: '<S470>/Compare'
     *  Switch: '<S1473>/Switch'
     */
    rtb_FixPtRelationalOperator_a0 = ((((ME11_ARID_DEF.DataTypeConversion1 == 2)
      || (ME11_ARID_DEF.DataTypeConversion1 == 5)) && (SOMCtl_eBatMode == 6)) ||
      (SOMCtl_eBatMode == 1) || (ME11_ARID_DEF.ACTCtl_eACCMCtlEnb_a &&
      rtb_AND1_hh));
  } else {
    /* DataTypeConversion: '<S8>/Data Type Conversion16' incorporates:
     *  Constant: '<S464>/Constant'
     *  DataTypeConversion: '<S1321>/Data Type Conversion1'
     *  Logic: '<S462>/OR12'
     *  Logic: '<S462>/OR4'
     *  RelationalOperator: '<S464>/Compare'
     *  Switch: '<S1473>/Switch'
     */
    rtb_FixPtRelationalOperator_a0 = ((SOMCtl_eBatMode == 1) ||
      (ME11_ARID_DEF.ACTCtl_eACCMCtlEnb_a && rtb_AND1_hh));
  }

  /* End of Switch: '<S462>/Switch' */

  /* Gain: '<S462>/Gain' */
  rtb_Gain_gr = rtb_FixPtRelationalOperator_a0;

  /* Relay: '<S500>/Relay1' */
  ME11_ARID_DEF.Relay1_Mode_g = ((ACSen_sEnvTempCor >= cal_HeatCOMPEnvTempLmtOn)
    || ((ACSen_sEnvTempCor > cal_HeatCOMPEnvTempLmtOff) &&
        ME11_ARID_DEF.Relay1_Mode_g));

  /* Relay: '<S500>/Relay' */
  ME11_ARID_DEF.Relay_Mode_km = ((ACSen_sEnvTempCor >= cal_NmCOMPEnvTempLmtOn) ||
    ((ACSen_sEnvTempCor > cal_NmCOMPEnvTempLmtOff) &&
     ME11_ARID_DEF.Relay_Mode_km));

  /* Switch: '<S500>/Switch1' incorporates:
   *  Constant: '<S518>/Constant'
   *  DataTypeConversion: '<S1316>/Data Type Conversion'
   *  RelationalOperator: '<S518>/Compare'
   *  Switch: '<S1735>/Switch'
   */
  if (SOMCtl_eRefModes == 0) {
    /* Switch: '<S500>/Switch1' incorporates:
     *  Constant: '<S500>/Constant'
     */
    ACTCrl_bEnvCOMPLmt = false;
  } else {
    for (b_previousEvent = 0; b_previousEvent < 6; b_previousEvent++) {
      /* RelationalOperator: '<S517>/Compare' incorporates:
       *  Constant: '<S517>/Constant'
       */
      rtb_Compare_no[b_previousEvent] = (SOMCtl_eRefModes ==
        ME11_ConstP.Constant_Value_dw[b_previousEvent]);
    }

    /* Logic: '<S500>/OR' */
    rtb_Compare_fx = rtb_Compare_no[0];
    for (b_previousEvent = 0; b_previousEvent < 5; b_previousEvent++) {
      rtb_Compare_fx = (rtb_Compare_fx || rtb_Compare_no[b_previousEvent + 1]);
    }

    /* Switch: '<S500>/Switch' incorporates:
     *  Logic: '<S500>/OR'
     */
    if (rtb_Compare_fx) {
      /* Switch: '<S500>/Switch1' incorporates:
       *  Relay: '<S500>/Relay1'
       */
      ACTCrl_bEnvCOMPLmt = !ME11_ARID_DEF.Relay1_Mode_g;
    } else {
      /* Switch: '<S500>/Switch1' incorporates:
       *  Relay: '<S500>/Relay'
       */
      ACTCrl_bEnvCOMPLmt = !ME11_ARID_DEF.Relay_Mode_km;
    }

    /* End of Switch: '<S500>/Switch' */
  }

  /* End of Switch: '<S500>/Switch1' */

  /* RelationalOperator: '<S522>/Compare' incorporates:
   *  Constant: '<S524>/Constant'
   *  Delay: '<S503>/Delay'
   *  RelationalOperator: '<S524>/Compare'
   */
  rtb_AND1_hh = !ME11_ARID_DEF.Delay_DSTATE_kf;

  /* Logic: '<S503>/AND1' incorporates:
   *  Constant: '<S521>/Constant'
   *  RelationalOperator: '<S521>/Compare'
   *  RelationalOperator: '<S522>/Compare'
   *  Sum: '<S503>/Add'
   */
  ACTCtl_bOCOLmtFlg = ((ACSen_sHiPressFilter - ACSen_sLoPressFilter >=
                        cal_HPAndLPDiffMaxVal) && rtb_AND1_hh);

  /* RelationalOperator: '<S523>/FixPt Relational Operator' incorporates:
   *  UnitDelay: '<S523>/Delay Input1'
   *
   * Block description for '<S523>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_Compare_mgx = ((sint32)rtb_AND1_hh > (sint32)
                     ME11_ARID_DEF.DelayInput1_DSTATE_ln);

  /* Chart: '<S503>/Chart' incorporates:
   *  Constant: '<S520>/Constant'
   *  RelationalOperator: '<S520>/Compare'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_hv < 63U) {
    ME11_ARID_DEF.temporalCounter_i1_hv++;
  }

  if (ME11_ARID_DEF.is_active_c30_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c30_ME11 = 1U;
    ME11_ARID_DEF.is_c30_ME11 = ME11_IN_Normal_m;
    ACTCtl_bCOMPEnbDelay = false;
  } else {
    switch (ME11_ARID_DEF.is_c30_ME11) {
     case ME11_IN_Normal_m:
      ACTCtl_bCOMPEnbDelay = false;
      if (rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c30_ME11 = ME11_IN_wait_f;
        ACTCtl_bCOMPEnbDelay = false;
      }
      break;

     case ME11_IN_Stop:
      ACTCtl_bCOMPEnbDelay = false;
      if (!rtb_Compare_mgx) {
        ME11_ARID_DEF.is_c30_ME11 = ME11_IN_Normal_m;
        ACTCtl_bCOMPEnbDelay = false;
      }
      break;

     case ME11_IN_Stop1:
      ACTCtl_bCOMPEnbDelay = true;
      if (ME11_ARID_DEF.temporalCounter_i1_hv >= 50U) {
        ME11_ARID_DEF.is_c30_ME11 = ME11_IN_Stop;
        ACTCtl_bCOMPEnbDelay = false;
      }
      break;

     default:
      /* case IN_wait: */
      ACTCtl_bCOMPEnbDelay = false;
      if (COMP_EcompActSpd <= 50.0F) {
        ME11_ARID_DEF.is_c30_ME11 = ME11_IN_Stop1;
        ME11_ARID_DEF.temporalCounter_i1_hv = 0U;
        ACTCtl_bCOMPEnbDelay = true;
      }
      break;
    }
  }

  /* End of Chart: '<S503>/Chart' */

  /* Chart: '<S533>/SecCal' incorporates:
   *  Constant: '<S541>/Constant'
   *  Constant: '<S542>/Constant'
   *  Constant: '<S543>/Constant'
   *  Gain: '<S533>/Gain'
   *  Gain: '<S533>/Gain1'
   *  RelationalOperator: '<S541>/Compare'
   *  RelationalOperator: '<S542>/Compare'
   *  RelationalOperator: '<S543>/Compare'
   *  Sum: '<S533>/Add1'
   */
  switch ((sint32)(((uint32)((COMP_EcompActSpd < cal_COMPActlSpd2) << 1) +
                    (uint32)(COMP_EcompActSpd < cal_COMPActlSpd1)) + (uint32)
                   ((COMP_EcompActSpd < cal_COMPActlSpd3) << 2))) {
   case 4:
    ACTCtl_eCOMPSpdSecSts = 1U;
    break;

   case 6:
    ACTCtl_eCOMPSpdSecSts = 2U;
    break;

   case 7:
    ACTCtl_eCOMPSpdSecSts = 3U;
    break;

   default:
    ACTCtl_eCOMPSpdSecSts = 0U;
    break;
  }

  /* End of Chart: '<S533>/SecCal' */

  /* Relay: '<S531>/Relay' */
  ME11_ARID_DEF.Relay_Mode_c = ((ACSen_sHiPressFilter >= cal_HPProVal1) ||
    ((ACSen_sHiPressFilter > cal_HPProVal1Relay) && ME11_ARID_DEF.Relay_Mode_c));

  /* Relay: '<S531>/Relay1' */
  ME11_ARID_DEF.Relay1_Mode_c = ((ACSen_sHiPressFilter >= cal_HPProVal2) ||
    ((ACSen_sHiPressFilter > cal_HPProVal2Relay) && ME11_ARID_DEF.Relay1_Mode_c));

  /* Relay: '<S531>/Relay2' */
  ME11_ARID_DEF.Relay2_Mode = ((ACSen_sHiPressFilter >= cal_HPProVal3) ||
    ((ACSen_sHiPressFilter > cal_HPProVal3Relay) && ME11_ARID_DEF.Relay2_Mode));

  /* Chart: '<S531>/Flg3Cal' incorporates:
   *  Relay: '<S531>/Relay'
   *  Relay: '<S531>/Relay1'
   *  Relay: '<S531>/Relay2'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_hq < 8191U) {
    ME11_ARID_DEF.temporalCounter_i1_hq++;
  }

  if (ME11_ARID_DEF.is_active_c31_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c31_ME11 = 1U;
    ME11_ARID_DEF.is_c31_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d = false;
  } else if (ME11_ARID_DEF.is_c31_ME11 == ME11_IN_Default_k) {
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d = false;
    if (ME11_ARID_DEF.Relay2_Mode) {
      ME11_ARID_DEF.is_c31_ME11 = ME11_IN_Fault_b;
      ME11_ARID_DEF.is_Fault_m = ME11_IN_Flg3_p;
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d = true;
    } else if (ME11_ARID_DEF.Relay1_Mode_c) {
      ME11_ARID_DEF.is_c31_ME11 = ME11_IN_Fault_b;
      ME11_ARID_DEF.is_Fault_m = ME11_IN_wait_2_i;
      ME11_ARID_DEF.temporalCounter_i1_hq = 0U;
    } else if (ME11_ARID_DEF.Relay_Mode_c) {
      ME11_ARID_DEF.is_c31_ME11 = ME11_IN_Fault_b;
      ME11_ARID_DEF.is_Fault_m = ME11_IN_wait_3;
      ME11_ARID_DEF.temporalCounter_i1_hq = 0U;
    }

    /* case IN_Fault: */
  } else if (!ME11_ARID_DEF.Relay_Mode_c) {
    ME11_ARID_DEF.is_Fault_m = ME11_IN_NO_ACTIVE_CHILD_gl;
    ME11_ARID_DEF.is_c31_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d = false;
  } else {
    switch (ME11_ARID_DEF.is_Fault_m) {
     case ME11_IN_Flg1:
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d = true;
      break;

     case ME11_IN_Flg2_j:
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d = true;
      break;

     case ME11_IN_Flg3_p:
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d = true;
      break;

     case ME11_IN_wait_2_i:
      if (ME11_ARID_DEF.Relay2_Mode) {
        ME11_ARID_DEF.is_Fault_m = ME11_IN_Flg3_p;
        ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d = true;
      } else if (ME11_ARID_DEF.temporalCounter_i1_hq >= 200U) {
        ME11_ARID_DEF.is_Fault_m = ME11_IN_Flg2_j;
        ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d = true;
      }
      break;

     default:
      /* case IN_wait_3: */
      if (ME11_ARID_DEF.temporalCounter_i1_hq >= 6000U) {
        ME11_ARID_DEF.is_Fault_m = ME11_IN_Flg1;
        ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d = true;
      } else if (ME11_ARID_DEF.Relay1_Mode_c) {
        ME11_ARID_DEF.is_Fault_m = ME11_IN_wait_2_i;
        ME11_ARID_DEF.temporalCounter_i1_hq = 0U;
      }
      break;
    }
  }

  /* End of Chart: '<S531>/Flg3Cal' */

  /* Relay: '<S529>/Relay1' */
  ME11_ARID_DEF.Relay1_Mode_gi = ((ACSen_sHiPressFilter >= cal_HPProVal2) ||
    ((ACSen_sHiPressFilter > cal_HPProVal2Relay) && ME11_ARID_DEF.Relay1_Mode_gi));

  /* Relay: '<S529>/Relay2' */
  ME11_ARID_DEF.Relay2_Mode_i = ((ACSen_sHiPressFilter >= cal_HPProVal3) ||
    ((ACSen_sHiPressFilter > cal_HPProVal3Relay) && ME11_ARID_DEF.Relay2_Mode_i));

  /* Chart: '<S529>/Flg3Cal' incorporates:
   *  Relay: '<S529>/Relay1'
   *  Relay: '<S529>/Relay2'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_i2 < 127U) {
    ME11_ARID_DEF.temporalCounter_i1_i2++;
  }

  if (ME11_ARID_DEF.is_active_c33_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c33_ME11 = 1U;
    ME11_ARID_DEF.is_c33_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_b = false;
  } else if (ME11_ARID_DEF.is_c33_ME11 == ME11_IN_Default_k) {
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_b = false;
    if (ME11_ARID_DEF.Relay2_Mode_i) {
      ME11_ARID_DEF.is_c33_ME11 = ME11_IN_Fault_b;
      ME11_ARID_DEF.is_Fault_k = ME11_IN_Flg3_n;
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_b = true;
    } else if (ME11_ARID_DEF.Relay1_Mode_gi) {
      ME11_ARID_DEF.is_c33_ME11 = ME11_IN_Fault_b;
      ME11_ARID_DEF.is_Fault_k = ME11_IN_wait_2;
      ME11_ARID_DEF.temporalCounter_i1_i2 = 0U;
    }

    /* case IN_Fault: */
  } else if (!ME11_ARID_DEF.Relay1_Mode_gi) {
    ME11_ARID_DEF.is_Fault_k = ME11_IN_NO_ACTIVE_CHILD_gl;
    ME11_ARID_DEF.is_c33_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_b = false;
  } else {
    switch (ME11_ARID_DEF.is_Fault_k) {
     case ME11_IN_Flg2:
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_b = true;
      break;

     case ME11_IN_Flg3_n:
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_b = true;
      break;

     default:
      /* case IN_wait_2: */
      if (ME11_ARID_DEF.Relay2_Mode_i) {
        ME11_ARID_DEF.is_Fault_k = ME11_IN_Flg3_n;
        ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_b = true;
      } else if (ME11_ARID_DEF.temporalCounter_i1_i2 >= 100U) {
        ME11_ARID_DEF.is_Fault_k = ME11_IN_Flg2;
        ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_b = true;
      }
      break;
    }
  }

  /* End of Chart: '<S529>/Flg3Cal' */

  /* Relay: '<S526>/Relay2' */
  ME11_ARID_DEF.Relay2_Mode_e = ((ACSen_sHiPressFilter >= cal_HPProVal3) ||
    ((ACSen_sHiPressFilter > cal_HPProVal3Relay) && ME11_ARID_DEF.Relay2_Mode_e));

  /* Chart: '<S526>/Flg3Cal' incorporates:
   *  Relay: '<S526>/Relay2'
   */
  ME11_Flg3Cal((float32)ME11_ARID_DEF.Relay2_Mode_e, &rtb_ACTCtl_eCOMPFlg3Cal_c,
               &ME11_ARID_DEF.ARID_DEF_Flg3Cal_e);

  /* Relay: '<S528>/Relay2' */
  ME11_ARID_DEF.Relay2_Mode_b = ((ACSen_sHiPressFilter >= cal_HPProVal4) ||
    ((ACSen_sHiPressFilter > cal_HPProVal3) && ME11_ARID_DEF.Relay2_Mode_b));

  /* MultiPortSwitch: '<S504>/Multiport Switch' */
  switch (ACTCtl_eCOMPSpdSecSts) {
   case 3:
    /* MultiPortSwitch: '<S504>/Multiport Switch' */
    ACTCtl_bPressProtectFlg = ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_d;
    break;

   case 2:
    /* MultiPortSwitch: '<S504>/Multiport Switch' */
    ACTCtl_bPressProtectFlg = ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_b;
    break;

   case 1:
    /* MultiPortSwitch: '<S504>/Multiport Switch' */
    ACTCtl_bPressProtectFlg = rtb_ACTCtl_eCOMPFlg3Cal_c;
    break;

   default:
    /* MultiPortSwitch: '<S504>/Multiport Switch' incorporates:
     *  Relay: '<S528>/Relay2'
     */
    ACTCtl_bPressProtectFlg = ME11_ARID_DEF.Relay2_Mode_b;
    break;
  }

  /* End of MultiPortSwitch: '<S504>/Multiport Switch' */

  /* Switch: '<S504>/Switch' incorporates:
   *  Constant: '<S525>/Constant'
   *  RelationalOperator: '<S525>/Compare'
   */
  if (ACSen_sLoPressFilter <= 0.0F) {
    /* Switch: '<S504>/Switch' incorporates:
     *  Constant: '<S504>/Constant1'
     */
    ACSen_sPressRateVal = 20.0F;
  } else {
    /* Switch: '<S504>/Switch' incorporates:
     *  Product: '<S504>/Divide'
     */
    ACSen_sPressRateVal = 1.0F / ACSen_sLoPressFilter * ACSen_sHiPressFilter;
  }

  /* End of Switch: '<S504>/Switch' */

  /* Relay: '<S532>/Relay' */
  ME11_ARID_DEF.Relay_Mode_f = ((ACSen_sPressRateVal >= cal_PressRateVal1) ||
    ((ACSen_sPressRateVal > cal_PressRateVal1Relay) &&
     ME11_ARID_DEF.Relay_Mode_f));

  /* Relay: '<S532>/Relay1' */
  ME11_ARID_DEF.Relay1_Mode_d = ((ACSen_sPressRateVal >= cal_PressRateVal2) ||
    ((ACSen_sPressRateVal > cal_PressRateVal2Relay) &&
     ME11_ARID_DEF.Relay1_Mode_d));

  /* Relay: '<S532>/Relay2' */
  ME11_ARID_DEF.Relay2_Mode_bp = ((ACSen_sPressRateVal >= cal_PressRateVal3) ||
    ((ACSen_sPressRateVal > cal_PressRateVal3Relay) &&
     ME11_ARID_DEF.Relay2_Mode_bp));

  /* Chart: '<S532>/Flg3Cal' incorporates:
   *  Relay: '<S532>/Relay'
   *  Relay: '<S532>/Relay1'
   *  Relay: '<S532>/Relay2'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_pw < 8191U) {
    ME11_ARID_DEF.temporalCounter_i1_pw++;
  }

  if (ME11_ARID_DEF.is_active_c93_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c93_ME11 = 1U;
    ME11_ARID_DEF.is_c93_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal = false;
  } else if (ME11_ARID_DEF.is_c93_ME11 == ME11_IN_Default_k) {
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal = false;
    if (ME11_ARID_DEF.Relay2_Mode_bp) {
      ME11_ARID_DEF.is_c93_ME11 = ME11_IN_Fault_b;
      ME11_ARID_DEF.is_Fault = ME11_IN_Flg3_p;
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal = true;
    } else if (ME11_ARID_DEF.Relay1_Mode_d) {
      ME11_ARID_DEF.is_c93_ME11 = ME11_IN_Fault_b;
      ME11_ARID_DEF.is_Fault = ME11_IN_wait_2_i;
      ME11_ARID_DEF.temporalCounter_i1_pw = 0U;
    } else if (ME11_ARID_DEF.Relay_Mode_f) {
      ME11_ARID_DEF.is_c93_ME11 = ME11_IN_Fault_b;
      ME11_ARID_DEF.is_Fault = ME11_IN_wait_3;
      ME11_ARID_DEF.temporalCounter_i1_pw = 0U;
    }

    /* case IN_Fault: */
  } else if (!ME11_ARID_DEF.Relay_Mode_f) {
    ME11_ARID_DEF.is_Fault = ME11_IN_NO_ACTIVE_CHILD_gl;
    ME11_ARID_DEF.is_c93_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal = false;
  } else {
    switch (ME11_ARID_DEF.is_Fault) {
     case ME11_IN_Flg1:
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal = true;
      break;

     case ME11_IN_Flg2_j:
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal = true;
      break;

     case ME11_IN_Flg3_p:
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal = true;
      break;

     case ME11_IN_wait_2_i:
      if (ME11_ARID_DEF.Relay2_Mode_bp) {
        ME11_ARID_DEF.is_Fault = ME11_IN_Flg3_p;
        ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal = true;
      } else if (ME11_ARID_DEF.temporalCounter_i1_pw >= 100U) {
        ME11_ARID_DEF.is_Fault = ME11_IN_Flg2_j;
        ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal = true;
      }
      break;

     default:
      /* case IN_wait_3: */
      if (ME11_ARID_DEF.temporalCounter_i1_pw >= 6000U) {
        ME11_ARID_DEF.is_Fault = ME11_IN_Flg1;
        ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal = true;
      } else if (ME11_ARID_DEF.Relay1_Mode_d) {
        ME11_ARID_DEF.is_Fault = ME11_IN_wait_2_i;
        ME11_ARID_DEF.temporalCounter_i1_pw = 0U;
      }
      break;
    }
  }

  /* End of Chart: '<S532>/Flg3Cal' */

  /* Relay: '<S530>/Relay1' */
  ME11_ARID_DEF.Relay1_Mode_j = ((ACSen_sPressRateVal >= cal_PressRateVal2) ||
    ((ACSen_sPressRateVal > cal_PressRateVal2Relay) &&
     ME11_ARID_DEF.Relay1_Mode_j));

  /* Relay: '<S530>/Relay2' */
  ME11_ARID_DEF.Relay2_Mode_ii = ((ACSen_sPressRateVal >= cal_PressRateVal3) ||
    ((ACSen_sPressRateVal > cal_PressRateVal3Relay) &&
     ME11_ARID_DEF.Relay2_Mode_ii));

  /* Chart: '<S530>/Flg3Cal' incorporates:
   *  Relay: '<S530>/Relay1'
   *  Relay: '<S530>/Relay2'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_ox < 127U) {
    ME11_ARID_DEF.temporalCounter_i1_ox++;
  }

  if (ME11_ARID_DEF.is_active_c92_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c92_ME11 = 1U;
    ME11_ARID_DEF.is_c92_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_h = false;
  } else if (ME11_ARID_DEF.is_c92_ME11 == ME11_IN_Default_k) {
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_h = false;
    if (ME11_ARID_DEF.Relay2_Mode_ii) {
      ME11_ARID_DEF.is_c92_ME11 = ME11_IN_Fault_b;
      ME11_ARID_DEF.is_Fault_i = ME11_IN_Flg3_n;
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_h = true;
    } else if (ME11_ARID_DEF.Relay1_Mode_j) {
      ME11_ARID_DEF.is_c92_ME11 = ME11_IN_Fault_b;
      ME11_ARID_DEF.is_Fault_i = ME11_IN_wait_2;
      ME11_ARID_DEF.temporalCounter_i1_ox = 0U;
    }

    /* case IN_Fault: */
  } else if (!ME11_ARID_DEF.Relay1_Mode_j) {
    ME11_ARID_DEF.is_Fault_i = ME11_IN_NO_ACTIVE_CHILD_gl;
    ME11_ARID_DEF.is_c92_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_h = false;
  } else {
    switch (ME11_ARID_DEF.is_Fault_i) {
     case ME11_IN_Flg2:
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_h = true;
      break;

     case ME11_IN_Flg3_n:
      ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_h = true;
      break;

     default:
      /* case IN_wait_2: */
      if (ME11_ARID_DEF.temporalCounter_i1_ox >= 100U) {
        ME11_ARID_DEF.is_Fault_i = ME11_IN_Flg2;
        ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_h = true;
      } else if (ME11_ARID_DEF.Relay2_Mode_ii) {
        ME11_ARID_DEF.is_Fault_i = ME11_IN_Flg3_n;
        ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_h = true;
      }
      break;
    }
  }

  /* End of Chart: '<S530>/Flg3Cal' */

  /* Relay: '<S527>/Relay2' */
  ME11_ARID_DEF.Relay2_Mode_l = ((ACSen_sPressRateVal >= cal_PressRateVal3) ||
    ((ACSen_sPressRateVal > cal_PressRateVal3Relay) &&
     ME11_ARID_DEF.Relay2_Mode_l));

  /* Chart: '<S527>/Flg3Cal' incorporates:
   *  Relay: '<S527>/Relay2'
   */
  ME11_Flg3Cal((float32)ME11_ARID_DEF.Relay2_Mode_l, &rtb_ACTCtl_eCOMPFlg3Cal,
               &ME11_ARID_DEF.ARID_DEF_Flg3Cal);

  /* Relay: '<S534>/Relay1' */
  ME11_ARID_DEF.Relay1_Mode_h = ((ACSen_sPressRateVal >= cal_PressRateVal4) ||
    ((ACSen_sPressRateVal > cal_PressRateVal3) && ME11_ARID_DEF.Relay1_Mode_h));

  /* MultiPortSwitch: '<S504>/Multiport Switch1' */
  switch (ACTCtl_eCOMPSpdSecSts) {
   case 3:
    /* MultiPortSwitch: '<S504>/Multiport Switch1' */
    ACTCtl_bPressRateFlg = ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal;
    break;

   case 2:
    /* MultiPortSwitch: '<S504>/Multiport Switch1' */
    ACTCtl_bPressRateFlg = ME11_ARID_DEF.ACTCtl_eCOMPFlg3Cal_h;
    break;

   case 1:
    /* MultiPortSwitch: '<S504>/Multiport Switch1' */
    ACTCtl_bPressRateFlg = rtb_ACTCtl_eCOMPFlg3Cal;
    break;

   default:
    /* MultiPortSwitch: '<S504>/Multiport Switch1' incorporates:
     *  Relay: '<S534>/Relay1'
     */
    ACTCtl_bPressRateFlg = ME11_ARID_DEF.Relay1_Mode_h;
    break;
  }

  /* End of MultiPortSwitch: '<S504>/Multiport Switch1' */

  /* SignalConversion: '<S2>/Signal Copy131' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_OverDuty = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPOverDuty_flg;

  /* Chart: '<S497>/OverDuty' incorporates:
   *  RelationalOperator: '<S505>/Compare'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_if < 31U) {
    ME11_ARID_DEF.temporalCounter_i1_if++;
  }

  if (ME11_ARID_DEF.temporalCounter_i2_f < 511U) {
    ME11_ARID_DEF.temporalCounter_i2_f++;
  }

  if (ME11_ARID_DEF.is_active_c35_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c35_ME11 = 1U;
    ME11_ARID_DEF.is_FaultJudge = ME11_IN_Normal_k;
    ME11_ARID_DEF.Sts_h = 0.0;
    ME11_ARID_DEF.is_ClearFault = ME11_IN_HVOff_o;
    ME11_ARID_DEF.Count = 0U;
    ME11_ARID_DEF.ClearFlt_n = 0.0;
  } else {
    switch (ME11_ARID_DEF.is_FaultJudge) {
     case ME11_IN_Fault_ax:
      ME11_ARID_DEF.Sts_h = 1.0;
      if ((!COMP_OverDuty) && (ME11_ARID_DEF.Count < 4)) {
        ME11_ARID_DEF.is_FaultJudge = ME11_IN_Normal_k;
        ME11_ARID_DEF.Sts_h = 0.0;
      }
      break;

     case ME11_IN_Normal_k:
      ME11_ARID_DEF.Sts_h = 0.0;
      if ((!COMP_OverDuty) && (ME11_ARID_DEF.ClearFlt_n == 0.0)) {
        ME11_ARID_DEF.is_FaultJudge = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_if = 0U;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_if >= 20U) {
        ME11_ARID_DEF.is_FaultJudge = ME11_IN_Fault_ax;
        ME11_ARID_DEF.Sts_h = 1.0;
      } else if (!COMP_OverDuty) {
        ME11_ARID_DEF.is_FaultJudge = ME11_IN_Normal_k;
        ME11_ARID_DEF.Sts_h = 0.0;
      }
      break;
    }

    if (ME11_ARID_DEF.is_ClearFault == ME11_IN_HVOff_o) {
      ME11_ARID_DEF.ClearFlt_n = 0.0;
      if (ME11_ARID_DEF.DataTypeConversion1 >= 2) {
        ME11_ARID_DEF.is_ClearFault = ME11_IN_HVOn_o;
        ME11_ARID_DEF.is_HVOn = ME11_IN_Normal_k;
        ME11_ARID_DEF.ClearFlt_n = 0.0;
      }

      /* case IN_HVOn: */
    } else if (ME11_ARID_DEF.DataTypeConversion1 < 2) {
      ME11_ARID_DEF.is_HVOn = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_ARID_DEF.is_ClearFault = ME11_IN_HVOff_o;
      ME11_ARID_DEF.Count = 0U;
      ME11_ARID_DEF.ClearFlt_n = 0.0;
    } else {
      switch (ME11_ARID_DEF.is_HVOn) {
       case ME11_IN_Clear_d:
        ME11_ARID_DEF.ClearFlt_n = 1.0;
        if (ME11_ARID_DEF.temporalCounter_i2_f >= 5U) {
          ME11_ARID_DEF.is_HVOn = ME11_IN_wait1_o;
          ME11_ARID_DEF.temporalCounter_i2_f = 0U;
          ME11_ARID_DEF.ClearFlt_n = 0.0;
        }
        break;

       case ME11_IN_Normal_k:
        ME11_ARID_DEF.ClearFlt_n = 0.0;
        if ((ME11_ARID_DEF.Sts_h == 1.0) && (ME11_ARID_DEF.Count < 4)) {
          ME11_ARID_DEF.is_HVOn = ME11_IN_wait_k;
          ME11_ARID_DEF.temporalCounter_i2_f = 0U;
        }
        break;

       case ME11_IN_wait_k:
        if (ME11_ARID_DEF.temporalCounter_i2_f >= 50U) {
          ME11_ARID_DEF.is_HVOn = ME11_IN_Clear_d;
          ME11_ARID_DEF.temporalCounter_i2_f = 0U;
          ME11_ARID_DEF.ClearFlt_n = 1.0;
          b_previousEvent = ME11_ARID_DEF.Count + 1;
          if (ME11_ARID_DEF.Count + 1 > 255) {
            b_previousEvent = 255;
          }

          ME11_ARID_DEF.Count = (uint8)b_previousEvent;
        }
        break;

       default:
        /* case IN_wait1: */
        ME11_ARID_DEF.ClearFlt_n = 0.0;
        if (ME11_ARID_DEF.temporalCounter_i2_f >= 300U) {
          ME11_ARID_DEF.is_HVOn = ME11_IN_Normal_k;
          ME11_ARID_DEF.ClearFlt_n = 0.0;
        }
        break;
      }
    }
  }

  /* End of Chart: '<S497>/OverDuty' */

  /* SignalConversion: '<S2>/Signal Copy132' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_PI_Saturation = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD()
    )->VIPM_COMPPISaturation_flg;

  /* Chart: '<S497>/OverDuty1' incorporates:
   *  RelationalOperator: '<S506>/Compare'
   */
  ME11_OverDuty1(ME11_ARID_DEF.DataTypeConversion1, COMP_PI_Saturation,
                 &ME11_ARID_DEF.Sts_b, &ME11_ARID_DEF.ClearFlt_m,
                 &ME11_ARID_DEF.ARID_DEF_OverDuty1);

  /* SignalConversion: '<S2>/Signal Copy134' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_SelfCheckError = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD()
    )->VIPM_COMPSelfChkErr_enum;

  /* Chart: '<S497>/OverDuty2' incorporates:
   *  Constant: '<S507>/Constant'
   *  Logic: '<S497>/OR'
   *  RelationalOperator: '<S507>/Compare'
   */
  ME11_OverDuty1(ME11_ARID_DEF.DataTypeConversion1, (COMP_SelfCheckError == 1) ||
                 (COMP_SelfCheckError == 2), &ME11_ARID_DEF.Sts_a,
                 &ME11_ARID_DEF.ClearFlt_k, &ME11_ARID_DEF.ARID_DEF_OverDuty2);

  /* SignalConversion: '<S2>/Signal Copy126' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_IPM_Error = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPIPMErr_flg;

  /* Chart: '<S497>/OverDuty3' incorporates:
   *  RelationalOperator: '<S508>/Compare'
   */
  ME11_OverDuty1(ME11_ARID_DEF.DataTypeConversion1, COMP_IPM_Error,
                 &ME11_ARID_DEF.Sts_e, &ME11_ARID_DEF.ClearFlt_c,
                 &ME11_ARID_DEF.ARID_DEF_OverDuty3);

  /* SignalConversion: '<S2>/Signal Copy130' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_OverCurrent = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPOvrCurr_enum;

  /* Chart: '<S497>/OverDuty4' incorporates:
   *  Constant: '<S509>/Constant'
   *  RelationalOperator: '<S509>/Compare'
   */
  ME11_OverDuty1(ME11_ARID_DEF.DataTypeConversion1, COMP_OverCurrent == 1,
                 &ME11_ARID_DEF.Sts_d, &ME11_ARID_DEF.ClearFlt_f,
                 &ME11_ARID_DEF.ARID_DEF_OverDuty4);

  /* SignalConversion: '<S2>/Signal Copy121' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_CurrentOffset = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD()
    )->VIPM_COMPCurrOfst_flg;

  /* Chart: '<S497>/OverDuty5' incorporates:
   *  RelationalOperator: '<S510>/Compare'
   */
  ME11_OverDuty1(ME11_ARID_DEF.DataTypeConversion1, COMP_CurrentOffset,
                 &ME11_ARID_DEF.Sts, &ME11_ARID_DEF.ClearFlt,
                 &ME11_ARID_DEF.ARID_DEF_OverDuty5);

  /* Logic: '<S497>/OR1' */
  ACTCtl_bCOMPRealFault = ((ME11_ARID_DEF.Sts_h != 0.0) || (ME11_ARID_DEF.Sts_b
    != 0.0) || (ME11_ARID_DEF.Sts_a != 0.0) || (ME11_ARID_DEF.Sts_e != 0.0) ||
    (ME11_ARID_DEF.Sts_d != 0.0) || (ME11_ARID_DEF.Sts != 0.0));

  /* Logic: '<S449>/OR' */
  ACTCtl_bCOMPForbidFlg = (ACTCrl_bEnvCOMPLmt || rtb_FixPtRelationalOperator_i1 ||
    ACTCtl_bOCOLmtFlg || ACTCtl_bCOMPEnbDelay || ACTCtl_bPressProtectFlg ||
    ACTCtl_bPressRateFlg || ACTCtl_bCOMPRealFault);

  /* Chart: '<S449>/Flg3Cal' */
  if (ME11_ARID_DEF.temporalCounter_i1_c < 15U) {
    ME11_ARID_DEF.temporalCounter_i1_c++;
  }

  if (ME11_ARID_DEF.is_active_c152_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c152_ME11 = 1U;
    ME11_ARID_DEF.is_c152_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_bCOMPForbidFlg_p = false;
  } else {
    switch (ME11_ARID_DEF.is_c152_ME11) {
     case ME11_IN_Default_k:
      ME11_ARID_DEF.ACTCtl_bCOMPForbidFlg_p = false;
      if (ACTCtl_bCOMPForbidFlg) {
        ME11_ARID_DEF.is_c152_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_c = 0U;
      }
      break;

     case ME11_IN_Fault_b:
      ME11_ARID_DEF.ACTCtl_bCOMPForbidFlg_p = true;
      if (!ACTCtl_bCOMPForbidFlg) {
        ME11_ARID_DEF.is_c152_ME11 = ME11_IN_Default_k;
        ME11_ARID_DEF.ACTCtl_bCOMPForbidFlg_p = false;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_c >= 10) {
        ME11_ARID_DEF.is_c152_ME11 = ME11_IN_Fault_b;
        ME11_ARID_DEF.ACTCtl_bCOMPForbidFlg_p = true;
      } else if (!ACTCtl_bCOMPForbidFlg) {
        ME11_ARID_DEF.is_c152_ME11 = ME11_IN_Default_k;
        ME11_ARID_DEF.ACTCtl_bCOMPForbidFlg_p = false;
      }
      break;
    }
  }

  /* End of Chart: '<S449>/Flg3Cal' */

  /* Relay: '<S457>/Relay2' */
  ME11_ARID_DEF.Relay2_Mode_o = ((ACSen_sEvapSurTemp >= cal_COMPEvapTNmlVal) ||
    ((ACSen_sEvapSurTemp > cal_COMPEvapTFrbVal) && ME11_ARID_DEF.Relay2_Mode_o));
  for (b_previousEvent = 0; b_previousEvent < 5; b_previousEvent++) {
    /* RelationalOperator: '<S636>/Compare' incorporates:
     *  Constant: '<S636>/Constant'
     *  DataTypeConversion: '<S1316>/Data Type Conversion'
     *  Switch: '<S1735>/Switch'
     */
    rtb_Compare_gw[b_previousEvent] = (SOMCtl_eRefModes ==
      ME11_ConstP.Constant_Value_dn[b_previousEvent]);
  }

  /* Logic: '<S457>/AND' incorporates:
   *  Logic: '<S457>/OR'
   *  Relay: '<S457>/Relay2'
   */
  ACTCtl_bCOMPEnvpTPrtFlg = ((!ME11_ARID_DEF.Relay2_Mode_o) && (rtb_Compare_gw[0]
    || rtb_Compare_gw[1] || rtb_Compare_gw[2] || rtb_Compare_gw[3] ||
    rtb_Compare_gw[4]));

  /* Gain: '<S1281>/Gain' incorporates:
   *  Inport: '<Root>/AcPMP_RealRPM'
   *
   * Block description for '<Root>/AcPMP_RealRPM':
   *  
   */
  AcPMP_RealRPM = 0.400390625F * (float32)
    Rte_IRead_Task_100ms_AcPMP_RealRPM_AcPMP_RealRPM();

  /* Relay: '<S641>/Relay' */
  ME11_ARID_DEF.Relay_Mode_o = ((BMS_InletCooltActlTemp >=
    cal_BMSInletTempHighOffMCV) || ((BMS_InletCooltActlTemp >
    cal_BMSInletTempLowOnMCV) && ME11_ARID_DEF.Relay_Mode_o));

  /* MultiPortSwitch: '<S1022>/Multiport Switch' incorporates:
   *  DataTypeConversion: '<S1316>/Data Type Conversion'
   *  Switch: '<S1735>/Switch'
   */
  switch (SOMCtl_eRefModes) {
   case 4:
   case 13:
    /* MultiPortSwitch: '<S1022>/Multiport Switch' incorporates:
     *  Constant: '<S1022>/Constant1'
     */
    ACTCtl_eACPumpRefSpd = cal_ACPumpCtrlASpd;
    break;

   case 5:
    /* MultiPortSwitch: '<S1022>/Multiport Switch' incorporates:
     *  Constant: '<S1022>/Constant6'
     */
    ACTCtl_eACPumpRefSpd = cal_ACPumpBatHeatSpd;
    break;

   case 6:
    /* MultiPortSwitch: '<S1022>/Multiport Switch' incorporates:
     *  Constant: '<S1022>/Constant7'
     */
    ACTCtl_eACPumpRefSpd = cal_ACPumpDoubleHeatSpd;
    break;

   case 7:
   case 8:
   case 14:
    /* MultiPortSwitch: '<S1022>/Multiport Switch' incorporates:
     *  Constant: '<S1022>/Constant8'
     */
    ACTCtl_eACPumpRefSpd = cal_ACPumpDehSpd;
    break;

   case 12:
    /* Switch: '<S1022>/Switch3' incorporates:
     *  Relay: '<S641>/Relay'
     */
    if (ME11_ARID_DEF.Relay_Mode_o) {
      /* MultiPortSwitch: '<S1022>/Multiport Switch' incorporates:
       *  Constant: '<S1022>/Constant17'
       */
      ACTCtl_eACPumpRefSpd = cal_ACPumpDefSpd;
    } else {
      /* MultiPortSwitch: '<S1022>/Multiport Switch' incorporates:
       *  Constant: '<S1022>/Constant18'
       */
      ACTCtl_eACPumpRefSpd = cal_ACPumpBatHeatSpd;
    }

    /* End of Switch: '<S1022>/Switch3' */
    break;

   default:
    /* MultiPortSwitch: '<S1022>/Multiport Switch' incorporates:
     *  Constant: '<S1022>/Constant2'
     */
    ACTCtl_eACPumpRefSpd = cal_ACPumpDefSpd;
    break;
  }

  /* End of MultiPortSwitch: '<S1022>/Multiport Switch' */

  /* Delay: '<S1022>/Delay' */
  rtb_FixPtRelationalOperator_i1 = ME11_ARID_DEF.Delay_DSTATE_po;

  /* Chart: '<S1022>/PTCOff' incorporates:
   *  Constant: '<S1022>/Constant16'
   *  Delay: '<S1022>/Delay'
   *  RelationalOperator: '<S1034>/FixPt Relational Operator'
   *  UnitDelay: '<S1034>/Delay Input1'
   *
   * Block description for '<S1034>/Delay Input1':
   *
   *  Store in Global RAM
   */
  if (ME11_ARID_DEF.temporalCounter_i1_f < 1023U) {
    ME11_ARID_DEF.temporalCounter_i1_f++;
  }

  if (ME11_ARID_DEF.is_active_c121_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c121_ME11 = 1U;
    ME11_ARID_DEF.is_c121_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.AcSpd = 10U;
  } else {
    switch (ME11_ARID_DEF.is_c121_ME11) {
     case ME11_IN_Default_k:
      if ((sint32)ME11_ARID_DEF.Delay_DSTATE_po < (sint32)
          ME11_ARID_DEF.DelayInput1_DSTATE_kp) {
        ME11_ARID_DEF.is_c121_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.AcSpd = cal_PTCOffAcPMPSpd;
      }
      break;

     case ME11_IN_On_li:
      if ((sint32)ME11_ARID_DEF.Delay_DSTATE_po >= (sint32)
          ME11_ARID_DEF.DelayInput1_DSTATE_kp) {
        ME11_ARID_DEF.is_c121_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_f = 0U;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_f >= 600U) {
        ME11_ARID_DEF.is_c121_ME11 = ME11_IN_Default_k;
        ME11_ARID_DEF.AcSpd = 10U;
      }
      break;
    }
  }

  /* End of Chart: '<S1022>/PTCOff' */

  /* Switch: '<S444>/Switch7' incorporates:
   *  Constant: '<S939>/Constant'
   *  RelationalOperator: '<S939>/Compare'
   */
  if (BMS_HVBatCellTempMin <= cal_ExtDefBatMinT) {
    /* Switch: '<S444>/Switch7' incorporates:
     *  Constant: '<S444>/Constant6'
     */
    ACTCtl_sPTCRequestTemp = cal_ExtDefPTCTrgTemp;
  } else {
    /* Switch: '<S444>/Switch7' incorporates:
     *  Constant: '<S444>/Constant7'
     */
    ACTCtl_sPTCRequestTemp = -40.0F;
  }

  /* End of Switch: '<S444>/Switch7' */

  /* Logic: '<S444>/AND1' incorporates:
   *  Constant: '<S940>/Constant'
   *  Constant: '<S941>/Constant'
   *  DataTypeConversion: '<S1316>/Data Type Conversion'
   *  RelationalOperator: '<S940>/Compare'
   *  RelationalOperator: '<S941>/Compare'
   *  Switch: '<S1735>/Switch'
   */
  rtb_FixPtRelationalOperator_fk = ((ACTCtl_sPTCRequestTemp >= 1.0F) &&
    (SOMCtl_eRefModes == 10));

  /* Delay: '<S444>/Delay' incorporates:
   *  Delay: '<S1022>/Delay'
   */
  ME11_ARID_DEF.Delay_DSTATE_po = ME11_ARID_DEF.Delay_DSTATE_en;

  /* SignalConversion: '<S24>/Signal Copy52' incorporates:
   *  Inport: '<Root>/C3WV_PosRec'
   *
   * Block description for '<Root>/C3WV_PosRec':
   *  C3WVPosRec
   */
  MCV_PosRec = Rte_IRead_Task_100ms_C3WV_PosRec_C3WV_PosRec();

  /* SignalConversion: '<S2>/Signal Copy159' incorporates:
   *  Inport: '<Root>/IPM_BMS_5_BatTemp_EPT'
   */
  BMS_HVBatCellTempAve =
    (Rte_IRead_Task_100ms_IPM_BMS_5_BatTemp_EPT_IPM_BMS_5_BatTemp_EPT())
    ->VIPM_BMSHVBatCellTempAve_C;

  /* Outputs for Enabled SubSystem: '<S1479>/DCCharge' incorporates:
   *  EnablePort: '<S1529>/Enable'
   */
  /* RelationalOperator: '<S1527>/Compare' incorporates:
   *  Constant: '<S1527>/Constant'
   */
  if (ME11_ARID_DEF.DataTypeConversion1 == 4) {
    /* Chart: '<S1529>/DCChargeHeat' incorporates:
     *  Constant: '<S1529>/Constant1'
     *  Constant: '<S1529>/Constant2'
     *  Constant: '<S1529>/Constant3'
     */
    if (ACSen_sEnvTempCor <= cal_DCBatHeatEnvTemp[0]) {
      ME11_ARID_DEF.SOMCtl_sBatHeatT1_k = cal_DCBatHeatT1[0];
      ME11_ARID_DEF.SOMCtl_sBatHeatT2_n = cal_DCBatHeatT2[0];

      /* Merge generated from: '<S1479>/Merge' incorporates:
       *  Constant: '<S1529>/Constant2'
       *  Constant: '<S1529>/Constant3'
       */
      SOMCtl_bCalTempBatHeatFlg = true;
    } else if (ACSen_sEnvTempCor <= cal_DCBatHeatEnvTemp[1]) {
      ME11_ARID_DEF.SOMCtl_sBatHeatT1_k = cal_DCBatHeatT1[1];
      ME11_ARID_DEF.SOMCtl_sBatHeatT2_n = cal_DCBatHeatT2[1];

      /* Merge generated from: '<S1479>/Merge' incorporates:
       *  Constant: '<S1529>/Constant2'
       *  Constant: '<S1529>/Constant3'
       */
      SOMCtl_bCalTempBatHeatFlg = true;
    } else if (ACSen_sEnvTempCor > cal_DCBatHeatEnvTemp[1]) {
      ME11_ARID_DEF.SOMCtl_sBatHeatT1_k = cal_DCBatHeatT1[2];
      ME11_ARID_DEF.SOMCtl_sBatHeatT2_n = cal_DCBatHeatT2[2];

      /* Merge generated from: '<S1479>/Merge' incorporates:
       *  Constant: '<S1529>/Constant2'
       *  Constant: '<S1529>/Constant3'
       */
      SOMCtl_bCalTempBatHeatFlg = true;
    } else {
      /* Merge generated from: '<S1479>/Merge' */
      SOMCtl_bCalTempBatHeatFlg = false;
    }

    /* End of Chart: '<S1529>/DCChargeHeat' */

    /* Merge generated from: '<S1479>/Merge' incorporates:
     *  SignalConversion generated from: '<S1529>/SOMCtl_sBatHeatT1'
     */
    SOMCtl_sBatHeatT1 = ME11_ARID_DEF.SOMCtl_sBatHeatT1_k;

    /* Merge generated from: '<S1479>/Merge' incorporates:
     *  SignalConversion generated from: '<S1529>/SOMCtl_sBatHeatT2'
     */
    SOMCtl_sBatHeatT2 = ME11_ARID_DEF.SOMCtl_sBatHeatT2_n;
  }

  /* End of RelationalOperator: '<S1527>/Compare' */
  /* End of Outputs for SubSystem: '<S1479>/DCCharge' */

  /* Outputs for Enabled SubSystem: '<S1479>/ACCharge' incorporates:
   *  EnablePort: '<S1526>/Enable'
   */
  /* RelationalOperator: '<S1528>/Compare' incorporates:
   *  Constant: '<S1528>/Constant'
   */
  if (ME11_ARID_DEF.DataTypeConversion1 == 3) {
    /* Chart: '<S1526>/ACChargeHeat' incorporates:
     *  Constant: '<S1526>/Constant1'
     *  Constant: '<S1526>/Constant2'
     *  Constant: '<S1526>/Constant3'
     */
    if (ACSen_sEnvTempCor <= cal_ACBatHeatEnvTemp[0]) {
      ME11_ARID_DEF.SOMCtl_sBatHeatT1_k1 = cal_ACBatHeatT1[0];
      ME11_ARID_DEF.SOMCtl_sBatHeatT2_f = cal_ACBatHeatT2[0];

      /* Merge generated from: '<S1479>/Merge' incorporates:
       *  Constant: '<S1526>/Constant2'
       *  Constant: '<S1526>/Constant3'
       */
      SOMCtl_bCalTempBatHeatFlg = true;
    } else if (ACSen_sEnvTempCor <= cal_ACBatHeatEnvTemp[1]) {
      ME11_ARID_DEF.SOMCtl_sBatHeatT1_k1 = cal_ACBatHeatT1[1];
      ME11_ARID_DEF.SOMCtl_sBatHeatT2_f = cal_ACBatHeatT2[1];

      /* Merge generated from: '<S1479>/Merge' incorporates:
       *  Constant: '<S1526>/Constant2'
       *  Constant: '<S1526>/Constant3'
       */
      SOMCtl_bCalTempBatHeatFlg = true;
    } else if (ACSen_sEnvTempCor > cal_ACBatHeatEnvTemp[1]) {
      ME11_ARID_DEF.SOMCtl_sBatHeatT1_k1 = cal_ACBatHeatT1[2];
      ME11_ARID_DEF.SOMCtl_sBatHeatT2_f = cal_ACBatHeatT2[2];

      /* Merge generated from: '<S1479>/Merge' incorporates:
       *  Constant: '<S1526>/Constant2'
       *  Constant: '<S1526>/Constant3'
       */
      SOMCtl_bCalTempBatHeatFlg = true;
    } else {
      /* Merge generated from: '<S1479>/Merge' */
      SOMCtl_bCalTempBatHeatFlg = false;
    }

    /* End of Chart: '<S1526>/ACChargeHeat' */

    /* Merge generated from: '<S1479>/Merge' incorporates:
     *  SignalConversion generated from: '<S1526>/SOMCtl_sBatHeatT1'
     */
    SOMCtl_sBatHeatT1 = ME11_ARID_DEF.SOMCtl_sBatHeatT1_k1;

    /* Merge generated from: '<S1479>/Merge' incorporates:
     *  SignalConversion generated from: '<S1526>/SOMCtl_sBatHeatT2'
     */
    SOMCtl_sBatHeatT2 = ME11_ARID_DEF.SOMCtl_sBatHeatT2_f;
  }

  /* End of RelationalOperator: '<S1528>/Compare' */
  /* End of Outputs for SubSystem: '<S1479>/ACCharge' */

  /* Outputs for Enabled SubSystem: '<S1479>/Discharge' incorporates:
   *  EnablePort: '<S1530>/Enable'
   */
  /* Logic: '<S1479>/OR' incorporates:
   *  Constant: '<S1479>/Constant'
   *  RelationalOperator: '<S1479>/Relational Operator'
   */
  if ((ME11_ARID_DEF.DataTypeConversion1 == 2) ||
      (ME11_ARID_DEF.DataTypeConversion1 == 5)) {
    /* Chart: '<S1530>/DisChargeHeat' incorporates:
     *  Constant: '<S1530>/Constant1'
     *  Constant: '<S1530>/Constant2'
     *  Constant: '<S1530>/Constant3'
     */
    if (ACSen_sEnvTempCor <= cal_NmlBatHeatEnvTemp[0]) {
      ME11_ARID_DEF.SOMCtl_sBatHeatT1_j = cal_NmlBatHeatT1[0];
      ME11_ARID_DEF.SOMCtl_sBatHeatT2_g = cal_NmlBatHeatT2[0];

      /* Merge generated from: '<S1479>/Merge' incorporates:
       *  Constant: '<S1530>/Constant2'
       *  Constant: '<S1530>/Constant3'
       */
      SOMCtl_bCalTempBatHeatFlg = true;
    } else if (ACSen_sEnvTempCor <= cal_NmlBatHeatEnvTemp[1]) {
      ME11_ARID_DEF.SOMCtl_sBatHeatT1_j = cal_NmlBatHeatT1[1];
      ME11_ARID_DEF.SOMCtl_sBatHeatT2_g = cal_NmlBatHeatT2[1];

      /* Merge generated from: '<S1479>/Merge' incorporates:
       *  Constant: '<S1530>/Constant2'
       *  Constant: '<S1530>/Constant3'
       */
      SOMCtl_bCalTempBatHeatFlg = true;
    } else if (ACSen_sEnvTempCor > cal_NmlBatHeatEnvTemp[1]) {
      ME11_ARID_DEF.SOMCtl_sBatHeatT1_j = cal_NmlBatHeatT1[2];
      ME11_ARID_DEF.SOMCtl_sBatHeatT2_g = cal_NmlBatHeatT2[2];

      /* Merge generated from: '<S1479>/Merge' incorporates:
       *  Constant: '<S1530>/Constant2'
       *  Constant: '<S1530>/Constant3'
       */
      SOMCtl_bCalTempBatHeatFlg = true;
    } else {
      /* Merge generated from: '<S1479>/Merge' */
      SOMCtl_bCalTempBatHeatFlg = false;
    }

    /* End of Chart: '<S1530>/DisChargeHeat' */

    /* Merge generated from: '<S1479>/Merge' incorporates:
     *  SignalConversion generated from: '<S1530>/SOMCtl_sBatHeatT1'
     */
    SOMCtl_sBatHeatT1 = ME11_ARID_DEF.SOMCtl_sBatHeatT1_j;

    /* Merge generated from: '<S1479>/Merge' incorporates:
     *  SignalConversion generated from: '<S1530>/SOMCtl_sBatHeatT2'
     */
    SOMCtl_sBatHeatT2 = ME11_ARID_DEF.SOMCtl_sBatHeatT2_g;
  }

  /* End of Logic: '<S1479>/OR' */
  /* End of Outputs for SubSystem: '<S1479>/Discharge' */

  /* Outputs for Enabled SubSystem: '<S641>/MinTempMoreThanT2' incorporates:
   *  EnablePort: '<S650>/Enable'
   *
   * Block description for '<S641>/MinTempMoreThanT2':
   *  fall in between t1 and t2
   */
  /* RelationalOperator: '<S641>/Relational Operator3' */
  if (BMS_HVBatCellTempMin > SOMCtl_sBatHeatT2) {
    /* Merge: '<S641>/Merge' incorporates:
     *  Constant: '<S650>/Constant'
     *  SignalConversion generated from: '<S650>/ACTCtl_eC3WVTrgPos'
     */
    ME11_ARID_DEF.Merge = 0U;
  }

  /* End of RelationalOperator: '<S641>/Relational Operator3' */
  /* End of Outputs for SubSystem: '<S641>/MinTempMoreThanT2' */

  /* Switch: '<S1531>/Switch' incorporates:
   *  Constant: '<S1535>/Constant'
   *  Constant: '<S1536>/Constant'
   *  Constant: '<S1537>/Constant'
   *  RelationalOperator: '<S1535>/Compare'
   *  RelationalOperator: '<S1536>/Compare'
   *  RelationalOperator: '<S1537>/Compare'
   *  Switch: '<S1531>/Switch1'
   *  Switch: '<S1531>/Switch2'
   */
  if (ME11_ARID_DEF.DataTypeConversion1 == 4) {
    /* Switch: '<S1531>/Switch' incorporates:
     *  Lookup_n-D: '<S1531>/cal_DCChrgBatHeatTrgTemp_CUR'
     *  Switch: '<S1085>/Switch'
     */
    SOMCtl_sBatHeatPTCTrgT = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32
      *)&cal_DCChrgBatHeatTrgTemp_1X[0], (const float32 *)
      &cal_DCChrgBatHeatTrgTemp_CUR[0], 6U);
  } else if (ME11_ARID_DEF.DataTypeConversion1 == 3) {
    /* Switch: '<S1531>/Switch' incorporates:
     *  Lookup_n-D: '<S1531>/cal_ACChrgBatHeatTrgTemp_CUR'
     *  Switch: '<S1085>/Switch'
     *  Switch: '<S1531>/Switch1'
     */
    SOMCtl_sBatHeatPTCTrgT = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32
      *)&cal_ACChrgBatHeatTrgTemp_1X[0], (const float32 *)
      &cal_ACChrgBatHeatTrgTemp_CUR[0], 6U);
  } else if (ME11_ARID_DEF.DataTypeConversion1 == 5) {
    /* Switch: '<S1531>/Switch' incorporates:
     *  Lookup_n-D: '<S1531>/cal_DisChrgBatHeatTrgTemp_CUR'
     *  Switch: '<S1085>/Switch'
     *  Switch: '<S1531>/Switch1'
     *  Switch: '<S1531>/Switch2'
     */
    SOMCtl_sBatHeatPTCTrgT = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32
      *)&cal_DisChrgBatHeatTrgTemp_1X[0], (const float32 *)
      &cal_DisChrgBatHeatTrgTemp_CUR[0], 6U);
  } else {
    /* Switch: '<S1531>/Switch' incorporates:
     *  Constant: '<S1531>/Constant'
     *  Switch: '<S1531>/Switch1'
     *  Switch: '<S1531>/Switch2'
     */
    SOMCtl_sBatHeatPTCTrgT = 0.0F;
  }

  /* End of Switch: '<S1531>/Switch' */

  /* Lookup_n-D: '<S1531>/cal_BatHeatTrgTempComp_CUR' incorporates:
   *  Sum: '<S1531>/Add'
   */
  SOMCtl_sBatHeatTrgTempComp = look1_iflf_binlca(ACTCtl_sBatHeatInletTrgT -
    BMS_InletCooltActlTemp, (const float32 *)&cal_BatHeatTrgTempComp_1X[0], (
    const float32 *)&cal_BatHeatTrgTempComp_CUR[0], 10U);

  /* Switch: '<S1330>/Switch' incorporates:
   *  Constant: '<S1330>/Constant1'
   */
  if (cal_BatTrgTempEnb) {
    /* Switch: '<S1330>/Switch' incorporates:
     *  Constant: '<S1330>/Constant'
     */
    SOMCtl_sBatTrgTemp = cal_BatTrgTempData;
  } else {
    /* Switch: '<S1330>/Switch' incorporates:
     *  Sum: '<S1531>/Add1'
     */
    SOMCtl_sBatTrgTemp = SOMCtl_sBatHeatPTCTrgT - SOMCtl_sBatHeatTrgTempComp;
  }

  /* End of Switch: '<S1330>/Switch' */

  /* Relay: '<S444>/Relay' */
  ME11_ARID_DEF.Relay_Mode_d = ((ACSen_sEnvTempCor >= cal_ACCMOpenEnvTemp) ||
    ((ACSen_sEnvTempCor > cal_ACCMClsEnvTemp) && ME11_ARID_DEF.Relay_Mode_d));

  /* Switch: '<S944>/Switch' incorporates:
   *  Constant: '<S936>/Constant'
   *  Constant: '<S944>/Constant1'
   *  Logic: '<S444>/AND'
   *  RelationalOperator: '<S936>/Compare'
   *  Switch: '<S444>/Switch2'
   */
  if (cal_PTCReqTempDataEnb) {
    /* Switch: '<S944>/Switch' incorporates:
     *  Constant: '<S944>/Constant'
     */
    ACTCtl_sPTCRequestTemp = cal_PTCReqTempData;
  } else {
    if (ME11_ARID_DEF.OutportBufferForHMICtl_bPTCOnReq &&
        (ME11_ARID_DEF.DataTypeConversion1 >= 2)) {
      /* MinMax: '<S444>/Max1' incorporates:
       *  Switch: '<S444>/Switch2'
       */
      if (SOMCtl_sBatTrgTemp >= ACCtl_tSetPointPTC) {
        /* Switch: '<S444>/Switch2' */
        ACTCtl_sPTCRequestTemp = SOMCtl_sBatTrgTemp;
      } else {
        /* Switch: '<S444>/Switch2' */
        ACTCtl_sPTCRequestTemp = ACCtl_tSetPointPTC;
      }

      /* End of MinMax: '<S444>/Max1' */
    } else {
      /* MultiPortSwitch: '<S444>/Multiport Switch' incorporates:
       *  DataTypeConversion: '<S1316>/Data Type Conversion'
       *  Switch: '<S1735>/Switch'
       *  Switch: '<S444>/Switch2'
       */
      switch (SOMCtl_eRefModes) {
       case 5:
        /* Switch: '<S444>/Switch2' incorporates:
         *  MultiPortSwitch: '<S444>/Multiport Switch'
         */
        ACTCtl_sPTCRequestTemp = SOMCtl_sBatTrgTemp;
        break;

       case 6:
        /* Switch: '<S444>/Switch' incorporates:
         *  MinMax: '<S444>/Max'
         *  Relay: '<S444>/Relay'
         */
        if (ME11_ARID_DEF.Relay_Mode_d) {
          /* Switch: '<S444>/Switch2' incorporates:
           *  Switch: '<S444>/Switch'
           */
          ACTCtl_sPTCRequestTemp = SOMCtl_sBatTrgTemp;
        } else if (SOMCtl_sBatTrgTemp >= ACCtl_tSetPointPTC) {
          /* MinMax: '<S444>/Max' incorporates:
           *  Switch: '<S444>/Switch'
           *  Switch: '<S444>/Switch2'
           */
          ACTCtl_sPTCRequestTemp = SOMCtl_sBatTrgTemp;
        } else {
          /* Switch: '<S444>/Switch2' incorporates:
           *  MinMax: '<S444>/Max'
           *  Switch: '<S444>/Switch'
           */
          ACTCtl_sPTCRequestTemp = ACCtl_tSetPointPTC;
        }

        /* End of Switch: '<S444>/Switch' */
        break;

       case 4:
       case 13:
        /* Switch: '<S444>/Switch2' incorporates:
         *  MultiPortSwitch: '<S444>/Multiport Switch'
         */
        ACTCtl_sPTCRequestTemp = ACCtl_tSetPointPTC;
        break;

       case 10:
        break;

       case 8:
        /* Switch: '<S444>/Switch1' incorporates:
         *  Constant: '<S938>/Constant'
         *  Constant: '<S942>/Constant'
         *  DataTypeConversion: '<S1321>/Data Type Conversion1'
         *  Logic: '<S444>/AND2'
         *  RelationalOperator: '<S938>/Compare'
         *  RelationalOperator: '<S942>/Compare'
         *  Switch: '<S1473>/Switch'
         */
        if ((ME11_ARID_DEF.DataTypeConversion1 == 4) && (SOMCtl_eBatMode == 6))
        {
          /* Switch: '<S444>/Switch2' incorporates:
           *  MultiPortSwitch: '<S444>/Multiport Switch'
           */
          ACTCtl_sPTCRequestTemp = SOMCtl_sBatTrgTemp;
        } else {
          /* Switch: '<S444>/Switch2' incorporates:
           *  MultiPortSwitch: '<S444>/Multiport Switch'
           */
          ACTCtl_sPTCRequestTemp = ACCtl_tSetPointPTC;
        }

        /* End of Switch: '<S444>/Switch1' */
        break;

       default:
        /* Switch: '<S444>/Switch2' incorporates:
         *  Constant: '<S444>/Constant2'
         *  MultiPortSwitch: '<S444>/Multiport Switch'
         */
        ACTCtl_sPTCRequestTemp = -40.0F;
        break;
      }

      /* End of MultiPortSwitch: '<S444>/Multiport Switch' */
    }

    /* Switch: '<S948>/Switch2' incorporates:
     *  Constant: '<S444>/Constant1'
     *  Constant: '<S444>/Constant3'
     *  RelationalOperator: '<S948>/LowerRelop1'
     *  RelationalOperator: '<S948>/UpperRelop'
     *  Switch: '<S948>/Switch'
     */
    if (ACTCtl_sPTCRequestTemp > cal_PTCMaxTemp) {
      /* Switch: '<S944>/Switch' incorporates:
       *  Switch: '<S948>/Switch2'
       */
      ACTCtl_sPTCRequestTemp = cal_PTCMaxTemp;
    } else if (ACTCtl_sPTCRequestTemp < cal_PTCMinTemp) {
      /* Switch: '<S948>/Switch' incorporates:
       *  Constant: '<S444>/Constant3'
       *  Switch: '<S944>/Switch'
       *  Switch: '<S948>/Switch2'
       */
      ACTCtl_sPTCRequestTemp = cal_PTCMinTemp;
    }

    /* End of Switch: '<S948>/Switch2' */
  }

  /* End of Switch: '<S944>/Switch' */

  /* Switch: '<S648>/Switch' incorporates:
   *  Constant: '<S652>/Constant'
   *  Constant: '<S653>/Constant'
   *  Constant: '<S654>/Constant'
   *  RelationalOperator: '<S652>/Compare'
   *  RelationalOperator: '<S653>/Compare'
   *  RelationalOperator: '<S654>/Compare'
   *  Switch: '<S648>/Switch1'
   *  Switch: '<S648>/Switch2'
   */
  if (ME11_ARID_DEF.DataTypeConversion1 == 3) {
    /* Switch: '<S648>/Switch' incorporates:
     *  Constant: '<S648>/Constant5'
     */
    ACTCtl_sBatHeatInletTrgT = cal_ACBatHeatTrgTemp;
  } else if (ME11_ARID_DEF.DataTypeConversion1 == 4) {
    /* Switch: '<S648>/Switch1' incorporates:
     *  Constant: '<S648>/Constant4'
     *  Switch: '<S648>/Switch'
     */
    ACTCtl_sBatHeatInletTrgT = cal_DCBatHeatTrgTemp;
  } else if (ME11_ARID_DEF.DataTypeConversion1 == 5) {
    /* Switch: '<S648>/Switch2' incorporates:
     *  Constant: '<S648>/Constant6'
     *  Switch: '<S648>/Switch'
     *  Switch: '<S648>/Switch1'
     */
    ACTCtl_sBatHeatInletTrgT = cal_NmlBatHeatTrgTemp;
  } else {
    /* Switch: '<S648>/Switch' incorporates:
     *  Switch: '<S648>/Switch1'
     *  Switch: '<S648>/Switch2'
     */
    ACTCtl_sBatHeatInletTrgT = ACTCtl_sPTCRequestTemp;
  }

  /* End of Switch: '<S648>/Switch' */

  /* Outputs for Enabled SubSystem: '<S641>/FallInBetweenT1AndT2' incorporates:
   *  EnablePort: '<S647>/Enable'
   *
   * Block description for '<S641>/FallInBetweenT1AndT2':
   *  fall in between t1 and t2
   */
  /* Logic: '<S641>/AND' incorporates:
   *  RelationalOperator: '<S641>/Relational Operator1'
   *  RelationalOperator: '<S641>/Relational Operator2'
   */
  if ((BMS_HVBatCellTempMin >= SOMCtl_sBatHeatT1) && (BMS_HVBatCellTempMin <=
       SOMCtl_sBatHeatT2)) {
    /* Sum: '<S647>/Add' */
    rtb_Delay1_ie = ACTCtl_sBatHeatInletTrgT - BMS_InletCooltActlTemp;

    /* Switch: '<S651>/Switch' incorporates:
     *  Delay: '<S651>/Delay'
     *  RelationalOperator: '<S651>/Relational Operator1'
     *  RelationalOperator: '<S651>/Relational Operator3'
     *  Switch: '<S651>/Switch1'
     */
    if (rtb_Delay1_ie > ME11_ARID_DEF.Delay_DSTATE_i1) {
      /* Switch: '<S651>/Switch' incorporates:
       *  Constant: '<S651>/Constant'
       */
      ACTCtl_bBatTempDiff = 1U;
    } else if (ME11_ARID_DEF.Delay_DSTATE_i1 > rtb_Delay1_ie) {
      /* Switch: '<S651>/Switch1' incorporates:
       *  Constant: '<S651>/Constant1'
       *  Switch: '<S651>/Switch'
       */
      ACTCtl_bBatTempDiff = 2U;
    }

    /* End of Switch: '<S651>/Switch' */

    /* Switch: '<S647>/Switch' incorporates:
     *  Constant: '<S647>/Constant3'
     */
    if (cal_LessThanT1CalSwt) {
      /* MultiPortSwitch: '<S647>/Multiport Switch' */
      switch (ACTCtl_bBatTempDiff) {
       case 1:
        /* Merge: '<S641>/Merge' incorporates:
         *  Lookup_n-D: '<S647>/cal_BetwT1AndT2DownMCV_CUR'
         *  MultiPortSwitch: '<S647>/Multiport Switch'
         *  Sum: '<S647>/Add'
         */
        ME11_ARID_DEF.Merge = cal_BetwT1AndT2DownMCV_CUR[plook_u32f_binckan
          (rtb_Delay1_ie, (const float32 *)&cal_BetwT1AndT2DownMCV_1X[0], 5U)];
        break;

       case 2:
        /* Merge: '<S641>/Merge' incorporates:
         *  Lookup_n-D: '<S647>/cal_BetwT1AndT2UpMCV_CUR'
         *  MultiPortSwitch: '<S647>/Multiport Switch'
         *  Sum: '<S647>/Add'
         */
        ME11_ARID_DEF.Merge = cal_BetwT1AndT2UpMCV_CUR[plook_u32f_binckan
          (rtb_Delay1_ie, (const float32 *)&cal_BetwT1AndT2UpMCV_1X[0], 5U)];
        break;

       default:
        /* Merge: '<S641>/Merge' incorporates:
         *  Lookup_n-D: '<S647>/cal_BetwT1AndT2StbyMCV_CUR'
         *  MultiPortSwitch: '<S647>/Multiport Switch'
         *  Sum: '<S647>/Add'
         */
        ME11_ARID_DEF.Merge = cal_BetwT1AndT2StbyMCV_CUR[plook_u32f_binckan
          (rtb_Delay1_ie, (const float32 *)&cal_BetwT1AndT2StbyMCV_1X[0], 5U)];
        break;
      }

      /* End of MultiPortSwitch: '<S647>/Multiport Switch' */
    } else {
      /* Merge: '<S641>/Merge' */
      ME11_ARID_DEF.Merge = 0U;
    }

    /* End of Switch: '<S647>/Switch' */

    /* Update for Delay: '<S651>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_i1 = rtb_Delay1_ie;
  }

  /* End of Logic: '<S641>/AND' */
  /* End of Outputs for SubSystem: '<S641>/FallInBetweenT1AndT2' */

  /* Outputs for Enabled SubSystem: '<S641>/MinTempLessThanT1' incorporates:
   *  EnablePort: '<S649>/Enable'
   */
  /* RelationalOperator: '<S641>/Relational Operator' */
  if (BMS_HVBatCellTempMin <= SOMCtl_sBatHeatT1) {
    /* Switch: '<S656>/Switch' incorporates:
     *  RelationalOperator: '<S656>/Relational Operator1'
     *  RelationalOperator: '<S656>/Relational Operator3'
     *  Switch: '<S656>/Switch1'
     */
    if (BMS_InletCooltActlTemp > ME11_ARID_DEF.Delay_DSTATE_kb) {
      /* Switch: '<S656>/Switch' incorporates:
       *  Constant: '<S656>/Constant'
       */
      ACTCtl_eLessThanT1Sts = 2U;
    } else if (ME11_ARID_DEF.Delay_DSTATE_kb > BMS_InletCooltActlTemp) {
      /* Switch: '<S656>/Switch1' incorporates:
       *  Constant: '<S656>/Constant1'
       *  Switch: '<S656>/Switch'
       */
      ACTCtl_eLessThanT1Sts = 1U;
    }

    /* End of Switch: '<S656>/Switch' */

    /* Switch: '<S649>/Switch' incorporates:
     *  Constant: '<S649>/Constant3'
     */
    if (cal_LessThanT1CalSwt) {
      /* MultiPortSwitch: '<S649>/Multiport Switch' */
      switch (ACTCtl_eLessThanT1Sts) {
       case 1:
        /* Merge: '<S641>/Merge' incorporates:
         *  Lookup_n-D: '<S649>/cal_LTT1DownMCV_CUR'
         *  MultiPortSwitch: '<S649>/Multiport Switch'
         *  SignalConversion: '<S2>/Signal Copy147'
         */
        ME11_ARID_DEF.Merge = cal_LTT1DownMCV_CUR[plook_u32f_binckan
          (BMS_InletCooltActlTemp, (const float32 *)&cal_LTT1DownMCV_1X[0], 4U)];
        break;

       case 2:
        /* Merge: '<S641>/Merge' incorporates:
         *  Lookup_n-D: '<S649>/cal_LTT1UpMCV_CUR'
         *  MultiPortSwitch: '<S649>/Multiport Switch'
         *  SignalConversion: '<S2>/Signal Copy147'
         */
        ME11_ARID_DEF.Merge = cal_LTT1UpMCV_CUR[plook_u32f_binckan
          (BMS_InletCooltActlTemp, (const float32 *)&cal_LTT1UpMCV_1X[0], 4U)];
        break;

       default:
        /* Merge: '<S641>/Merge' incorporates:
         *  Lookup_n-D: '<S649>/cal_LTT1StbyMCV_CUR'
         *  MultiPortSwitch: '<S649>/Multiport Switch'
         *  SignalConversion: '<S2>/Signal Copy147'
         */
        ME11_ARID_DEF.Merge = cal_LTT1StbyMCV_CUR[plook_u32f_binckan
          (BMS_InletCooltActlTemp, (const float32 *)&cal_LTT1StbyMCV_1X[0], 5U)];
        break;
      }

      /* End of MultiPortSwitch: '<S649>/Multiport Switch' */
    } else {
      /* Merge: '<S641>/Merge' */
      ME11_ARID_DEF.Merge = 0U;
    }

    /* End of Switch: '<S649>/Switch' */

    /* Update for Delay: '<S656>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_kb = BMS_InletCooltActlTemp;
  }

  /* End of RelationalOperator: '<S641>/Relational Operator' */
  /* End of Outputs for SubSystem: '<S641>/MinTempLessThanT1' */

  /* Switch: '<S641>/Switch7' incorporates:
   *  Constant: '<S643>/Constant'
   *  Constant: '<S644>/Constant'
   *  Constant: '<S645>/Constant'
   *  Constant: '<S646>/Constant'
   *  DataTypeConversion: '<S1316>/Data Type Conversion'
   *  Logic: '<S641>/AND1'
   *  RelationalOperator: '<S643>/Compare'
   *  RelationalOperator: '<S644>/Compare'
   *  RelationalOperator: '<S645>/Compare'
   *  RelationalOperator: '<S646>/Compare'
   *  Switch: '<S1735>/Switch'
   *  Switch: '<S641>/Switch1'
   *  Switch: '<S641>/Switch2'
   *  Switch: '<S641>/Switch3'
   *  Switch: '<S641>/Switch5'
   */
  if (ACCtl_bExhFlg) {
    /* DataTypeConversion: '<S24>/Data Type Conversion' incorporates:
     *  Constant: '<S641>/Constant7'
     */
    rtb_Add3_do = cal_C3WVExhPosVal;
  } else if (SOMCtl_eRefModes == 12) {
    /* Switch: '<S641>/Switch6' incorporates:
     *  Relay: '<S641>/Relay'
     *  Switch: '<S641>/Switch5'
     */
    if (ME11_ARID_DEF.Relay_Mode_o) {
      /* DataTypeConversion: '<S24>/Data Type Conversion' incorporates:
       *  Constant: '<S641>/Constant6'
       *  Switch: '<S641>/Switch5'
       */
      rtb_Add3_do = 0U;
    } else {
      /* DataTypeConversion: '<S24>/Data Type Conversion' incorporates:
       *  Constant: '<S641>/Constant5'
       *  Switch: '<S641>/Switch5'
       */
      rtb_Add3_do = 20U;
    }

    /* End of Switch: '<S641>/Switch6' */
  } else if ((SOMCtl_eRefModes == 10) && rtb_FixPtRelationalOperator_fk) {
    /* Switch: '<S641>/Switch3' incorporates:
     *  Constant: '<S641>/Constant3'
     *  DataTypeConversion: '<S24>/Data Type Conversion'
     *  Switch: '<S641>/Switch5'
     */
    rtb_Add3_do = 20U;
  } else if (SOMCtl_eRefModes == 5) {
    /* Switch: '<S641>/Switch1' incorporates:
     *  Constant: '<S641>/Constant1'
     *  DataTypeConversion: '<S24>/Data Type Conversion'
     *  Switch: '<S641>/Switch3'
     *  Switch: '<S641>/Switch5'
     */
    rtb_Add3_do = 20U;
  } else if (SOMCtl_eRefModes == 6) {
    /* Switch: '<S641>/Switch2' incorporates:
     *  DataTypeConversion: '<S24>/Data Type Conversion'
     *  Switch: '<S641>/Switch1'
     *  Switch: '<S641>/Switch3'
     *  Switch: '<S641>/Switch5'
     */
    rtb_Add3_do = ME11_ARID_DEF.Merge;
  } else {
    /* DataTypeConversion: '<S24>/Data Type Conversion' incorporates:
     *  Constant: '<S641>/Constant2'
     *  Switch: '<S641>/Switch1'
     *  Switch: '<S641>/Switch2'
     *  Switch: '<S641>/Switch3'
     *  Switch: '<S641>/Switch5'
     */
    rtb_Add3_do = 0U;
  }

  /* End of Switch: '<S641>/Switch7' */

  /* RelationalOperator: '<S642>/Relational Operator' incorporates:
   *  Sum: '<S642>/Add'
   */
  rtb_RelationalOperator_nf = ((uint16)(MCV_PosRec - rtb_Add3_do) >= 1);

  /* Switch: '<S1035>/Switch' incorporates:
   *  Constant: '<S1035>/Constant1'
   *  Logic: '<S642>/NOT'
   *  Switch: '<S1022>/Switch4'
   */
  if (cal_AcPMPSpdSetDataEnb) {
    /* Switch: '<S1022>/Switch2' incorporates:
     *  Constant: '<S1035>/Constant'
     *  Switch: '<S1035>/Switch'
     */
    ACTCtl_eAcPMPSpdPerc = cal_AcPMPSpdSetData;
  } else if (!rtb_RelationalOperator_nf) {
    /* Switch: '<S1022>/Switch7' incorporates:
     *  Switch: '<S1022>/Switch4'
     */
    if (ACCtl_bExhFlg) {
      /* Switch: '<S1022>/Switch2' incorporates:
       *  Constant: '<S1022>/Constant19'
       *  Switch: '<S1022>/Switch7'
       *  Switch: '<S1035>/Switch'
       */
      ACTCtl_eAcPMPSpdPerc = 50U;
    } else {
      for (b_previousEvent = 0; b_previousEvent < 5; b_previousEvent++) {
        /* RelationalOperator: '<S1033>/Compare' incorporates:
         *  Constant: '<S1033>/Constant'
         *  DataTypeConversion: '<S1316>/Data Type Conversion'
         *  Switch: '<S1735>/Switch'
         */
        rtb_Compare_gw[b_previousEvent] = (SOMCtl_eRefModes ==
          ME11_ConstP.pooled89[b_previousEvent]);
      }

      /* Switch: '<S1022>/Switch' incorporates:
       *  Constant: '<S1022>/Constant4'
       *  Constant: '<S1022>/Constant5'
       */
      if (rtb_FixPtRelationalOperator_fk) {
        rtb_Add7_i = 100U;
      } else {
        rtb_Add7_i = 10U;
      }

      /* Switch: '<S1022>/Switch2' incorporates:
       *  Constant: '<S1022>/Constant12'
       *  Constant: '<S1022>/Constant13'
       *  Delay: '<S1022>/Delay'
       *  Logic: '<S1022>/OR1'
       *  Logic: '<S1022>/OR2'
       */
      if (ME11_ARID_DEF.Delay_DSTATE_po || (rtb_Compare_gw[0] || rtb_Compare_gw
           [1] || rtb_Compare_gw[2] || rtb_Compare_gw[3] || rtb_Compare_gw[4]))
      {
        ACTCtl_eAcPMPSpdPerc = cal_PTCRunAcPMPFFSpd;
      } else {
        ACTCtl_eAcPMPSpdPerc = 10U;
      }

      /* MinMax: '<S1022>/Max' incorporates:
       *  Switch: '<S1022>/Switch'
       *  Switch: '<S1022>/Switch2'
       */
      if (ACTCtl_eACPumpRefSpd >= ME11_ARID_DEF.AcSpd) {
        rtb_Add6_d = ACTCtl_eACPumpRefSpd;
      } else {
        rtb_Add6_d = ME11_ARID_DEF.AcSpd;
      }

      if (rtb_Add6_d >= rtb_Add7_i) {
        rtb_Add7_i = rtb_Add6_d;
      }

      if (rtb_Add7_i >= ACTCtl_eAcPMPSpdPerc) {
        /* Switch: '<S1035>/Switch' incorporates:
         *  Switch: '<S1022>/Switch7'
         */
        ACTCtl_eAcPMPSpdPerc = rtb_Add7_i;
      }

      /* End of MinMax: '<S1022>/Max' */
    }

    /* End of Switch: '<S1022>/Switch7' */
  } else {
    /* Switch: '<S1022>/Switch2' incorporates:
     *  Constant: '<S1022>/Constant20'
     *  Switch: '<S1022>/Switch4'
     *  Switch: '<S1035>/Switch'
     */
    ACTCtl_eAcPMPSpdPerc = 10U;
  }

  /* End of Switch: '<S1035>/Switch' */

  /* Switch: '<S1039>/Switch2' incorporates:
   *  Constant: '<S1022>/Constant10'
   *  Constant: '<S1022>/Constant9'
   *  RelationalOperator: '<S1039>/LowerRelop1'
   *  RelationalOperator: '<S1039>/UpperRelop'
   *  Switch: '<S1039>/Switch'
   */
  if (ACTCtl_eAcPMPSpdPerc > 100) {
    /* Switch: '<S1039>/Switch2' */
    rtb_Add6_d = 100U;
  } else if (ACTCtl_eAcPMPSpdPerc < 10) {
    /* Switch: '<S1039>/Switch' incorporates:
     *  Constant: '<S1022>/Constant9'
     *  Switch: '<S1039>/Switch2'
     */
    rtb_Add6_d = 10U;
  } else {
    /* Switch: '<S1039>/Switch2' incorporates:
     *  Switch: '<S1039>/Switch'
     */
    rtb_Add6_d = ACTCtl_eAcPMPSpdPerc;
  }

  /* End of Switch: '<S1039>/Switch2' */

  /* Chart: '<S1022>/AcPMPSpdPrt' incorporates:
   *  Constant: '<S1022>/Constant'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_ja < 63U) {
    ME11_ARID_DEF.temporalCounter_i1_ja++;
  }

  if (ME11_ARID_DEF.is_active_c94_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c94_ME11 = 1U;
    ME11_ARID_DEF.is_c94_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_bAcPMPSpdFlt_a = false;
  } else {
    switch (ME11_ARID_DEF.is_c94_ME11) {
     case ME11_IN_Default_k:
      ME11_ARID_DEF.ACTCtl_bAcPMPSpdFlt_a = false;
      if ((rtb_Add6_d > AcPMP_RealRPM + (float32)cal_ACPMPSpdDiffVal) ||
          (rtb_Add6_d < AcPMP_RealRPM - (float32)cal_ACPMPSpdDiffVal)) {
        ME11_ARID_DEF.is_c94_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_ja = 0U;
      }
      break;

     case ME11_IN_Fault_b:
      ME11_ARID_DEF.ACTCtl_bAcPMPSpdFlt_a = true;
      if ((rtb_Add6_d < AcPMP_RealRPM + (float32)cal_ACPMPSpdDiffVal) &&
          (rtb_Add6_d > AcPMP_RealRPM - (float32)cal_ACPMPSpdDiffVal)) {
        ME11_ARID_DEF.is_c94_ME11 = ME11_IN_Default_k;
        ME11_ARID_DEF.ACTCtl_bAcPMPSpdFlt_a = false;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_ja >= 50U) {
        ME11_ARID_DEF.is_c94_ME11 = ME11_IN_Fault_b;
        ME11_ARID_DEF.ACTCtl_bAcPMPSpdFlt_a = true;
      } else if ((rtb_Add6_d < AcPMP_RealRPM + (float32)cal_ACPMPSpdDiffVal) &&
                 (rtb_Add6_d > AcPMP_RealRPM - (float32)cal_ACPMPSpdDiffVal)) {
        ME11_ARID_DEF.is_c94_ME11 = ME11_IN_Default_k;
        ME11_ARID_DEF.ACTCtl_bAcPMPSpdFlt_a = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1022>/AcPMPSpdPrt' */

  /* Switch: '<S1022>/Switch1' incorporates:
   *  Constant: '<S1032>/Constant'
   *  RelationalOperator: '<S1032>/Compare'
   */
  ACTCtl_bAcPMPSpdFlt = ((rtb_Add6_d > 12) &&
    ME11_ARID_DEF.ACTCtl_bAcPMPSpdFlt_a);

  /* Gain: '<S1284>/Gain' incorporates:
   *  Inport: '<Root>/BatPMP_RealRPM'
   *
   * Block description for '<Root>/BatPMP_RealRPM':
   *  
   */
  BatPMP_RealRPM = 0.400390625F * (float32)
    Rte_IRead_Task_100ms_BatPMP_RealRPM_BatPMP_RealRPM();

  /* Chart: '<S1311>/OTS_WaterMode' */
  if (ME11_ARID_DEF.is_active_c145_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c145_ME11 = 1U;

    /* /_
       0x0:OFF
       0x1:Cool
       0x2:thermal storage
       0x3:motor heat battary
       0x4:Balancec
       0x5:LTR
       0x6:Heat
       _/ */
    ME11_ARID_DEF.is_WatMode = ME11_IN_Off_nh;
    rtb_Add7_i = 0U;
  } else {
    switch (ME11_ARID_DEF.is_WatMode) {
     case ME11_IN_Balance:
      rtb_Add7_i = 4U;
      if (!SOMCtl_bMotorLTRAndBatBalFlg) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_Off_nh;
        rtb_Add7_i = 0U;
      }
      break;

     case ME11_IN_HStr_m:
      rtb_Add7_i = 3U;
      if (rtb_SOMCtl_bBatTSFlg == 0) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_Off_nh;
        rtb_Add7_i = 0U;
      }
      break;

     case ME11_IN_LTR_n:
      rtb_Add7_i = 1U;
      if (!SOMCtl_bMotAndBatLTRFlg) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_Off_nh;
        rtb_Add7_i = 0U;
      }
      break;

     case ME11_IN_MotLTRAndBat:
      rtb_Add7_i = 2U;
      if (!SOMCtl_bBatHeatFlg) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_Off_nh;
        rtb_Add7_i = 0U;
      }
      break;

     case ME11_IN_MotLTRAndBatCool:
      rtb_Add7_i = 2U;
      if (!SOMCtl_bBatCoolFlg) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_Off_nh;
        rtb_Add7_i = 0U;
      }
      break;

     case ME11_IN_MotorHeatBat:
      rtb_Add7_i = 5U;
      if (!SOMCtl_bMotHeatBatFlg) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_Off_nh;
        rtb_Add7_i = 0U;
      }
      break;

     default:
      /* case IN_Off: */
      rtb_Add7_i = 0U;
      if (SOMCtl_bBatCoolFlg) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_MotLTRAndBatCool;
        rtb_Add7_i = 2U;
      } else if (rtb_SOMCtl_bBatTSFlg == 1) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_HStr_m;
        rtb_Add7_i = 3U;
      } else if (SOMCtl_bMotHeatBatFlg) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_MotorHeatBat;
        rtb_Add7_i = 5U;
      } else if (SOMCtl_bMotorLTRAndBatBalFlg) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_Balance;
        rtb_Add7_i = 4U;
      } else if (SOMCtl_bMotAndBatLTRFlg) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_LTR_n;
        rtb_Add7_i = 1U;
      } else if (SOMCtl_bBatHeatFlg) {
        ME11_ARID_DEF.is_WatMode = ME11_IN_MotLTRAndBat;
        rtb_Add7_i = 2U;
      }
      break;
    }
  }

  /* End of Chart: '<S1311>/OTS_WaterMode' */

  /* Switch: '<S1727>/Switch' incorporates:
   *  Chart: '<S1317>/WaterMode'
   *  Constant: '<S1727>/Constant1'
   *  Constant: '<S32>/Constant1'
   *  DataTypeConversion: '<S1321>/Data Type Conversion1'
   *  Switch: '<S1473>/Switch'
   *  Switch: '<S32>/Switch1'
   */
  /*
     0x0:default
     0x1:LTR(+)
     0x2:LTR+/
     0x3:+
     0x4:LTR+
     0x5:
     0x6:+
   */
  if (cal_WaterModeEnb) {
    /* Switch: '<S1727>/Switch' incorporates:
     *  Constant: '<S1727>/Constant'
     */
    SOMCtl_eWaterMode = cal_WaterModeData;
  } else if (cal_BatModeSwitch) {
    /* Switch: '<S32>/Switch1' incorporates:
     *  Switch: '<S1727>/Switch'
     */
    SOMCtl_eWaterMode = rtb_Add7_i;
  } else if (SOMCtl_eBatMode == 5) {
    /* Chart: '<S1317>/WaterMode' incorporates:
     *  DataTypeConversion: '<S1313>/Data Type Conversion'
     *  Switch: '<S1727>/Switch'
     */
    SOMCtl_eWaterMode = 1U;
  } else if (((SOMCtl_eBatMode == 1) || (SOMCtl_eBatMode == 6)) &&
             (SOMCtl_eHVPartMode == 1)) {
    /* Chart: '<S1317>/WaterMode' incorporates:
     *  DataTypeConversion: '<S1313>/Data Type Conversion'
     *  Switch: '<S1727>/Switch'
     */
    SOMCtl_eWaterMode = 2U;
  } else if (SOMCtl_eBatMode == 2) {
    /* Chart: '<S1317>/WaterMode' incorporates:
     *  DataTypeConversion: '<S1313>/Data Type Conversion'
     *  Switch: '<S1727>/Switch'
     */
    SOMCtl_eWaterMode = 3U;
  } else if ((SOMCtl_eBatMode == 4) || (SOMCtl_eHVPartMode == 1)) {
    /* Chart: '<S1317>/WaterMode' incorporates:
     *  DataTypeConversion: '<S1313>/Data Type Conversion'
     *  Switch: '<S1727>/Switch'
     */
    SOMCtl_eWaterMode = 4U;
  } else if (SOMCtl_eBatMode == 3) {
    /* Chart: '<S1317>/WaterMode' incorporates:
     *  DataTypeConversion: '<S1313>/Data Type Conversion'
     *  Switch: '<S1727>/Switch'
     */
    SOMCtl_eWaterMode = 5U;
  } else {
    /* Switch: '<S1727>/Switch' incorporates:
     *  DataTypeConversion: '<S1313>/Data Type Conversion'
     */
    SOMCtl_eWaterMode = 0U;
  }

  /* End of Switch: '<S1727>/Switch' */

  /* DataTypeConversion: '<S1313>/Data Type Conversion1' incorporates:
   *  Switch: '<S1727>/Switch'
   */
  rtb_DataTypeConversion1_j0 = SOMCtl_eWaterMode;

  /* DataTypeConversion: '<S8>/Data Type Conversion16' incorporates:
   *  Constant: '<S1063>/Constant1'
   *  Constant: '<S1063>/Constant8'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   *  MultiPortSwitch: '<S1063>/Index Vector1'
   *  RelationalOperator: '<S1063>/Relational Operator'
   */
  rtb_FixPtRelationalOperator_a0 = (cal_LTRIGBTTempMotPMPCtrl_1X[0] >
    (Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
    ->VIPM_INV2IgbtMaxTemp_C);

  /* Switch: '<S1063>/Switch' */
  if (rtb_FixPtRelationalOperator_a0) {
    /* Switch: '<S663>/Switch3' incorporates:
     *  Constant: '<S1063>/Constant4'
     *  Constant: '<S1063>/Constant5'
     *  MultiPortSwitch: '<S1063>/Index Vector3'
     */
    rtb_Switch3_l = cal_LTRIGBTTempMotPMPCtrl_1Y[0];
  } else {
    /* RelationalOperator: '<S1063>/Relational Operator1' incorporates:
     *  Constant: '<S1063>/Constant2'
     *  Constant: '<S1063>/Constant3'
     *  Inport: '<Root>/IPM_INV_2_Value_EPT'
     *  MultiPortSwitch: '<S1063>/Index Vector2'
     */
    rtb_Compare_mgx =
      ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
       ->VIPM_INV2IgbtMaxTemp_C >= cal_LTRIGBTTempMotPMPCtrl_1X[1]);

    /* Switch: '<S1063>/Switch1' */
    if (rtb_Compare_mgx) {
      /* Switch: '<S663>/Switch3' incorporates:
       *  Constant: '<S1063>/Constant6'
       *  Constant: '<S1063>/Constant7'
       *  MultiPortSwitch: '<S1063>/Index Vector4'
       *  Switch: '<S1063>/Switch1'
       */
      rtb_Switch3_l = cal_LTRIGBTTempMotPMPCtrl_1Y[2];
    } else {
      /* Switch: '<S663>/Switch3' incorporates:
       *  Constant: '<S1063>/Constant10'
       *  Constant: '<S1063>/Constant9'
       *  MultiPortSwitch: '<S1063>/Index Vector5'
       *  Switch: '<S1063>/Switch1'
       */
      rtb_Switch3_l = cal_LTRIGBTTempMotPMPCtrl_1Y[1];
    }

    /* End of Switch: '<S1063>/Switch1' */
  }

  /* End of Switch: '<S1063>/Switch' */

  /* DataTypeConversion: '<S8>/Data Type Conversion16' incorporates:
   *  Constant: '<S1064>/Constant1'
   *  Constant: '<S1064>/Constant8'
   *  Inport: '<Root>/IPM_INV_2_Value_EPT'
   *  MultiPortSwitch: '<S1064>/Index Vector1'
   *  RelationalOperator: '<S1064>/Relational Operator'
   */
  rtb_FixPtRelationalOperator_a0 = (cal_LTRMotorTempMotPMPCtrl_1X[0] >
    (Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
    ->VIPM_INV2MotorMaxTemp_C);

  /* Switch: '<S1064>/Switch' */
  if (rtb_FixPtRelationalOperator_a0) {
    /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
     *  Constant: '<S1064>/Constant4'
     *  Constant: '<S1064>/Constant5'
     *  MultiPortSwitch: '<S1064>/Index Vector3'
     */
    rtb_DataTypeConversion_jr = cal_LTRMotorTempMotPMPCtrl_1Y[0];
  } else {
    /* RelationalOperator: '<S1064>/Relational Operator1' incorporates:
     *  Constant: '<S1064>/Constant2'
     *  Constant: '<S1064>/Constant3'
     *  Inport: '<Root>/IPM_INV_2_Value_EPT'
     *  MultiPortSwitch: '<S1064>/Index Vector2'
     */
    rtb_Compare_mgx =
      ((Rte_IRead_Task_100ms_IPM_INV_2_Value_EPT_IPM_INV_2_Value_EPT())
       ->VIPM_INV2MotorMaxTemp_C >= cal_LTRMotorTempMotPMPCtrl_1X[1]);

    /* Switch: '<S1064>/Switch1' */
    if (rtb_Compare_mgx) {
      /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
       *  Constant: '<S1064>/Constant6'
       *  Constant: '<S1064>/Constant7'
       *  MultiPortSwitch: '<S1064>/Index Vector4'
       *  Switch: '<S1064>/Switch1'
       */
      rtb_DataTypeConversion_jr = cal_LTRMotorTempMotPMPCtrl_1Y[2];
    } else {
      /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
       *  Constant: '<S1064>/Constant10'
       *  Constant: '<S1064>/Constant9'
       *  MultiPortSwitch: '<S1064>/Index Vector5'
       *  Switch: '<S1064>/Switch1'
       */
      rtb_DataTypeConversion_jr = cal_LTRMotorTempMotPMPCtrl_1Y[1];
    }

    /* End of Switch: '<S1064>/Switch1' */
  }

  /* End of Switch: '<S1064>/Switch' */

  /* DataTypeConversion: '<S8>/Data Type Conversion16' incorporates:
   *  Constant: '<S1067>/Constant1'
   *  Constant: '<S1067>/Constant8'
   *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
   *  MultiPortSwitch: '<S1067>/Index Vector1'
   *  RelationalOperator: '<S1067>/Relational Operator'
   */
  rtb_FixPtRelationalOperator_a0 = (cal_LTRIPUTempMotPMPCtrl_1X[0] >
    (Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT())
    ->VIPM_IPUDeviceIntTemp_C);

  /* Switch: '<S1067>/Switch' */
  if (rtb_FixPtRelationalOperator_a0) {
    /* DataTypeConversion: '<S452>/Data Type Conversion' incorporates:
     *  Constant: '<S1067>/Constant4'
     *  Constant: '<S1067>/Constant5'
     *  MultiPortSwitch: '<S1067>/Index Vector3'
     */
    rtb_Add5_d = cal_LTRIPUTempMotPMPCtrl_1Y[0];
  } else {
    /* RelationalOperator: '<S1067>/Relational Operator1' incorporates:
     *  Constant: '<S1067>/Constant2'
     *  Constant: '<S1067>/Constant3'
     *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
     *  MultiPortSwitch: '<S1067>/Index Vector2'
     */
    rtb_Compare_mgx =
      ((Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT()
       )->VIPM_IPUDeviceIntTemp_C >= cal_LTRIPUTempMotPMPCtrl_1X[1]);

    /* Switch: '<S1067>/Switch1' */
    if (rtb_Compare_mgx) {
      /* DataTypeConversion: '<S452>/Data Type Conversion' incorporates:
       *  Constant: '<S1067>/Constant6'
       *  Constant: '<S1067>/Constant7'
       *  MultiPortSwitch: '<S1067>/Index Vector4'
       *  Switch: '<S1067>/Switch1'
       */
      rtb_Add5_d = cal_LTRIPUTempMotPMPCtrl_1Y[2];
    } else {
      /* DataTypeConversion: '<S452>/Data Type Conversion' incorporates:
       *  Constant: '<S1067>/Constant10'
       *  Constant: '<S1067>/Constant9'
       *  MultiPortSwitch: '<S1067>/Index Vector5'
       *  Switch: '<S1067>/Switch1'
       */
      rtb_Add5_d = cal_LTRIPUTempMotPMPCtrl_1Y[1];
    }

    /* End of Switch: '<S1067>/Switch1' */
  }

  /* End of Switch: '<S1067>/Switch' */

  /* MinMax: '<S1024>/Max1' */
  if (rtb_Switch3_l >= rtb_DataTypeConversion_jr) {
    rtb_DataTypeConversion_jr = rtb_Switch3_l;
  }

  if (rtb_DataTypeConversion_jr >= rtb_Add5_d) {
    /* MinMax: '<S1024>/Max1' */
    rtb_Add5_d = rtb_DataTypeConversion_jr;
  }

  /* End of MinMax: '<S1024>/Max1' */

  /* Chart: '<S1023>/CoolStopDelayPMP' incorporates:
   *  Constant: '<S1023>/Constant15'
   *  Constant: '<S1023>/Constant16'
   *  Constant: '<S1023>/Constant17'
   *  Constant: '<S1048>/Constant'
   *  Delay: '<S1023>/Delay'
   *  Logic: '<S1023>/AND'
   *  Product: '<S1023>/Divide1'
   *  RelationalOperator: '<S1048>/Compare'
   *  RelationalOperator: '<S1050>/FixPt Relational Operator'
   *  UnitDelay: '<S1050>/Delay Input1'
   *
   * Block description for '<S1050>/Delay Input1':
   *
   *  Store in Global RAM
   */
  if (ME11_ARID_DEF.is_active_c151_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c151_ME11 = 1U;
    ME11_ARID_DEF.is_c151_ME11 = ME11_IN_OFF;
    ME11_ARID_DEF.BatPMPSpd = 10U;
    ME11_ARID_DEF.counter = 0U;
  } else if (ME11_ARID_DEF.is_c151_ME11 == ME11_IN_OFF) {
    if ((ME11_ARID_DEF.Delay_DSTATE_lv == 1) && (rtb_IFreezFlag_k !=
         ME11_ARID_DEF.DelayInput1_DSTATE_ju)) {
      ME11_ARID_DEF.is_c151_ME11 = ME11_IN_ON;
      ME11_ARID_DEF.BatPMPSpd = cal_BatCoolStopBatPMPSpd;
    }

    /* case IN_ON: */
  } else if (ME11_ARID_DEF.counter > (sint32)(cal_BatCoolStopBatPMPRunTime * 10U))
  {
    ME11_ARID_DEF.is_c151_ME11 = ME11_IN_OFF;
    ME11_ARID_DEF.BatPMPSpd = 10U;
    ME11_ARID_DEF.counter = 0U;
  } else {
    b_previousEvent = ME11_ARID_DEF.counter + 1;
    if (ME11_ARID_DEF.counter + 1 > 65535) {
      b_previousEvent = 65535;
    }

    ME11_ARID_DEF.counter = (uint16)b_previousEvent;
  }

  /* End of Chart: '<S1023>/CoolStopDelayPMP' */

  /* SignalConversion: '<S17>/Signal Copy68' incorporates:
   *  Inport: '<Root>/C5WVPosRec'
   *
   * Block description for '<Root>/C5WVPosRec':
   *  C5WVPosRec
   */
  BCV_PosRec = Rte_IRead_Task_100ms_C5WVPosRec_C5WVPosRec();

  /* Switch: '<S663>/Switch3' incorporates:
   *  Constant: '<S663>/Constant'
   *  Constant: '<S665>/Constant'
   *  Constant: '<S666>/Constant'
   *  DataTypeConversion: '<S1316>/Data Type Conversion'
   *  RelationalOperator: '<S665>/Compare'
   *  RelationalOperator: '<S666>/Compare'
   *  Switch: '<S1735>/Switch'
   *  Switch: '<S663>/Switch'
   *  Switch: '<S663>/Switch1'
   *  Switch: '<S663>/Switch2'
   */
  if (ACCtl_bExhFlg) {
    /* Switch: '<S663>/Switch3' incorporates:
     *  Constant: '<S663>/Constant11'
     */
    rtb_Switch3_l = cal_C5WVExhPosVal;
  } else if (cal_BatModeTestCtrl) {
    /* Switch: '<S663>/Switch3' incorporates:
     *  Constant: '<S663>/Constant9'
     *  Switch: '<S663>/Switch1'
     */
    rtb_Switch3_l = 13U;
  } else if (SOMCtl_eRefModes == 13) {
    /* Switch: '<S663>/Switch3' incorporates:
     *  Constant: '<S663>/Constant10'
     *  Switch: '<S663>/Switch1'
     *  Switch: '<S663>/Switch2'
     */
    rtb_Switch3_l = 12U;
  } else if (SOMCtl_eRefModes == 10) {
    /* Switch: '<S663>/Switch3' incorporates:
     *  Constant: '<S663>/Constant8'
     *  Switch: '<S663>/Switch'
     *  Switch: '<S663>/Switch1'
     *  Switch: '<S663>/Switch2'
     */
    rtb_Switch3_l = 25U;
  } else {
    /* MultiPortSwitch: '<S663>/Multiport Switch' incorporates:
     *  DataTypeConversion: '<S1313>/Data Type Conversion1'
     *  Switch: '<S1727>/Switch'
     *  Switch: '<S663>/Switch'
     *  Switch: '<S663>/Switch1'
     *  Switch: '<S663>/Switch2'
     */
    switch (SOMCtl_eWaterMode) {
     case 1:
      /* Switch: '<S663>/Switch3' incorporates:
       *  Constant: '<S663>/Constant7'
       *  MultiPortSwitch: '<S663>/Multiport Switch'
       */
      rtb_Switch3_l = 12U;
      break;

     case 2:
      /* Switch: '<S663>/Switch3' incorporates:
       *  Constant: '<S663>/Constant1'
       *  MultiPortSwitch: '<S663>/Multiport Switch'
       */
      rtb_Switch3_l = 25U;
      break;

     case 3:
      /* Switch: '<S663>/Switch3' incorporates:
       *  Constant: '<S663>/Constant2'
       *  MultiPortSwitch: '<S663>/Multiport Switch'
       */
      rtb_Switch3_l = 13U;
      break;

     case 4:
      /* Switch: '<S663>/Switch3' incorporates:
       *  Constant: '<S663>/Constant5'
       *  MultiPortSwitch: '<S663>/Multiport Switch'
       */
      rtb_Switch3_l = 25U;
      break;

     case 5:
      /* Switch: '<S663>/Switch3' incorporates:
       *  Constant: '<S663>/Constant3'
       *  MultiPortSwitch: '<S663>/Multiport Switch'
       */
      rtb_Switch3_l = 0U;
      break;

     case 6:
      /* Switch: '<S663>/Switch3' incorporates:
       *  Constant: '<S663>/Constant4'
       *  MultiPortSwitch: '<S663>/Multiport Switch'
       */
      rtb_Switch3_l = 0U;
      break;

     default:
      /* Switch: '<S663>/Switch3' incorporates:
       *  Constant: '<S663>/Constant6'
       *  MultiPortSwitch: '<S663>/Multiport Switch'
       */
      rtb_Switch3_l = 25U;
      break;
    }

    /* End of MultiPortSwitch: '<S663>/Multiport Switch' */
  }

  /* End of Switch: '<S663>/Switch3' */

  /* DataTypeConversion: '<S8>/Data Type Conversion16' incorporates:
   *  RelationalOperator: '<S664>/Relational Operator'
   *  Sum: '<S664>/Add'
   */
  rtb_FixPtRelationalOperator_a0 = ((uint16)(BCV_PosRec - rtb_Switch3_l) >= 1);

  /* Logic: '<S664>/NOT' */
  rtb_Compare_mgx = !rtb_FixPtRelationalOperator_a0;

  /* Switch: '<S1051>/Switch' incorporates:
   *  Constant: '<S1051>/Constant1'
   *  Switch: '<S1023>/Switch2'
   */
  if (cal_BatPMPSpdSetDataEnb) {
    /* Switch: '<S1051>/Switch' incorporates:
     *  Constant: '<S1051>/Constant'
     */
    rtb_MultiportSwitch1 = cal_BatPMPSpdSetData;
  } else if (rtb_Compare_mgx) {
    /* Switch: '<S1023>/Switch7' incorporates:
     *  Switch: '<S1023>/Switch2'
     */
    if (ACCtl_bExhFlg) {
      /* Switch: '<S1051>/Switch' incorporates:
       *  Constant: '<S1023>/Constant19'
       *  Switch: '<S1023>/Switch7'
       */
      rtb_MultiportSwitch1 = 50U;
    } else {
      /* MultiPortSwitch: '<S1023>/Multiport Switch1' incorporates:
       *  DataTypeConversion: '<S1313>/Data Type Conversion1'
       *  Switch: '<S1727>/Switch'
       */
      switch (SOMCtl_eWaterMode) {
       case 4:
        /* MultiPortSwitch: '<S1023>/Multiport Switch1' incorporates:
         *  Lookup_n-D: '<S1023>/cal_BatPumpBal_CUR'
         */
        rtb_MultiportSwitch1 = look1_iflftu8Df_binlca(rtb_Delay, (const float32 *)
          &cal_BatPumpBal_1X[0], (const uint8 *)&cal_BatPumpBal_CUR[0], 3U);
        break;

       case 5:
        /* MultiPortSwitch: '<S1023>/Multiport Switch1' incorporates:
         *  Constant: '<S1023>/Constant13'
         */
        rtb_MultiportSwitch1 = cal_BatPumpMotHeatBatSpd;
        break;

       case 3:
        /* MultiPortSwitch: '<S1023>/Multiport Switch1' incorporates:
         *  Lookup_n-D: '<S1023>/cal_BatPumpThSto_CUR'
         */
        rtb_MultiportSwitch1 = look1_iflftu8Df_binlca(rtb_Delay, (const float32 *)
          &cal_BatPumpThSto_1X[0], (const uint8 *)&cal_BatPumpThSto_CUR[0], 3U);
        break;

       case 1:
        /* MultiPortSwitch: '<S1023>/Multiport Switch1' */
        rtb_MultiportSwitch1 = rtb_Add5_d;
        break;

       case 2:
        /* MultiPortSwitch: '<S1023>/Multiport Switch1' incorporates:
         *  Constant: '<S1023>/Constant14'
         */
        rtb_MultiportSwitch1 = cal_BatPumpMotLTRAndBatCHSpd;
        break;

       default:
        /* MultiPortSwitch: '<S1023>/Multiport Switch1' incorporates:
         *  Constant: '<S1023>/Constant5'
         */
        rtb_MultiportSwitch1 = 10U;
        break;
      }

      /* End of MultiPortSwitch: '<S1023>/Multiport Switch1' */

      /* MultiPortSwitch: '<S1023>/Multiport Switch' incorporates:
       *  DataTypeConversion: '<S1316>/Data Type Conversion'
       *  Switch: '<S1735>/Switch'
       */
      switch (SOMCtl_eRefModes) {
       case 2:
       case 3:
       case 13:
       case 14:
        /* MultiPortSwitch: '<S1023>/Multiport Switch' incorporates:
         *  Constant: '<S1023>/Constant1'
         */
        rtb_Add7_i = cal_BatPumpCtrlASpd;
        break;

       case 5:
       case 6:
       case 10:
        /* MultiPortSwitch: '<S1023>/Multiport Switch' incorporates:
         *  Constant: '<S1023>/Constant6'
         */
        rtb_Add7_i = 100U;
        break;

       default:
        /* MultiPortSwitch: '<S1023>/Multiport Switch' incorporates:
         *  Constant: '<S1023>/Constant2'
         */
        rtb_Add7_i = 10U;
        break;
      }

      /* End of MultiPortSwitch: '<S1023>/Multiport Switch' */

      /* MinMax: '<S1023>/Max' */
      if (rtb_Add7_i >= rtb_MultiportSwitch1) {
        rtb_MultiportSwitch1 = rtb_Add7_i;
      }

      if (rtb_MultiportSwitch1 < ME11_ARID_DEF.BatPMPSpd) {
        /* Switch: '<S1051>/Switch' incorporates:
         *  Switch: '<S1023>/Switch7'
         */
        rtb_MultiportSwitch1 = ME11_ARID_DEF.BatPMPSpd;
      }

      /* End of MinMax: '<S1023>/Max' */
    }

    /* End of Switch: '<S1023>/Switch7' */
  } else {
    /* Switch: '<S1051>/Switch' incorporates:
     *  Constant: '<S1023>/Constant18'
     *  Switch: '<S1023>/Switch2'
     */
    rtb_MultiportSwitch1 = 10U;
  }

  /* End of Switch: '<S1051>/Switch' */

  /* Switch: '<S1053>/Switch2' incorporates:
   *  Constant: '<S1023>/Constant7'
   *  Constant: '<S1023>/Constant8'
   *  RelationalOperator: '<S1053>/LowerRelop1'
   *  RelationalOperator: '<S1053>/UpperRelop'
   *  Switch: '<S1053>/Switch'
   */
  if (rtb_MultiportSwitch1 > 100) {
    /* Switch: '<S1053>/Switch2' */
    rtb_MultiportSwitch1 = 100U;
  } else if (rtb_MultiportSwitch1 < 10) {
    /* Switch: '<S1053>/Switch' incorporates:
     *  Constant: '<S1023>/Constant7'
     *  Switch: '<S1053>/Switch2'
     */
    rtb_MultiportSwitch1 = 10U;
  }

  /* End of Switch: '<S1053>/Switch2' */

  /* Chart: '<S1023>/BatPMPSpdPrt' incorporates:
   *  Constant: '<S1023>/Constant'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_ih < 63U) {
    ME11_ARID_DEF.temporalCounter_i1_ih++;
  }

  if (ME11_ARID_DEF.is_active_c125_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c125_ME11 = 1U;
    ME11_ARID_DEF.is_c125_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ACTCtl_bBatPMPSpdFlt_c = false;
  } else {
    switch (ME11_ARID_DEF.is_c125_ME11) {
     case ME11_IN_Default_k:
      ME11_ARID_DEF.ACTCtl_bBatPMPSpdFlt_c = false;
      if (rtb_MultiportSwitch1 > BatPMP_RealRPM + (float32)cal_BATPMPSpdDiffVal)
      {
        ME11_ARID_DEF.is_c125_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_ih = 0U;
      }
      break;

     case ME11_IN_Fault_b:
      ME11_ARID_DEF.ACTCtl_bBatPMPSpdFlt_c = true;
      if ((rtb_MultiportSwitch1 < BatPMP_RealRPM + (float32)cal_BATPMPSpdDiffVal)
          && (rtb_MultiportSwitch1 > BatPMP_RealRPM - (float32)
              cal_BATPMPSpdDiffVal)) {
        ME11_ARID_DEF.is_c125_ME11 = ME11_IN_Default_k;
        ME11_ARID_DEF.ACTCtl_bBatPMPSpdFlt_c = false;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_ih >= 50U) {
        ME11_ARID_DEF.is_c125_ME11 = ME11_IN_Fault_b;
        ME11_ARID_DEF.ACTCtl_bBatPMPSpdFlt_c = true;
      } else if ((rtb_MultiportSwitch1 < BatPMP_RealRPM + (float32)
                  cal_BATPMPSpdDiffVal) && (rtb_MultiportSwitch1 >
                  BatPMP_RealRPM - (float32)cal_BATPMPSpdDiffVal)) {
        ME11_ARID_DEF.is_c125_ME11 = ME11_IN_Default_k;
        ME11_ARID_DEF.ACTCtl_bBatPMPSpdFlt_c = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1023>/BatPMPSpdPrt' */

  /* Switch: '<S1023>/Switch1' incorporates:
   *  Constant: '<S1047>/Constant'
   *  RelationalOperator: '<S1047>/Compare'
   */
  ACTCtl_bBatPMPSpdFlt = ((rtb_MultiportSwitch1 > 12) &&
    ME11_ARID_DEF.ACTCtl_bBatPMPSpdFlt_c);

  /* Chart: '<S1022>/PTCRunAcPMPFF' incorporates:
   *  Constant: '<S1022>/Constant14'
   *  Constant: '<S1022>/Constant15'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_a < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i1_a++;
  }

  if (ME11_ARID_DEF.is_active_c123_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c123_ME11 = 1U;
    ME11_ARID_DEF.is_c123_ME11 = ME11_IN_Off_a;
    ME11_ARID_DEF.ACTCtl_bAcPMPRunFFForPTC = false;
  } else {
    switch (ME11_ARID_DEF.is_c123_ME11) {
     case ME11_IN_Off_a:
      ME11_ARID_DEF.ACTCtl_bAcPMPRunFFForPTC = false;
      if (AcPMP_RealRPM >= cal_PTCRunAcPMPFFSpd) {
        ME11_ARID_DEF.is_c123_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_a = 0U;
      }
      break;

     case ME11_IN_On_li:
      ME11_ARID_DEF.ACTCtl_bAcPMPRunFFForPTC = true;
      if (AcPMP_RealRPM < cal_PTCRunAcPMPFFSpd) {
        ME11_ARID_DEF.is_c123_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.ACTCtl_bAcPMPRunFFForPTC = false;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_a >= cal_PTCRunAcPMPFFTime * 10.0F) {
        ME11_ARID_DEF.is_c123_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.ACTCtl_bAcPMPRunFFForPTC = true;
      }
      break;
    }
  }

  /* End of Chart: '<S1022>/PTCRunAcPMPFF' */
  for (b_previousEvent = 0; b_previousEvent < 5; b_previousEvent++) {
    /* RelationalOperator: '<S466>/Compare' incorporates:
     *  Constant: '<S466>/Constant'
     *  DataTypeConversion: '<S1316>/Data Type Conversion'
     *  Switch: '<S1735>/Switch'
     */
    rtb_Compare_gw[b_previousEvent] = (SOMCtl_eRefModes ==
      ME11_ConstP.pooled89[b_previousEvent]);
  }

  /* Sum: '<S462>/Add' incorporates:
   *  Constant: '<S474>/Constant'
   *  Constant: '<S476>/Constant'
   *  DataTypeConversion: '<S1321>/Data Type Conversion1'
   *  DataTypeConversion: '<S1683>/Data Type Conversion1'
   *  Delay: '<S451>/Delay1'
   *  Gain: '<S462>/Gain1'
   *  Gain: '<S462>/Gain2'
   *  Gain: '<S462>/Gain3'
   *  Gain: '<S462>/Gain4'
   *  Gain: '<S462>/Gain5'
   *  Logic: '<S462>/NOT'
   *  Logic: '<S462>/NOT1'
   *  Logic: '<S462>/OR10'
   *  Logic: '<S462>/OR3'
   *  Logic: '<S462>/OR6'
   *  Logic: '<S462>/OR7'
   *  Logic: '<S462>/OR8'
   *  Logic: '<S462>/OR9'
   *  RelationalOperator: '<S465>/Compare'
   *  RelationalOperator: '<S472>/Compare'
   *  RelationalOperator: '<S473>/Compare'
   *  RelationalOperator: '<S474>/Compare'
   *  RelationalOperator: '<S475>/Compare'
   *  RelationalOperator: '<S476>/Compare'
   *  Switch: '<S1473>/Switch'
   *  Switch: '<S1726>/Switch'
   *  Switch: '<S462>/Switch1'
   */
  ACTCtl_eCOMPJudgeFlg = (uint8)((((((uint32)(((((SOMCtl_eCabinMode != 1) &&
    (SOMCtl_eCabinMode != 2) && (SOMCtl_eCabinMode != 3) && (SOMCtl_eCabinMode
    != 4)) || (!ACTCtl_bAcPMPSpdFlt)) && ((!ACTCtl_bBatPMPSpdFlt) ||
    ((SOMCtl_eBatMode != 1) && (SOMCtl_eBatMode != 6)))) << 3) + (uint32)
    (!ME11_ARID_DEF.ACTCtl_bCOMPForbidFlg_p << 1)) + rtb_Gain_gr) + (uint32)
    (!ACTCtl_bCOMPEnvpTPrtFlg << 2)) + (uint32)(!ME11_ARID_DEF.Delay1_DSTATE_hf <<
    4)) + (uint32)((((!rtb_Compare_gw[0]) && (!rtb_Compare_gw[1]) &&
                     (!rtb_Compare_gw[2]) && (!rtb_Compare_gw[3]) &&
                     (!rtb_Compare_gw[4])) ||
                    ME11_ARID_DEF.ACTCtl_bAcPMPRunFFForPTC) << 5));

  /* RelationalOperator: '<S462>/Relational Operator' */
  rtb_AND2_of = (ACTCtl_eCOMPJudgeFlg == 63);

  /* Chart: '<S459>/delay' */
  if (ME11_ARID_DEF.temporalCounter_i1_ep < 15U) {
    ME11_ARID_DEF.temporalCounter_i1_ep++;
  }

  if (ME11_ARID_DEF.is_active_c44_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c44_ME11 = 1U;
    ME11_ARID_DEF.is_c44_ME11 = ME11_IN_Off_a;
    ME11_ARID_DEF.ACTCtl_eACCMCtlEnb = false;
  } else {
    switch (ME11_ARID_DEF.is_c44_ME11) {
     case ME11_IN_Off_a:
      ME11_ARID_DEF.ACTCtl_eACCMCtlEnb = false;
      if (rtb_AND2_of) {
        ME11_ARID_DEF.is_c44_ME11 = ME11_IN_Wait_c;
        ME11_ARID_DEF.temporalCounter_i1_ep = 0U;
      }
      break;

     case ME11_IN_On_li:
      ME11_ARID_DEF.ACTCtl_eACCMCtlEnb = true;
      if (!rtb_AND2_of) {
        ME11_ARID_DEF.is_c44_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.ACTCtl_eACCMCtlEnb = false;
      }
      break;

     default:
      /* case IN_Wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_ep >= 10U) {
        ME11_ARID_DEF.is_c44_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.ACTCtl_eACCMCtlEnb = true;
      } else if (!rtb_AND2_of) {
        ME11_ARID_DEF.is_c44_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.ACTCtl_eACCMCtlEnb = false;
      }
      break;
    }
  }

  /* End of Chart: '<S459>/delay' */

  /* Switch: '<S460>/Switch' incorporates:
   *  Constant: '<S460>/Constant1'
   *  Delay: '<S451>/Delay2'
   *  Switch: '<S458>/Switch'
   */
  if (cal_ACCMEnbDataEnb) {
    /* Switch: '<S460>/Switch' incorporates:
     *  Constant: '<S460>/Constant'
     */
    ACTCtl_bACCMCtlEnb = cal_ACCMEnbData;
  } else if (ME11_ARID_DEF.Delay2_DSTATE_lz) {
    /* Switch: '<S458>/Switch' incorporates:
     *  Constant: '<S458>/Constant'
     *  Switch: '<S460>/Switch'
     */
    ACTCtl_bACCMCtlEnb = false;
  } else {
    /* Switch: '<S460>/Switch' incorporates:
     *  Constant: '<S478>/Constant'
     *  Logic: '<S461>/AND1'
     *  RelationalOperator: '<S478>/Compare'
     *  RelationalOperator: '<S479>/Compare'
     *  Switch: '<S458>/Switch'
     *  Switch: '<S461>/Switch'
     */
    ACTCtl_bACCMCtlEnb = (((COMP_EcompActSpd >= cal_COMPClsLowSpeed) &&
      (!ME11_ARID_DEF.ACTCtl_eACCMCtlEnb)) || ME11_ARID_DEF.ACTCtl_eACCMCtlEnb);
  }

  /* End of Switch: '<S460>/Switch' */

  /* Switch: '<S440>/Switch' incorporates:
   *  Constant: '<S440>/Constant'
   *  Delay: '<S503>/Delay'
   */
  ME11_ARID_DEF.Delay_DSTATE_kf = (cal_ACCMForbidCtrl && ACTCtl_bACCMCtlEnb);

  /* Switch: '<S918>/Switch5' incorporates:
   *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
   */
  if ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA()
      )->VIPM_ESCVehSpdVld_flg) {
    /* Gain: '<S8>/Gain8' */
    rtb_Delay1_ie =
      (Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA()
      )->VIPM_ESCVehSpd_kph;
  } else {
    /* Gain: '<S8>/Gain8' incorporates:
     *  Constant: '<S918>/Constant9'
     */
    rtb_Delay1_ie = 0.0F;
  }

  /* End of Switch: '<S918>/Switch5' */

  /* Lookup_n-D: '<S918>/cal_HeatFanCtrl_MAP' incorporates:
   *  Gain: '<S8>/Gain8'
   */
  ACTCtl_eHeatFanCtrl = look2_iflftu8Dfdf_binlca(rtb_Delay1_ie, rtb_Merge, (
    const float32 *)&cal_HeatFanCtrl_2X[0], (const float32 *)
    &cal_HeatFanCtrl_2Y[0], (const uint8 *)&cal_HeatFanCtrl_MAP[0],
    ME11_ConstP.pooled41, 4U);

  /* RelationalOperator: '<S931>/Compare' incorporates:
   *  Constant: '<S931>/Constant'
   */
  rtb_AND2_of = (ACSen_sLoPressFilter <= cal_LPFanOn);

  /* RelationalOperator: '<S932>/Compare' incorporates:
   *  Constant: '<S932>/Constant'
   */
  rtb_Compare_fx = (ACSen_sLoPressFilter >= cal_LPFanOff);

  /* Chart: '<S919>/Delay' incorporates:
   *  Constant: '<S919>/Constant'
   *  Constant: '<S919>/Constant1'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_j < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i1_j++;
  }

  if (ME11_ARID_DEF.is_active_c65_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c65_ME11 = 1U;
    ME11_ARID_DEF.is_c65_ME11 = ME11_IN_Off_a;
    ME11_ARID_DEF.B_pl = false;
  } else {
    switch (ME11_ARID_DEF.is_c65_ME11) {
     case ME11_IN_Off_a:
      ME11_ARID_DEF.B_pl = false;
      if (rtb_AND2_of) {
        ME11_ARID_DEF.is_c65_ME11 = ME11_IN_wait_On;
        ME11_ARID_DEF.temporalCounter_i1_j = 0U;
      }
      break;

     case ME11_IN_On_li:
      ME11_ARID_DEF.B_pl = true;
      if (rtb_Compare_fx) {
        ME11_ARID_DEF.is_c65_ME11 = ME11_IN_wait_Off;
        ME11_ARID_DEF.temporalCounter_i1_j = 0U;
      }
      break;

     case ME11_IN_wait_Off:
      if (!rtb_Compare_fx) {
        ME11_ARID_DEF.is_c65_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.B_pl = true;
      } else if (ME11_ARID_DEF.temporalCounter_i1_j >= cal_LPProOffTimer * 10.0F)
      {
        ME11_ARID_DEF.is_c65_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.B_pl = false;
      }
      break;

     default:
      /* case IN_wait_On: */
      if (ME11_ARID_DEF.temporalCounter_i1_j >= cal_LPProOnTimer * 10.0F) {
        ME11_ARID_DEF.is_c65_ME11 = ME11_IN_On_li;
        ME11_ARID_DEF.B_pl = true;
      } else if (!rtb_AND2_of) {
        ME11_ARID_DEF.is_c65_ME11 = ME11_IN_Off_a;
        ME11_ARID_DEF.B_pl = false;
      }
      break;
    }
  }

  /* End of Chart: '<S919>/Delay' */

  /* Chart: '<S443>/FanLmt' incorporates:
   *  Constant: '<S443>/Constant13'
   *  Constant: '<S443>/Constant14'
   */
  if (COMP_EcompActSpd >= cal_COMPSpdLmt[3]) {
    rtb_DataTypeConversion_jr = cal_COMPFanSpdLmt[2];
    ME11_ARID_DEF.Flg = 3U;
  } else if (COMP_EcompActSpd >= cal_COMPSpdLmt[2]) {
    if (ME11_ARID_DEF.Flg == 3) {
      rtb_DataTypeConversion_jr = cal_COMPFanSpdLmt[2];
      ME11_ARID_DEF.Flg = 3U;
    } else {
      rtb_DataTypeConversion_jr = cal_COMPFanSpdLmt[1];
      ME11_ARID_DEF.Flg = 2U;
    }
  } else if (COMP_EcompActSpd >= cal_COMPSpdLmt[1]) {
    if (ME11_ARID_DEF.Flg >= 2) {
      rtb_DataTypeConversion_jr = cal_COMPFanSpdLmt[1];
      ME11_ARID_DEF.Flg = 2U;
    } else {
      rtb_DataTypeConversion_jr = cal_COMPFanSpdLmt[0];
      ME11_ARID_DEF.Flg = 1U;
    }
  } else if ((COMP_EcompActSpd >= cal_COMPSpdLmt[0]) && (ME11_ARID_DEF.Flg >= 1))
  {
    rtb_DataTypeConversion_jr = cal_COMPFanSpdLmt[0];
    ME11_ARID_DEF.Flg = 1U;
  } else {
    rtb_DataTypeConversion_jr = 10U;
    ME11_ARID_DEF.Flg = 0U;
  }

  /* End of Chart: '<S443>/FanLmt' */

  /* Switch: '<S921>/Switch' incorporates:
   *  Constant: '<S921>/Constant1'
   */
  if (cal_CoolFanEnb) {
    /* Switch: '<S443>/Switch' incorporates:
     *  Constant: '<S921>/Constant'
     *  Switch: '<S921>/Switch'
     */
    ACTCtl_eFanPerc = cal_CoolFanData;
  } else {
    for (b_previousEvent = 0; b_previousEvent < 5; b_previousEvent++) {
      /* RelationalOperator: '<S928>/Compare' incorporates:
       *  Constant: '<S928>/Constant'
       *  DataTypeConversion: '<S1316>/Data Type Conversion'
       *  Switch: '<S1735>/Switch'
       */
      rtb_Compare_gw[b_previousEvent] = (SOMCtl_eRefModes ==
        ME11_ConstP.Constant_Value_l2[b_previousEvent]);
    }

    /* Switch: '<S917>/Switch6' incorporates:
     *  Logic: '<S917>/OR5'
     */
    if (rtb_Compare_gw[0] || rtb_Compare_gw[1] || rtb_Compare_gw[2] ||
        rtb_Compare_gw[3] || rtb_Compare_gw[4]) {
      /* Switch: '<S917>/Switch3' */
      if (ME11_ARID_DEF.B_a) {
        /* Switch: '<S917>/Switch6' incorporates:
         *  Constant: '<S917>/Constant5'
         */
        rtb_Switch1_mn = cal_ACCMHiTempFanCtrl;
      } else {
        /* Switch: '<S917>/Switch6' incorporates:
         *  Constant: '<S917>/Constant6'
         */
        rtb_Switch1_mn = 10U;
      }

      /* End of Switch: '<S917>/Switch3' */
    } else {
      /* Switch: '<S917>/Switch6' incorporates:
       *  Constant: '<S917>/Constant10'
       */
      rtb_Switch1_mn = 10U;
    }

    /* End of Switch: '<S917>/Switch6' */

    /* Switch: '<S913>/Switch1' incorporates:
     *  Constant: '<S923>/Constant'
     *  Constant: '<S924>/Constant'
     *  DataTypeConversion: '<S1321>/Data Type Conversion1'
     *  Logic: '<S913>/OR'
     *  RelationalOperator: '<S923>/Compare'
     *  RelationalOperator: '<S924>/Compare'
     *  Switch: '<S1473>/Switch'
     *  Switch: '<S913>/Switch2'
     */
    if ((SOMCtl_eBatMode == 0) || (SOMCtl_eBatMode == 4)) {
      /* Switch: '<S913>/Switch1' */
      rtb_Switch_dwm = rtb_Add4_ox;
    } else if (SOMCtl_eBatMode == 5) {
      /* RelationalOperator: '<S925>/Relational Operator' incorporates:
       *  Constant: '<S925>/Constant1'
       *  Constant: '<S925>/Constant8'
       *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
       *  MultiPortSwitch: '<S925>/Index Vector1'
       *  Switch: '<S913>/Switch2'
       */
      rtb_AND2_of = (cal_LTRIPUTempFanCtrl_1X[0] >
                     (Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT
                      ())->VIPM_IPUDeviceIntTemp_C);

      /* Switch: '<S925>/Switch' incorporates:
       *  Switch: '<S913>/Switch2'
       */
      if (rtb_AND2_of) {
        /* Switch: '<S925>/Switch' incorporates:
         *  Constant: '<S925>/Constant4'
         *  Constant: '<S925>/Constant5'
         *  MultiPortSwitch: '<S925>/Index Vector3'
         */
        rtb_Switch_dwm = cal_LTRIPUTempFanCtrl_1Y[0];
      } else {
        /* RelationalOperator: '<S925>/Relational Operator1' incorporates:
         *  Constant: '<S925>/Constant2'
         *  Constant: '<S925>/Constant3'
         *  Inport: '<Root>/IPM_IPU_OBC_2_Inlet_EPT'
         *  MultiPortSwitch: '<S925>/Index Vector2'
         */
        rtb_AND2_of =
          ((Rte_IRead_Task_100ms_IPM_IPU_OBC_2_Inlet_EPT_IPM_IPU_OBC_2_Inlet_EPT
            ())->VIPM_IPUDeviceIntTemp_C >= cal_LTRIPUTempFanCtrl_1X[1]);

        /* Switch: '<S925>/Switch1' */
        if (rtb_AND2_of) {
          /* Switch: '<S925>/Switch' incorporates:
           *  Constant: '<S925>/Constant6'
           *  Constant: '<S925>/Constant7'
           *  MultiPortSwitch: '<S925>/Index Vector4'
           *  Switch: '<S925>/Switch1'
           */
          rtb_Switch_dwm = cal_LTRIPUTempFanCtrl_1Y[2];
        } else {
          /* Switch: '<S925>/Switch' incorporates:
           *  Constant: '<S925>/Constant10'
           *  Constant: '<S925>/Constant9'
           *  MultiPortSwitch: '<S925>/Index Vector5'
           *  Switch: '<S925>/Switch1'
           */
          rtb_Switch_dwm = cal_LTRIPUTempFanCtrl_1Y[1];
        }

        /* End of Switch: '<S925>/Switch1' */
      }

      /* End of Switch: '<S925>/Switch' */

      /* MinMax: '<S913>/Max' incorporates:
       *  Switch: '<S913>/Switch2'
       */
      if (rtb_Add4_ox >= rtb_Switch_dwm) {
        /* Switch: '<S913>/Switch1' incorporates:
         *  Switch: '<S913>/Switch2'
         */
        rtb_Switch_dwm = rtb_Add4_ox;
      }

      /* End of MinMax: '<S913>/Max' */
    } else {
      /* Switch: '<S913>/Switch1' incorporates:
       *  Constant: '<S913>/Constant3'
       *  Switch: '<S913>/Switch2'
       */
      rtb_Switch_dwm = 10U;
    }

    /* End of Switch: '<S913>/Switch1' */

    /* Switch: '<S920>/Switch2' incorporates:
     *  Constant: '<S920>/Constant2'
     *  Constant: '<S920>/Constant4'
     *  Constant: '<S934>/Constant'
     *  Constant: '<S935>/Constant'
     *  DataTypeConversion: '<S1321>/Data Type Conversion1'
     *  DataTypeConversion: '<S1683>/Data Type Conversion1'
     *  Logic: '<S920>/OR'
     *  Logic: '<S920>/OR1'
     *  RelationalOperator: '<S934>/Compare'
     *  RelationalOperator: '<S935>/Compare'
     *  Switch: '<S1473>/Switch'
     *  Switch: '<S1726>/Switch'
     */
    if ((SOMCtl_eCabinMode == 0) && ((SOMCtl_eBatMode == 0) || (SOMCtl_eBatMode ==
          2) || (SOMCtl_eBatMode == 3))) {
      rtb_Add7_i = cal_FanCtrlOff;
    } else {
      rtb_Add7_i = 10U;
    }

    /* Switch: '<S915>/Switch4' incorporates:
     *  Constant: '<S915>/Constant8'
     *  Delay: '<S503>/Delay'
     */
    if (ME11_ARID_DEF.Delay_DSTATE_kf) {
      rtb_Add4_ox = ACTCtl_eCoolFanCtrl;
    } else {
      rtb_Add4_ox = 10U;
    }

    /* Switch: '<S918>/Switch6' incorporates:
     *  Constant: '<S918>/Constant10'
     *  Constant: '<S929>/Constant'
     *  DataTypeConversion: '<S1316>/Data Type Conversion'
     *  Logic: '<S918>/OR5'
     *  RelationalOperator: '<S929>/Compare'
     *  Switch: '<S1735>/Switch'
     */
    if ((SOMCtl_eRefModes == 4) || (SOMCtl_eRefModes == 5) || (SOMCtl_eRefModes ==
         6) || (SOMCtl_eRefModes == 8)) {
      rtb_Gain_gr = ACTCtl_eHeatFanCtrl;
    } else {
      rtb_Gain_gr = 10U;
    }

    /* Switch: '<S919>/Switch7' incorporates:
     *  Constant: '<S919>/Constant11'
     *  Constant: '<S919>/Constant12'
     *  Constant: '<S930>/Constant'
     *  DataTypeConversion: '<S1313>/Data Type Conversion1'
     *  Delay: '<S503>/Delay'
     *  Logic: '<S919>/OR1'
     *  Logic: '<S919>/OR2'
     *  Logic: '<S919>/OR4'
     *  RelationalOperator: '<S930>/Compare'
     *  Switch: '<S1727>/Switch'
     */
    if (ME11_ARID_DEF.B_pl && (ME11_ARID_DEF.Delay_DSTATE_kf &&
         ((SOMCtl_eWaterMode != 3) || (SOMCtl_eWaterMode != 4)))) {
      u1 = cal_LPFanCtrl;
    } else {
      u1 = 10U;
    }

    /* Switch: '<S443>/Switch' incorporates:
     *  Constant: '<S443>/Constant1'
     *  Constant: '<S443>/Constant12'
     *  Constant: '<S914>/Constant'
     *  DataTypeConversion: '<S1316>/Data Type Conversion'
     *  RelationalOperator: '<S914>/Compare'
     *  Switch: '<S1735>/Switch'
     */
    if (SOMCtl_eRefModes == 13) {
      ACTCtl_eFanPerc = cal_HeatCabinAndCoolBatFanSpd;
    } else {
      ACTCtl_eFanPerc = 10U;
    }

    /* MinMax: '<S443>/Max' incorporates:
     *  Switch: '<S443>/Switch'
     *  Switch: '<S915>/Switch4'
     *  Switch: '<S918>/Switch6'
     *  Switch: '<S919>/Switch7'
     *  Switch: '<S920>/Switch2'
     */
    if (rtb_Switch_dwm >= rtb_Add7_i) {
      rtb_Add7_i = rtb_Switch_dwm;
    }

    if (rtb_Add7_i >= rtb_Switch1_mn) {
      rtb_Switch1_mn = rtb_Add7_i;
    }

    if (rtb_Switch1_mn >= rtb_Add4_ox) {
      rtb_Add4_ox = rtb_Switch1_mn;
    }

    if (rtb_Add4_ox >= rtb_Gain_gr) {
      rtb_Gain_gr = rtb_Add4_ox;
    }

    if (rtb_Gain_gr >= u1) {
      u1 = rtb_Gain_gr;
    }

    if (u1 >= ACTCtl_eFanPerc) {
      /* MinMax: '<S443>/Max' */
      ACTCtl_eFanPerc = u1;
    }

    /* End of MinMax: '<S443>/Max' */

    /* Switch: '<S922>/Switch2' incorporates:
     *  Constant: '<S443>/Constant15'
     *  RelationalOperator: '<S922>/LowerRelop1'
     *  RelationalOperator: '<S922>/UpperRelop'
     *  Switch: '<S922>/Switch'
     */
    if (ACTCtl_eFanPerc > 100) {
      /* Switch: '<S443>/Switch' incorporates:
       *  Switch: '<S921>/Switch'
       *  Switch: '<S922>/Switch2'
       */
      ACTCtl_eFanPerc = 100U;
    } else if (ACTCtl_eFanPerc < rtb_DataTypeConversion_jr) {
      /* Switch: '<S443>/Switch' incorporates:
       *  Switch: '<S921>/Switch'
       *  Switch: '<S922>/Switch'
       *  Switch: '<S922>/Switch2'
       */
      ACTCtl_eFanPerc = rtb_DataTypeConversion_jr;
    }

    /* End of Switch: '<S922>/Switch2' */
  }

  /* End of Switch: '<S921>/Switch' */

  /* Sum: '<S443>/Add1' incorporates:
   *  Constant: '<S443>/Constant15'
   */
  ME11_ARID_DEF.Add1 = (uint8)(100 - ACTCtl_eFanPerc);

  /* RelationalOperator: '<S43>/Relational Operator1' incorporates:
   *  Constant: '<S43>/Constant'
   */
  rtb_AND2_of = (ME11_ARID_DEF.Switch1_nv != ACOff);

  /* Outputs for Enabled SubSystem: '<S43>/BlowerControlShutOff' */
  /* Logic: '<S43>/Logical Operator1' incorporates:
   *  DataTypeConversion: '<S43>/Data Type Conversion'
   */
  ME11_ManualMode(!rtb_AND2_of, HMICtl_eModeMotor, (BlowerModes *)
                  &ACCtl_BlowerMode);

  /* End of Outputs for SubSystem: '<S43>/BlowerControlShutOff' */

  /* Outputs for Enabled SubSystem: '<S43>/BlowerControlEnable' incorporates:
   *  EnablePort: '<S76>/Enable'
   */
  if (rtb_AND2_of) {
    /* RelationalOperator: '<S76>/Relational Operator' incorporates:
     *  Constant: '<S76>/ACModes.BlowerModeManual'
     */
    rtb_AND2_of = (ME11_ARID_DEF.Switch1_nv == 0);

    /* Outputs for Enabled SubSystem: '<S76>/AutoMode' incorporates:
     *  EnablePort: '<S78>/Enable'
     */
    /* Logic: '<S76>/NOT' incorporates:
     *  DataTypeConversion: '<S78>/Data Type Conversion'
     *  Logic: '<S78>/NOT'
     */
    if (!rtb_AND2_of) {
      /* Outputs for Enabled SubSystem: '<S78>/AutoBlowerMode' incorporates:
       *  EnablePort: '<S80>/Enable'
       */
      if (!HMICtl_bACDefrost) {
        /* Lookup_n-D: '<S80>/cal_RFaceFloor2FaceByEnv_CUR' incorporates:
         *  Switch: '<S1085>/Switch'
         */
        ACCtl_RFaceFloor2Face = look1_iflf_binlca(ACSen_sEnvTempCor, (const
          float32 *)&cal_RFaceFloor2FaceByEnv_1X[0], (const float32 *)
          &cal_RFaceFloor2FaceByEnv_CUR[0], 13U);

        /* Lookup_n-D: '<S80>/cal_RFace2FaceFloorByEnv_CUR' incorporates:
         *  Switch: '<S1085>/Switch'
         */
        ACCtl_RFace2FaceFloor = look1_iflf_binlca(ACSen_sEnvTempCor, (const
          float32 *)&cal_RFace2FaceFloorByEnv_1X[0], (const float32 *)
          &cal_RFace2FaceFloorByEnv_CUR[0], 13U);

        /* Lookup_n-D: '<S80>/cal_RFaceFloor2FloorByEnv_CUR' incorporates:
         *  Switch: '<S1085>/Switch'
         */
        ACCtl_RFaceFloor2Floor = look1_iflf_binlca(ACSen_sEnvTempCor, (const
          float32 *)&cal_RFaceFloor2FloorByEnv_1X[0], (const float32 *)
          &cal_RFaceFloor2FloorByEnv_CUR[0], 13U);

        /* Lookup_n-D: '<S80>/cal_RFloor2FaceFloorByEnv_CUR' incorporates:
         *  Switch: '<S1085>/Switch'
         */
        ACCtl_RFloor2FaceFloor = look1_iflf_binlca(ACSen_sEnvTempCor, (const
          float32 *)&cal_RFloor2FaceFloorByEnv_1X[0], (const float32 *)
          &cal_RFloor2FaceFloorByEnv_CUR[0], 13U);

        /* Chart: '<S80>/AutoBlowerMode' */
        if (ME11_ARID_DEF.is_active_c3_ME11 == 0U) {
          ME11_ARID_DEF.is_active_c3_ME11 = 1U;
          ME11_ARID_DEF.is_c3_ME11 = ME11_IN_BlowerNormal;
          if (ACCtl_tDrDVT < ACCtl_RFaceFloor2Face) {
            ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_c;
            rtb_Add7_i = BlowerACMode;
          } else if (ACCtl_tDrDVT > ACCtl_RFaceFloor2Floor) {
            ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Floor;
            rtb_Add7_i = BlowerHeaterMode;
          } else {
            ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_Floor;
            rtb_Add7_i = BlowerBILevelMode;
          }
        } else {
          switch (ME11_ARID_DEF.is_c3_ME11) {
           case ME11_IN_BlowerModeLim:
            rtb_Add7_i = BlowerHeaterMode;
            if (ACCtl_stStartState != ME11_HotStart) {
              ME11_ARID_DEF.is_c3_ME11 = ME11_IN_BlowerNormal;
              if (ACCtl_tDrDVT < ACCtl_RFaceFloor2Face) {
                ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_c;
                rtb_Add7_i = BlowerACMode;
              } else if (ACCtl_tDrDVT > ACCtl_RFaceFloor2Floor) {
                ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Floor;
              } else {
                ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_Floor;
                rtb_Add7_i = BlowerBILevelMode;
              }
            }
            break;

           case ME11_IN_BlowerModeLockFloor:
            rtb_Add7_i = BlowerDefrostMode;
            if (ACCtl_stStartState == ME11_NormalStart) {
              ME11_ARID_DEF.is_c3_ME11 = ME11_IN_BlowerNormal;
              if (ACCtl_tDrDVT < ACCtl_RFaceFloor2Face) {
                ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_c;
                rtb_Add7_i = BlowerACMode;
              } else if (ACCtl_tDrDVT > ACCtl_RFaceFloor2Floor) {
                ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Floor;
                rtb_Add7_i = BlowerHeaterMode;
              } else {
                ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_Floor;
                rtb_Add7_i = BlowerBILevelMode;
              }
            } else if (ACCtl_stStartState == ME11_LittleCold) {
              ME11_ARID_DEF.is_c3_ME11 = ME11_IN_BlowerModeLockFloor1;
              rtb_Add7_i = BlowerHeaterDefrostMode;
            }
            break;

           case ME11_IN_BlowerModeLockFloor1:
            rtb_Add7_i = BlowerHeaterDefrostMode;
            if (ACCtl_stStartState == ME11_ColdStart) {
              ME11_ARID_DEF.is_c3_ME11 = ME11_IN_BlowerModeLockFloor;
              rtb_Add7_i = BlowerDefrostMode;
            } else if (ACCtl_stStartState == ME11_NormalStart) {
              ME11_ARID_DEF.is_c3_ME11 = ME11_IN_BlowerNormal;
              if (ACCtl_tDrDVT < ACCtl_RFaceFloor2Face) {
                ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_c;
                rtb_Add7_i = BlowerACMode;
              } else if (ACCtl_tDrDVT > ACCtl_RFaceFloor2Floor) {
                ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Floor;
                rtb_Add7_i = BlowerHeaterMode;
              } else {
                ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_Floor;
                rtb_Add7_i = BlowerBILevelMode;
              }
            }
            break;

           default:
            /* case IN_BlowerNormal: */
            if (ACCtl_stStartState == ME11_ColdStart) {
              ME11_ARID_DEF.is_BlowerNormal = ME11_IN_NO_ACTIVE_CHILD_gl;
              ME11_ARID_DEF.is_c3_ME11 = ME11_IN_BlowerModeLockFloor;
              rtb_Add7_i = BlowerDefrostMode;
            } else if (ACCtl_stStartState == ME11_HotStart) {
              ME11_ARID_DEF.is_BlowerNormal = ME11_IN_NO_ACTIVE_CHILD_gl;
              ME11_ARID_DEF.is_c3_ME11 = ME11_IN_BlowerModeLim;
              rtb_Add7_i = BlowerHeaterMode;
            } else if (ACCtl_stStartState == ME11_LittleCold) {
              ME11_ARID_DEF.is_BlowerNormal = ME11_IN_NO_ACTIVE_CHILD_gl;
              ME11_ARID_DEF.is_c3_ME11 = ME11_IN_BlowerModeLockFloor1;
              rtb_Add7_i = BlowerHeaterDefrostMode;
            } else {
              switch (ME11_ARID_DEF.is_BlowerNormal) {
               case ME11_IN_Face_c:
                rtb_Add7_i = BlowerACMode;
                if (ACCtl_tDrDVT > ACCtl_RFace2FaceFloor) {
                  ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_Floor;
                  rtb_Add7_i = BlowerBILevelMode;
                }
                break;

               case ME11_IN_Face_Floor:
                rtb_Add7_i = BlowerBILevelMode;
                if (ACCtl_tDrDVT < ACCtl_RFaceFloor2Face) {
                  ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_c;
                  rtb_Add7_i = BlowerACMode;
                } else if (ACCtl_tDrDVT > ACCtl_RFaceFloor2Floor) {
                  ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Floor;
                  rtb_Add7_i = BlowerHeaterMode;
                }
                break;

               default:
                /* case IN_Floor: */
                rtb_Add7_i = BlowerHeaterMode;
                if (ACCtl_tDrDVT < ACCtl_RFloor2FaceFloor) {
                  ME11_ARID_DEF.is_BlowerNormal = ME11_IN_Face_Floor;
                  rtb_Add7_i = BlowerBILevelMode;
                }
                break;
              }
            }
            break;
          }
        }

        /* End of Chart: '<S80>/AutoBlowerMode' */

        /* Merge: '<S43>/Merge' incorporates:
         *  DataTypeConversion: '<S80>/Data Type Conversion'
         */
        ACCtl_BlowerMode = rtb_Add7_i;
      } else {
        /* Outputs for Enabled SubSystem: '<S78>/DefogBlowerMode' incorporates:
         *  EnablePort: '<S81>/Enable'
         */
        /* Merge: '<S43>/Merge' incorporates:
         *  Constant: '<S81>/1 - DEFROST'
         *  SignalConversion generated from: '<S81>/ACCtl_stBlowerMode'
         */
        ACCtl_BlowerMode = BlowerModes_DeforstMode;

        /* End of Outputs for SubSystem: '<S78>/DefogBlowerMode' */
      }

      /* End of Outputs for SubSystem: '<S78>/AutoBlowerMode' */
    }

    /* End of Logic: '<S76>/NOT' */
    /* End of Outputs for SubSystem: '<S76>/AutoMode' */

    /* Outputs for Enabled SubSystem: '<S76>/ManualMode' */
    /* DataTypeConversion: '<S43>/Data Type Conversion' */
    ME11_ManualMode(rtb_AND2_of, HMICtl_eModeMotor, (BlowerModes *)
                    &ACCtl_BlowerMode);

    /* End of Outputs for SubSystem: '<S76>/ManualMode' */
  }

  /* End of Outputs for SubSystem: '<S43>/BlowerControlEnable' */

  /* DataTypeConversion: '<S4>/Data Type Conversion1' incorporates:
   *  Merge: '<S43>/Merge'
   */
  ME11_ARID_DEF.DataTypeConversion1_b = ACCtl_BlowerMode;

  /* Switch: '<S1074>/Switch' incorporates:
   *  Constant: '<S388>/Comfort'
   *  Constant: '<S388>/Constant5'
   *  Constant: '<S388>/Constant7'
   *  Logic: '<S388>/Logical Operator'
   *  RelationalOperator: '<S388>/Relational Operator1'
   *  RelationalOperator: '<S388>/Relational Operator2'
   *  RelationalOperator: '<S388>/Relational Operator4'
   */
  rtb_AND2_of = ((rtb_DataTypeConversion_f == ACEconMode_FanOnly) &&
                 (ME11_ARID_DEF.Switch1_nv != ACOff) &&
                 (ME11_ARID_DEF.Switch1_nv != ACDefog));

  /* Logic: '<S388>/Logical Operator1' incorporates:
   *  Constant: '<S388>/Constant'
   *  Constant: '<S388>/Constant3'
   *  RelationalOperator: '<S388>/Relational Operator'
   *  RelationalOperator: '<S388>/Relational Operator3'
   */
  rtb_Compare_fx = ((rtb_IFreezFlag_k == 2) && (ME11_ARID_DEF.Switch1_nv ==
    ACOff));

  /* RelationalOperator: '<S957>/Compare' incorporates:
   *  Constant: '<S957>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Compare_dy =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 14);

  /* Chart: '<S943>/Outlet_Temp_Sensor_Fault' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Compare_dy,
    &ME11_ARID_DEF.ErrSts_e, &ME11_ARID_DEF.ARID_DEF_Outlet_Temp_Sensor_Fault);

  /* Outputs for Enabled SubSystem: '<S41>/CalDrMixDoorDesRatio' incorporates:
   *  EnablePort: '<S386>/Enable'
   */
  /* RelationalOperator: '<S41>/Relational Operator1' incorporates:
   *  Constant: '<S386>/Constant'
   *  Constant: '<S390>/Kp11'
   *  Constant: '<S390>/Kp5'
   *  Constant: '<S390>/Kp6'
   *  Constant: '<S390>/Kp7'
   *  Constant: '<S41>/Constant1'
   *  DataTypeConversion: '<S386>/Data Type Conversion'
   *  Logic: '<S398>/Logical Operator'
   *  Logic: '<S399>/Logical Operator'
   *  Logic: '<S400>/Logical Operator'
   *  Switch: '<S390>/Switch4'
   *  Switch: '<S390>/Switch5'
   */
  if (ME11_ARID_DEF.Switch1_nv != ACOff) {
    /* Switch: '<S391>/Switch1' incorporates:
     *  Logic: '<S391>/Logical Operator'
     */
    if (ME11_TMSADCSampleFunc_ARID_DEF.Compare_n ||
        ME11_TMSADCSampleFunc_ARID_DEF.Compare_g) {
      /* Switch: '<S391>/Switch1' incorporates:
       *  Constant: '<S391>/ACPressSensorFaultPrt'
       */
      rtb_Delay = 0.0F;
    } else {
      /* Switch: '<S391>/Switch1' */
      rtb_Delay = ACSen_sEvapTempFilter;
    }

    /* End of Switch: '<S391>/Switch1' */

    /* Switch: '<S391>/Switch4' incorporates:
     *  Constant: '<S386>/Constant1'
     *  Constant: '<S386>/Constant5'
     *  Logic: '<S391>/Logical Operator1'
     *  Switch: '<S391>/Switch2'
     *  Switch: '<S391>/Switch3'
     */
    if (cal_PtcEnable) {
      /* Switch: '<S391>/Switch4' incorporates:
       *  Constant: '<S391>/ACPressSensorFaultPrt3'
       */
      ACCtl_DrfacPtc2NominalTemp = 0.0F;
    } else if (ME11_ARID_DEF.ErrSts_e) {
      /* Switch: '<S391>/Switch4' incorporates:
       *  Constant: '<S391>/ACPressSensorFaultPrt2'
       *  Switch: '<S391>/Switch2'
       */
      ACCtl_DrfacPtc2NominalTemp = 0.0F;
    } else {
      if (cal_EvaEnable) {
        /* Switch: '<S391>/Switch3' incorporates:
         *  Constant: '<S391>/ACPressSensorFaultPrt1'
         *  Switch: '<S391>/Switch2'
         */
        rtb_Merge = 0.0F;
      } else {
        /* Switch: '<S391>/Switch3' incorporates:
         *  Switch: '<S391>/Switch2'
         */
        rtb_Merge = rtb_Delay;
      }

      /* Sum: '<S391>/Add1' incorporates:
       *  Switch: '<S391>/Switch2'
       */
      rtb_Delay1_ie = rtb_Merge_g - rtb_Merge;

      /* MinMax: '<S391>/MinMax' incorporates:
       *  Switch: '<S391>/Switch2'
       */
      if (rtb_Delay1_ie < 1.0F) {
        rtb_Delay1_ie = 1.0F;
      }

      /* Product: '<S391>/Divide' incorporates:
       *  Constant: '<S391>/Constant6'
       *  MinMax: '<S391>/MinMax'
       *  Sum: '<S391>/Add'
       *  Switch: '<S391>/Switch2'
       */
      ACCtl_DrfacPtc2NominalTemp = (cal_LAirmixNomOutWaterT - rtb_Merge) /
        rtb_Delay1_ie;

      /* Switch: '<S393>/Switch2' incorporates:
       *  Constant: '<S391>/ACPressSensorFaultPrt5'
       *  Constant: '<S391>/ACPressSensorFaultPrt6'
       *  RelationalOperator: '<S393>/LowerRelop1'
       *  RelationalOperator: '<S393>/UpperRelop'
       *  Switch: '<S391>/Switch2'
       *  Switch: '<S393>/Switch'
       */
      if (ACCtl_DrfacPtc2NominalTemp > 1.0F) {
        /* Switch: '<S391>/Switch4' incorporates:
         *  Switch: '<S393>/Switch2'
         */
        ACCtl_DrfacPtc2NominalTemp = 1.0F;
      } else if (ACCtl_DrfacPtc2NominalTemp < 0.0F) {
        /* Switch: '<S393>/Switch' incorporates:
         *  Constant: '<S391>/ACPressSensorFaultPrt6'
         *  Switch: '<S391>/Switch4'
         *  Switch: '<S393>/Switch2'
         */
        ACCtl_DrfacPtc2NominalTemp = 0.0F;
      }

      /* End of Switch: '<S393>/Switch2' */
    }

    /* End of Switch: '<S391>/Switch4' */

    /* Sum: '<S389>/Subtract2' */
    rtb_Add_ok = (float32)floor((rtb_Delay - ACCtl_tDrDVT) * 2.0F);
    if (rtb_Add_ok < 32768.0F) {
      if (rtb_Add_ok >= -32768.0F) {
        rtb_DataTypeConversion_dt = (sint16)rtb_Add_ok;
      } else {
        rtb_DataTypeConversion_dt = MIN_int16_T;
      }
    } else {
      rtb_DataTypeConversion_dt = MAX_int16_T;
    }

    /* Relay: '<S389>/On:cal_DrErrOfEvaDVT2CoolMixOn Off:cal_DrErrOfEvaDVT2CoolMixOff ' incorporates:
     *  Sum: '<S389>/Subtract2'
     */
    rtb_Delay1_ie = cal_DrErrOfEvaDVT2CoolMixOn * 2.0F;
    rtb_Delay = cal_DrErrOfEvaDVT2CoolMixOff * 2.0F;
    if ((float32)fabs(rtb_Delay1_ie) >= 0.5F) {
      rtb_Add_ok = (float32)floor(rtb_Delay1_ie + 0.5F);
    } else {
      rtb_Add_ok = 0.0F;
    }

    if ((float32)fabs(rtb_Delay) >= 0.5F) {
      rtb_Delay1_ie = (float32)floor(rtb_Delay + 0.5F);
    } else {
      rtb_Delay1_ie = 0.0F;
    }

    ME11_ARID_DEF.Oncal_DrErrOfEvaDVT2CoolMixOnOffcal_DrErrOfEvaDVT2CoolMixOff_Mode
      = ((rtb_DataTypeConversion_dt >= (sint16)rtb_Add_ok) ||
         ((rtb_DataTypeConversion_dt > (sint16)rtb_Delay1_ie) &&
          ME11_ARID_DEF.Oncal_DrErrOfEvaDVT2CoolMixOnOffcal_DrErrOfEvaDVT2CoolMixOff_Mode));

    /* Sum: '<S389>/Subtract1' */
    rtb_Add_ok = (float32)floor(AC_DVT2PTCErr * 2.0F);
    if (rtb_Add_ok < 32768.0F) {
      if (rtb_Add_ok >= -32768.0F) {
        rtb_DataTypeConversion_dt = (sint16)rtb_Add_ok;
      } else {
        rtb_DataTypeConversion_dt = MIN_int16_T;
      }
    } else {
      rtb_DataTypeConversion_dt = MAX_int16_T;
    }

    /* Relay: '<S389>/On:cal_DrErrOfPtcDVT2HeatMixOn Off:cal_DrErrOfPtcDVT2HeatMixOff' incorporates:
     *  Sum: '<S389>/Subtract1'
     */
    rtb_Delay1_ie = cal_DrErrOfPtcDVT2HeatMixOn * 2.0F;
    rtb_Delay = cal_DrErrOfPtcDVT2HeatMixOff * 2.0F;
    if ((float32)fabs(rtb_Delay1_ie) >= 0.5F) {
      rtb_Add_ok = (float32)floor(rtb_Delay1_ie + 0.5F);
    } else {
      rtb_Add_ok = 0.0F;
    }

    if ((float32)fabs(rtb_Delay) >= 0.5F) {
      rtb_Delay1_ie = (float32)floor(rtb_Delay + 0.5F);
    } else {
      rtb_Delay1_ie = 0.0F;
    }

    ME11_ARID_DEF.Oncal_DrErrOfPtcDVT2HeatMixOnOffcal_DrErrOfPtcDVT2HeatMixOff_Mode
      = ((rtb_DataTypeConversion_dt >= (sint16)rtb_Add_ok) ||
         ((rtb_DataTypeConversion_dt > (sint16)rtb_Delay1_ie) &&
          ME11_ARID_DEF.Oncal_DrErrOfPtcDVT2HeatMixOnOffcal_DrErrOfPtcDVT2HeatMixOff_Mode));

    /* Switch: '<S389>/Switch6' incorporates:
     *  Relay: '<S389>/On:cal_DrErrOfEvaDVT2CoolMixOn Off:cal_DrErrOfEvaDVT2CoolMixOff '
     *  Relay: '<S389>/On:cal_DrErrOfPtcDVT2HeatMixOn Off:cal_DrErrOfPtcDVT2HeatMixOff'
     *  Switch: '<S389>/Switch1'
     */
    if (ME11_ARID_DEF.Oncal_DrErrOfEvaDVT2CoolMixOnOffcal_DrErrOfEvaDVT2CoolMixOff_Mode)
    {
      /* Switch: '<S389>/Switch6' incorporates:
       *  Constant: '<S389>/Constant1'
       */
      ACCtl_rDrBasicMixDoor = 0U;
    } else if
        (ME11_ARID_DEF.Oncal_DrErrOfPtcDVT2HeatMixOnOffcal_DrErrOfPtcDVT2HeatMixOff_Mode)
    {
      /* Switch: '<S389>/Switch6' incorporates:
       *  Constant: '<S389>/Constant'
       *  Switch: '<S389>/Switch1'
       */
      ACCtl_rDrBasicMixDoor = 100U;
    } else {
      /* MultiPortSwitch: '<S389>/Multiport Switch2' incorporates:
       *  Delay: '<S4>/Delay'
       *  Switch: '<S389>/Switch1'
       */
      switch (ME11_ARID_DEF.Delay_DSTATE_fl) {
       case BlowerModes_FaceMode:
        /* MultiPortSwitch: '<S389>/Multiport Switch2' incorporates:
         *  Lookup_n-D: '<S389>/cal_DrMixBacSetFace_CUR'
         *  Switch: '<S181>/Switch3'
         */
        rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
          &cal_DrMixBacSetFace_1X[0], (const float32 *)&cal_DrMixBacSetFace_CUR
          [0], 7U);
        break;

       case BlowerModes_FaceHeaterMode:
        /* MultiPortSwitch: '<S389>/Multiport Switch2' incorporates:
         *  Lookup_n-D: '<S389>/cal_DrMixBacSetFaceHeater_CUR'
         *  Switch: '<S181>/Switch3'
         */
        rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
          &cal_DrMixBacSetFaceHeater_1X[0], (const float32 *)
          &cal_DrMixBacSetFaceHeater_CUR[0], 7U);
        break;

       case BlowerModes_HeaterMode:
        /* MultiPortSwitch: '<S389>/Multiport Switch2' incorporates:
         *  Lookup_n-D: '<S389>/cal_DrMixBacSetHeater_CUR'
         *  Switch: '<S181>/Switch3'
         */
        rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
          &cal_DrMixBacSetHeater_1X[0], (const float32 *)
          &cal_DrMixBacSetHeater_CUR[0], 7U);
        break;

       case BlowerModes_HeaterDeforstMode:
        /* MultiPortSwitch: '<S389>/Multiport Switch2' incorporates:
         *  Lookup_n-D: '<S389>/cal_DrMixBacSetHeaterDeforst_CUR'
         *  Switch: '<S181>/Switch3'
         */
        rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
          &cal_DrMixBacSetHeaterDeforst_1X[0], (const float32 *)
          &cal_DrMixBacSetHeaterDeforst_CUR[0], 7U);
        break;

       default:
        /* MultiPortSwitch: '<S389>/Multiport Switch2' incorporates:
         *  Lookup_n-D: '<S389>/cal_DrMixBacSetDefog_CUR'
         *  Switch: '<S181>/Switch3'
         */
        rtb_Delay1_ie = look1_iflf_binlca(ACCtl_tDrDVT, (const float32 *)
          &cal_DrMixBacSetDefog_1X[0], (const float32 *)
          &cal_DrMixBacSetDefog_CUR[0], 7U);
        break;
      }

      /* End of MultiPortSwitch: '<S389>/Multiport Switch2' */

      /* Product: '<S389>/Divide1' incorporates:
       *  Switch: '<S389>/Switch1'
       */
      rtb_Divide1_f = (uint32)(ACCtl_DrfacPtc2NominalTemp * rtb_Delay1_ie *
        256.0F);

      /* Switch: '<S392>/Switch2' incorporates:
       *  Product: '<S389>/Divide1'
       *  RelationalOperator: '<S392>/LowerRelop1'
       *  Switch: '<S389>/Switch1'
       */
      if (rtb_Divide1_f > 25600U) {
        /* Switch: '<S389>/Switch6' incorporates:
         *  Constant: '<S389>/ACPressSensorFaultPrt5'
         *  Switch: '<S392>/Switch2'
         */
        ACCtl_rDrBasicMixDoor = 100U;
      } else {
        /* Switch: '<S389>/Switch6' incorporates:
         *  Switch: '<S392>/Switch'
         *  Switch: '<S392>/Switch2'
         */
        ACCtl_rDrBasicMixDoor = (uint8)(rtb_Divide1_f >> 8);
      }

      /* End of Switch: '<S392>/Switch2' */
    }

    /* End of Switch: '<S389>/Switch6' */

    /* Outputs for Enabled SubSystem: '<S386>/CalDrMixDoorDesRatio_FIXPID' incorporates:
     *  EnablePort: '<S390>/Enable'
     */
    if (cal_FixPIDSecletFlag) {
      /* Sum: '<S390>/Add' incorporates:
       *  Sum: '<S397>/Sum'
       */
      rtb_Merge = ACCtl_tDrDVT - ACCtl_tRightDuct;

      /* Outputs for Enabled SubSystem: '<S398>/PI_Controller1' */
      ME11_PI_Controller1(!rtb_FixPtRelationalOperator_mk, (float32)
                          ACCtl_rDrBasicMixDoor, &rtb_PI_Cor_d,
                          &rtb_IFreezFlag_bd);

      /* End of Outputs for SubSystem: '<S398>/PI_Controller1' */

      /* RelationalOperator: '<S397>/Relational Operator' incorporates:
       *  DataTypeConversion: '<S386>/Data Type Conversion'
       *  Logic: '<S398>/Logical Operator'
       */
      rtb_Compare_dy = (ACCtl_tDrDVT >= ACCtl_tRightDuct);

      /* Logic: '<S390>/OR' incorporates:
       *  Constant: '<S394>/Constant'
       *  DataTypeConversion: '<S1316>/Data Type Conversion'
       *  RelationalOperator: '<S394>/Compare'
       *  Switch: '<S1735>/Switch'
       */
      rtb_OR_k0 = ((SOMCtl_eRefModes == 7) || (SOMCtl_eRefModes == 8));

      /* Switch: '<S390>/Switch' */
      if (rtb_OR_k0) {
        /* Switch: '<S390>/Switch' incorporates:
         *  Lookup_n-D: '<S390>/cal_MixDoorClsFF_CUR'
         *  Sum: '<S390>/Add'
         */
        ACCtl_sMixDoorClsFF = look1_iflf_binlca(rtb_Merge, (const float32 *)
          &cal_MixDoorClsFF_1X[0], (const float32 *)&cal_MixDoorClsFF_CUR[0], 7U);
      } else {
        /* Switch: '<S390>/Switch' incorporates:
         *  DataTypeConversion: '<S386>/Data Type Conversion'
         */
        ACCtl_sMixDoorClsFF = (float32)ACCtl_rDrBasicMixDoor;
      }

      /* End of Switch: '<S390>/Switch' */

      /* Chart: '<S397>/deadzone' incorporates:
       *  Constant: '<S390>/Constant'
       */
      ME11_deadzone_h(rtb_Merge, 0.5, &rtb_flag_g);

      /* Switch: '<S397>/Switch1' incorporates:
       *  Switch: '<S397>/Switch'
       */
      if (rtb_flag_g) {
        /* Switch: '<S397>/Switch1' incorporates:
         *  Constant: '<S397>/Constant'
         */
        rtb_Merge1 = 0.0F;
      } else if (rtb_Compare_dy) {
        /* Switch: '<S397>/Switch' incorporates:
         *  Switch: '<S397>/Switch1'
         */
        rtb_Merge1 = rtb_Merge;
      } else {
        /* Switch: '<S397>/Switch1' incorporates:
         *  Sum: '<S397>/Sum1'
         *  Switch: '<S397>/Switch'
         */
        rtb_Merge1 = ACCtl_tRightDuct - ACCtl_tDrDVT;
      }

      /* End of Switch: '<S397>/Switch1' */

      /* Switch: '<S390>/Switch1' incorporates:
       *  Constant: '<S390>/Constant6'
       *  Constant: '<S390>/Kp4'
       *  Switch: '<S390>/Switch3'
       *  Switch: '<S390>/Switch4'
       */
      if (rtb_OR_k0) {
        /* Lookup_n-D: '<S390>/cal_MixDoorKp_CUR' incorporates:
         *  Sum: '<S390>/Add'
         */
        rtb_Delay = look1_iflf_binlca(rtb_Merge, (const float32 *)
          &cal_MixDoorKp_1X[0], (const float32 *)&cal_MixDoorKp_CUR[0], 7U);

        /* Switch: '<S390>/Switch1' */
        rtb_Delay1_ie = rtb_Delay;

        /* Switch: '<S390>/Switch3' incorporates:
         *  Constant: '<S390>/Constant4'
         */
        rtb_Gain6 = 0.0F;
        rtb_Add_ok = 0.0F;
      } else {
        /* Switch: '<S390>/Switch1' incorporates:
         *  Constant: '<S390>/Kp1'
         *  Constant: '<S390>/Kp2'
         */
        rtb_Delay = cal_DrMixDesValPID_KpPos;
        rtb_Delay1_ie = cal_DrMixDesValPID_KpNeg;

        /* Switch: '<S390>/Switch3' incorporates:
         *  Constant: '<S390>/Kp'
         */
        rtb_Gain6 = cal_DrMixDesValPID_Kp;
        rtb_Add_ok = cal_DrMixDesValPID_pWinNeg;
      }

      /* End of Switch: '<S390>/Switch1' */

      /* Outputs for Enabled SubSystem: '<S399>/P_NEG' */
      ME11_P_NEG_h(!rtb_Compare_dy, rtb_Merge1, rtb_Add_ok, rtb_Delay1_ie,
                   rtb_Gain6, (float32 *)&ACCtl_rDrSetMixDoorPCor);

      /* End of Outputs for SubSystem: '<S399>/P_NEG' */

      /* Switch: '<S390>/Switch5' incorporates:
       *  Constant: '<S390>/Constant7'
       *  Constant: '<S390>/Kp3'
       *  Logic: '<S399>/Logical Operator'
       *  Switch: '<S390>/Switch4'
       */
      if (rtb_OR_k0) {
        rtb_Add_ok = 0.0F;
      } else {
        rtb_Add_ok = cal_DrMixDesValPID_pWinPos;
      }

      /* Outputs for Enabled SubSystem: '<S399>/P_POS' */
      ME11_P_POS_c(rtb_Compare_dy, rtb_Merge1, rtb_Add_ok, rtb_Delay, rtb_Gain6,
                   (float32 *)&ACCtl_rDrSetMixDoorPCor);

      /* End of Outputs for SubSystem: '<S399>/P_POS' */

      /* Switch: '<S390>/Switch2' incorporates:
       *  Switch: '<S390>/Switch5'
       */
      if (rtb_OR_k0) {
        /* Lookup_n-D: '<S390>/cal_MixDoorKi_CUR' incorporates:
         *  Sum: '<S390>/Add'
         */
        rtb_Delay = look1_iflf_binlca(rtb_Merge, (const float32 *)
          &cal_MixDoorKi_1X[0], (const float32 *)&cal_MixDoorKi_CUR[0], 7U);

        /* Switch: '<S390>/Switch2' */
        rtb_Delay1_ie = rtb_Delay;
      } else {
        /* Switch: '<S390>/Switch2' incorporates:
         *  Constant: '<S390>/Kp10'
         *  Constant: '<S390>/Kp9'
         */
        rtb_Delay = cal_DrMixDesValPID_KiPos;
        rtb_Delay1_ie = cal_DrMixDesValPID_KiNeg;
      }

      /* End of Switch: '<S390>/Switch2' */

      /* Outputs for Enabled SubSystem: '<S400>/P_NEG' */
      ME11_P_NEG(!rtb_Compare_dy, rtb_Merge1, cal_DrMixDesValPIDIntegDeadBand,
                 rtb_Delay1_ie, cal_DrMixDesValPID_Ki, (float32 *)
                 &ACCtl_rDrSetMixDoorICor);

      /* End of Outputs for SubSystem: '<S400>/P_NEG' */

      /* Outputs for Enabled SubSystem: '<S400>/P_POS' */
      ME11_P_POS(rtb_Compare_dy, rtb_Merge1, cal_DrMixDesValPIDIntegDeadBand,
                 rtb_Delay, cal_DrMixDesValPID_Ki, (float32 *)
                 &ACCtl_rDrSetMixDoorICor);

      /* End of Outputs for SubSystem: '<S400>/P_POS' */

      /* Switch: '<S396>/Switch1' incorporates:
       *  Constant: '<S390>/Kp11'
       *  Constant: '<S390>/Kp7'
       *  Logic: '<S400>/Logical Operator'
       *  RelationalOperator: '<S395>/FixPt Relational Operator'
       *  Switch: '<S390>/Switch6'
       *  UnitDelay: '<S395>/Delay Input1'
       *
       * Block description for '<S395>/Delay Input1':
       *
       *  Store in Global RAM
       */
      if ((rtb_OR_k0 == ME11_ARID_DEF.DelayInput1_DSTATE_dw) &&
          rtb_FixPtRelationalOperator_mk) {
        /* MultiPortSwitch: '<S400>/Multiport Switch' incorporates:
         *  Delay: '<S400>/Delay'
         */
        switch (ME11_ARID_DEF.Delay_DSTATE_axe) {
         case 0:
          /* Switch: '<S404>/Switch' */
          if (rtb_Compare_dy) {
            /* Switch: '<S401>/Switch2' incorporates:
             *  Delay: '<S396>/Delay'
             *  Sum: '<S404>/Add'
             *  Switch: '<S404>/Switch'
             */
            ACCtl_rDrSetMixDoorISum = ACCtl_rDrSetMixDoorISum +
              ACCtl_rDrSetMixDoorICor;
          } else {
            /* Switch: '<S401>/Switch2' incorporates:
             *  Delay: '<S396>/Delay'
             *  Sum: '<S404>/Add1'
             *  Switch: '<S404>/Switch'
             */
            ACCtl_rDrSetMixDoorISum = ACCtl_rDrSetMixDoorISum -
              ACCtl_rDrSetMixDoorICor;
          }

          /* End of Switch: '<S404>/Switch' */
          break;

         case 1:
          /* Switch: '<S405>/Switch' */
          if (!rtb_Compare_dy) {
            /* Switch: '<S401>/Switch2' incorporates:
             *  Delay: '<S396>/Delay'
             *  Sum: '<S405>/Add1'
             *  Switch: '<S405>/Switch'
             */
            ACCtl_rDrSetMixDoorISum = ACCtl_rDrSetMixDoorISum -
              ACCtl_rDrSetMixDoorICor;
          }

          /* End of Switch: '<S405>/Switch' */
          break;

         case 2:
          /* Switch: '<S402>/Switch' */
          if (rtb_Compare_dy) {
            /* Switch: '<S401>/Switch2' incorporates:
             *  Delay: '<S396>/Delay'
             *  Sum: '<S402>/Add'
             *  Switch: '<S402>/Switch'
             */
            ACCtl_rDrSetMixDoorISum = ACCtl_rDrSetMixDoorISum +
              ACCtl_rDrSetMixDoorICor;
          }

          /* End of Switch: '<S402>/Switch' */
          break;

         case 3:
          break;
        }

        /* End of MultiPortSwitch: '<S400>/Multiport Switch' */

        /* Switch: '<S401>/Switch2' incorporates:
         *  Constant: '<S390>/Kp13'
         *  Constant: '<S390>/Kp8'
         *  RelationalOperator: '<S401>/LowerRelop1'
         *  RelationalOperator: '<S401>/UpperRelop'
         *  Sum: '<S396>/Add'
         *  Switch: '<S401>/Switch'
         */
        if (ACCtl_rDrSetMixDoorISum > cal_DrMixDesValPID_IsumMax) {
          /* Switch: '<S396>/Switch1' incorporates:
           *  Switch: '<S401>/Switch2'
           */
          ACCtl_rDrSetMixDoorISum = cal_DrMixDesValPID_IsumMax;
        } else if (ACCtl_rDrSetMixDoorISum < cal_DrMixDesValPID_IsumMin) {
          /* Switch: '<S401>/Switch' incorporates:
           *  Constant: '<S390>/Kp13'
           *  Switch: '<S396>/Switch1'
           *  Switch: '<S401>/Switch2'
           */
          ACCtl_rDrSetMixDoorISum = cal_DrMixDesValPID_IsumMin;
        }

        /* End of Switch: '<S401>/Switch2' */
      } else {
        /* Switch: '<S396>/Switch1' incorporates:
         *  Constant: '<S390>/Constant5'
         */
        ACCtl_rDrSetMixDoorISum = 0.0F;
      }

      /* End of Switch: '<S396>/Switch1' */

      /* Outputs for Enabled SubSystem: '<S398>/PI_Controller' */
      ME11_PI_Controller(rtb_FixPtRelationalOperator_mk, rtb_Compare_dy,
                         ACCtl_sMixDoorClsFF, ACCtl_rDrSetMixDoorPCor,
                         ACCtl_rDrSetMixDoorISum, (float32)cal_DrMixDesValPIDUL,
                         (float32)cal_DrMixDesValPIDLL, &rtb_PI_Cor_d,
                         &rtb_IFreezFlag_bd);

      /* End of Outputs for SubSystem: '<S398>/PI_Controller' */

      /* DataTypeConversion: '<S390>/Data Type Conversion' incorporates:
       *  Constant: '<S390>/Kp5'
       *  Constant: '<S390>/Kp6'
       */
      ACCtl_rDrMixDoorDes = (uint8)rtb_PI_Cor_d;

      /* Update for Delay: '<S400>/Delay' */
      ME11_ARID_DEF.Delay_DSTATE_axe = rtb_IFreezFlag_bd;

      /* Update for UnitDelay: '<S395>/Delay Input1'
       *
       * Block description for '<S395>/Delay Input1':
       *
       *  Store in Global RAM
       */
      ME11_ARID_DEF.DelayInput1_DSTATE_dw = rtb_OR_k0;
    }

    /* End of Outputs for SubSystem: '<S386>/CalDrMixDoorDesRatio_FIXPID' */
  }

  /* End of RelationalOperator: '<S41>/Relational Operator1' */
  /* End of Outputs for SubSystem: '<S41>/CalDrMixDoorDesRatio' */

  /* Switch: '<S388>/Switch3' incorporates:
   *  Constant: '<S388>/Constant6'
   *  Switch: '<S388>/Switch1'
   */
  if (rtb_AND2_of) {
    ThCo_rSetLeftMixDoor = 0.0F;
  } else if (rtb_Compare_fx) {
    /* Switch: '<S388>/Switch1' incorporates:
     *  Constant: '<S388>/Constant2'
     */
    ThCo_rSetLeftMixDoor = 100.0F;
  } else {
    /* Switch: '<S388>/Switch1' incorporates:
     *  DataTypeConversion: '<S388>/Data Type Conversion1'
     */
    ThCo_rSetLeftMixDoor = (float32)ACCtl_rDrMixDoorDes;
  }

  /* End of Switch: '<S388>/Switch3' */

  /* Relay: '<S446>/Relay' */
  ME11_ARID_DEF.Relay_Mode_n = ((ACSen_sEvapSurTemp >= cal_EVAPSufTempClsSOV) ||
    ((ACSen_sEvapSurTemp > cal_EVAPSufTempOpenSOV) && ME11_ARID_DEF.Relay_Mode_n));

  /* MultiPortSwitch: '<S446>/Multiport Switch' incorporates:
   *  Constant: '<S446>/Constant'
   *  Constant: '<S446>/Constant1'
   *  DataTypeConversion: '<S1316>/Data Type Conversion'
   *  Relay: '<S446>/Relay'
   *  Switch: '<S1735>/Switch'
   */
  switch (SOMCtl_eRefModes) {
   case 4:
   case 5:
   case 6:
    ACTCtl_bSOVCmd = true;
    break;

   case 8:
    ACTCtl_bSOVCmd = !ME11_ARID_DEF.Relay_Mode_n;
    break;

   default:
    ACTCtl_bSOVCmd = false;
    break;
  }

  /* End of MultiPortSwitch: '<S446>/Multiport Switch' */

  /* Switch: '<S51>/Switch4' incorporates:
   *  Constant: '<S51>/Constant12'
   *  Constant: '<S51>/Constant14'
   *  Constant: '<S51>/HotStart'
   *  RelationalOperator: '<S51>/Relational Operator2'
   */
  if (ACCtl_stStartState == AC_HotStart) {
    AC_BlowerFanSpeedMin = cal_FANSpdHotStartLL;
  } else {
    AC_BlowerFanSpeedMin = cal_BlowerFanSpdLL;
  }

  /* End of Switch: '<S51>/Switch4' */

  /* Outputs for Atomic SubSystem: '<S2>/IODriver' */
  ME11_TMSIODriverFunc();

  /* End of Outputs for SubSystem: '<S2>/IODriver' */

  /* DataTypeConversion: '<S50>/Data Type Conversion' incorporates:
   *  Merge: '<S43>/Merge'
   *  RelationalOperator: '<S4>/Relational Operator4'
   */
  rtb_DataTypeConversion_ks = ACCtl_BlowerMode;

  /* RelationalOperator: '<S75>/FixPt Relational Operator' incorporates:
   *  DataTypeConversion: '<S50>/Data Type Conversion'
   *  Merge: '<S43>/Merge'
   *  UnitDelay: '<S75>/Delay Input1'
   *
   * Block description for '<S75>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_FixPtRelationalOperator_mk = (ACCtl_BlowerMode !=
    ME11_ARID_DEF.DelayInput1_DSTATE_hd);

  /* Chart: '<S50>/BlowerChangeCheck' */
  if (ME11_ARID_DEF.is_active_c2_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c2_ME11 = 1U;
    ME11_ARID_DEF.is_c2_ME11 = ME11_IN_Mode;
    rtb_Compare_dy = false;
    ME11_ARID_DEF.FanLimitTime = 0U;
  } else {
    switch (ME11_ARID_DEF.is_c2_ME11) {
     case ME11_IN_Limit:
      rtb_Compare_dy = true;
      if (((!rtb_FixPtRelationalOperator_mk) && (!IOCtl_bModeMoveSts)) ||
          (ME11_ARID_DEF.FanLimitTime >= 2000)) {
        ME11_ARID_DEF.is_c2_ME11 = ME11_IN_Mode;
        rtb_Compare_dy = false;
        ME11_ARID_DEF.FanLimitTime = 0U;
      } else {
        /* after 20 seconds reset */
        b_previousEvent = ME11_ARID_DEF.FanLimitTime + 1;
        if (ME11_ARID_DEF.FanLimitTime + 1 > 65535) {
          b_previousEvent = 65535;
        }

        ME11_ARID_DEF.FanLimitTime = (uint16)b_previousEvent;
      }
      break;

     case ME11_IN_Mode:
      rtb_Compare_dy = false;
      if (rtb_FixPtRelationalOperator_mk) {
        ME11_ARID_DEF.is_c2_ME11 = ME11_IN_Modehaschanged;
        rtb_Compare_dy = true;
        ME11_ARID_DEF.FanLimitTime = 0U;
      }
      break;

     default:
      /* case IN_Modehaschanged: */
      rtb_Compare_dy = true;
      if (IOCtl_bModeMoveSts) {
        ME11_ARID_DEF.is_c2_ME11 = ME11_IN_Limit;
        ME11_ARID_DEF.FanLimitTime = 0U;

        /* after 5 seconds reset */
      } else if (ME11_ARID_DEF.FanLimitTime >= 50) {
        ME11_ARID_DEF.is_c2_ME11 = ME11_IN_Mode;
        rtb_Compare_dy = false;
        ME11_ARID_DEF.FanLimitTime = 0U;
      } else {
        b_previousEvent = ME11_ARID_DEF.FanLimitTime + 1;
        if (ME11_ARID_DEF.FanLimitTime + 1 > 65535) {
          b_previousEvent = 65535;
        }

        ME11_ARID_DEF.FanLimitTime = (uint16)b_previousEvent;
      }
      break;
    }
  }

  /* End of Chart: '<S50>/BlowerChangeCheck' */

  /* RelationalOperator: '<S547>/Compare' incorporates:
   *  Constant: '<S50>/Constant1'
   *  Inport: '<Root>/IPM_BMS_10_DC_ChargeStates_EPT'
   *  RelationalOperator: '<S50>/Relational Operator'
   */
  rtb_FixPtRelationalOperator_mk =
    ((Rte_IRead_Task_100ms_IPM_BMS_10_DC_ChargeStates_EPT_IPM_BMS_10_DC_ChargeStates_EPT
      ())->VIPM_BMSDCSActOprtMode_enum == 5);

  /* Switch: '<S50>/Switch1' incorporates:
   *  Constant: '<S50>/ColdStart'
   *  Constant: '<S50>/ColdStart6'
   *  Logic: '<S50>/Logical Operator1'
   *  RelationalOperator: '<S50>/Relational Operator1'
   *  RelationalOperator: '<S50>/Relational Operator5'
   */
  if ((ACCtl_stStartState == AC_ColdStart) || (AC_LittleColdStart ==
       ACCtl_stStartState)) {
    /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
     *  Lookup_n-D: '<S50>/cal_ACFanMaxSpdDvtLim_CUR'
     *  Sum: '<S50>/Add'
     */
    rtb_DataTypeConversion_jr = look1_iflftu8Df_binlca(AC_DVT2PTCErr, (const
      float32 *)&cal_ACFanMaxSpdDvtLim_1X[0], (const uint8 *)
      &cal_ACFanMaxSpdDvtLim_CUR[0], 4U);
  } else {
    /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
     *  Constant: '<S50>/ColdStart1'
     */
    rtb_DataTypeConversion_jr = 93U;
  }

  /* End of Switch: '<S50>/Switch1' */

  /* Switch: '<S50>/Switch5' incorporates:
   *  Constant: '<S50>/Constant2'
   *  Logic: '<S50>/Logical Operator'
   *  RelationalOperator: '<S50>/Relational Operator4'
   */
  if (rtb_FixPtRelationalOperator_mk && (rtb_IFreezFlag_k == 1)) {
    /* Switch: '<S50>/Switch5' incorporates:
     *  Lookup_n-D: '<S50>/cal_ACFanMaxSpdCellTempLim'
     *  SignalConversion: '<S2>/Signal Copy160'
     */
    AC_BlowerFanSpeedMax = look1_iflftu8Df_binlca(BMS_HVBatCellTempMax, (const
      float32 *)&cal_ACFanMaxSpdCellTempLim_1X[0], (const uint8 *)
      &cal_ACFanMaxSpdCellTempLim_CUR[0], 4U);
  } else {
    /* Switch: '<S50>/Switch5' incorporates:
     *  Constant: '<S50>/ColdStart5'
     */
    AC_BlowerFanSpeedMax = 93U;
  }

  /* End of Switch: '<S50>/Switch5' */

  /* Switch: '<S50>/Switch2' incorporates:
   *  Constant: '<S50>/ColdStart2'
   *  Constant: '<S50>/Constant3'
   */
  if (rtb_Compare_dy) {
    rtb_Add7_i = cal_FANSpdModeShiftMax;
  } else {
    rtb_Add7_i = 93U;
  }

  /* Switch: '<S50>/Switch3' incorporates:
   *  Constant: '<S50>/ColdStart3'
   *  Constant: '<S50>/Constant27'
   *  Constant: '<S50>/HotStart'
   *  RelationalOperator: '<S50>/Relational Operator2'
   */
  if (ACCtl_stStartState == AC_HotStart) {
    rtb_Add4_ox = cal_FANSpdHotStartUL;
  } else {
    rtb_Add4_ox = 93U;
  }

  /* Switch: '<S50>/Switch4' incorporates:
   *  Constant: '<S50>/ColdStart4'
   *  Constant: '<S50>/Comfort'
   *  Constant: '<S50>/Constant29'
   *  RelationalOperator: '<S50>/Relational Operator3'
   */
  if (rtb_DataTypeConversion_f == ACEconMode_FanOnly) {
    rtb_Gain_gr = cal_BlowerFanSpdVentUL;
  } else {
    rtb_Gain_gr = 93U;
  }

  /* MinMax: '<S50>/MinMax' incorporates:
   *  Switch: '<S50>/Switch2'
   *  Switch: '<S50>/Switch3'
   *  Switch: '<S50>/Switch4'
   */
  if (rtb_DataTypeConversion_jr <= rtb_Add7_i) {
    rtb_Add7_i = rtb_DataTypeConversion_jr;
  }

  if (rtb_Add7_i <= rtb_Add4_ox) {
    rtb_Add4_ox = rtb_Add7_i;
  }

  if (rtb_Add4_ox <= rtb_Gain_gr) {
    rtb_Gain_gr = rtb_Add4_ox;
  }

  if (rtb_Gain_gr <= AC_BlowerFanSpeedMax) {
    AC_BlowerFanSpeedMax = rtb_Gain_gr;
  }

  /* End of MinMax: '<S50>/MinMax' */

  /* Outputs for Enabled SubSystem: '<S44>/CabinAccmReqDisEnable' incorporates:
   *  EnablePort: '<S83>/Enable'
   */
  /* Merge: '<S44>/Merge' incorporates:
   *  Constant: '<S83>/DisEnable'
   *  SignalConversion generated from: '<S83>/ACCtl_stCabinCoolingEnable'
   */
  ACCtl_stCabinCoolingEn = false;

  /* End of Outputs for SubSystem: '<S44>/CabinAccmReqDisEnable' */

  /* Outputs for Enabled SubSystem: '<S41>/CalPsMixDoorDesRatio' incorporates:
   *  EnablePort: '<S387>/Enable'
   */
  /* RelationalOperator: '<S41>/Relational Operator2' incorporates:
   *  Constant: '<S387>/Constant'
   *  Constant: '<S416>/Kp'
   *  Constant: '<S416>/Kp1'
   *  Constant: '<S416>/Kp10'
   *  Constant: '<S416>/Kp11'
   *  Constant: '<S416>/Kp2'
   *  Constant: '<S416>/Kp3'
   *  Constant: '<S416>/Kp4'
   *  Constant: '<S416>/Kp5'
   *  Constant: '<S416>/Kp6'
   *  Constant: '<S416>/Kp7'
   *  Constant: '<S416>/Kp9'
   *  Constant: '<S41>/Constant5'
   *  DataTypeConversion: '<S387>/Data Type Conversion'
   *  Logic: '<S422>/Logical Operator'
   *  Logic: '<S423>/Logical Operator'
   *  Logic: '<S424>/Logical Operator'
   */
  if (ME11_ARID_DEF.Switch1_nv != ACOff) {
    /* Switch: '<S417>/Switch1' incorporates:
     *  Logic: '<S417>/Logical Operator'
     */
    if (ME11_TMSADCSampleFunc_ARID_DEF.Compare_n ||
        ME11_TMSADCSampleFunc_ARID_DEF.Compare_g) {
      /* Switch: '<S417>/Switch1' incorporates:
       *  Constant: '<S417>/ACPressSensorFaultPrt'
       */
      rtb_PI_Cor_d = 0.0F;
    } else {
      /* Switch: '<S417>/Switch1' */
      rtb_PI_Cor_d = ACSen_sEvapTempFilter;
    }

    /* End of Switch: '<S417>/Switch1' */

    /* Switch: '<S417>/Switch4' incorporates:
     *  Constant: '<S387>/Constant1'
     *  Constant: '<S387>/Constant5'
     *  Logic: '<S417>/Logical Operator1'
     *  Switch: '<S417>/Switch2'
     *  Switch: '<S417>/Switch3'
     */
    if (cal_PtcEnable) {
      /* Switch: '<S417>/Switch4' incorporates:
       *  Constant: '<S417>/ACPressSensorFaultPrt3'
       */
      ACCtl_PsfacPtc2NominalTemp = 0.0F;
    } else if (ME11_ARID_DEF.ErrSts_e) {
      /* Switch: '<S417>/Switch4' incorporates:
       *  Constant: '<S417>/ACPressSensorFaultPrt2'
       *  Switch: '<S417>/Switch2'
       */
      ACCtl_PsfacPtc2NominalTemp = 0.0F;
    } else {
      if (cal_EvaEnable) {
        /* Switch: '<S417>/Switch3' incorporates:
         *  Constant: '<S417>/ACPressSensorFaultPrt1'
         *  Switch: '<S417>/Switch2'
         */
        rtb_Delay = 0.0F;
      } else {
        /* Switch: '<S417>/Switch3' incorporates:
         *  Switch: '<S417>/Switch2'
         */
        rtb_Delay = rtb_PI_Cor_d;
      }

      /* Sum: '<S417>/Add1' incorporates:
       *  Switch: '<S417>/Switch2'
       */
      rtb_Delay1_ie = rtb_Merge_g - rtb_Delay;

      /* MinMax: '<S417>/MinMax' incorporates:
       *  Switch: '<S417>/Switch2'
       */
      if (rtb_Delay1_ie < 1.0F) {
        rtb_Delay1_ie = 1.0F;
      }

      /* Product: '<S417>/Divide' incorporates:
       *  Constant: '<S417>/Constant6'
       *  MinMax: '<S417>/MinMax'
       *  Sum: '<S417>/Add'
       *  Switch: '<S417>/Switch2'
       */
      ACCtl_PsfacPtc2NominalTemp = (cal_LAirmixNomOutWaterT - rtb_Delay) /
        rtb_Delay1_ie;

      /* Switch: '<S419>/Switch2' incorporates:
       *  Constant: '<S417>/ACPressSensorFaultPrt5'
       *  Constant: '<S417>/ACPressSensorFaultPrt6'
       *  RelationalOperator: '<S419>/LowerRelop1'
       *  RelationalOperator: '<S419>/UpperRelop'
       *  Switch: '<S417>/Switch2'
       *  Switch: '<S419>/Switch'
       */
      if (ACCtl_PsfacPtc2NominalTemp > 1.0F) {
        /* Switch: '<S417>/Switch4' incorporates:
         *  Switch: '<S419>/Switch2'
         */
        ACCtl_PsfacPtc2NominalTemp = 1.0F;
      } else if (ACCtl_PsfacPtc2NominalTemp < 0.0F) {
        /* Switch: '<S419>/Switch' incorporates:
         *  Constant: '<S417>/ACPressSensorFaultPrt6'
         *  Switch: '<S417>/Switch4'
         *  Switch: '<S419>/Switch2'
         */
        ACCtl_PsfacPtc2NominalTemp = 0.0F;
      }

      /* End of Switch: '<S419>/Switch2' */
    }

    /* End of Switch: '<S417>/Switch4' */

    /* MultiPortSwitch: '<S415>/Multiport Switch2' incorporates:
     *  Delay: '<S4>/Delay'
     */
    switch (rtb_Delay_n2) {
     case BlowerModes_FaceMode:
      /* MultiPortSwitch: '<S415>/Multiport Switch2' incorporates:
       *  Lookup_n-D: '<S415>/cal_PsMixBacSetAC_CUR'
       *  Switch: '<S182>/Switch1'
       */
      ACCtl_rPsBlowerModeSet = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
        &cal_PsMixBacSetAC_1X[0], (const float32 *)&cal_PsMixBacSetAC_CUR[0], 7U);
      break;

     case BlowerModes_FaceHeaterMode:
      /* MultiPortSwitch: '<S415>/Multiport Switch2' incorporates:
       *  Lookup_n-D: '<S415>/cal_PsMixBacSetBi_CUR'
       *  Switch: '<S182>/Switch1'
       */
      ACCtl_rPsBlowerModeSet = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
        &cal_PsMixBacSetBi_1X[0], (const float32 *)&cal_PsMixBacSetBi_CUR[0], 7U);
      break;

     case BlowerModes_HeaterMode:
      /* MultiPortSwitch: '<S415>/Multiport Switch2' incorporates:
       *  Lookup_n-D: '<S415>/cal_PsMixBacSetFoot_CUR'
       *  Switch: '<S182>/Switch1'
       */
      ACCtl_rPsBlowerModeSet = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
        &cal_PsMixBacSetFoot_1X[0], (const float32 *)&cal_PsMixBacSetFoot_CUR[0],
        7U);
      break;

     case BlowerModes_HeaterDeforstMode:
      /* MultiPortSwitch: '<S415>/Multiport Switch2' incorporates:
       *  Lookup_n-D: '<S415>/cal_PsMixBacSetFootDe_CUR'
       *  Switch: '<S182>/Switch1'
       */
      ACCtl_rPsBlowerModeSet = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
        &cal_PsMixBacSetFootDe_1X[0], (const float32 *)
        &cal_PsMixBacSetFootDe_CUR[0], 7U);
      break;

     default:
      /* MultiPortSwitch: '<S415>/Multiport Switch2' incorporates:
       *  Lookup_n-D: '<S415>/cal_PsMixBacSetDefog_CUR'
       *  Switch: '<S182>/Switch1'
       */
      ACCtl_rPsBlowerModeSet = look1_iflf_binlca(ACCtl_tPsDVT, (const float32 *)
        &cal_PsMixBacSetDefog_1X[0], (const float32 *)&cal_PsMixBacSetDefog_CUR
        [0], 7U);
      break;
    }

    /* End of MultiPortSwitch: '<S415>/Multiport Switch2' */

    /* Sum: '<S415>/Subtract2' */
    rtb_Add_ok = (float32)floor((rtb_PI_Cor_d - ACCtl_tPsDVT) * 2.0F);
    if (rtb_Add_ok < 32768.0F) {
      if (rtb_Add_ok >= -32768.0F) {
        rtb_DataTypeConversion_dt = (sint16)rtb_Add_ok;
      } else {
        rtb_DataTypeConversion_dt = MIN_int16_T;
      }
    } else {
      rtb_DataTypeConversion_dt = MAX_int16_T;
    }

    /* Relay: '<S415>/On:cal_PsErrOfEvaDVT2CoolMixOn Off:cal_PsErrOfEvaDVT2CoolMixOff ' incorporates:
     *  Sum: '<S415>/Subtract2'
     */
    rtb_Delay1_ie = cal_PsErrOfEvaDVT2CoolMixOn * 2.0F;
    rtb_Delay = cal_PsErrOfEvaDVT2CoolMixOff * 2.0F;
    if ((float32)fabs(rtb_Delay1_ie) >= 0.5F) {
      rtb_Add_ok = (float32)floor(rtb_Delay1_ie + 0.5F);
    } else {
      rtb_Add_ok = 0.0F;
    }

    if ((float32)fabs(rtb_Delay) >= 0.5F) {
      rtb_Delay1_ie = (float32)floor(rtb_Delay + 0.5F);
    } else {
      rtb_Delay1_ie = 0.0F;
    }

    ME11_ARID_DEF.Oncal_PsErrOfEvaDVT2CoolMixOnOffcal_PsErrOfEvaDVT2CoolMixOff_Mode
      = ((rtb_DataTypeConversion_dt >= (sint16)rtb_Add_ok) ||
         ((rtb_DataTypeConversion_dt > (sint16)rtb_Delay1_ie) &&
          ME11_ARID_DEF.Oncal_PsErrOfEvaDVT2CoolMixOnOffcal_PsErrOfEvaDVT2CoolMixOff_Mode));

    /* Sum: '<S415>/Subtract1' */
    rtb_Add_ok = (float32)floor((ACCtl_tPsDVT - rtb_Merge_g) * 2.0F);
    if (rtb_Add_ok < 32768.0F) {
      if (rtb_Add_ok >= -32768.0F) {
        rtb_DataTypeConversion_dt = (sint16)rtb_Add_ok;
      } else {
        rtb_DataTypeConversion_dt = MIN_int16_T;
      }
    } else {
      rtb_DataTypeConversion_dt = MAX_int16_T;
    }

    /* Relay: '<S415>/On:cal_PsErrOfPtcDVT2HeatMixOn Off:cal_PsErrOfPtcDVT2HeatMixOff' incorporates:
     *  Sum: '<S415>/Subtract1'
     */
    rtb_Delay1_ie = cal_PsErrOfPtcDVT2HeatMixOn * 2.0F;
    rtb_Delay = cal_PsErrOfPtcDVT2HeatMixOff * 2.0F;
    if ((float32)fabs(rtb_Delay1_ie) >= 0.5F) {
      rtb_Add_ok = (float32)floor(rtb_Delay1_ie + 0.5F);
    } else {
      rtb_Add_ok = 0.0F;
    }

    if ((float32)fabs(rtb_Delay) >= 0.5F) {
      rtb_Delay1_ie = (float32)floor(rtb_Delay + 0.5F);
    } else {
      rtb_Delay1_ie = 0.0F;
    }

    ME11_ARID_DEF.Oncal_PsErrOfPtcDVT2HeatMixOnOffcal_PsErrOfPtcDVT2HeatMixOff_Mode
      = ((rtb_DataTypeConversion_dt >= (sint16)rtb_Add_ok) ||
         ((rtb_DataTypeConversion_dt > (sint16)rtb_Delay1_ie) &&
          ME11_ARID_DEF.Oncal_PsErrOfPtcDVT2HeatMixOnOffcal_PsErrOfPtcDVT2HeatMixOff_Mode));

    /* Switch: '<S415>/Switch6' incorporates:
     *  Relay: '<S415>/On:cal_PsErrOfEvaDVT2CoolMixOn Off:cal_PsErrOfEvaDVT2CoolMixOff '
     *  Relay: '<S415>/On:cal_PsErrOfPtcDVT2HeatMixOn Off:cal_PsErrOfPtcDVT2HeatMixOff'
     *  Switch: '<S415>/Switch1'
     */
    if (ME11_ARID_DEF.Oncal_PsErrOfEvaDVT2CoolMixOnOffcal_PsErrOfEvaDVT2CoolMixOff_Mode)
    {
      /* Switch: '<S415>/Switch6' incorporates:
       *  Constant: '<S415>/Constant1'
       */
      ACCtl_rPsBasicMixDoor = 0U;
    } else if
        (ME11_ARID_DEF.Oncal_PsErrOfPtcDVT2HeatMixOnOffcal_PsErrOfPtcDVT2HeatMixOff_Mode)
    {
      /* Switch: '<S415>/Switch6' incorporates:
       *  Constant: '<S415>/Constant'
       *  Switch: '<S415>/Switch1'
       */
      ACCtl_rPsBasicMixDoor = 100U;
    } else {
      /* Product: '<S415>/Divide1' incorporates:
       *  Switch: '<S415>/Switch1'
       */
      rtb_Divide1_f = (uint32)(ACCtl_PsfacPtc2NominalTemp *
        ACCtl_rPsBlowerModeSet * 256.0F);

      /* Switch: '<S418>/Switch2' incorporates:
       *  Product: '<S415>/Divide1'
       *  RelationalOperator: '<S418>/LowerRelop1'
       *  Switch: '<S415>/Switch1'
       */
      if (rtb_Divide1_f > 25600U) {
        /* Switch: '<S415>/Switch6' incorporates:
         *  Constant: '<S415>/ACPressSensorFaultPrt5'
         *  Switch: '<S418>/Switch2'
         */
        ACCtl_rPsBasicMixDoor = 100U;
      } else {
        /* Switch: '<S415>/Switch6' incorporates:
         *  Switch: '<S418>/Switch'
         *  Switch: '<S418>/Switch2'
         */
        ACCtl_rPsBasicMixDoor = (uint8)((uint32)((rtb_Divide1_f & 128U) != 0U) +
          (rtb_Divide1_f >> 8));
      }

      /* End of Switch: '<S418>/Switch2' */
    }

    /* End of Switch: '<S415>/Switch6' */

    /* Outputs for Enabled SubSystem: '<S387>/CalPsMixDoorDesRatio' incorporates:
     *  EnablePort: '<S416>/Enable'
     */
    if (cal_FixPIDSecletFlag) {
      /* Outputs for Enabled SubSystem: '<S422>/PI_Controller1' */
      ME11_PI_Controller1(!rtb_Delay1_ag, (float32)ACCtl_rPsBasicMixDoor,
                          &rtb_PI_Cor_n, &rtb_IFreezFlag_jz);

      /* End of Outputs for SubSystem: '<S422>/PI_Controller1' */

      /* RelationalOperator: '<S421>/Relational Operator' incorporates:
       *  DataTypeConversion: '<S387>/Data Type Conversion'
       *  Logic: '<S422>/Logical Operator'
       */
      rtb_FixPtRelationalOperator_mk = (ACCtl_tPsDVT >= ACCtl_tLeftDuct);

      /* Sum: '<S421>/Sum' */
      rtb_PI_Cor_d = ACCtl_tPsDVT - ACCtl_tLeftDuct;

      /* Chart: '<S421>/deadzone' incorporates:
       *  Constant: '<S416>/Constant'
       */
      ME11_deadzone_h(rtb_PI_Cor_d, 0.5, &rtb_flag_f);

      /* Switch: '<S421>/Switch1' incorporates:
       *  Switch: '<S421>/Switch'
       */
      if (rtb_flag_f) {
        /* Switch: '<S421>/Switch1' incorporates:
         *  Constant: '<S421>/Constant'
         */
        rtb_PI_Cor_d = 0.0F;
      } else if (!rtb_FixPtRelationalOperator_mk) {
        /* Switch: '<S421>/Switch1' incorporates:
         *  Sum: '<S421>/Sum1'
         *  Switch: '<S421>/Switch'
         */
        rtb_PI_Cor_d = ACCtl_tLeftDuct - ACCtl_tPsDVT;
      }

      /* End of Switch: '<S421>/Switch1' */

      /* Outputs for Enabled SubSystem: '<S423>/P_NEG' */
      ME11_P_NEG_h(!rtb_FixPtRelationalOperator_mk, rtb_PI_Cor_d,
                   cal_PsMixDesValPID_pWinNeg, cal_PsMixDesValPID_KpNeg,
                   cal_PsMixDesValPID_Kp, (float32 *)&ACCtl_rPsSetMixDoorPCor);

      /* End of Outputs for SubSystem: '<S423>/P_NEG' */

      /* Outputs for Enabled SubSystem: '<S423>/P_POS' */
      ME11_P_POS_c(rtb_FixPtRelationalOperator_mk, rtb_PI_Cor_d,
                   cal_PsMixDesValPID_pWinPos, cal_PsMixDesValPID_KpPos,
                   cal_PsMixDesValPID_Kp, (float32 *)&ACCtl_rPsSetMixDoorPCor);

      /* End of Outputs for SubSystem: '<S423>/P_POS' */

      /* Outputs for Enabled SubSystem: '<S424>/P_NEG' */
      ME11_P_NEG(!rtb_FixPtRelationalOperator_mk, rtb_PI_Cor_d,
                 cal_PsMixDesValPIDIntegDeadBand, cal_PsMixDesValPID_KiNeg,
                 cal_PsMixDesValPID_Ki, (float32 *)&ACCtl_rPsSetMixDoorICor);

      /* End of Outputs for SubSystem: '<S424>/P_NEG' */

      /* Outputs for Enabled SubSystem: '<S424>/P_POS' */
      ME11_P_POS(rtb_FixPtRelationalOperator_mk, rtb_PI_Cor_d,
                 cal_PsMixDesValPIDIntegDeadBand, cal_PsMixDesValPID_KiPos,
                 cal_PsMixDesValPID_Ki, (float32 *)&ACCtl_rPsSetMixDoorICor);

      /* End of Outputs for SubSystem: '<S424>/P_POS' */

      /* Switch: '<S420>/Switch1' incorporates:
       *  Constant: '<S416>/Kp'
       *  Constant: '<S416>/Kp1'
       *  Constant: '<S416>/Kp10'
       *  Constant: '<S416>/Kp11'
       *  Constant: '<S416>/Kp2'
       *  Constant: '<S416>/Kp3'
       *  Constant: '<S416>/Kp4'
       *  Constant: '<S416>/Kp7'
       *  Constant: '<S416>/Kp9'
       *  Logic: '<S423>/Logical Operator'
       *  Logic: '<S424>/Logical Operator'
       */
      if (rtb_Delay1_ag) {
        /* MultiPortSwitch: '<S424>/Multiport Switch' incorporates:
         *  Delay: '<S424>/Delay'
         */
        switch (ME11_ARID_DEF.Delay_DSTATE_nz) {
         case 0:
          /* Switch: '<S428>/Switch' */
          if (rtb_FixPtRelationalOperator_mk) {
            /* Switch: '<S425>/Switch2' incorporates:
             *  Delay: '<S420>/Delay'
             *  Sum: '<S428>/Add'
             *  Switch: '<S428>/Switch'
             */
            ACCtl_rPsSetMixDoorISum = ACCtl_rPsSetMixDoorISum +
              ACCtl_rPsSetMixDoorICor;
          } else {
            /* Switch: '<S425>/Switch2' incorporates:
             *  Delay: '<S420>/Delay'
             *  Sum: '<S428>/Add1'
             *  Switch: '<S428>/Switch'
             */
            ACCtl_rPsSetMixDoorISum = ACCtl_rPsSetMixDoorISum -
              ACCtl_rPsSetMixDoorICor;
          }

          /* End of Switch: '<S428>/Switch' */
          break;

         case 1:
          /* Switch: '<S429>/Switch' */
          if (!rtb_FixPtRelationalOperator_mk) {
            /* Switch: '<S425>/Switch2' incorporates:
             *  Delay: '<S420>/Delay'
             *  Sum: '<S429>/Add1'
             *  Switch: '<S429>/Switch'
             */
            ACCtl_rPsSetMixDoorISum = ACCtl_rPsSetMixDoorISum -
              ACCtl_rPsSetMixDoorICor;
          }

          /* End of Switch: '<S429>/Switch' */
          break;

         case 2:
          /* Switch: '<S426>/Switch' */
          if (rtb_FixPtRelationalOperator_mk) {
            /* Switch: '<S425>/Switch2' incorporates:
             *  Delay: '<S420>/Delay'
             *  Sum: '<S426>/Add'
             *  Switch: '<S426>/Switch'
             */
            ACCtl_rPsSetMixDoorISum = ACCtl_rPsSetMixDoorISum +
              ACCtl_rPsSetMixDoorICor;
          }

          /* End of Switch: '<S426>/Switch' */
          break;

         case 3:
          break;
        }

        /* End of MultiPortSwitch: '<S424>/Multiport Switch' */

        /* Switch: '<S425>/Switch2' incorporates:
         *  Constant: '<S416>/Constant5'
         *  Constant: '<S416>/Kp13'
         *  Constant: '<S416>/Kp8'
         *  RelationalOperator: '<S425>/LowerRelop1'
         *  RelationalOperator: '<S425>/UpperRelop'
         *  Sum: '<S420>/Add'
         *  Switch: '<S425>/Switch'
         */
        if ((ACCtl_rPsSetMixDoorISum - 8000.0F) + 8000.0F >
            cal_PsMixDesValPID_IsumMax) {
          /* Switch: '<S420>/Switch1' incorporates:
           *  Switch: '<S425>/Switch2'
           */
          ACCtl_rPsSetMixDoorISum = cal_PsMixDesValPID_IsumMax;
        } else if ((ACCtl_rPsSetMixDoorISum - 8000.0F) + 8000.0F <
                   cal_PsMixDesValPID_IsumMin) {
          /* Switch: '<S425>/Switch' incorporates:
           *  Constant: '<S416>/Kp13'
           *  Switch: '<S420>/Switch1'
           *  Switch: '<S425>/Switch2'
           */
          ACCtl_rPsSetMixDoorISum = cal_PsMixDesValPID_IsumMin;
        } else {
          /* Switch: '<S420>/Switch1' incorporates:
           *  Switch: '<S425>/Switch2'
           */
          ACCtl_rPsSetMixDoorISum = (ACCtl_rPsSetMixDoorISum - 8000.0F) +
            8000.0F;
        }

        /* End of Switch: '<S425>/Switch2' */
      } else {
        /* Switch: '<S420>/Switch1' incorporates:
         *  Constant: '<S416>/Constant5'
         */
        ACCtl_rPsSetMixDoorISum = 0.0F;
      }

      /* End of Switch: '<S420>/Switch1' */

      /* Outputs for Enabled SubSystem: '<S422>/PI_Controller' */
      ME11_PI_Controller(rtb_Delay1_ag, rtb_FixPtRelationalOperator_mk, (float32)
                         ACCtl_rPsBasicMixDoor, ACCtl_rPsSetMixDoorPCor,
                         ACCtl_rPsSetMixDoorISum, (float32)cal_PsMixDesValPIDUL,
                         (float32)cal_PsMixDesValPIDLL, &rtb_PI_Cor_n,
                         &rtb_IFreezFlag_jz);

      /* End of Outputs for SubSystem: '<S422>/PI_Controller' */

      /* DataTypeConversion: '<S416>/Data Type Conversion' incorporates:
       *  Constant: '<S416>/Kp5'
       *  Constant: '<S416>/Kp6'
       *  DataTypeConversion: '<S387>/Data Type Conversion'
       */
      ACCtl_rPsMixDoorDes = (uint8)rtb_PI_Cor_n;

      /* Update for Delay: '<S424>/Delay' */
      ME11_ARID_DEF.Delay_DSTATE_nz = rtb_IFreezFlag_jz;
    }

    /* End of Outputs for SubSystem: '<S387>/CalPsMixDoorDesRatio' */
  }

  /* End of RelationalOperator: '<S41>/Relational Operator2' */
  /* End of Outputs for SubSystem: '<S41>/CalPsMixDoorDesRatio' */

  /* Switch: '<S388>/Switch2' incorporates:
   *  Switch: '<S388>/Switch'
   */
  if (rtb_AND2_of) {
    /* Switch: '<S388>/Switch2' incorporates:
     *  Constant: '<S388>/Constant4'
     */
    ThCo_rSetRightMixDoor = 0.0F;
  } else if (rtb_Compare_fx) {
    /* Switch: '<S388>/Switch' incorporates:
     *  Constant: '<S388>/Constant1'
     *  Switch: '<S388>/Switch2'
     */
    ThCo_rSetRightMixDoor = 100.0F;
  } else {
    /* Switch: '<S388>/Switch2' incorporates:
     *  DataTypeConversion: '<S388>/Data Type Conversion'
     *  Switch: '<S388>/Switch'
     */
    ThCo_rSetRightMixDoor = (float32)ACCtl_rPsMixDoorDes;
  }

  /* End of Switch: '<S388>/Switch2' */

  /* Sum: '<S95>/Add' */
  rtb_Add_ei_0 = (uint16)((ACCtl_tSetPointPTC - rtb_Merge_g) * 2.0F + 400.0F);

  /* Switch: '<S100>/Switch2' incorporates:
   *  RelationalOperator: '<S100>/LowerRelop1'
   *  RelationalOperator: '<S100>/UpperRelop'
   *  Sum: '<S95>/Add'
   *  Switch: '<S100>/Switch'
   */
  if (rtb_Add_ei_0 > 560) {
    /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
     *  Constant: '<S95>/Constant1'
     */
    rtb_DataTypeConversion_jr = 240U;
  } else if (rtb_Add_ei_0 < 320) {
    /* Switch: '<S100>/Switch' incorporates:
     *  Constant: '<S95>/Constant2'
     *  DataTypeConversion: '<S497>/Data Type Conversion'
     */
    rtb_DataTypeConversion_jr = 0U;
  } else {
    /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
     *  Switch: '<S100>/Switch'
     */
    rtb_DataTypeConversion_jr = (uint8)(rtb_Add_ei_0 + -320);
  }

  /* End of Switch: '<S100>/Switch2' */

  /* Relay: '<S95>/On:cal_ErrOfPTCActTargInComf_ON Off:cal_ErrOfPTCActTargInComf_OFF ' incorporates:
   *  DataTypeConversion: '<S497>/Data Type Conversion'
   */
  rtb_Delay1_ie = cal_ErrOfPTCActTargInComf_ON * 2.0F + 80.0F;
  if (rtb_Delay1_ie >= 0.5F) {
    rtb_Add_ok = (float32)floor(rtb_Delay1_ie + 0.5F);
  } else {
    rtb_Add_ok = 0.0F;
  }

  rtb_Delay1_ie = cal_ErrOfPTCActTargInComf_OFF * 2.0F + 80.0F;
  if (rtb_Delay1_ie >= 0.5F) {
    rtb_Delay1_ie = (float32)floor(rtb_Delay1_ie + 0.5F);
  } else {
    rtb_Delay1_ie = 0.0F;
  }

  if (rtb_Add_ok < 256.0F) {
    rtb_Add7_i = (uint8)rtb_Add_ok;
  } else {
    rtb_Add7_i = MAX_uint8_T;
  }

  if (rtb_Delay1_ie < 256.0F) {
    rtb_IFreezFlag_bd = (uint8)rtb_Delay1_ie;
  } else {
    rtb_IFreezFlag_bd = MAX_uint8_T;
  }

  ME11_ARID_DEF.Oncal_ErrOfPTCActTargInComf_ONOffcal_ErrOfPTCActTargInComf_OFF_Mode
    = ((rtb_DataTypeConversion_jr >= rtb_Add7_i) || ((rtb_DataTypeConversion_jr >
         rtb_IFreezFlag_bd) &&
        ME11_ARID_DEF.Oncal_ErrOfPTCActTargInComf_ONOffcal_ErrOfPTCActTargInComf_OFF_Mode));

  /* End of Relay: '<S95>/On:cal_ErrOfPTCActTargInComf_ON Off:cal_ErrOfPTCActTargInComf_OFF ' */

  /* Relay: '<S95>/On:cal_ErrOfPTCActTargInEcon_ON Off:cal_ErrOfPTCActTargInEcon_OFF' incorporates:
   *  DataTypeConversion: '<S497>/Data Type Conversion'
   */
  rtb_Delay1_ie = cal_ErrOfPTCActTargInEcon_ON * 2.0F + 80.0F;
  if (rtb_Delay1_ie >= 0.5F) {
    rtb_Add_ok = (float32)floor(rtb_Delay1_ie + 0.5F);
  } else {
    rtb_Add_ok = 0.0F;
  }

  rtb_Delay1_ie = cal_ErrOfPTCActTargInEcon_OFF * 2.0F + 80.0F;
  if (rtb_Delay1_ie >= 0.5F) {
    rtb_Delay1_ie = (float32)floor(rtb_Delay1_ie + 0.5F);
  } else {
    rtb_Delay1_ie = 0.0F;
  }

  if (rtb_Add_ok < 256.0F) {
    rtb_Add7_i = (uint8)rtb_Add_ok;
  } else {
    rtb_Add7_i = MAX_uint8_T;
  }

  if (rtb_Delay1_ie < 256.0F) {
    rtb_IFreezFlag_bd = (uint8)rtb_Delay1_ie;
  } else {
    rtb_IFreezFlag_bd = MAX_uint8_T;
  }

  ME11_ARID_DEF.Oncal_ErrOfPTCActTargInEcon_ONOffcal_ErrOfPTCActTargInEcon_OFF_Mode
    = ((rtb_DataTypeConversion_jr >= rtb_Add7_i) || ((rtb_DataTypeConversion_jr >
         rtb_IFreezFlag_bd) &&
        ME11_ARID_DEF.Oncal_ErrOfPTCActTargInEcon_ONOffcal_ErrOfPTCActTargInEcon_OFF_Mode));

  /* End of Relay: '<S95>/On:cal_ErrOfPTCActTargInEcon_ON Off:cal_ErrOfPTCActTargInEcon_OFF' */

  /* MinMax: '<S41>/MinMax1' */
  if (ThCo_rSetRightMixDoor >= ThCo_rSetLeftMixDoor) {
    /* Gain: '<S8>/Gain8' */
    rtb_Delay1_ie = ThCo_rSetRightMixDoor;
  } else {
    /* Gain: '<S8>/Gain8' */
    rtb_Delay1_ie = ThCo_rSetLeftMixDoor;
  }

  /* End of MinMax: '<S41>/MinMax1' */

  /* Relay: '<S93>/On:cal_MixDoor2CabinHeatingEn_ON Off:cal_MixDoor2CabinHeatingEn_OFF ' */
  ME11_ARID_DEF.Oncal_MixDoor2CabinHeatingEn_ONOffcal_MixDoor2CabinHeatingEn_OFF_Mode
    = ((rtb_Delay1_ie >= cal_MixDoor2CabinHeatingEn_ON) || ((rtb_Delay1_ie >
         cal_MixDoor2CabinHeatingEn_OFF) &&
        ME11_ARID_DEF.Oncal_MixDoor2CabinHeatingEn_ONOffcal_MixDoor2CabinHeatingEn_OFF_Mode));

  /* Logic: '<S93>/Logical Operator' */
  ACCtl_stCabinHeatingEn = false;

  /* RelationalOperator: '<S956>/Compare' incorporates:
   *  Constant: '<S956>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 13);

  /* Chart: '<S943>/Inlet_Temp_Sensor_Fault' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_oi, &ME11_ARID_DEF.ARID_DEF_Inlet_Temp_Sensor_Fault);

  /* Outputs for Atomic SubSystem: '<S45>/PTC_PID' */
  /* SignalConversion: '<S38>/Signal Copy' */
  ACCtl_pwrHeatingReq = ME11_PTC_PID(ACCtl_tSetPointPTC, rtb_Merge_g,
    ACCtl_stCabinHeatingEn, ME11_ARID_DEF.ErrSts_oi, ACSen_sEnvTempCor,
    &ME11_ARID_DEF.ARID_DEF_PTC_PID);

  /* End of Outputs for SubSystem: '<S45>/PTC_PID' */

  /* RelationalOperator: '<S4>/Relational Operator3' incorporates:
   *  Constant: '<S4>/Constant2'
   */
  rtb_Delay1_ag = (ME11_ARID_DEF.Switch1_nv == ACOff);

  /* RelationalOperator: '<S4>/Relational Operator4' incorporates:
   *  Constant: '<S4>/1 - DEFROST'
   *  DataTypeConversion: '<S50>/Data Type Conversion'
   *  Merge: '<S43>/Merge'
   */
  rtb_FixPtRelationalOperator_mk = (ACCtl_BlowerMode == BlowerModes_DeforstMode);

  /* RelationalOperator: '<S4>/Relational Operator5' incorporates:
   *  Constant: '<S4>/SetPointLowValue'
   */
  rtb_AND2_of = (HMICtl_sLeftSetPoint < 16.5F);

  /* RelationalOperator: '<S4>/Relational Operator6' incorporates:
   *  Constant: '<S4>/SetPointHighValue'
   */
  rtb_Compare_fx = (HMICtl_sLeftSetPoint > 31.5F);

  /* RelationalOperator: '<S4>/Relational Operator7' incorporates:
   *  Constant: '<S4>/Constant15'
   */
  rtb_Compare_dy = (AC_FanLevelAct == 5);

  /* RelationalOperator: '<S4>/Relational Operator8' incorporates:
   *  Constant: '<S4>/Comfort'
   */
  rtb_OR_k0 = (rtb_DataTypeConversion_f == ACEconMode_FanOnly);

  /* Chart: '<S4>/stExhaustFunCheck' incorporates:
   *  RelationalOperator: '<S4>/Relational Operator9'
   */
  /*  */
  if (ME11_ARID_DEF.is_active_c57_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c57_ME11 = 1U;
    if (rtb_FixPtRelationalOperator_mk && rtb_Compare_fx && rtb_AND2_of &&
        rtb_Compare_dy && rtb_OR_k0 && ACCtl_stRecOut) {
      ME11_ARID_DEF.is_c57_ME11 = ME11_IN_Exhaust_Check;
      ME11_ARID_DEF.ExhaustTime = 0U;
      ME11_ARID_DEF.is_Exhaust_Check = ME11_IN_Exhaust_intl;
      AC_stExhaust = false;
    } else {
      ME11_ARID_DEF.is_c57_ME11 = ME11_IN_Exhaust_OFF;
      AC_stExhaust = false;
    }
  } else if (ME11_ARID_DEF.is_c57_ME11 == ME11_IN_Exhaust_Check) {
    if ((!AC_stIGNON) || (ME11_ARID_DEF.ExhaustTime >= 15000)) {
      ME11_ARID_DEF.is_Exhaust_Check = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_ARID_DEF.is_c57_ME11 = ME11_IN_Exhaust_OFF;
      AC_stExhaust = false;
    } else if (ME11_ARID_DEF.is_Exhaust_Check == ME11_IN_Exhaust_ON) {
      AC_stExhaust = true;
      if (!rtb_Delay1_ag) {
        ME11_ARID_DEF.is_Exhaust_Check = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_c57_ME11 = ME11_IN_Exhaust_OFF;
        AC_stExhaust = false;
      } else {
        b_previousEvent = ME11_ARID_DEF.ExhaustTime + 1;
        if (ME11_ARID_DEF.ExhaustTime + 1 > 65535) {
          b_previousEvent = 65535;
        }

        ME11_ARID_DEF.ExhaustTime = (uint16)b_previousEvent;
      }
    } else {
      /* case IN_Exhaust_intl: */
      AC_stExhaust = false;
      if (rtb_Delay1_ag) {
        ME11_ARID_DEF.is_Exhaust_Check = ME11_IN_Exhaust_ON;
        AC_stExhaust = true;
      } else if ((!rtb_FixPtRelationalOperator_mk) || (!rtb_Compare_fx) ||
                 (!rtb_AND2_of) || (!rtb_Compare_dy) || (!rtb_OR_k0) ||
                 (!ACCtl_stRecOut)) {
        ME11_ARID_DEF.is_Exhaust_Check = ME11_IN_NO_ACTIVE_CHILD_gl;
        ME11_ARID_DEF.is_c57_ME11 = ME11_IN_Exhaust_OFF;
        AC_stExhaust = false;
      }
    }
  } else {
    /* case IN_Exhaust_OFF: */
    AC_stExhaust = false;
    if (rtb_FixPtRelationalOperator_mk && rtb_Compare_fx && rtb_AND2_of &&
        rtb_Compare_dy && rtb_OR_k0 && ACCtl_stRecOut) {
      ME11_ARID_DEF.is_c57_ME11 = ME11_IN_Exhaust_Check;
      ME11_ARID_DEF.ExhaustTime = 0U;
      ME11_ARID_DEF.is_Exhaust_Check = ME11_IN_Exhaust_intl;
      AC_stExhaust = false;
    }
  }

  /* End of Chart: '<S4>/stExhaustFunCheck' */

  /* Product: '<S1079>/Divide' incorporates:
   *  Constant: '<S1079>/Constant14'
   *  DataStoreWrite: '<S1079>/Data Store Write8'
   *  Sum: '<S1079>/Add'
   */
  ME11_ARID_DEF.EEWrite_AmbienceTemp = (uint8)((uint8)(ME11_ARID_DEF.OutData +
    40.0F) << 1);

  /* CCaller: '<S1073>/C Caller1' incorporates:
   *  Constant: '<S1073>/Constant1'
   *  Constant: '<S1073>/Constant2'
   *  Constant: '<S1073>/Constant5'
   *  Product: '<S1073>/Divide'
   *  Sum: '<S1073>/Add1'
   */
  Rte_DIDReadData((uint8)(2.0F * (ACSen_sEnvTempCor + 40.0F)), ((uint8)
    DID_0xF260));

  /* CCaller: '<S1074>/C Caller1' incorporates:
   *  Constant: '<S1074>/Constant6'
   *  Constant: '<S1086>/Constant'
   *  DataTypeConversion: '<S1089>/Data Type Conversion'
   *  RelationalOperator: '<S1086>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941B11), (uint8)
                     (ACSen_eEnvSenSts == Ground));

  /* CCaller: '<S1074>/C Caller2' incorporates:
   *  Constant: '<S1074>/Constant7'
   *  Constant: '<S1087>/Constant'
   *  DataTypeConversion: '<S1089>/Data Type Conversion'
   *  RelationalOperator: '<S1087>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x941B15), (uint8)
                     (ACSen_eEnvSenSts == Power));

  /* Switch: '<S1074>/Switch' incorporates:
   *  Constant: '<S1074>/Constant'
   */
  if (cal_EnvFailSwFlg) {
    /* Switch: '<S1074>/Switch' incorporates:
     *  Constant: '<S1074>/Constant4'
     */
    rtb_AND2_of = false;
  } else {
    /* Switch: '<S1074>/Switch' incorporates:
     *  Constant: '<S1088>/Constant'
     *  DataTypeConversion: '<S1089>/Data Type Conversion'
     *  RelationalOperator: '<S1088>/Compare'
     */
    rtb_AND2_of = (ACSen_eEnvSenSts != Normal);
  }

  /* End of Switch: '<S1074>/Switch' */

  /* DataTypeConversion: '<S15>/Data Type Conversion' incorporates:
   *  ArithShift: '<S15>/Shift Arithmetic'
   *  Gain: '<S1280>/Gain'
   *  Inport: '<Root>/EXV_CurrentPosition'
   *
   * Block description for '<Root>/EXV_CurrentPosition':
   *  EXV:
   */
  rtb_Add_ei_0 = Rte_IRead_Task_100ms_EXV_CurrentPosition_EXV_CurrentPosition();

  /* DataStoreWrite: '<S15>/Data Store Write' incorporates:
   *  ArithShift: '<S15>/Shift Arithmetic'
   *  DataTypeConversion: '<S15>/Data Type Conversion'
   *  DataTypeConversion: '<S15>/Data Type Conversion1'
   *  Inport: '<Root>/EXV_CurrentPosition'
   *
   * Block description for '<Root>/EXV_CurrentPosition':
   *  EXV:
   */
  Buffer_DcmDspData_F27DH[0] = (uint8)rtb_Add_ei_0;
  Buffer_DcmDspData_F27DH[1] = (uint8)((uint32)rtb_Add_ei_0 >> 8);

  /* Gain: '<S1280>/Gain' */
  EXV_CurrentPosition = 0.15625F * (float32)rtb_Add_ei_0;

  /* SignalConversion: '<S15>/Signal Copy97' incorporates:
   *  Inport: '<Root>/EXV_CurrentInitState'
   *
   * Block description for '<Root>/EXV_CurrentInitState':
   *  Current Init State
   */
  EXV_CurrentInitState =
    Rte_IRead_Task_100ms_EXV_CurrentInitState_EXV_CurrentInitState();

  /* SignalConversion: '<S15>/Signal Copy98' incorporates:
   *  Inport: '<Root>/EXV_RunState'
   *
   * Block description for '<Root>/EXV_RunState':
   *  Run State
   */
  EXV_RunState = Rte_IRead_Task_100ms_EXV_RunState_EXV_RunState();

  /* DataTypeConversion: '<S18>/Data Type Conversion' incorporates:
   *  ArithShift: '<S18>/Shift Arithmetic'
   *  Gain: '<S1283>/Gain'
   *  Inport: '<Root>/BAT_EXV_CurrentPosition_B'
   *
   * Block description for '<Root>/BAT_EXV_CurrentPosition_B':
   *  CurrentPosition
   */
  rtb_Add_ei_0 =
    Rte_IRead_Task_100ms_BAT_EXV_CurrentPosition_B_BAT_EXV_CurrentPosition_B();

  /* DataStoreWrite: '<S18>/Data Store Write' incorporates:
   *  ArithShift: '<S18>/Shift Arithmetic'
   *  DataTypeConversion: '<S18>/Data Type Conversion'
   *  DataTypeConversion: '<S18>/Data Type Conversion1'
   *  Inport: '<Root>/BAT_EXV_CurrentPosition_B'
   *
   * Block description for '<Root>/BAT_EXV_CurrentPosition_B':
   *  CurrentPosition
   */
  Buffer_DcmDspData_F27EH[0] = (uint8)rtb_Add_ei_0;
  Buffer_DcmDspData_F27EH[1] = (uint8)((uint32)rtb_Add_ei_0 >> 8);

  /* Gain: '<S1283>/Gain' */
  BAT_EXV_CurrentPosition_B = 0.15625F * (float32)rtb_Add_ei_0;

  /* SignalConversion: '<S18>/Signal Copy35' incorporates:
   *  Inport: '<Root>/BAT_EXV_initialize_status'
   *
   * Block description for '<Root>/BAT_EXV_initialize_status':
   *  EXV calibration status.
   */
  BAT_EXV_CurrentInitState_B =
    Rte_IRead_Task_100ms_BAT_EXV_initialize_status_BAT_EXV_initialize_status();

  /* SignalConversion: '<S18>/Signal Copy36' incorporates:
   *  Inport: '<Root>/BAT_EXV_RunState_B'
   *
   * Block description for '<Root>/BAT_EXV_RunState_B':
   *  Run State
   */
  BAT_EXV_RunState_B =
    Rte_IRead_Task_100ms_BAT_EXV_RunState_B_BAT_EXV_RunState_B();

  /* SignalConversion: '<S18>/Signal Copy40' incorporates:
   *  Inport: '<Root>/BAT_EXV_SupplierLabel'
   *
   * Block description for '<Root>/BAT_EXV_SupplierLabel':
   *  SupplierLabel
   */
  BAT_EXV_SupplierLabel =
    Rte_IRead_Task_100ms_BAT_EXV_SupplierLabel_BAT_EXV_SupplierLabel();

  /* SignalConversion: '<S18>/Signal Copy42' incorporates:
   *  Inport: '<Root>/Bat_EXV_ProjectCode1'
   *
   * Block description for '<Root>/Bat_EXV_ProjectCode1':
   *  1
   */
  Bat_EXV_ProjectCode1 =
    Rte_IRead_Task_100ms_Bat_EXV_ProjectCode1_Bat_EXV_ProjectCode1();

  /* SignalConversion: '<S18>/Signal Copy43' incorporates:
   *  Inport: '<Root>/Bat_EXV_ProjectCode2'
   *
   * Block description for '<Root>/Bat_EXV_ProjectCode2':
   *  1
   */
  Bat_EXV_ProjectCode2 =
    Rte_IRead_Task_100ms_Bat_EXV_ProjectCode2_Bat_EXV_ProjectCode2();

  /* SignalConversion: '<S18>/Signal Copy44' incorporates:
   *  Inport: '<Root>/Bat_EXV_SupplierNumber'
   *
   * Block description for '<Root>/Bat_EXV_SupplierNumber':
   *  
   */
  Bat_EXV_SupplierNumber =
    Rte_IRead_Task_100ms_Bat_EXV_SupplierNumber_Bat_EXV_SupplierNumber();

  /* SignalConversion: '<S18>/Signal Copy45' incorporates:
   *  Inport: '<Root>/Bat_EXV_PartNumber'
   *
   * Block description for '<Root>/Bat_EXV_PartNumber':
   *  
   */
  Bat_EXV_PartNumber =
    Rte_IRead_Task_100ms_Bat_EXV_PartNumber_Bat_EXV_PartNumber();

  /* SignalConversion: '<S18>/Signal Copy46' incorporates:
   *  Inport: '<Root>/Bat_EXV_HWVersion'
   *
   * Block description for '<Root>/Bat_EXV_HWVersion':
   *  
   */
  Bat_EXV_HWVersion = Rte_IRead_Task_100ms_Bat_EXV_HWVersion_Bat_EXV_HWVersion();

  /* SignalConversion: '<S18>/Signal Copy47' incorporates:
   *  Inport: '<Root>/Bat_EXV_SWVersion_Main'
   *
   * Block description for '<Root>/Bat_EXV_SWVersion_Main':
   *  -
   */
  Bat_EXV_SWVersion_Main =
    Rte_IRead_Task_100ms_Bat_EXV_SWVersion_Main_Bat_EXV_SWVersion_Main();

  /* SignalConversion: '<S18>/Signal Copy48' incorporates:
   *  Inport: '<Root>/Bat_EXV_SWVersion_Sub'
   *
   * Block description for '<Root>/Bat_EXV_SWVersion_Sub':
   *  -
   */
  Bat_EXV_SWVersion_Sub =
    Rte_IRead_Task_100ms_Bat_EXV_SWVersion_Sub_Bat_EXV_SWVersion_Sub();

  /* SignalConversion: '<S18>/Signal Copy49' incorporates:
   *  Inport: '<Root>/Bat_EXV_SWVersion_Patch'
   *
   * Block description for '<Root>/Bat_EXV_SWVersion_Patch':
   *  -
   */
  Bat_EXV_SWVersion_Patch =
    Rte_IRead_Task_100ms_Bat_EXV_SWVersion_Patch_Bat_EXV_SWVersion_Patch();

  /* DataStoreWrite: '<S22>/Data Store Write' incorporates:
   *  ArithShift: '<S22>/Shift Arithmetic'
   *  DataTypeConversion: '<S22>/Data Type Conversion'
   *  DataTypeConversion: '<S22>/Data Type Conversion1'
   */
  Buffer_DcmDspData_F27CH[0] = (uint8)rtb_Divide_ox;
  Buffer_DcmDspData_F27CH[1] = (uint8)((uint32)rtb_Divide_ox >> 8);

  /* SignalConversion: '<S22>/Signal Copy18' incorporates:
   *  Inport: '<Root>/HP_EXV_initialize_status'
   *
   * Block description for '<Root>/HP_EXV_initialize_status':
   *  EXV calibration status.
   */
  HP_EXV_initialize_status =
    Rte_IRead_Task_100ms_HP_EXV_initialize_status_HP_EXV_initialize_status();

  /* SignalConversion: '<S22>/Signal Copy19' incorporates:
   *  Inport: '<Root>/HP_EXV_SupplierLabel'
   *
   * Block description for '<Root>/HP_EXV_SupplierLabel':
   *  SupplierLabel
   */
  HP_EXV_SupplierLabel =
    Rte_IRead_Task_100ms_HP_EXV_SupplierLabel_HP_EXV_SupplierLabel();

  /* SignalConversion: '<S22>/Signal Copy22' incorporates:
   *  Inport: '<Root>/HP_EXV_RunState_B'
   *
   * Block description for '<Root>/HP_EXV_RunState_B':
   *  Run State
   */
  HP_EXV_RunState_B = Rte_IRead_Task_100ms_HP_EXV_RunState_B_HP_EXV_RunState_B();

  /* SignalConversion: '<S22>/Signal Copy26' incorporates:
   *  Inport: '<Root>/HP_EXV_ProjectCode1'
   *
   * Block description for '<Root>/HP_EXV_ProjectCode1':
   *  1
   */
  HP_EXV_ProjectCode1 =
    Rte_IRead_Task_100ms_HP_EXV_ProjectCode1_HP_EXV_ProjectCode1();

  /* SignalConversion: '<S22>/Signal Copy27' incorporates:
   *  Inport: '<Root>/HP_EXV_ProjectCode2'
   *
   * Block description for '<Root>/HP_EXV_ProjectCode2':
   *  1
   */
  HP_EXV_ProjectCode2 =
    Rte_IRead_Task_100ms_HP_EXV_ProjectCode2_HP_EXV_ProjectCode2();

  /* SignalConversion: '<S22>/Signal Copy28' incorporates:
   *  Inport: '<Root>/HP_EXV_SupplierNumber'
   *
   * Block description for '<Root>/HP_EXV_SupplierNumber':
   *  
   */
  HP_EXV_SupplierNumber =
    Rte_IRead_Task_100ms_HP_EXV_SupplierNumber_HP_EXV_SupplierNumber();

  /* SignalConversion: '<S22>/Signal Copy29' incorporates:
   *  Inport: '<Root>/HP_EXV_PartNumber'
   *
   * Block description for '<Root>/HP_EXV_PartNumber':
   *  
   */
  HP_EXV_PartNumber = Rte_IRead_Task_100ms_HP_EXV_PartNumber_HP_EXV_PartNumber();

  /* SignalConversion: '<S22>/Signal Copy30' incorporates:
   *  Inport: '<Root>/HP_EXV_HWVersion'
   *
   * Block description for '<Root>/HP_EXV_HWVersion':
   *  
   */
  HP_EXV_HWVersion = Rte_IRead_Task_100ms_HP_EXV_HWVersion_HP_EXV_HWVersion();

  /* SignalConversion: '<S22>/Signal Copy31' incorporates:
   *  Inport: '<Root>/HP_EXV_SWVersion_Main'
   *
   * Block description for '<Root>/HP_EXV_SWVersion_Main':
   *  -
   */
  HP_EXV_SWVersion_Main =
    Rte_IRead_Task_100ms_HP_EXV_SWVersion_Main_HP_EXV_SWVersion_Main();

  /* SignalConversion: '<S22>/Signal Copy32' incorporates:
   *  Inport: '<Root>/HP_EXV_SWVersion_Sub'
   *
   * Block description for '<Root>/HP_EXV_SWVersion_Sub':
   *  -
   */
  HP_EXV_SWVersion_Sub =
    Rte_IRead_Task_100ms_HP_EXV_SWVersion_Sub_HP_EXV_SWVersion_Sub();

  /* SignalConversion: '<S22>/Signal Copy33' incorporates:
   *  Inport: '<Root>/HP_EXV_SWVersion_Patch'
   *
   * Block description for '<Root>/HP_EXV_SWVersion_Patch':
   *  -
   */
  HP_EXV_SWVersion_Patch =
    Rte_IRead_Task_100ms_HP_EXV_SWVersion_Patch_HP_EXV_SWVersion_Patch();

  /* Outputs for Enabled SubSystem: '<S1292>/Start_Manage' incorporates:
   *  EnablePort: '<S1299>/Enable'
   */
  /* RelationalOperator: '<S1292>/Relational Operator1' incorporates:
   *  Constant: '<S1292>/Constant1'
   */
  if (CoAC_stwork == 1) {
    /* DataStoreRead: '<S1299>/Data Store Read' */
    EE_tEnv = ME11_ARID_DEF.EERead_AmbienceTemp;

    /* DataStoreRead: '<S1299>/Data Store Read1' */
    EE_PCUInletTemp = ME11_ARID_DEF.EERead_PCUInletTemp;

    /* DataTypeConversion: '<S1299>/Data Type Conversion' */
    PCU_StartClntTemp = ME11_ARID_DEF.Delay_DSTATE_kx;

    /* Lookup_n-D: '<S1299>/cal_ColdStartPCUTempMinByEnv_CUR' incorporates:
     *  DataStoreRead: '<S1299>/Data Store Read'
     */
    ColdStartPCUTempMinByEnv =
      cal_ColdStartPCUTempMinByEnv_CUR[plook_u32f_bincka(EE_tEnv, (const float32
      *)&cal_ColdStartPCUTempMinByEnv_1X[0], 6U)];

    /* Switch: '<S1299>/Switch4' incorporates:
     *  Constant: '<S1299>/ColdStart3'
     *  RelationalOperator: '<S1299>/Relational Operator3'
     *  Sum: '<S1299>/Subtract1'
     */
    if (EE_PCUInletTemp - PCU_StartClntTemp > 5.0F) {
      /* Switch: '<S1299>/Switch4' */
      ME11_ARID_DEF.Switch4 = EE_PCUInletTemp;
    } else {
      /* Switch: '<S1299>/Switch4' */
      ME11_ARID_DEF.Switch4 = PCU_StartClntTemp;
    }

    /* End of Switch: '<S1299>/Switch4' */

    /* Lookup_n-D: '<S1299>/cal_PCUtempOffset2ShutByEnv_CUR' incorporates:
     *  DataStoreRead: '<S1299>/Data Store Read'
     */
    PCUtempOffset2ShutByEnv = cal_PCUtempOffset2ShutByEnv_CUR[plook_u32f_bincka
      (EE_tEnv, (const float32 *)&cal_PCUtempOffset2ShutByEnv_1X[0], 6U)];

    /* Switch: '<S1299>/Switch' incorporates:
     *  Constant: '<S1299>/ColdStart4'
     *  Logic: '<S1299>/Logical Operator'
     *  RelationalOperator: '<S1299>/Relational Operator'
     *  RelationalOperator: '<S1299>/Relational Operator1'
     *  RelationalOperator: '<S1299>/Relational Operator4'
     *  Switch: '<S1299>/Switch2'
     *  Switch: '<S1299>/Switch3'
     */
    if ((EE_tEnv < 30.0F) && (PCU_StartClntTemp <= ColdStartPCUTempMinByEnv)) {
      /* Switch: '<S1299>/Switch3' incorporates:
       *  Constant: '<S1299>/ColdStart'
       *  Switch: '<S1299>/Switch'
       */
      ME11_ARID_DEF.Switch3 = true;
    } else {
      if (PCU_StartClntTemp < ME11_ARID_DEF.Switch4) {
        /* Switch: '<S1299>/Switch2' incorporates:
         *  Sum: '<S1299>/Subtract'
         */
        rtb_Add_ok = ME11_ARID_DEF.Switch4 - PCU_StartClntTemp;
      } else {
        /* Switch: '<S1299>/Switch2' incorporates:
         *  Constant: '<S1299>/ColdStart1'
         */
        rtb_Add_ok = 0.0F;
      }

      /* Switch: '<S1299>/Switch3' incorporates:
       *  RelationalOperator: '<S1299>/Relational Operator2'
       *  Switch: '<S1299>/Switch'
       *  Switch: '<S1299>/Switch2'
       */
      ME11_ARID_DEF.Switch3 = (PCUtempOffset2ShutByEnv <= rtb_Add_ok);
    }

    /* End of Switch: '<S1299>/Switch' */
  }

  /* End of RelationalOperator: '<S1292>/Relational Operator1' */
  /* End of Outputs for SubSystem: '<S1292>/Start_Manage' */

  /* Switch: '<S1292>/Switch3' incorporates:
   *  Constant: '<S1292>/ColdStart4'
   *  RelationalOperator: '<S1292>/Relational Operator4'
   */
  CoAC_stColdStart = ((AC_tiAfterRun >= 90) || ME11_ARID_DEF.Switch3);

  /* DataStoreWrite: '<S30>/Data Store Write' */
  GLB_CoAC_stColdStart = CoAC_stColdStart;

  /* DataStoreWrite: '<S30>/Data Store Write1' */
  GLB_CoAC_stwork = CoAC_stwork;

  /* MinMax: '<S1297>/Max' incorporates:
   *  Switch: '<S1297>/Switch1'
   */
  if (ME11_ARID_DEF.Delay_DSTATE_kx >= ME11_ARID_DEF.Switch4) {
    rtb_Add_ok = ME11_ARID_DEF.Delay_DSTATE_kx;
  } else {
    rtb_Add_ok = ME11_ARID_DEF.Switch4;
  }

  /* Product: '<S1301>/Divide' incorporates:
   *  Constant: '<S1301>/Constant14'
   *  DataStoreWrite: '<S1301>/Data Store Write'
   *  MinMax: '<S1297>/Max'
   *  Sum: '<S1301>/Add'
   *  Switch: '<S1297>/Switch1'
   */
  ME11_ARID_DEF.EEWrite_PCUInletTemp = (uint8)((uint8)(rtb_Add_ok + 40.0F) << 1);

  /* Chart: '<S30>/Cal_RunTime' */
  if (ME11_ARID_DEF.temporalCounter_i1_ex < 1U) {
    ME11_ARID_DEF.temporalCounter_i1_ex++;
  }

  if (ME11_ARID_DEF.is_active_c40_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c40_ME11 = 1U;
    ME11_ARID_DEF.is_c40_ME11 = ME11_IN_Counter_Init_f;
    ME11_ARID_DEF.temporalCounter_i1_ex = 0U;
    PWRCtl_uTMSRunTimer = 0U;
  } else if (ME11_ARID_DEF.is_c40_ME11 == ME11_IN_Counter_Cal_f) {
    if (PWRCtl_uTMSRunTimer >= 4294967294U) {
      ME11_ARID_DEF.is_c40_ME11 = ME11_IN_Counter_Init_f;
      ME11_ARID_DEF.temporalCounter_i1_ex = 0U;
      PWRCtl_uTMSRunTimer = 0U;
    } else {
      rtb_Divide1_f = PWRCtl_uTMSRunTimer + /*MW:OvSatOk*/ 1U;
      if (PWRCtl_uTMSRunTimer + 1U < PWRCtl_uTMSRunTimer) {
        rtb_Divide1_f = MAX_uint32_T;
      }

      PWRCtl_uTMSRunTimer = rtb_Divide1_f;
    }

    /* case IN_Counter_Init: */
  } else if (ME11_ARID_DEF.temporalCounter_i1_ex >= 1) {
    ME11_ARID_DEF.is_c40_ME11 = ME11_IN_Counter_Cal_f;
  }

  /* End of Chart: '<S30>/Cal_RunTime' */

  /* Product: '<S582>/Divide' incorporates:
   *  Constant: '<S582>/Constant2'
   *  MultiPortSwitch: '<S454>/Multiport Switch'
   *  Product: '<S587>/Divide'
   *  Sum: '<S582>/Add'
   *  UnitDelay: '<S225>/FixPt Unit Delay1'
   */
  rtb_Add_ok = (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn - ACSen_sEvapSurTemp) *
    cal_ACCMCtrlACct * (float32)ACCtl_BloweFanSpeed;

  /* Lookup_n-D: '<S582>/cal_ACCMCtrlA2FF_MAP ' incorporates:
   *  Product: '<S582>/Divide'
   *  Switch: '<S1085>/Switch'
   */
  ACTCtl_sCOMPCtrlAClsFF = look2_iflf_binlca(ACSen_sEnvTempCor, rtb_Add_ok, (
    const float32 *)&cal_ACCMCtrlA2FF_2X[0], (const float32 *)
    &cal_ACCMCtrlA2FF_2Y[0], (const float32 *)&cal_ACCMCtrlA2FF_MAP[0],
    ME11_ConstP.cal_ACCMCtrlA2FF_MAP_maxIndex, 6U);

  /* Switch: '<S591>/Switch1' incorporates:
   *  Constant: '<S591>/Constant9'
   */
  if (cal_BatHeatACCMEnb) {
    /* Switch: '<S591>/Switch2' incorporates:
     *  Constant: '<S593>/Constant'
     *  Constant: '<S594>/Constant'
     *  RelationalOperator: '<S593>/Compare'
     *  RelationalOperator: '<S594>/Compare'
     *  Switch: '<S591>/Switch3'
     */
    if (rtb_Add_b1 == 6) {
      /* Switch: '<S591>/Switch4' incorporates:
       *  RelationalOperator: '<S591>/Relational Operator'
       */
      if (ACCtl_tSetPointPTC >= SOMCtl_sBatTrgTemp) {
        /* Switch: '<S591>/Switch1' incorporates:
         *  Switch: '<S591>/Switch2'
         */
        rtb_Delay = ACCtl_tSetPointPTC;
        rtb_Delay1_ie = rtb_Merge_g;
      } else {
        /* Switch: '<S591>/Switch1' incorporates:
         *  Switch: '<S591>/Switch2'
         */
        rtb_Delay = SOMCtl_sBatTrgTemp;
        rtb_Delay1_ie = BMS_InletCooltActlTemp;
      }

      /* End of Switch: '<S591>/Switch4' */
    } else if (rtb_Add_b1 == 5) {
      /* Switch: '<S591>/Switch3' incorporates:
       *  Switch: '<S591>/Switch1'
       *  Switch: '<S591>/Switch2'
       */
      rtb_Delay = SOMCtl_sBatTrgTemp;
      rtb_Delay1_ie = BMS_InletCooltActlTemp;
    } else {
      /* Switch: '<S591>/Switch1' incorporates:
       *  Switch: '<S591>/Switch2'
       *  Switch: '<S591>/Switch3'
       */
      rtb_Delay = ACCtl_tSetPointPTC;
      rtb_Delay1_ie = rtb_Merge_g;
    }

    /* End of Switch: '<S591>/Switch2' */
  } else {
    /* Switch: '<S591>/Switch1' */
    rtb_Delay = ACCtl_tSetPointPTC;
    rtb_Delay1_ie = rtb_Merge_g;
  }

  /* End of Switch: '<S591>/Switch1' */

  /* Sum: '<S582>/Add1' */
  ACTCtl_tCtrlADiff = rtb_Delay - rtb_Delay1_ie;

  /* Outputs for Enabled SubSystem: '<S583>/Descending_filter' */
  /* RelationalOperator: '<S595>/Compare' incorporates:
   *  Constant: '<S583>/Constant3'
   *  Constant: '<S583>/Constant5'
   *  Constant: '<S595>/Constant'
   */
  ME11_Descending_filter(rtb_Add_b1 == 2, BMS_InletCooltActlTemp,
    cal_BatCoolInletTrgTemp, cal_BatCoolTrgFilter, COMP_EcompActSpd,
    &ME11_ARID_DEF.Init_la, &ME11_ARID_DEF.ARID_DEF_Descending_filter_h);

  /* End of Outputs for SubSystem: '<S583>/Descending_filter' */

  /* Sum: '<S583>/Add' */
  ACTCtl_tCtrlBDiff = BMS_InletCooltActlTemp - ME11_ARID_DEF.Init_la;

  /* Sum: '<S584>/Add1' incorporates:
   *  Sum: '<S589>/Add3'
   */
  ACTCtl_tCtrlCDiff = ACSen_sEvapSurTemp - ACCtl_tSetPointEvap;

  /* Outputs for Enabled SubSystem: '<S586>/Descending_filter' */
  /* RelationalOperator: '<S602>/Compare' incorporates:
   *  Constant: '<S586>/Constant6'
   *  Constant: '<S586>/Constant9'
   *  Constant: '<S602>/Constant'
   */
  ME11_Descending_filter(rtb_Add_b1 == 14, BMS_InletCooltActlTemp,
    cal_ACCMCtrlETrgTemp, cal_BatCoolTrgFilter, COMP_EcompActSpd,
    &ME11_ARID_DEF.Init_l, &ME11_ARID_DEF.ARID_DEF_Descending_filter_ln);

  /* End of Outputs for SubSystem: '<S586>/Descending_filter' */

  /* Sum: '<S587>/Add1' */
  rtb_ACFanLevel5EnvCor = ACCtl_tSetPointPTC - rtb_Merge_g;

  /* Sum: '<S589>/Add2' incorporates:
   *  Constant: '<S589>/Constant5'
   */
  ACTCtl_sDCoolBatTempDiff = BMS_InletCooltActlTemp - cal_BatCoolInletTrgTemp;

  /* Sum: '<S589>/Add3' */
  ACTCtl_sDCoolCabinTempDiff = ACTCtl_tCtrlCDiff;

  /* MultiPortSwitch: '<S454>/Multiport Switch' */
  switch (rtb_Add_b1) {
   case 4:
   case 5:
   case 6:
   case 13:
    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S582>/Constant'
     *  Constant: '<S582>/Constant1'
     *  Lookup_n-D: '<S582>/cal_ACCMCtrlA1FF_CUR'
     *  Switch: '<S1085>/Switch'
     */
    rtb_Merge1 = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACCMCtrlA1FF_1X[0], (const float32 *)&cal_ACCMCtrlA1FF_CUR[0], 5U);
    rtb_PI_Cor_d = cal_ACCMCtrlADlyTime;
    rtb_Merge = cal_ACCMCtrlARunTime;
    rtb_Add_ok = ACTCtl_sCOMPCtrlAClsFF;

    /* SignalConversion: '<S440>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPSetPoint = rtb_Delay;

    /* SignalConversion: '<S440>/Signal Copy1' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPActure = rtb_Delay1_ie;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S582>/Constant3'
     */
    rtb_Delay1_ie = cal_ACCMCtrlADeadzone;

    /* SignalConversion: '<S440>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S582>/cal_ACCMCtrlAKp_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S582>/Add1'
     */
    ACTCtl_sCOMPCtrlKp = look1_iflf_binlca(ACTCtl_tCtrlADiff, (const float32 *)
      &cal_ACCMCtrlAKp_1X[0], (const float32 *)&cal_ACCMCtrlAKp_CUR[0], 7U);

    /* SignalConversion: '<S440>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S582>/cal_ACCMCtrlAKi_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S582>/Add1'
     */
    ACTCtl_sCOMPCtrlKi = look1_iflf_binlca(ACTCtl_tCtrlADiff, (const float32 *)
      &cal_ACCMCtrlAKi_1X[0], (const float32 *)&cal_ACCMCtrlAKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S582>/Constant7'
     *  Constant: '<S582>/Constant8'
     */
    rtb_Delay = cal_ACCMCtrlAPIMax;
    rtb_Gain6 = cal_ACCMCtrlAPIMin;
    break;

   case 2:
    /* Lookup_n-D: '<S583>/cal_ACCMCtrlB1FF_CUR' incorporates:
     *  SignalConversion: '<S2>/Signal Copy161'
     */
    rtb_Merge1 = look1_iflf_binlca(BMS_HVBatCellTempMin, (const float32 *)
      &cal_ACCMCtrlBFF_1X[0], (const float32 *)&cal_ACCMCtrlBFF_CUR[0], 5U);

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S583>/Constant'
     *  Constant: '<S583>/Constant1'
     */
    rtb_PI_Cor_d = cal_ACCMCtrlBDlyTime;
    rtb_Merge = cal_ACCMCtrlBRunTime;
    rtb_Add_ok = rtb_Merge1;

    /* SignalConversion: '<S440>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPSetPoint = BMS_InletCooltActlTemp;

    /* SignalConversion: '<S440>/Signal Copy1' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPActure = ME11_ARID_DEF.Init_la;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S583>/Constant2'
     */
    rtb_Delay1_ie = cal_ACCMCtrlBDeadzone;

    /* SignalConversion: '<S440>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S583>/cal_ACCMCtrlBKp_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S583>/Add'
     */
    ACTCtl_sCOMPCtrlKp = look1_iflf_binlca(ACTCtl_tCtrlBDiff, (const float32 *)
      &cal_ACCMCtrlBKp_1X[0], (const float32 *)&cal_ACCMCtrlBKp_CUR[0], 7U);

    /* SignalConversion: '<S440>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S583>/cal_ACCMCtrlBKi_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S583>/Add'
     */
    ACTCtl_sCOMPCtrlKi = look1_iflf_binlca(ACTCtl_tCtrlBDiff, (const float32 *)
      &cal_ACCMCtrlBKi_1X[0], (const float32 *)&cal_ACCMCtrlBKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S583>/Constant7'
     *  Constant: '<S583>/Constant8'
     */
    rtb_Delay = cal_ACCMCtrlBPIMax;
    rtb_Gain6 = cal_ACCMCtrlBPIMin;
    break;

   case 1:
   case 12:
    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Abs: '<S584>/Abs'
     *  Constant: '<S584>/Constant'
     *  Constant: '<S584>/Constant1'
     *  Constant: '<S584>/Constant2'
     *  Lookup_n-D: '<S584>/cal_ACCMCtrlC1FF_CUR'
     *  Lookup_n-D: '<S584>/cal_ACCMCtrlC2FF_CUR'
     *  Product: '<S584>/Divide'
     *  Switch: '<S1085>/Switch'
     */
    rtb_Merge1 = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACCMCtrlC1FF_1X[0], (const float32 *)&cal_ACCMCtrlC1FF_CUR[0], 4U);
    rtb_PI_Cor_d = cal_ACCMCtrlCDlyTime;
    rtb_Merge = cal_ACCMCtrlCRunTime;
    rtb_Add_ok = look1_iflf_binlca((float32)fabs(ACTCtl_tCtrlCDiff) *
      cal_ACCMCtrlACct * (float32)ACCtl_BloweFanSpeed, (const float32 *)
      &cal_ACCMCtrlC2FF_1X[0], (const float32 *)&cal_ACCMCtrlC2FF_CUR[0], 3U);

    /* SignalConversion: '<S440>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPSetPoint = ACSen_sEvapSurTemp;

    /* SignalConversion: '<S440>/Signal Copy1' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPActure = ACCtl_tSetPointEvap;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S584>/Constant3'
     */
    rtb_Delay1_ie = cal_ACCMCtrlCDeadzone;

    /* SignalConversion: '<S440>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S584>/cal_ACCMCtrlCKp_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S584>/Add1'
     */
    ACTCtl_sCOMPCtrlKp = look1_iflf_binlca(ACTCtl_tCtrlCDiff, (const float32 *)
      &cal_ACCMCtrlCKp_1X[0], (const float32 *)&cal_ACCMCtrlCKp_CUR[0], 7U);

    /* SignalConversion: '<S440>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S584>/cal_ACCMCtrlCKi_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S584>/Add1'
     */
    ACTCtl_sCOMPCtrlKi = look1_iflf_binlca(ACTCtl_tCtrlCDiff, (const float32 *)
      &cal_ACCMCtrlCKi_1X[0], (const float32 *)&cal_ACCMCtrlCKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S584>/Constant7'
     *  Constant: '<S584>/Constant8'
     */
    rtb_Delay = cal_ACCMCtrlCPIMax;
    rtb_Gain6 = cal_ACCMCtrlCPIMin;
    break;

   case 7:
    /* Lookup_n-D: '<S585>/cal_ACCMCtrlDTrg_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    ACTCtl_sCOMPActure = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACCMCtrlDTrg_1X[0], (const float32 *)&cal_ACCMCtrlDTrg_CUR[0], 6U);

    /* Sum: '<S585>/Add1' */
    rtb_Delay = ACSen_sEvapSurTemp - ACTCtl_sCOMPActure;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S585>/Constant'
     *  Constant: '<S585>/Constant1'
     *  Constant: '<S585>/Constant2'
     *  Lookup_n-D: '<S585>/cal_ACCMCtrlD1FF_CUR'
     *  Lookup_n-D: '<S585>/cal_ACCMCtrlD2FF_CUR'
     *  Product: '<S585>/Divide'
     *  Sum: '<S585>/Add'
     *  Switch: '<S1085>/Switch'
     *  UnitDelay: '<S225>/FixPt Unit Delay1'
     */
    rtb_Merge1 = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACCMCtrlD1FF_1X[0], (const float32 *)&cal_ACCMCtrlD1FF_CUR[0], 2U);
    rtb_PI_Cor_d = cal_ACCMCtrlDDlyTime;
    rtb_Merge = cal_ACCMCtrlDRunTime;
    rtb_Add_ok = look1_iflf_binlca((ACSen_sEvapSurTemp -
      ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn) * cal_ACCMCtrlACct * (float32)
      ACCtl_BloweFanSpeed, (const float32 *)&cal_ACCMCtrlD2FF_1X[0], (const
      float32 *)&cal_ACCMCtrlD2FF_CUR[0], 3U);

    /* SignalConversion: '<S440>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPSetPoint = ACSen_sEvapSurTemp;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S585>/Constant3'
     */
    rtb_Delay1_ie = cal_ACCMCtrlDDeadzone;

    /* SignalConversion: '<S440>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S585>/cal_ACCMCtrlDKp_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S585>/Add1'
     */
    ACTCtl_sCOMPCtrlKp = look1_iflf_binlca(rtb_Delay, (const float32 *)
      &cal_ACCMCtrlDKp_1X[0], (const float32 *)&cal_ACCMCtrlDKp_CUR[0], 7U);

    /* SignalConversion: '<S440>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S585>/cal_ACCMCtrlDKi_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S585>/Add1'
     */
    ACTCtl_sCOMPCtrlKi = look1_iflf_binlca(rtb_Delay, (const float32 *)
      &cal_ACCMCtrlDKi_1X[0], (const float32 *)&cal_ACCMCtrlDKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S585>/Constant8'
     *  Lookup_n-D: '<S585>/cal_ACCMCtrlDPIMax_CUR'
     *  Switch: '<S1085>/Switch'
     */
    rtb_Delay = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACCMCtrlDPIMax_1X[0], (const float32 *)&cal_ACCMCtrlDPIMax_CUR[0], 4U);
    rtb_Gain6 = cal_ACCMCtrlDPIMin;
    break;

   case 14:
    /* Sum: '<S586>/Add1' */
    rtb_Delay = BMS_InletCooltActlTemp - ME11_ARID_DEF.Init_l;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S586>/Constant'
     *  Constant: '<S586>/Constant1'
     *  Constant: '<S586>/Constant2'
     *  Constant: '<S586>/Constant4'
     *  Lookup_n-D: '<S586>/cal_ACCMCtrlE1FF_CUR'
     *  Lookup_n-D: '<S586>/cal_ACCMCtrlE2FF_CUR'
     *  Product: '<S586>/Divide'
     *  Sum: '<S586>/Add'
     *  Switch: '<S1085>/Switch'
     */
    rtb_Merge1 = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACCMCtrlE1FF_1X[0], (const float32 *)&cal_ACCMCtrlE1FF_CUR[0], 6U);
    rtb_PI_Cor_d = cal_ACCMCtrlEDlyTime;
    rtb_Merge = cal_ACCMCtrlERunTime;
    rtb_Add_ok = look1_iflf_binlca((ACSen_sEvapSurTemp - cal_ACCMCtrlETrgTemp) *
      cal_ACCMCtrlACct * (float32)ACCtl_BloweFanSpeed, (const float32 *)
      &cal_ACCMCtrlE2FF_1X[0], (const float32 *)&cal_ACCMCtrlE2FF_CUR[0], 3U);

    /* SignalConversion: '<S440>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPSetPoint = BMS_InletCooltActlTemp;

    /* SignalConversion: '<S440>/Signal Copy1' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPActure = ME11_ARID_DEF.Init_l;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S586>/Constant3'
     */
    rtb_Delay1_ie = cal_ACCMCtrlEDeadzone;

    /* SignalConversion: '<S440>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S586>/cal_ACCMCtrlEKp_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S586>/Add1'
     */
    ACTCtl_sCOMPCtrlKp = look1_iflf_binlca(rtb_Delay, (const float32 *)
      &cal_ACCMCtrlEKp_1X[0], (const float32 *)&cal_ACCMCtrlEKp_CUR[0], 7U);

    /* SignalConversion: '<S440>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S586>/cal_ACCMCtrlEKi_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S586>/Add1'
     */
    ACTCtl_sCOMPCtrlKi = look1_iflf_binlca(rtb_Delay, (const float32 *)
      &cal_ACCMCtrlEKi_1X[0], (const float32 *)&cal_ACCMCtrlEKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S586>/Constant7'
     *  Constant: '<S586>/Constant8'
     */
    rtb_Delay = cal_ACCMCtrlEPIMax;
    rtb_Gain6 = cal_ACCMCtrlEPIMin;
    break;

   case 8:
    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S587>/Constant'
     *  Constant: '<S587>/Constant1'
     *  Lookup_n-D: '<S587>/cal_ACCMCtrlF1FF_CUR'
     *  Lookup_n-D: '<S587>/cal_ACCMCtrlF2FF_CUR'
     *  Switch: '<S1085>/Switch'
     */
    rtb_Merge1 = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACCMCtrlF1FF_1X[0], (const float32 *)&cal_ACCMCtrlF1FF_CUR[0], 4U);
    rtb_PI_Cor_d = cal_ACCMCtrlFDlyTime;
    rtb_Merge = cal_ACCMCtrlFRunTime;
    rtb_Add_ok = look1_iflf_binlca(rtb_Add_ok, (const float32 *)
      &cal_ACCMCtrlF2FF_1X[0], (const float32 *)&cal_ACCMCtrlF2FF_CUR[0], 4U);

    /* SignalConversion: '<S440>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPSetPoint = ACCtl_tSetPointPTC;

    /* SignalConversion: '<S440>/Signal Copy1' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPActure = rtb_Merge_g;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S587>/Constant3'
     */
    rtb_Delay1_ie = cal_ACCMCtrlFDeadzone;

    /* SignalConversion: '<S440>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S587>/cal_ACCMCtrlFKp_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S587>/Add1'
     */
    ACTCtl_sCOMPCtrlKp = look1_iflf_binlca(rtb_ACFanLevel5EnvCor, (const float32
      *)&cal_ACCMCtrlFKp_1X[0], (const float32 *)&cal_ACCMCtrlFKp_CUR[0], 7U);

    /* SignalConversion: '<S440>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S587>/cal_ACCMCtrlFKi_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S587>/Add1'
     */
    ACTCtl_sCOMPCtrlKi = look1_iflf_binlca(rtb_ACFanLevel5EnvCor, (const float32
      *)&cal_ACCMCtrlFKi_1X[0], (const float32 *)&cal_ACCMCtrlFKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S587>/Constant8'
     *  Lookup_n-D: '<S587>/cal_ACCMCtrlFPIMax_CUR'
     *  Switch: '<S1085>/Switch'
     */
    rtb_Delay = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACCMCtrlFPIMax_1X[0], (const float32 *)&cal_ACCMCtrlFPIMax_CUR[0], 4U);
    rtb_Gain6 = cal_ACCMCtrlFPIMin;
    break;

   case 3:
    /* Switch: '<S589>/Switch' incorporates:
     *  RelationalOperator: '<S589>/Relational Operator'
     */
    if (ACTCtl_sDCoolBatTempDiff >= ACTCtl_sDCoolCabinTempDiff) {
      /* Switch: '<S589>/Switch' incorporates:
       *  Constant: '<S589>/Constant5'
       */
      rtb_Delay = BMS_InletCooltActlTemp;
      rtb_Delay1_ie = cal_BatCoolInletTrgTemp;
    } else {
      /* Switch: '<S589>/Switch' */
      rtb_Delay = ACSen_sEvapSurTemp;
      rtb_Delay1_ie = ACCtl_tSetPointEvap;
    }

    /* End of Switch: '<S589>/Switch' */

    /* Sum: '<S589>/Add1' */
    rtb_Gain6 = rtb_Delay - rtb_Delay1_ie;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Abs: '<S589>/Abs'
     *  Constant: '<S589>/Constant'
     *  Constant: '<S589>/Constant1'
     *  Constant: '<S589>/Constant2'
     *  Lookup_n-D: '<S589>/cal_ACCMCtrlH1FF_CUR'
     *  Lookup_n-D: '<S589>/cal_ACCMCtrlH2FF_CUR'
     *  Product: '<S589>/Divide'
     *  Switch: '<S1085>/Switch'
     */
    rtb_Merge1 = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_ACCMCtrlH1FF_1X[0], (const float32 *)&cal_ACCMCtrlH1FF_CUR[0], 4U);
    rtb_PI_Cor_d = cal_ACCMCtrlHDlyTime;
    rtb_Merge = cal_ACCMCtrlHRunTime;
    rtb_Add_ok = look1_iflf_binlca((float32)fabs(rtb_Gain6) * cal_ACCMCtrlHCct *
      (float32)ACCtl_BloweFanSpeed, (const float32 *)&cal_ACCMCtrlH2FF_1X[0], (
      const float32 *)&cal_ACCMCtrlH2FF_CUR[0], 3U);

    /* SignalConversion: '<S440>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPSetPoint = rtb_Delay;

    /* SignalConversion: '<S440>/Signal Copy1' incorporates:
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPActure = rtb_Delay1_ie;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S589>/Constant3'
     */
    rtb_Delay1_ie = cal_ACCMCtrlHDeadzone;

    /* SignalConversion: '<S440>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S589>/cal_ACCMCtrlHKp_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S589>/Add1'
     */
    ACTCtl_sCOMPCtrlKp = look1_iflf_binlca(rtb_Gain6, (const float32 *)
      &cal_ACCMCtrlHKp_1X[0], (const float32 *)&cal_ACCMCtrlHKp_CUR[0], 7U);

    /* SignalConversion: '<S440>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S589>/cal_ACCMCtrlHKi_CUR'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     *  Sum: '<S589>/Add1'
     */
    ACTCtl_sCOMPCtrlKi = look1_iflf_binlca(rtb_Gain6, (const float32 *)
      &cal_ACCMCtrlHKi_1X[0], (const float32 *)&cal_ACCMCtrlHKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S589>/Constant7'
     *  Constant: '<S589>/Constant8'
     */
    rtb_Delay = cal_ACCMCtrlHPIMax;
    rtb_Gain6 = cal_ACCMCtrlHPIMin;
    break;

   default:
    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S590>/Constant'
     */
    rtb_Merge1 = 0.0F;
    rtb_PI_Cor_d = 0.0F;
    rtb_Merge = 0.0F;
    rtb_Add_ok = 0.0F;

    /* SignalConversion: '<S440>/Signal Copy' incorporates:
     *  Constant: '<S590>/Constant'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPSetPoint = 0.0F;

    /* SignalConversion: '<S440>/Signal Copy1' incorporates:
     *  Constant: '<S590>/Constant'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPActure = 0.0F;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S590>/Constant'
     */
    rtb_Delay1_ie = 0.0F;

    /* SignalConversion: '<S440>/Signal Copy2' incorporates:
     *  Constant: '<S590>/Constant'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPCtrlKp = 0.0F;

    /* SignalConversion: '<S440>/Signal Copy3' incorporates:
     *  Constant: '<S590>/Constant'
     *  MultiPortSwitch: '<S454>/Multiport Switch'
     */
    ACTCtl_sCOMPCtrlKi = 0.0F;

    /* MultiPortSwitch: '<S454>/Multiport Switch' incorporates:
     *  Constant: '<S590>/Constant'
     */
    rtb_Delay = 0.0F;
    rtb_Gain6 = 0.0F;
    break;
  }

  /* Sum: '<S453>/Sum' */
  ACTCtl_sDvtCOMPCtrl = ACTCtl_sCOMPSetPoint - ACTCtl_sCOMPActure;

  /* Chart: '<S453>/deadzone' */
  ME11_deadzone_h1(ACTCtl_sDvtCOMPCtrl, rtb_Delay1_ie, &rtb_flag_k);

  /* RelationalOperator: '<S453>/Relational Operator' */
  ACTCtl_bCOMPDvtFlg = (ACTCtl_sCOMPSetPoint >= ACTCtl_sCOMPActure);

  /* Switch: '<S453>/Switch1' incorporates:
   *  Switch: '<S453>/Switch'
   */
  if (rtb_flag_k) {
    /* Switch: '<S453>/Switch1' incorporates:
     *  Constant: '<S453>/Constant'
     */
    ACTCtl_sDvtCOMPCtrl = 0.0F;
  } else if (!ACTCtl_bCOMPDvtFlg) {
    /* Switch: '<S453>/Switch1' incorporates:
     *  Sum: '<S453>/Sum1'
     *  Switch: '<S453>/Switch'
     */
    ACTCtl_sDvtCOMPCtrl = ACTCtl_sCOMPActure - ACTCtl_sCOMPSetPoint;
  }

  /* End of Switch: '<S453>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S483>/P_NEG' */
  /* Logic: '<S483>/Logical Operator' incorporates:
   *  Constant: '<S448>/Constant3'
   *  Constant: '<S448>/Constant9'
   */
  ME11_P_NEG(!ACTCtl_bCOMPDvtFlg, ACTCtl_sDvtCOMPCtrl, cal_ACCMCtlKiDeadzoneNeg,
             ACTCtl_sCOMPCtrlKi, cal_ACCMCtrlKi, (float32 *)&ACTCtl_sACCMI_Cor);

  /* End of Outputs for SubSystem: '<S483>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S483>/P_POS' */
  /* Constant: '<S448>/Constant8' incorporates:
   *  Constant: '<S448>/Constant3'
   */
  ME11_P_POS(ACTCtl_bCOMPDvtFlg, ACTCtl_sDvtCOMPCtrl, cal_ACCMCtlKiDeadzonePos,
             ACTCtl_sCOMPCtrlKi, cal_ACCMCtrlKi, (float32 *)&ACTCtl_sACCMI_Cor);

  /* End of Outputs for SubSystem: '<S483>/P_POS' */

  /* Chart: '<S456>/FFCal' incorporates:
   *  Constant: '<S632>/Constant'
   *  Constant: '<S633>/Constant'
   *  Delay: '<S456>/Delay'
   *  Delay: '<S503>/Delay'
   *  Logic: '<S456>/AND'
   *  RelationalOperator: '<S632>/Compare'
   *  RelationalOperator: '<S633>/Compare'
   */
  if (ME11_ARID_DEF.temporalCounter_i2 < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i2++;
  }

  if (ME11_ARID_DEF.temporalCounter_i1_k < 3U) {
    ME11_ARID_DEF.temporalCounter_i1_k++;
  }

  if (ME11_ARID_DEF.is_active_c5_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c5_ME11 = 1U;
    ME11_ARID_DEF.is_c5_ME11 = ME11_IN_Off_a;
    ACTCtl_bCOMPPIEnble = false;
    ACTCtl_sACCMCtlFF = 0.0F;
  } else if (ME11_ARID_DEF.is_c5_ME11 == ME11_IN_Off_a) {
    if (ME11_ARID_DEF.Delay_DSTATE_kf) {
      ME11_ARID_DEF.is_c5_ME11 = ME11_IN_On_li;
      ME11_ARID_DEF.is_On_e = ME11_IN_DelayOpen;
      ME11_ARID_DEF.temporalCounter_i2 = 0U;
    }

    /* case IN_On: */
  } else if (!ME11_ARID_DEF.Delay_DSTATE_kf) {
    ME11_ARID_DEF.is_On_e = ME11_IN_NO_ACTIVE_CHILD_gl;
    ME11_ARID_DEF.is_c5_ME11 = ME11_IN_Off_a;
    ACTCtl_bCOMPPIEnble = false;
    ACTCtl_sACCMCtlFF = 0.0F;
  } else {
    switch (ME11_ARID_DEF.is_On_e) {
     case ME11_IN_CloseCtl:
      if ((ME11_ARID_DEF.Delay_DSTATE_af == 3) && (rtb_Add_b1 == 1)) {
        ME11_ARID_DEF.is_On_e = ME11_IN_RelayOpen;
        ME11_ARID_DEF.temporalCounter_i1_k = 0U;
        ACTCtl_bCOMPPIEnble = false;
        ACTCtl_sACCMCtlFF = rtb_Merge1;
      } else {
        ACTCtl_bCOMPPIEnble = true;
        ACTCtl_sACCMCtlFF = rtb_Add_ok;
      }
      break;

     case ME11_IN_DelayOpen:
      if (ME11_ARID_DEF.temporalCounter_i2 >= rtb_PI_Cor_d * 10.0F) {
        ME11_ARID_DEF.is_On_e = ME11_IN_OpenCtl;
        ME11_ARID_DEF.temporalCounter_i2 = 0U;
        ACTCtl_sACCMCtlFF = rtb_Merge1;
      }
      break;

     case ME11_IN_OpenCtl:
      if (ME11_ARID_DEF.temporalCounter_i2 >= rtb_Merge * 10.0F) {
        ME11_ARID_DEF.is_On_e = ME11_IN_CloseCtl;
        ACTCtl_bCOMPPIEnble = true;
        ACTCtl_sACCMCtlFF = rtb_Add_ok;
      } else {
        ACTCtl_sACCMCtlFF = rtb_Merge1;
      }
      break;

     default:
      /* case IN_RelayOpen: */
      if (ME11_ARID_DEF.temporalCounter_i1_k >= 2) {
        ME11_ARID_DEF.is_On_e = ME11_IN_OpenCtl;
        ME11_ARID_DEF.temporalCounter_i2 = 0U;
        ACTCtl_sACCMCtlFF = rtb_Merge1;
      } else {
        ACTCtl_bCOMPPIEnble = false;
        ACTCtl_sACCMCtlFF = rtb_Merge1;
      }
      break;
    }
  }

  /* End of Chart: '<S456>/FFCal' */

  /* Switch: '<S480>/Switch1' */
  if (ACTCtl_bCOMPPIEnble) {
    /* MultiPortSwitch: '<S483>/Multiport Switch' incorporates:
     *  Delay: '<S483>/Delay'
     */
    switch (ME11_ARID_DEF.Delay_DSTATE_cv) {
     case 0:
      /* Switch: '<S487>/Switch' */
      if (ACTCtl_bCOMPDvtFlg) {
        /* Switch: '<S484>/Switch2' incorporates:
         *  Delay: '<S480>/Delay'
         *  Sum: '<S487>/Add'
         *  Switch: '<S487>/Switch'
         */
        ACTCtl_sACCMI_Sum = ACTCtl_sACCMI_Sum + ACTCtl_sACCMI_Cor;
      } else {
        /* Switch: '<S484>/Switch2' incorporates:
         *  Delay: '<S480>/Delay'
         *  Sum: '<S487>/Add1'
         *  Switch: '<S487>/Switch'
         */
        ACTCtl_sACCMI_Sum = ACTCtl_sACCMI_Sum - ACTCtl_sACCMI_Cor;
      }

      /* End of Switch: '<S487>/Switch' */
      break;

     case 1:
      /* Switch: '<S488>/Switch' */
      if (!ACTCtl_bCOMPDvtFlg) {
        /* Switch: '<S484>/Switch2' incorporates:
         *  Delay: '<S480>/Delay'
         *  Sum: '<S488>/Add1'
         *  Switch: '<S488>/Switch'
         */
        ACTCtl_sACCMI_Sum = ACTCtl_sACCMI_Sum - ACTCtl_sACCMI_Cor;
      }

      /* End of Switch: '<S488>/Switch' */
      break;

     case 2:
      /* Switch: '<S485>/Switch' */
      if (ACTCtl_bCOMPDvtFlg) {
        /* Switch: '<S484>/Switch2' incorporates:
         *  Delay: '<S480>/Delay'
         *  Sum: '<S485>/Add'
         *  Switch: '<S485>/Switch'
         */
        ACTCtl_sACCMI_Sum = ACTCtl_sACCMI_Sum + ACTCtl_sACCMI_Cor;
      }

      /* End of Switch: '<S485>/Switch' */
      break;

     case 3:
      break;
    }

    /* End of MultiPortSwitch: '<S483>/Multiport Switch' */

    /* Switch: '<S484>/Switch2' incorporates:
     *  Constant: '<S448>/Constant12'
     *  Constant: '<S448>/Constant13'
     *  RelationalOperator: '<S484>/LowerRelop1'
     *  RelationalOperator: '<S484>/UpperRelop'
     *  Sum: '<S480>/Add'
     *  Switch: '<S484>/Switch'
     */
    if (ACTCtl_sACCMI_Sum > cal_ACCMCtlPID_IsumMax) {
      /* Switch: '<S480>/Switch1' incorporates:
       *  Switch: '<S484>/Switch2'
       */
      ACTCtl_sACCMI_Sum = cal_ACCMCtlPID_IsumMax;
    } else if (ACTCtl_sACCMI_Sum < cal_ACCMCtlPID_IsumMin) {
      /* Switch: '<S484>/Switch' incorporates:
       *  Constant: '<S448>/Constant12'
       *  Switch: '<S480>/Switch1'
       *  Switch: '<S484>/Switch2'
       */
      ACTCtl_sACCMI_Sum = cal_ACCMCtlPID_IsumMin;
    }

    /* End of Switch: '<S484>/Switch2' */
  } else {
    /* Switch: '<S480>/Switch1' incorporates:
     *  Constant: '<S448>/Constant4'
     */
    ACTCtl_sACCMI_Sum = 0.0F;
  }

  /* End of Switch: '<S480>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S481>/PI_Controller1' */
  /* Logic: '<S481>/Logical Operator' */
  ME11_PI_Controller1(!ACTCtl_bCOMPPIEnble, ACTCtl_sACCMCtlFF, (float32 *)
                      &ACTCtl_sACCMPIVal, (uint8 *)&ACTCtl_bCOMPIFreeFlag);

  /* End of Outputs for SubSystem: '<S481>/PI_Controller1' */

  /* Outputs for Enabled SubSystem: '<S482>/P_NEG' */
  /* Logic: '<S482>/Logical Operator' incorporates:
   *  Constant: '<S448>/Constant10'
   *  Constant: '<S448>/Constant2'
   */
  ME11_P_NEG_h(!ACTCtl_bCOMPDvtFlg, ACTCtl_sDvtCOMPCtrl,
               cal_ACCMCtlKpDeadzoneNeg, ACTCtl_sCOMPCtrlKp, cal_ACCMCtrlKp,
               (float32 *)&ACTCtl_sACCMP_Cor);

  /* End of Outputs for SubSystem: '<S482>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S482>/P_POS' */
  /* Constant: '<S448>/Constant11' incorporates:
   *  Constant: '<S448>/Constant2'
   */
  ME11_P_POS_c(ACTCtl_bCOMPDvtFlg, ACTCtl_sDvtCOMPCtrl, cal_ACCMCtlKpDeadzonePos,
               ACTCtl_sCOMPCtrlKp, cal_ACCMCtrlKp, (float32 *)&ACTCtl_sACCMP_Cor);

  /* End of Outputs for SubSystem: '<S482>/P_POS' */

  /* Outputs for Enabled SubSystem: '<S481>/PI_Controller' */
  ME11_PI_Controller(ACTCtl_bCOMPPIEnble, ACTCtl_bCOMPDvtFlg, ACTCtl_sACCMCtlFF,
                     ACTCtl_sACCMP_Cor, ACTCtl_sACCMI_Sum, rtb_Delay, rtb_Gain6,
                     (float32 *)&ACTCtl_sACCMPIVal, (uint8 *)
                     &ACTCtl_bCOMPIFreeFlag);

  /* End of Outputs for SubSystem: '<S481>/PI_Controller' */

  /* Logic: '<S497>/OR2' */
  ACTCtl_bCOMPFaultClc = ((ME11_ARID_DEF.ClearFlt_n != 0.0) ||
    (ME11_ARID_DEF.ClearFlt_m != 0.0) || (ME11_ARID_DEF.ClearFlt_k != 0.0) ||
    (ME11_ARID_DEF.ClearFlt_c != 0.0) || (ME11_ARID_DEF.ClearFlt_f != 0.0) ||
    (ME11_ARID_DEF.ClearFlt != 0.0));

  /* BusCreator: '<S8>/Bus Creator6' incorporates:
   *  DataTypeConversion: '<S497>/Data Type Conversion'
   */
  rtb_BusCreator6.COMP_EcompErrorClean = ACTCtl_bCOMPFaultClc;

  /* RelationalOperator: '<S547>/Compare' incorporates:
   *  Constant: '<S547>/Constant'
   *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
   */
  rtb_FixPtRelationalOperator_mk =
    ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA()
     )->VIPM_ESCVehSpd_kph > cal_COMPCoolLowSpd);

  /* Lookup_n-D: '<S545>/cal_COMPATNoiseSpdLmtHVS_CUR' incorporates:
   *  Switch: '<S1085>/Switch'
   */
  ACTCtl_sCOMPATNoiseLmtHVSSpd = look1_iflf_binlca(ACSen_sEnvTempCor, (const
    float32 *)&cal_COMPATNoiseSpdLmtHVS_1X[0], (const float32 *)
    &cal_COMPATNoiseSpdLmtHVS_CUR[0], 7U);

  /* Lookup_n-D: '<S545>/cal_COMPATNoiseSpdLmt_MAP' incorporates:
   *  DataTypeConversion: '<S545>/Data Type Conversion'
   *  Merge generated from: '<S481>/Merge'
   */
  ACTCtl_sCOMPATNoiseBlwAndAccmSpd = look2_ifbfu8lf_binlca(ACTCtl_sACCMPIVal,
    ACCtl_BloweFanSpeed, (const float32 *)&cal_COMPATNoiseSpdLmt_2X[0], (const
    uint8 *)&cal_COMPATNoiseSpdLmt_2Y[0], (const float32 *)
    &cal_COMPATNoiseSpdLmt_MAP[0], ME11_ConstP.pooled36, 10U);

  /* Switch: '<S545>/Switch4' incorporates:
   *  Constant: '<S548>/Constant'
   *  Constant: '<S549>/Constant'
   *  Logic: '<S545>/OR'
   *  Logic: '<S545>/OR1'
   *  Logic: '<S545>/OR2'
   *  RelationalOperator: '<S548>/Compare'
   *  RelationalOperator: '<S549>/Compare'
   */
  if ((rtb_Add_b1 == 3) && ((ME11_ARID_DEF.DataTypeConversion1 == 3) ||
       (ME11_ARID_DEF.DataTypeConversion1 == 4) ||
       rtb_FixPtRelationalOperator_mk)) {
    /* Switch: '<S545>/Switch4' */
    ACTCtl_sCOMPCoolLmtSpd = ACTCtl_sCOMPATNoiseLmtHVSSpd;
  } else {
    /* RelationalOperator: '<S550>/Compare' incorporates:
     *  Constant: '<S550>/Constant'
     *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
     */
    rtb_Delay1_ag =
      ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA())
       ->VIPM_ESCVehSpd_kph > cal_COMPCoolLowSpd);

    /* Switch: '<S545>/Switch5' incorporates:
     *  Constant: '<S551>/Constant'
     *  Logic: '<S545>/OR3'
     *  RelationalOperator: '<S551>/Compare'
     */
    if (rtb_Delay1_ag && (rtb_Add_b1 == 1)) {
      /* Switch: '<S545>/Switch4' incorporates:
       *  Constant: '<S545>/Constant3'
       *  Switch: '<S545>/Switch5'
       */
      ACTCtl_sCOMPCoolLmtSpd = 6000.0F;
    } else {
      /* RelationalOperator: '<S554>/Compare' incorporates:
       *  Constant: '<S554>/Constant'
       *  Inport: '<Root>/IPM_ESC_7_FuncStatus_CHA'
       */
      rtb_Delay1_ag =
        ((Rte_IRead_Task_100ms_IPM_ESC_7_FuncStatus_CHA_IPM_ESC_7_FuncStatus_CHA
          ())->VIPM_ESCVehSpd_kph < cal_COMPCoolLowSpd);

      /* Switch: '<S545>/Switch6' incorporates:
       *  Constant: '<S552>/Constant'
       *  Constant: '<S553>/Constant'
       *  Constant: '<S555>/Constant'
       *  Logic: '<S545>/OR4'
       *  Logic: '<S545>/OR5'
       *  Logic: '<S545>/OR6'
       *  RelationalOperator: '<S552>/Compare'
       *  RelationalOperator: '<S553>/Compare'
       *  RelationalOperator: '<S555>/Compare'
       */
      if (((rtb_Add_b1 == 3) && (ME11_ARID_DEF.DataTypeConversion1 == 5)) ||
          (rtb_Delay1_ag && (rtb_Add_b1 == 1))) {
        /* Switch: '<S545>/Switch4' incorporates:
         *  Switch: '<S545>/Switch5'
         */
        ACTCtl_sCOMPCoolLmtSpd = ACTCtl_sCOMPATNoiseBlwAndAccmSpd;
      } else {
        /* Switch: '<S545>/Switch4' incorporates:
         *  Constant: '<S545>/Constant4'
         *  Switch: '<S545>/Switch5'
         */
        ACTCtl_sCOMPCoolLmtSpd = 8000.0F;
      }

      /* End of Switch: '<S545>/Switch6' */
    }

    /* End of Switch: '<S545>/Switch5' */
  }

  /* End of Switch: '<S545>/Switch4' */

  /* Lookup_n-D: '<S545>/cal_AccmSpdLimByHiPressLevelCalcu_CUR' incorporates:
   *  Switch: '<S1864>/Switch'
   */
  rtb_IFreezFlag_bd = look1_iflftu8Df_binlca(ACSen_sHiPressFilter, (const
    float32 *)&cal_AccmSpdLimByHiPressLevelCalcu_1X[0], (const uint8 *)
    &cal_AccmSpdLimByHiPressLevelCalcu_CUR[0], 11U);

  /* Switch: '<S545>/Switch' incorporates:
   *  RelationalOperator: '<S556>/FixPt Relational Operator'
   *  RelationalOperator: '<S558>/FixPt Relational Operator'
   *  Switch: '<S545>/Switch1'
   *  UnitDelay: '<S556>/Delay Input1'
   *  UnitDelay: '<S558>/Delay Input1'
   *
   * Block description for '<S556>/Delay Input1':
   *
   *  Store in Global RAM
   *
   * Block description for '<S558>/Delay Input1':
   *
   *  Store in Global RAM
   */
  if (ACSen_sHiPressFilter < ME11_ARID_DEF.DelayInput1_DSTATE_e) {
    /* Switch: '<S545>/Switch' incorporates:
     *  Lookup_n-D: '<S545>/cal_AccmSpdLimByHiPressDownSide_CUR'
     *  Lookup_n-D: '<S545>/cal_AccmSpdLimByHiPressLevelCalcu_CUR'
     */
    ACTCtl_sCOMPHPLmtSpd =
      cal_AccmSpdLimByHiPressDownSide_CUR[plook_u32u8_binckan(rtb_IFreezFlag_bd,
      (const uint8 *)&cal_AccmSpdLimByHiPressDownSide_1X[0], 11U)];
  } else if (ACSen_sHiPressFilter > ME11_ARID_DEF.DelayInput1_DSTATE_i) {
    /* Switch: '<S545>/Switch' incorporates:
     *  Lookup_n-D: '<S545>/cal_AccmSpdLimByHiPressLevelCalcu_CUR'
     *  Lookup_n-D: '<S545>/cal_AccmSpdLimByHiPressUpSide_CUR'
     *  Switch: '<S545>/Switch1'
     */
    ACTCtl_sCOMPHPLmtSpd = cal_AccmSpdLimByHiPressUpSide_CUR[plook_u32u8_binckan
      (rtb_IFreezFlag_bd, (const uint8 *)&cal_AccmSpdLimByHiPressUpSide_1X[0],
       11U)];
  }

  /* End of Switch: '<S545>/Switch' */

  /* Lookup_n-D: '<S545>/cal_AccmSpdLimByLoPressLevelCalcu_CUR' incorporates:
   *  Switch: '<S1788>/Switch'
   */
  rtb_IFreezFlag_bd = look1_iflftu8Df_binlca(ACSen_sLoPressFilter, (const
    float32 *)&cal_AccmSpdLimByLoPressLevelCalcu_1X[0], (const uint8 *)
    &cal_AccmSpdLimByLoPressLevelCalcu_CUR[0], 11U);

  /* Switch: '<S545>/Switch2' incorporates:
   *  RelationalOperator: '<S557>/FixPt Relational Operator'
   *  RelationalOperator: '<S559>/FixPt Relational Operator'
   *  Switch: '<S545>/Switch3'
   *  UnitDelay: '<S557>/Delay Input1'
   *  UnitDelay: '<S559>/Delay Input1'
   *
   * Block description for '<S557>/Delay Input1':
   *
   *  Store in Global RAM
   *
   * Block description for '<S559>/Delay Input1':
   *
   *  Store in Global RAM
   */
  if (ACSen_sLoPressFilter < ME11_ARID_DEF.DelayInput1_DSTATE_o) {
    /* Switch: '<S545>/Switch2' incorporates:
     *  Lookup_n-D: '<S545>/cal_AccmSpdLimByLoPressDownSide_CUR'
     *  Lookup_n-D: '<S545>/cal_AccmSpdLimByLoPressLevelCalcu_CUR'
     */
    ACTCtl_sCOMPLPLmtSpd =
      cal_AccmSpdLimByLoPressDownSide_CUR[plook_u32u8_binckan(rtb_IFreezFlag_bd,
      (const uint8 *)&cal_AccmSpdLimByLoPressDownSide_1X[0], 11U)];
  } else if (ACSen_sLoPressFilter > ME11_ARID_DEF.DelayInput1_DSTATE_g) {
    /* Switch: '<S545>/Switch2' incorporates:
     *  Lookup_n-D: '<S545>/cal_AccmSpdLimByLoPressLevelCalcu_CUR'
     *  Lookup_n-D: '<S545>/cal_AccmSpdLimByLoPressUpSide_CUR'
     *  Switch: '<S545>/Switch3'
     */
    ACTCtl_sCOMPLPLmtSpd = cal_AccmSpdLimByLoPressUpSide_CUR[plook_u32u8_binckan
      (rtb_IFreezFlag_bd, (const uint8 *)&cal_AccmSpdLimByLoPressUpSide_1X[0],
       11U)];
  }

  /* End of Switch: '<S545>/Switch2' */

  /* MultiPortSwitch: '<S545>/Multiport Switch' */
  switch (rtb_Add_b1) {
   case 1:
    /* MultiPortSwitch: '<S545>/Multiport Switch' incorporates:
     *  Lookup_n-D: '<S545>/cal_PCULimCabinAccmSpdDes_CUR'
     *  Switch: '<S1098>/Switch'
     */
    ACTCtl_sCOMPPCULimSpd = look1_iflf_binlca(ACSen_sMotTempFilter, (const
      float32 *)&cal_PCULimCabinAccmSpdDes_1X[0], (const float32 *)
      &cal_PCULimCabinAccmSpdDes_CUR[0], 7U);
    break;

   case 2:
    /* MultiPortSwitch: '<S545>/Multiport Switch' incorporates:
     *  Lookup_n-D: '<S545>/cal_PCULimBTMAccmSpdDes_CUR'
     *  Switch: '<S1098>/Switch'
     */
    ACTCtl_sCOMPPCULimSpd = look1_iflf_binlca(ACSen_sMotTempFilter, (const
      float32 *)&cal_PCULimBTMAccmSpdDes_1X[0], (const float32 *)
      &cal_PCULimBTMAccmSpdDes_CUR[0], 7U);
    break;

   case 3:
    /* MultiPortSwitch: '<S545>/Multiport Switch' incorporates:
     *  Lookup_n-D: '<S545>/cal_PCULimBTMAndCabinAccmSpdDes_CUR'
     *  Switch: '<S1098>/Switch'
     */
    ACTCtl_sCOMPPCULimSpd = look1_iflf_binlca(ACSen_sMotTempFilter, (const
      float32 *)&cal_PCULimBTMAndCabinAccmSpdDes_1X[0], (const float32 *)
      &cal_PCULimBTMAndCabinAccmSpdDes_CUR[0], 7U);
    break;

   default:
    /* MultiPortSwitch: '<S545>/Multiport Switch' incorporates:
     *  Constant: '<S545>/Constant2'
     */
    ACTCtl_sCOMPPCULimSpd = 8000.0F;
    break;
  }

  /* End of MultiPortSwitch: '<S545>/Multiport Switch' */

  /* MinMax: '<S545>/Min' */
  if (ACTCtl_sCOMPCoolLmtSpd <= ACTCtl_sCOMPHPLmtSpd) {
    ACTCtl_sCOMPATNoiseLmtSpd = ACTCtl_sCOMPCoolLmtSpd;
  } else {
    ACTCtl_sCOMPATNoiseLmtSpd = ACTCtl_sCOMPHPLmtSpd;
  }

  if (ACTCtl_sCOMPATNoiseLmtSpd > ACTCtl_sCOMPLPLmtSpd) {
    ACTCtl_sCOMPATNoiseLmtSpd = ACTCtl_sCOMPLPLmtSpd;
  }

  if (ACTCtl_sCOMPATNoiseLmtSpd > ACTCtl_sCOMPPCULimSpd) {
    /* MinMax: '<S545>/Min' */
    ACTCtl_sCOMPATNoiseLmtSpd = ACTCtl_sCOMPPCULimSpd;
  }

  /* End of MinMax: '<S545>/Min' */

  /* Switch: '<S546>/Switch' incorporates:
   *  Switch: '<S546>/Switch1'
   *  Switch: '<S546>/Switch2'
   *  Switch: '<S546>/Switch3'
   */
  if (ACSen_sEnvTempCor > 40.0F) {
    /* Switch: '<S546>/Switch' incorporates:
     *  Constant: '<S546>/Constant'
     */
    ACTCtl_sCOMPEnvLmtSpd = 8000.0F;
  } else if (ACSen_sEnvTempCor > 35.0F) {
    /* Switch: '<S546>/Switch' incorporates:
     *  Lookup_n-D: '<S546>/cal_COMPEnvSpdLmt3_CUR'
     *  Switch: '<S1085>/Switch'
     *  Switch: '<S546>/Switch1'
     */
    ACTCtl_sCOMPEnvLmtSpd = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_COMPEnvSpdLmt3_1X[0], (const float32 *)&cal_COMPEnvSpdLmt3_CUR[0], 1U);
  } else if (ACSen_sEnvTempCor > 30.0F) {
    /* Switch: '<S546>/Switch' incorporates:
     *  Lookup_n-D: '<S546>/cal_COMPEnvSpdLmt2_CUR'
     *  Switch: '<S1085>/Switch'
     *  Switch: '<S546>/Switch1'
     *  Switch: '<S546>/Switch2'
     */
    ACTCtl_sCOMPEnvLmtSpd = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_COMPEnvSpdLmt2_1X[0], (const float32 *)&cal_COMPEnvSpdLmt2_CUR[0], 1U);
  } else if (ACSen_sEnvTempCor > 20.0F) {
    /* Switch: '<S546>/Switch' incorporates:
     *  Lookup_n-D: '<S546>/cal_COMPEnvSpdLmt1_CUR'
     *  Switch: '<S1085>/Switch'
     *  Switch: '<S546>/Switch1'
     *  Switch: '<S546>/Switch2'
     *  Switch: '<S546>/Switch3'
     */
    ACTCtl_sCOMPEnvLmtSpd = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_COMPEnvSpdLmt1_1X[0], (const float32 *)&cal_COMPEnvSpdLmt1_CUR[0], 1U);
  } else {
    /* Switch: '<S546>/Switch' incorporates:
     *  Constant: '<S546>/Constant1'
     *  Switch: '<S546>/Switch1'
     *  Switch: '<S546>/Switch2'
     *  Switch: '<S546>/Switch3'
     */
    ACTCtl_sCOMPEnvLmtSpd = 4000.0F;
  }

  /* End of Switch: '<S546>/Switch' */

  /* Lookup_n-D: '<S546>/cal_COMPFanLevelLmt_CUR' incorporates:
   *  Merge generated from: '<S42>/Merge'
   */
  ACTCtl_sCOMPFanlevelLmtSpd = look1_iu8lftf_binlca(AC_FanLeVel, (const uint8 *)
    &cal_COMPFanLevelLmt_1X[0], (const float32 *)&cal_COMPFanLevelLmt_CUR[0], 8U);

  /* Chart: '<S546>/Judge' */
  if (ME11_ARID_DEF.is_active_c149_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c149_ME11 = 1U;
    ME11_enter_internal_Choice(&rtb_Add_b1);
  } else {
    switch (ME11_ARID_DEF.is_Choice) {
     case ME11_IN_ChgBatCool:
      ME11_ARID_DEF.is_Choice = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Choice(&rtb_Add_b1);
      break;

     case ME11_IN_ChgDCool:
      ME11_ARID_DEF.is_Choice = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Choice(&rtb_Add_b1);
      break;

     case ME11_IN_NmlBatCool:
      ME11_ARID_DEF.is_Choice = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Choice(&rtb_Add_b1);
      break;

     case ME11_IN_NmlBatCool1:
      ME11_ARID_DEF.is_Choice = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Choice(&rtb_Add_b1);
      break;

     case ME11_IN_NmlBatCool2:
      ME11_ARID_DEF.is_Choice = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Choice(&rtb_Add_b1);
      break;

     case ME11_IN_NmlDCoolHVS:
      ME11_ARID_DEF.is_Choice = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Choice(&rtb_Add_b1);
      break;

     default:
      /* case IN_NmlDCoolLVS: */
      ME11_ARID_DEF.is_Choice = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_enter_internal_Choice(&rtb_Add_b1);
      break;
    }
  }

  /* End of Chart: '<S546>/Judge' */

  /* MinMax: '<S450>/Min' */
  if (ME11_ARID_DEF.ACTCtl_sCOMPLmtSpd <= ACTCtl_sCOMPATNoiseLmtSpd) {
    /* MinMax: '<S450>/Min' */
    ACTCtl_sCOMPLmtMaxSpd = ME11_ARID_DEF.ACTCtl_sCOMPLmtSpd;
  } else {
    /* MinMax: '<S450>/Min' */
    ACTCtl_sCOMPLmtMaxSpd = ACTCtl_sCOMPATNoiseLmtSpd;
  }

  /* End of MinMax: '<S450>/Min' */

  /* MinMax: '<S440>/Min' */
  if (ACTCtl_sACCMPIVal <= ACTCtl_sCOMPLmtMaxSpd) {
    /* MinMax: '<S440>/Min' */
    rtb_PI_Cor_d = ACTCtl_sACCMPIVal;
  } else {
    /* MinMax: '<S440>/Min' */
    rtb_PI_Cor_d = ACTCtl_sCOMPLmtMaxSpd;
  }

  /* End of MinMax: '<S440>/Min' */

  /* Switch: '<S571>/Switch1' incorporates:
   *  Constant: '<S571>/Constant'
   *  Constant: '<S571>/Constant6'
   *  Delay: '<S451>/Delay'
   *  RelationalOperator: '<S571>/Relational Operator'
   *  RelationalOperator: '<S571>/Relational Operator1'
   *  Sum: '<S571>/Add2'
   *  Sum: '<S571>/Add3'
   *  Switch: '<S571>/Switch3'
   */
  if (cal_COMPSpdDiffUp <= rtb_PI_Cor_d - ME11_ARID_DEF.Delay_DSTATE_h) {
    /* Switch: '<S571>/Switch1' incorporates:
     *  Constant: '<S571>/Constant5'
     *  Sum: '<S571>/Add1'
     */
    rtb_PI_Cor_d = cal_COMPSpdDiffUpRate + ME11_ARID_DEF.Delay_DSTATE_h;
  } else if (ME11_ARID_DEF.Delay_DSTATE_h - rtb_PI_Cor_d >= cal_COMPSpdDiffDown)
  {
    /* Switch: '<S571>/Switch3' incorporates:
     *  Constant: '<S571>/Constant7'
     *  Sum: '<S571>/Add4'
     *  Switch: '<S571>/Switch1'
     */
    rtb_PI_Cor_d = ME11_ARID_DEF.Delay_DSTATE_h - cal_COMPSpdDiffDownRate;
  }

  /* End of Switch: '<S571>/Switch1' */

  /* Chart: '<S572>/PwrOn' */
  ME11_PwrOn(&rtb_flg_m, &ME11_ARID_DEF.ARID_DEF_PwrOn_da);

  /* Switch: '<S572>/Switch2' incorporates:
   *  Constant: '<S567>/Constant1'
   *  Constant: '<S567>/Constant2'
   *  Delay: '<S572>/Delay'
   *  RelationalOperator: '<S572>/Relational Operator'
   *  RelationalOperator: '<S572>/Relational Operator1'
   *  Sum: '<S572>/Add2'
   *  Sum: '<S572>/Add3'
   *  Switch: '<S572>/Switch'
   *  Switch: '<S572>/Switch1'
   */
  if (rtb_flg_m) {
    ME11_ARID_DEF.Delay_DSTATE_b = rtb_PI_Cor_d;
  } else if (rtb_PI_Cor_d > ME11_ARID_DEF.Delay_DSTATE_b + cal_ACCMCtlUplmt) {
    /* Switch: '<S572>/Switch' incorporates:
     *  Constant: '<S567>/Constant1'
     *  Delay: '<S572>/Delay'
     *  Sum: '<S572>/Add'
     */
    ME11_ARID_DEF.Delay_DSTATE_b += cal_ACCMCtlUplmt;
  } else if (rtb_PI_Cor_d < ME11_ARID_DEF.Delay_DSTATE_b - cal_ACCMCtlDownlmt) {
    /* Switch: '<S572>/Switch1' incorporates:
     *  Constant: '<S567>/Constant2'
     *  Delay: '<S572>/Delay'
     *  Sum: '<S572>/Add1'
     *  Switch: '<S572>/Switch'
     */
    ME11_ARID_DEF.Delay_DSTATE_b -= cal_ACCMCtlDownlmt;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_b = rtb_PI_Cor_d;
  }

  /* End of Switch: '<S572>/Switch2' */

  /* Chart: '<S573>/PwrOn' */
  ME11_PwrOn(&rtb_flg_n, &ME11_ARID_DEF.ARID_DEF_PwrOn_b);

  /* Switch: '<S573>/Switch2' incorporates:
   *  Constant: '<S567>/Constant3'
   *  Constant: '<S567>/Constant4'
   *  Delay: '<S573>/Delay'
   *  RelationalOperator: '<S573>/Relational Operator'
   *  RelationalOperator: '<S573>/Relational Operator1'
   *  Sum: '<S573>/Add2'
   *  Sum: '<S573>/Add3'
   *  Switch: '<S573>/Switch'
   *  Switch: '<S573>/Switch1'
   */
  if (rtb_flg_n) {
    ME11_ARID_DEF.Delay_DSTATE_p0 = rtb_PI_Cor_d;
  } else if (rtb_PI_Cor_d > ME11_ARID_DEF.Delay_DSTATE_p0 +
             cal_OpenCtrlCOMPUplmt) {
    /* Switch: '<S573>/Switch' incorporates:
     *  Constant: '<S567>/Constant3'
     *  Delay: '<S573>/Delay'
     *  Sum: '<S573>/Add'
     */
    ME11_ARID_DEF.Delay_DSTATE_p0 += cal_OpenCtrlCOMPUplmt;
  } else if (rtb_PI_Cor_d < ME11_ARID_DEF.Delay_DSTATE_p0 -
             cal_OpenCtrlCOMPDownlmt) {
    /* Switch: '<S573>/Switch1' incorporates:
     *  Constant: '<S567>/Constant4'
     *  Delay: '<S573>/Delay'
     *  Sum: '<S573>/Add1'
     *  Switch: '<S573>/Switch'
     */
    ME11_ARID_DEF.Delay_DSTATE_p0 -= cal_OpenCtrlCOMPDownlmt;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_p0 = rtb_PI_Cor_d;
  }

  /* End of Switch: '<S573>/Switch2' */

  /* Switch: '<S567>/Switch2' */
  if (ACTCtl_bCOMPPIEnble) {
    /* Switch: '<S567>/Switch2' incorporates:
     *  Delay: '<S572>/Delay'
     */
    rtb_Delay = ME11_ARID_DEF.Delay_DSTATE_b;
  } else {
    /* Switch: '<S567>/Switch2' incorporates:
     *  Delay: '<S573>/Delay'
     */
    rtb_Delay = ME11_ARID_DEF.Delay_DSTATE_p0;
  }

  /* End of Switch: '<S567>/Switch2' */

  /* Logic: '<S451>/AND' incorporates:
   *  Constant: '<S562>/Constant'
   *  Constant: '<S563>/Constant'
   *  RelationalOperator: '<S562>/Compare'
   *  RelationalOperator: '<S563>/Compare'
   */
  rtb_Delay1_ag = ((rtb_Delay >= cal_COMPClsLowSpeed) && (COMP_EcompActSpd ==
    0.0F));

  /* Relay: '<S455>/Relay2' */
  ME11_ARID_DEF.Relay2_Mode_d = ((ACSen_sHiPressFilter >= cal_NmlCOMPHPrsP6) ||
    ((ACSen_sHiPressFilter > cal_NmlCOMPHPrsP5) && ME11_ARID_DEF.Relay2_Mode_d));

  /* Relay: '<S455>/Relay' */
  ME11_ARID_DEF.Relay_Mode_dd = ((ACSen_sHiPressFilter >= cal_NmlCOMPHPrsP4) ||
    ((ACSen_sHiPressFilter > cal_NmlCOMPHPrsP3) && ME11_ARID_DEF.Relay_Mode_dd));

  /* Relay: '<S455>/Relay1' */
  ME11_ARID_DEF.Relay1_Mode_hl = ((ACSen_sHiPressFilter >= cal_NmlCOMPHPrsP2) ||
    ((ACSen_sHiPressFilter > cal_NmlCOMPHPrsP1) && ME11_ARID_DEF.Relay1_Mode_hl));

  /* Relay: '<S455>/Relay3' */
  ME11_ARID_DEF.Relay3_Mode = ((ACSen_sHiPressFilter >= cal_NmlCOMPHPrsP8) ||
    ((ACSen_sHiPressFilter > cal_NmlCOMPHPrsP7) && ME11_ARID_DEF.Relay3_Mode));

  /* Logic: '<S455>/OR' incorporates:
   *  Constant: '<S618>/Constant'
   *  RelationalOperator: '<S618>/Compare'
   */
  rtb_FixPtRelationalOperator_mk = ((rtb_Add_b1 == 1) || (rtb_Add_b1 == 2) ||
    (rtb_Add_b1 == 3));

  /* Relay: '<S455>/Relay14' */
  ME11_ARID_DEF.Relay14_Mode = ((ACSen_sHiPressFilter >= cal_HeatPumpCOMPHPrsP6)
    || ((ACSen_sHiPressFilter > cal_HeatPumpCOMPHPrsP5) &&
        ME11_ARID_DEF.Relay14_Mode));

  /* Relay: '<S455>/Relay12' */
  ME11_ARID_DEF.Relay12_Mode = ((ACSen_sHiPressFilter >= cal_HeatPumpCOMPHPrsP4)
    || ((ACSen_sHiPressFilter > cal_HeatPumpCOMPHPrsP3) &&
        ME11_ARID_DEF.Relay12_Mode));

  /* Relay: '<S455>/Relay13' */
  ME11_ARID_DEF.Relay13_Mode = ((ACSen_sHiPressFilter >= cal_HeatPumpCOMPHPrsP2)
    || ((ACSen_sHiPressFilter > cal_HeatPumpCOMPHPrsP1) &&
        ME11_ARID_DEF.Relay13_Mode));

  /* Relay: '<S455>/Relay15' */
  ME11_ARID_DEF.Relay15_Mode = ((ACSen_sHiPressFilter >= cal_HeatPumpCOMPHPrsP8)
    || ((ACSen_sHiPressFilter > cal_HeatPumpCOMPHPrsP7) &&
        ME11_ARID_DEF.Relay15_Mode));

  /* Switch: '<S455>/Switch' incorporates:
   *  Switch: '<S455>/Switch1'
   */
  if (rtb_FixPtRelationalOperator_mk) {
    /* SignalConversion: '<S455>/Signal Copy2' incorporates:
     *  Logic: '<S455>/OR5'
     *  Relay: '<S455>/Relay'
     *  Relay: '<S455>/Relay2'
     *  Switch: '<S455>/Switch4'
     */
    ACTCtl_bCOMPHPLmtFlg = (ME11_ARID_DEF.Relay2_Mode_d ||
      (!ME11_ARID_DEF.Relay_Mode_dd));

    /* SignalConversion: '<S455>/Signal Copy3' incorporates:
     *  Logic: '<S455>/OR6'
     *  Relay: '<S455>/Relay1'
     *  Relay: '<S455>/Relay3'
     *  Switch: '<S455>/Switch4'
     */
    ACTCtl_bCOMPHPFrbFlg = ((!ME11_ARID_DEF.Relay1_Mode_hl) ||
      ME11_ARID_DEF.Relay3_Mode);

    /* Switch: '<S455>/Switch1' incorporates:
     *  Constant: '<S455>/Constant'
     */
    rtb_PI_Cor_d = cal_NmlCOMPHPrsDownSpd;
  } else {
    /* SignalConversion: '<S455>/Signal Copy2' incorporates:
     *  Logic: '<S455>/OR7'
     *  Relay: '<S455>/Relay12'
     *  Relay: '<S455>/Relay14'
     *  Switch: '<S455>/Switch4'
     */
    ACTCtl_bCOMPHPLmtFlg = (ME11_ARID_DEF.Relay14_Mode ||
      (!ME11_ARID_DEF.Relay12_Mode));

    /* SignalConversion: '<S455>/Signal Copy3' incorporates:
     *  Logic: '<S455>/OR8'
     *  Relay: '<S455>/Relay13'
     *  Relay: '<S455>/Relay15'
     *  Switch: '<S455>/Switch4'
     */
    ACTCtl_bCOMPHPFrbFlg = ((!ME11_ARID_DEF.Relay13_Mode) ||
      ME11_ARID_DEF.Relay15_Mode);

    /* Switch: '<S455>/Switch1' incorporates:
     *  Constant: '<S455>/Constant1'
     */
    rtb_PI_Cor_d = cal_HeatPumpCOMPHPrsDownSpd;
  }

  /* End of Switch: '<S455>/Switch' */

  /* Chart: '<S455>/HPrsPro' */
  if (ME11_ARID_DEF.is_active_c85_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c85_ME11 = 1U;
    ME11_ARID_DEF.is_c85_ME11 = ME11_IN_Default_k;
    rtb_IFreezFlag_bd = 0U;
  } else {
    switch (ME11_ARID_DEF.is_c85_ME11) {
     case ME11_IN_Default_k:
      rtb_IFreezFlag_bd = 0U;
      if (ACTCtl_bCOMPHPLmtFlg) {
        ME11_ARID_DEF.is_c85_ME11 = ME11_IN_Lmt;
        rtb_IFreezFlag_bd = 1U;
        ME11_ARID_DEF.ACTCtl_sCOMPDownSpd_g = rtb_PI_Cor_d;
      }
      break;

     case ME11_IN_Forbit:
      rtb_IFreezFlag_bd = 2U;
      if (!ACTCtl_bCOMPHPFrbFlg) {
        ME11_ARID_DEF.is_c85_ME11 = ME11_IN_Lmt;
        rtb_IFreezFlag_bd = 1U;
        ME11_ARID_DEF.ACTCtl_sCOMPDownSpd_g = rtb_PI_Cor_d;
      }
      break;

     default:
      /* case IN_Lmt: */
      rtb_IFreezFlag_bd = 1U;
      if (!ACTCtl_bCOMPHPLmtFlg) {
        ME11_ARID_DEF.is_c85_ME11 = ME11_IN_Default_k;
        rtb_IFreezFlag_bd = 0U;
      } else if (ACTCtl_bCOMPHPFrbFlg) {
        ME11_ARID_DEF.is_c85_ME11 = ME11_IN_Forbit;
        rtb_IFreezFlag_bd = 2U;
      }
      break;
    }
  }

  /* End of Chart: '<S455>/HPrsPro' */

  /* RelationalOperator: '<S621>/Compare' incorporates:
   *  Constant: '<S621>/Constant'
   */
  rtb_Compare_fx = (COMP_EcompActSpd > 800.0F);

  /* Chart: '<S455>/ActSpdDelay' incorporates:
   *  Constant: '<S455>/Constant4'
   *  Constant: '<S455>/Constant5'
   *  Product: '<S455>/Divide'
   */
  if (ME11_ARID_DEF.is_active_c4_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c4_ME11 = 1U;
    ME11_ARID_DEF.is_c4_ME11 = ME11_IN_Init_i;
    ME11_ARID_DEF.ACTCtl_bLowPrsProFlg = true;
    ME11_ARID_DEF.Counter = 0.0F;
  } else {
    switch (ME11_ARID_DEF.is_c4_ME11) {
     case ME11_IN_Init_i:
      ME11_ARID_DEF.ACTCtl_bLowPrsProFlg = true;
      if (rtb_Compare_fx) {
        ME11_ARID_DEF.is_c4_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.Counter++;
      }
      break;

     case ME11_IN_protect:
      ME11_ARID_DEF.ACTCtl_bLowPrsProFlg = false;
      if (!rtb_Compare_fx) {
        ME11_ARID_DEF.is_c4_ME11 = ME11_IN_Init_i;
        ME11_ARID_DEF.ACTCtl_bLowPrsProFlg = true;
        ME11_ARID_DEF.Counter = 0.0F;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.Counter > (float32)(cal_StartPrsProTimes * 600.0)) {
        ME11_ARID_DEF.is_c4_ME11 = ME11_IN_protect;
        ME11_ARID_DEF.ACTCtl_bLowPrsProFlg = false;
        ME11_ARID_DEF.Counter = 0.0F;
      } else if (!rtb_Compare_fx) {
        ME11_ARID_DEF.is_c4_ME11 = ME11_IN_Init_i;
        ME11_ARID_DEF.ACTCtl_bLowPrsProFlg = true;
        ME11_ARID_DEF.Counter = 0.0F;
      } else {
        ME11_ARID_DEF.Counter++;
      }
      break;
    }
  }

  /* End of Chart: '<S455>/ActSpdDelay' */

  /* Relay: '<S455>/Relay10' */
  ME11_ARID_DEF.Relay10_Mode = ((ACSen_sLoPressFilter >= cal_NmlCOMPLPrsP6) ||
    ((ACSen_sLoPressFilter > cal_NmlCOMPLPrsP5) && ME11_ARID_DEF.Relay10_Mode));

  /* Relay: '<S455>/Relay8' */
  ME11_ARID_DEF.Relay8_Mode = ((ACSen_sLoPressFilter >= cal_NmlCOMPLPrsP4) ||
    ((ACSen_sLoPressFilter > cal_NmlCOMPLPrsP3) && ME11_ARID_DEF.Relay8_Mode));

  /* Relay: '<S455>/Relay9' */
  ME11_ARID_DEF.Relay9_Mode = ((ACSen_sLoPressFilter >= cal_NmlCOMPLPrsP2) ||
    ((ACSen_sLoPressFilter > cal_NmlCOMPLPrsP1) && ME11_ARID_DEF.Relay9_Mode));

  /* Relay: '<S455>/Relay11' */
  ME11_ARID_DEF.Relay11_Mode = ((ACSen_sLoPressFilter >= cal_NmlCOMPLPrsP8) ||
    ((ACSen_sLoPressFilter > cal_NmlCOMPLPrsP7) && ME11_ARID_DEF.Relay11_Mode));

  /* Relay: '<S455>/Relay6' */
  ME11_ARID_DEF.Relay6_Mode = ((ACSen_sLoPressFilter >= cal_HeatPumpCOMPLPrsP6) ||
    ((ACSen_sLoPressFilter > cal_HeatPumpCOMPLPrsP5) &&
     ME11_ARID_DEF.Relay6_Mode));

  /* Relay: '<S455>/Relay4' */
  ME11_ARID_DEF.Relay4_Mode = ((ACSen_sLoPressFilter >= cal_HeatPumpCOMPLPrsP4) ||
    ((ACSen_sLoPressFilter > cal_HeatPumpCOMPLPrsP3) &&
     ME11_ARID_DEF.Relay4_Mode));

  /* Relay: '<S455>/Relay5' */
  ME11_ARID_DEF.Relay5_Mode = ((ACSen_sLoPressFilter >= cal_HeatPumpCOMPLPrsP2) ||
    ((ACSen_sLoPressFilter > cal_HeatPumpCOMPLPrsP1) &&
     ME11_ARID_DEF.Relay5_Mode));

  /* Relay: '<S455>/Relay7' */
  ME11_ARID_DEF.Relay7_Mode = ((ACSen_sLoPressFilter >= cal_HeatPumpCOMPLPrsP8) ||
    ((ACSen_sLoPressFilter > cal_HeatPumpCOMPLPrsP7) &&
     ME11_ARID_DEF.Relay7_Mode));

  /* Switch: '<S455>/Switch4' incorporates:
   *  Switch: '<S455>/Switch2'
   */
  if (ME11_ARID_DEF.ACTCtl_bLowPrsProFlg) {
    /* SignalConversion: '<S455>/Signal Copy' incorporates:
     *  Constant: '<S455>/Constant6'
     *  Switch: '<S455>/Switch4'
     */
    ACTCtl_bCOMPLPLmtFlg = false;

    /* SignalConversion: '<S455>/Signal Copy1' incorporates:
     *  Constant: '<S455>/Constant6'
     *  Switch: '<S455>/Switch4'
     */
    ACTCtl_bCOMPLPFrbFlg = false;
  } else if (rtb_FixPtRelationalOperator_mk) {
    /* SignalConversion: '<S455>/Signal Copy' incorporates:
     *  Logic: '<S455>/OR3'
     *  Relay: '<S455>/Relay10'
     *  Relay: '<S455>/Relay8'
     *  Switch: '<S455>/Switch2'
     *  Switch: '<S455>/Switch4'
     */
    ACTCtl_bCOMPLPLmtFlg = (ME11_ARID_DEF.Relay10_Mode ||
      (!ME11_ARID_DEF.Relay8_Mode));

    /* SignalConversion: '<S455>/Signal Copy1' incorporates:
     *  Logic: '<S455>/OR4'
     *  Relay: '<S455>/Relay11'
     *  Relay: '<S455>/Relay9'
     *  Switch: '<S455>/Switch2'
     *  Switch: '<S455>/Switch4'
     */
    ACTCtl_bCOMPLPFrbFlg = ((!ME11_ARID_DEF.Relay9_Mode) ||
      ME11_ARID_DEF.Relay11_Mode);
  } else {
    /* SignalConversion: '<S455>/Signal Copy' incorporates:
     *  Logic: '<S455>/OR1'
     *  Relay: '<S455>/Relay4'
     *  Relay: '<S455>/Relay6'
     *  Switch: '<S455>/Switch2'
     *  Switch: '<S455>/Switch4'
     */
    ACTCtl_bCOMPLPLmtFlg = (ME11_ARID_DEF.Relay6_Mode ||
      (!ME11_ARID_DEF.Relay4_Mode));

    /* SignalConversion: '<S455>/Signal Copy1' incorporates:
     *  Logic: '<S455>/OR2'
     *  Relay: '<S455>/Relay5'
     *  Relay: '<S455>/Relay7'
     *  Switch: '<S455>/Switch2'
     *  Switch: '<S455>/Switch4'
     */
    ACTCtl_bCOMPLPFrbFlg = ((!ME11_ARID_DEF.Relay5_Mode) ||
      ME11_ARID_DEF.Relay7_Mode);
  }

  /* End of Switch: '<S455>/Switch4' */

  /* Switch: '<S455>/Switch3' */
  if (rtb_FixPtRelationalOperator_mk) {
    /* Switch: '<S455>/Switch3' incorporates:
     *  Constant: '<S455>/Constant2'
     */
    rtb_PI_Cor_d = cal_NmlCOMPLPrsDownSpd;
  } else {
    /* Switch: '<S455>/Switch3' incorporates:
     *  Constant: '<S455>/Constant3'
     */
    rtb_PI_Cor_d = cal_HeatPumpCOMPLPrsDownSpd;
  }

  /* End of Switch: '<S455>/Switch3' */

  /* Chart: '<S455>/LPrsPro' */
  if (ME11_ARID_DEF.is_active_c86_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c86_ME11 = 1U;
    ME11_ARID_DEF.is_c86_ME11 = ME11_IN_Default_k;
    rtb_IFreezFlag_jz = 0U;
  } else {
    switch (ME11_ARID_DEF.is_c86_ME11) {
     case ME11_IN_Default_k:
      rtb_IFreezFlag_jz = 0U;
      if (ACTCtl_bCOMPLPLmtFlg) {
        ME11_ARID_DEF.is_c86_ME11 = ME11_IN_Lmt;
        rtb_IFreezFlag_jz = 1U;
        ME11_ARID_DEF.ACTCtl_sCOMPDownSpd_m = rtb_PI_Cor_d;
      }
      break;

     case ME11_IN_Forbit:
      rtb_IFreezFlag_jz = 2U;
      if (!ACTCtl_bCOMPLPFrbFlg) {
        ME11_ARID_DEF.is_c86_ME11 = ME11_IN_Lmt;
        rtb_IFreezFlag_jz = 1U;
        ME11_ARID_DEF.ACTCtl_sCOMPDownSpd_m = rtb_PI_Cor_d;
      }
      break;

     default:
      /* case IN_Lmt: */
      rtb_IFreezFlag_jz = 1U;
      if (!ACTCtl_bCOMPLPLmtFlg) {
        ME11_ARID_DEF.is_c86_ME11 = ME11_IN_Default_k;
        rtb_IFreezFlag_jz = 0U;
      } else if (ACTCtl_bCOMPLPFrbFlg) {
        ME11_ARID_DEF.is_c86_ME11 = ME11_IN_Forbit;
        rtb_IFreezFlag_jz = 2U;
      }
      break;
    }
  }

  /* End of Chart: '<S455>/LPrsPro' */

  /* Sum: '<S455>/Add' incorporates:
   *  Constant: '<S619>/Constant'
   *  Constant: '<S620>/Constant'
   *  Constant: '<S622>/Constant'
   *  Constant: '<S623>/Constant'
   *  Constant: '<S624>/Constant'
   *  Constant: '<S625>/Constant'
   *  Constant: '<S626>/Constant'
   *  Constant: '<S627>/Constant'
   *  Constant: '<S628>/Constant'
   *  Constant: '<S629>/Constant'
   *  Gain: '<S455>/Gain'
   *  Gain: '<S455>/Gain1'
   *  Gain: '<S455>/Gain2'
   *  Gain: '<S455>/Gain3'
   *  Logic: '<S455>/AND'
   *  Logic: '<S455>/AND1'
   *  Logic: '<S455>/AND2'
   *  Logic: '<S455>/AND3'
   *  Logic: '<S455>/AND4'
   *  RelationalOperator: '<S619>/Compare'
   *  RelationalOperator: '<S620>/Compare'
   *  RelationalOperator: '<S622>/Compare'
   *  RelationalOperator: '<S623>/Compare'
   *  RelationalOperator: '<S624>/Compare'
   *  RelationalOperator: '<S625>/Compare'
   *  RelationalOperator: '<S626>/Compare'
   *  RelationalOperator: '<S627>/Compare'
   *  RelationalOperator: '<S628>/Compare'
   *  RelationalOperator: '<S629>/Compare'
   */
  ACTCtl_eCOMPPrsPrtSts = (uint8)(((((uint32)(((rtb_IFreezFlag_bd == 2) ||
    (rtb_IFreezFlag_jz == 2)) << 4) + (uint32)(((rtb_IFreezFlag_bd == 1) &&
    (rtb_IFreezFlag_jz == 1)) << 3)) + (uint32)(((rtb_IFreezFlag_jz == 1) &&
    (rtb_IFreezFlag_bd == 0)) << 2)) + (uint32)(((rtb_IFreezFlag_jz == 0) &&
    (rtb_IFreezFlag_bd == 1)) << 1)) + (uint32)((rtb_IFreezFlag_jz == 0) &&
    (rtb_IFreezFlag_bd == 0)));

  /* Switch: '<S570>/Switch1' incorporates:
   *  Constant: '<S578>/Constant'
   *  Constant: '<S579>/Constant'
   *  Constant: '<S580>/Constant'
   *  RelationalOperator: '<S578>/Compare'
   *  RelationalOperator: '<S579>/Compare'
   *  RelationalOperator: '<S580>/Compare'
   *  Switch: '<S570>/Switch2'
   *  Switch: '<S570>/Switch3'
   */
  if (ACTCtl_eCOMPPrsPrtSts == 8) {
    /* MinMax: '<S570>/Max' */
    if (ME11_ARID_DEF.ACTCtl_sCOMPDownSpd_g >=
        ME11_ARID_DEF.ACTCtl_sCOMPDownSpd_m) {
      /* Gain: '<S8>/Gain8' */
      rtb_Delay1_ie = ME11_ARID_DEF.ACTCtl_sCOMPDownSpd_g;
    } else {
      /* Gain: '<S8>/Gain8' */
      rtb_Delay1_ie = ME11_ARID_DEF.ACTCtl_sCOMPDownSpd_m;
    }

    /* End of MinMax: '<S570>/Max' */
  } else if (ACTCtl_eCOMPPrsPrtSts == 4) {
    /* Switch: '<S570>/Switch2' incorporates:
     *  Gain: '<S8>/Gain8'
     */
    rtb_Delay1_ie = ME11_ARID_DEF.ACTCtl_sCOMPDownSpd_m;
  } else if (ACTCtl_eCOMPPrsPrtSts == 4) {
    /* Switch: '<S570>/Switch3' incorporates:
     *  Gain: '<S8>/Gain8'
     *  Switch: '<S570>/Switch2'
     */
    rtb_Delay1_ie = ME11_ARID_DEF.ACTCtl_sCOMPDownSpd_g;
  } else {
    /* Gain: '<S8>/Gain8' incorporates:
     *  Constant: '<S570>/Constant3'
     *  Switch: '<S570>/Switch2'
     *  Switch: '<S570>/Switch3'
     */
    rtb_Delay1_ie = 0.0F;
  }

  /* End of Switch: '<S570>/Switch1' */

  /* Relay: '<S457>/Relay' */
  ME11_ARID_DEF.Relay_Mode_p = ((ACSen_sACCMHiTempFilter >= cal_COMPExhTLmtVal) ||
    ((ACSen_sACCMHiTempFilter > cal_COMPExhTNmlVal) &&
     ME11_ARID_DEF.Relay_Mode_p));

  /* Relay: '<S457>/Relay1' */
  ME11_ARID_DEF.Relay1_Mode_e = ((ACSen_sACCMHiTempFilter >= cal_COMPExhTFrbVal)
    || ((ACSen_sACCMHiTempFilter > cal_COMPExhTLmtRlybVal) &&
        ME11_ARID_DEF.Relay1_Mode_e));

  /* Chart: '<S457>/Chart' incorporates:
   *  Relay: '<S457>/Relay'
   *  Relay: '<S457>/Relay1'
   */
  if (ME11_ARID_DEF.is_active_c87_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c87_ME11 = 1U;
    ME11_ARID_DEF.is_c87_ME11 = ME11_IN_Default_k;
    ACTCtl_eCOMPExhTPrtSts = 0U;
  } else {
    switch (ME11_ARID_DEF.is_c87_ME11) {
     case ME11_IN_Default_k:
      ACTCtl_eCOMPExhTPrtSts = 0U;
      if (ME11_ARID_DEF.Relay_Mode_p) {
        ME11_ARID_DEF.is_c87_ME11 = ME11_IN_limit;
        ACTCtl_eCOMPExhTPrtSts = 1U;
      }
      break;

     case ME11_IN_forbit:
      ACTCtl_eCOMPExhTPrtSts = 2U;
      if (!ME11_ARID_DEF.Relay1_Mode_e) {
        ME11_ARID_DEF.is_c87_ME11 = ME11_IN_limit;
        ACTCtl_eCOMPExhTPrtSts = 1U;
      }
      break;

     default:
      /* case IN_limit: */
      ACTCtl_eCOMPExhTPrtSts = 1U;
      if (ME11_ARID_DEF.Relay1_Mode_e) {
        ME11_ARID_DEF.is_c87_ME11 = ME11_IN_forbit;
        ACTCtl_eCOMPExhTPrtSts = 2U;
      } else if (!ME11_ARID_DEF.Relay_Mode_p) {
        ME11_ARID_DEF.is_c87_ME11 = ME11_IN_Default_k;
        ACTCtl_eCOMPExhTPrtSts = 0U;
      }
      break;
    }
  }

  /* End of Chart: '<S457>/Chart' */

  /* Switch: '<S570>/Switch4' incorporates:
   *  Constant: '<S570>/Constant1'
   *  Constant: '<S570>/Constant2'
   *  Constant: '<S577>/Constant'
   *  RelationalOperator: '<S577>/Compare'
   */
  if (ACTCtl_eCOMPExhTPrtSts == 1) {
    ACTCtl_sCOMPDownSpd = cal_COMPExhTDownSpd;
  } else {
    ACTCtl_sCOMPDownSpd = 0.0F;
  }

  /* MinMax: '<S570>/Max1' incorporates:
   *  Switch: '<S570>/Switch4'
   */
  if (rtb_Delay1_ie >= ACTCtl_sCOMPDownSpd) {
    /* MinMax: '<S570>/Max1' */
    ACTCtl_sCOMPDownSpd = rtb_Delay1_ie;
  }

  /* End of MinMax: '<S570>/Max1' */

  /* Chart: '<S451>/Chart' */
  if (ME11_ARID_DEF.temporalCounter_i1_il < 255U) {
    ME11_ARID_DEF.temporalCounter_i1_il++;
  }

  if (ME11_ARID_DEF.is_active_c29_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c29_ME11 = 1U;
    ME11_ARID_DEF.is_c29_ME11 = ME11_IN_Off_a;
    ACTCtl_bCOMPSpdDiffFlt = false;
  } else {
    switch (ME11_ARID_DEF.is_c29_ME11) {
     case ME11_IN_Off_a:
      ACTCtl_bCOMPSpdDiffFlt = false;
      if (rtb_Delay1_ag) {
        ME11_ARID_DEF.is_c29_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_il = 0U;
      }
      break;

     case ME11_IN_On_li:
      ACTCtl_bCOMPSpdDiffFlt = true;
      if (!rtb_Delay1_ag) {
        ME11_ARID_DEF.is_c29_ME11 = ME11_IN_wait1_o;
        ME11_ARID_DEF.temporalCounter_i1_il = 0U;
      }
      break;

     case ME11_IN_wait_k:
      if (ME11_ARID_DEF.temporalCounter_i1_il >= 50U) {
        ME11_ARID_DEF.is_c29_ME11 = ME11_IN_On_li;
        ACTCtl_bCOMPSpdDiffFlt = true;
      } else if (!rtb_Delay1_ag) {
        ME11_ARID_DEF.is_c29_ME11 = ME11_IN_Off_a;
        ACTCtl_bCOMPSpdDiffFlt = false;
      }
      break;

     default:
      /* case IN_wait1: */
      if (ME11_ARID_DEF.temporalCounter_i1_il >= 200U) {
        ME11_ARID_DEF.is_c29_ME11 = ME11_IN_Off_a;
        ACTCtl_bCOMPSpdDiffFlt = false;
      }
      break;
    }
  }

  /* End of Chart: '<S451>/Chart' */

  /* Delay: '<S683>/Delay' */
  rtb_PI_Cor_d = ME11_ARID_DEF.Delay_DSTATE_k3;

  /* Chart: '<S683>/EvapTemperature' incorporates:
   *  Delay: '<S683>/Delay'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_h < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i1_h++;
  }

  if (ME11_ARID_DEF.is_active_c52_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c52_ME11 = 1U;
    ME11_ARID_DEF.is_c52_ME11 = ME11_IN_Default_o;
    ACTCtl_eEvapProSts = 0U;
  } else {
    switch (ME11_ARID_DEF.is_c52_ME11) {
     case ME11_IN_CalClsSpd:
      ACTCtl_eEvapProSts = 1U;
      if (ACSen_sEvapSurTemp > cal_AEXVOpenEvapNOPrtTemp) {
        ME11_ARID_DEF.is_c52_ME11 = ME11_IN_wait_oc;
        ME11_ARID_DEF.temporalCounter_i1_h = 0U;
        ACTCtl_eEvapProSts = 5U;
        ME11_ARID_DEF.ACTCtl_sAEXVVal = ME11_ARID_DEF.Delay_DSTATE_k3;
      } else if (ME11_ARID_DEF.Delay_DSTATE_k3 <= cal_AEXVClsValEvapPrt) {
        ME11_ARID_DEF.is_c52_ME11 = ME11_IN_Wait_b;
        ME11_ARID_DEF.temporalCounter_i1_h = 0U;
        ACTCtl_eEvapProSts = 2U;
      }
      break;

     case ME11_IN_CloseVavle:
      ACTCtl_eEvapProSts = 3U;
      if (ACSen_sEvapSurTemp > cal_AEXVOpenEvapNOPrtTemp) {
        ME11_ARID_DEF.is_c52_ME11 = ME11_IN_Wait1;
        ME11_ARID_DEF.temporalCounter_i1_h = 0U;
        ACTCtl_eEvapProSts = 4U;
      }
      break;

     case ME11_IN_Default_o:
      ACTCtl_eEvapProSts = 0U;
      if (ACSen_sEvapSurTemp < cal_AEXVClsEvapPrtTemp) {
        ME11_ARID_DEF.is_c52_ME11 = ME11_IN_CalClsSpd;
        ACTCtl_eEvapProSts = 1U;
      }
      break;

     case ME11_IN_OpenCtrl_l:
      ACTCtl_eEvapProSts = 5U;
      if (ME11_ARID_DEF.temporalCounter_i1_h >= cal_AEXVOpenRunTimeEvapNOPrt *
          10.0F) {
        ME11_ARID_DEF.is_c52_ME11 = ME11_IN_Default_o;
        ACTCtl_eEvapProSts = 0U;
      } else if (ACSen_sEvapSurTemp < cal_AEXVClsEvapPrtTemp) {
        ME11_ARID_DEF.is_c52_ME11 = ME11_IN_CalClsSpd;
        ACTCtl_eEvapProSts = 1U;
      }
      break;

     case ME11_IN_Wait_b:
      ACTCtl_eEvapProSts = 2U;
      if (ME11_ARID_DEF.temporalCounter_i1_h >= cal_AEXVClsValRunTimeEvapPrt *
          10.0F) {
        ME11_ARID_DEF.is_c52_ME11 = ME11_IN_CloseVavle;
        ACTCtl_eEvapProSts = 3U;
        ME11_ARID_DEF.ACTCtl_sAEXVVal = 0.0F;
      }
      break;

     case ME11_IN_Wait1:
      ACTCtl_eEvapProSts = 4U;
      if (ME11_ARID_DEF.temporalCounter_i1_h >= cal_AEXVOpenDelayTimeEvapNOPrt *
          10.0F) {
        ME11_ARID_DEF.is_c52_ME11 = ME11_IN_OpenCtrl_l;
        ME11_ARID_DEF.temporalCounter_i1_h = 0U;
        ACTCtl_eEvapProSts = 5U;
        ME11_ARID_DEF.ACTCtl_sAEXVVal = cal_AEXVOpenValEvapNOPrt;
      }
      break;

     default:
      /* case IN_wait: */
      ACTCtl_eEvapProSts = 5U;
      if (ME11_ARID_DEF.temporalCounter_i1_h >= cal_AEXVOpenRunTimeEvapNOPrt *
          10.0F) {
        ME11_ARID_DEF.is_c52_ME11 = ME11_IN_Default_o;
        ACTCtl_eEvapProSts = 0U;
      }
      break;
    }
  }

  /* End of Chart: '<S683>/EvapTemperature' */
  for (b_previousEvent = 0; b_previousEvent < 6; b_previousEvent++) {
    /* RelationalOperator: '<S737>/Compare' incorporates:
     *  Constant: '<S737>/Constant'
     */
    rtb_Compare_no[b_previousEvent] = (rtb_Add_b1 ==
      ME11_ConstP.Constant_Value_ig[b_previousEvent]);
  }

  /* Logic: '<S683>/OR' */
  rtb_Compare_fx = rtb_Compare_no[0];
  for (b_previousEvent = 0; b_previousEvent < 5; b_previousEvent++) {
    rtb_Compare_fx = (rtb_Compare_fx || rtb_Compare_no[b_previousEvent + 1]);
  }

  /* Logic: '<S683>/AND2' incorporates:
   *  Delay: '<S503>/Delay'
   *  Logic: '<S683>/OR'
   */
  rtb_Delay1_ag = (ME11_ARID_DEF.Delay_DSTATE_kf && rtb_Compare_fx);

  /* Switch: '<S683>/Switch4' */
  if (rtb_Delay1_ag) {
    /* Switch: '<S683>/Switch4' */
    rtb_IFreezFlag_bd = ACTCtl_eEvapProSts;
  } else {
    /* Switch: '<S683>/Switch4' incorporates:
     *  Constant: '<S683>/Constant8'
     */
    rtb_IFreezFlag_bd = 0U;
  }

  /* End of Switch: '<S683>/Switch4' */

  /* Logic: '<S451>/OR' incorporates:
   *  Constant: '<S564>/Constant'
   *  Constant: '<S565>/Constant'
   *  Constant: '<S566>/Constant'
   *  Delay: '<S451>/Delay1'
   *  RelationalOperator: '<S564>/Compare'
   *  RelationalOperator: '<S565>/Compare'
   *  RelationalOperator: '<S566>/Compare'
   */
  ME11_ARID_DEF.Delay1_DSTATE_hf = ((ACTCtl_eCOMPExhTPrtSts == 2) ||
    (ACTCtl_eCOMPPrsPrtSts == 16) || (rtb_IFreezFlag_bd >= 2) ||
    ACTCtl_bCOMPSpdDiffFlt);

  /* Switch: '<S568>/Switch' incorporates:
   *  Constant: '<S568>/Constant1'
   *  Constant: '<S576>/Constant'
   *  Delay: '<S451>/Delay1'
   *  RelationalOperator: '<S576>/Compare'
   *  Switch: '<S451>/Switch'
   *  Switch: '<S451>/Switch1'
   */
  if (cal_ACCMCtrlSpdDataEnb) {
    /* Switch: '<S568>/Switch' incorporates:
     *  Constant: '<S568>/Constant'
     */
    rtb_Delay = cal_ACCMCtrlSpdData;
  } else if (ME11_ARID_DEF.Delay1_DSTATE_hf) {
    /* Switch: '<S451>/Switch' incorporates:
     *  Constant: '<S451>/Constant'
     *  Switch: '<S568>/Switch'
     */
    rtb_Delay = 0.0F;
  } else if (ACTCtl_sCOMPDownSpd > 0.0F) {
    /* Switch: '<S451>/Switch1' incorporates:
     *  Delay: '<S451>/Delay'
     *  Sum: '<S451>/Add'
     *  Switch: '<S451>/Switch'
     *  Switch: '<S568>/Switch'
     */
    rtb_Delay = ME11_ARID_DEF.Delay_DSTATE_h - ACTCtl_sCOMPDownSpd;
  }

  /* End of Switch: '<S568>/Switch' */

  /* Switch: '<S569>/Switch2' incorporates:
   *  Constant: '<S451>/Constant3'
   *  Constant: '<S451>/Constant4'
   *  Delay: '<S451>/Delay'
   *  RelationalOperator: '<S569>/LowerRelop1'
   *  RelationalOperator: '<S569>/UpperRelop'
   *  Switch: '<S569>/Switch'
   */
  if (rtb_Delay > 8000.0F) {
    ME11_ARID_DEF.Delay_DSTATE_h = 8000.0F;
  } else if (rtb_Delay < 0.0F) {
    /* Switch: '<S569>/Switch' incorporates:
     *  Constant: '<S451>/Constant4'
     *  Delay: '<S451>/Delay'
     */
    ME11_ARID_DEF.Delay_DSTATE_h = 0.0F;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_h = rtb_Delay;
  }

  /* End of Switch: '<S569>/Switch2' */

  /* Relay: '<S451>/Relay' incorporates:
   *  Delay: '<S451>/Delay'
   */
  ME11_ARID_DEF.Relay_Mode_jb = ((ME11_ARID_DEF.Delay_DSTATE_h >=
    cal_COMPONMinSpd) || ((ME11_ARID_DEF.Delay_DSTATE_h > cal_COMPOffMaxSpd) &&
    ME11_ARID_DEF.Relay_Mode_jb));

  /* Switch: '<S451>/Switch2' incorporates:
   *  Relay: '<S451>/Relay'
   */
  if (ME11_ARID_DEF.Relay_Mode_jb) {
    /* Switch: '<S451>/Switch2' incorporates:
     *  Delay: '<S451>/Delay'
     */
    ACTCtl_sACCMCtlSpd = ME11_ARID_DEF.Delay_DSTATE_h;
  } else {
    /* Switch: '<S451>/Switch2' incorporates:
     *  Constant: '<S451>/Constant1'
     */
    ACTCtl_sACCMCtlSpd = 0.0F;
  }

  /* End of Switch: '<S451>/Switch2' */

  /* BusCreator: '<S8>/Bus Creator6' incorporates:
   *  DataTypeConversion: '<S452>/Data Type Conversion'
   *  Delay: '<S503>/Delay'
   */
  rtb_BusCreator6.COMP_EcompHVSt = ME11_ARID_DEF.Delay_DSTATE_kf;

  /* CCaller: '<S452>/C Caller1' incorporates:
   *  Constant: '<S452>/Constant5'
   *  DataTypeConversion: '<S452>/Data Type Conversion'
   *  Delay: '<S503>/Delay'
   */
  Rte_DIDReadData(ME11_ARID_DEF.Delay_DSTATE_kf, ((uint8)DID_0xF274));

  /* Lookup_n-D: '<S582>/cal_PTCAuxHeatPwrLmt_MAP' incorporates:
   *  Sum: '<S582>/Add1'
   *  Switch: '<S1165>/Switch'
   */
  ACTCtl_sPTCAuxHeatPwr = look2_iflf_binlca(ACTCtl_tCtrlADiff,
    HMICtl_sLeftSetPoint, (const float32 *)&cal_PTCAuxHeatPwrLmt_2Y[0], (const
    float32 *)&cal_PTCAuxHeatPwrLmt_2X[0], (const float32 *)
    &cal_PTCAuxHeatPwrLmt_MAP[0], ME11_ConstP.pooled38, 6U);

  /* Switch: '<S592>/Switch' incorporates:
   *  Lookup_n-D: '<S582>/cal_PTCOnReqPower_CUR'
   *  RelationalOperator: '<S592>/Relational Operator'
   *  Switch: '<S338>/Switch2'
   */
  if (ACTCtl_sPTCAuxHeatPwr >= look1_iflf_binlca(ACCtl_tSetPointPTC, (const
        float32 *)&cal_PTCOnReqPower_1X[0], (const float32 *)
       &cal_PTCOnReqPower_CUR[0], 5U)) {
    /* Switch: '<S592>/Switch' incorporates:
     *  Constant: '<S592>/Constant'
     */
    ACTCtl_bPTCOnOrOffPwrDiff = true;
  } else {
    /* Switch: '<S592>/Switch' incorporates:
     *  Constant: '<S582>/Constant6'
     *  Delay: '<S592>/Delay'
     *  RelationalOperator: '<S592>/Relational Operator1'
     */
    ACTCtl_bPTCOnOrOffPwrDiff = ((ACTCtl_sPTCAuxHeatPwr > cal_PTCOffPowerVal) &&
      ACTCtl_bPTCOnOrOffPwrDiff);
  }

  /* End of Switch: '<S592>/Switch' */

  /* Lookup_n-D: '<S587>/cal_CtrlFPTCAuxHeatPwrLmt_MAP' incorporates:
   *  Sum: '<S587>/Add1'
   *  Switch: '<S1165>/Switch'
   */
  ACTCtl_sCtrlFPTCAuxHeatPwr = look2_iflf_binlca(rtb_ACFanLevel5EnvCor,
    HMICtl_sLeftSetPoint, (const float32 *)&cal_CtrlFPTCAuxHeatPwrLmt_2Y[0], (
    const float32 *)&cal_CtrlFPTCAuxHeatPwrLmt_2X[0], (const float32 *)
    &cal_CtrlFPTCAuxHeatPwrLmt_MAP[0], ME11_ConstP.pooled38, 6U);

  /* Switch: '<S609>/Switch' incorporates:
   *  Lookup_n-D: '<S587>/cal_CtrlFPTCOnReqPower_CUR'
   *  RelationalOperator: '<S609>/Relational Operator'
   *  Switch: '<S338>/Switch2'
   */
  if (ACTCtl_sCtrlFPTCAuxHeatPwr >= look1_iflf_binlca(ACCtl_tSetPointPTC, (const
        float32 *)&cal_CtrlFPTCOnReqPower_1X[0], (const float32 *)
       &cal_CtrlFPTCOnReqPower_CUR[0], 5U)) {
    /* Switch: '<S609>/Switch' incorporates:
     *  Constant: '<S609>/Constant'
     */
    ACTCtl_bCtrlFPTCOnOrOffPwrDiff = true;
  } else {
    /* Switch: '<S609>/Switch' incorporates:
     *  Constant: '<S587>/Constant6'
     *  Delay: '<S609>/Delay'
     *  RelationalOperator: '<S609>/Relational Operator1'
     */
    ACTCtl_bCtrlFPTCOnOrOffPwrDiff = ((ACTCtl_sCtrlFPTCAuxHeatPwr >
      cal_CtrlFPTCOffPowerVal) && ACTCtl_bCtrlFPTCOnOrOffPwrDiff);
  }

  /* End of Switch: '<S609>/Switch' */

  /* SignalConversion: '<S24>/Signal Copy50' incorporates:
   *  Inport: '<Root>/C3WV_FltSts'
   *
   * Block description for '<Root>/C3WV_FltSts':
   *  C3WV electric error
   */
  MCV_FltSts = Rte_IRead_Task_100ms_C3WV_FltSts_C3WV_FltSts();

  /* Chart: '<S642>/Chart' incorporates:
   *  Constant: '<S642>/Constant5'
   *  Constant: '<S642>/Constant6'
   *  Constant: '<S658>/Constant'
   *  Logic: '<S642>/AND1'
   *  Product: '<S642>/Divide1'
   *  RelationalOperator: '<S658>/Compare'
   */
  ME11_Chart((MCV_FltSts == 1) || (MCV_FltSts == 2), (uint16)
             (cal_MCVFltStsDelayTime * 10U), &ME11_ARID_DEF.Flag_a,
             &ME11_ARID_DEF.ARID_DEF_Chart_b);

  /* Switch: '<S642>/Switch1' */
  rtb_FixPtRelationalOperator_mk = ((ACTCtl_eC3WVSLSts <= 0) &&
    rtb_RelationalOperator_nf);

  /* Chart: '<S661>/Delay' incorporates:
   *  Constant: '<S642>/Constant2'
   *  Constant: '<S642>/Constant3'
   *  Product: '<S642>/Divide'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_n < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i1_n++;
  }

  if (ME11_ARID_DEF.is_active_c8_ME11Lib == 0U) {
    ME11_ARID_DEF.is_active_c8_ME11Lib = 1U;
    ME11_ARID_DEF.is_c8_ME11Lib = ME11_IN_Init_i;
    ME11_ARID_DEF.Flag_o = false;
  } else {
    switch (ME11_ARID_DEF.is_c8_ME11Lib) {
     case ME11_IN_Init_i:
      ME11_ARID_DEF.Flag_o = false;
      if (rtb_FixPtRelationalOperator_mk) {
        ME11_ARID_DEF.is_c8_ME11Lib = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_n = 0U;
      }
      break;

     case ME11_IN_StepUp:
      ME11_ARID_DEF.Flag_o = true;
      if (!rtb_FixPtRelationalOperator_mk) {
        ME11_ARID_DEF.is_c8_ME11Lib = ME11_IN_Init_i;
        ME11_ARID_DEF.Flag_o = false;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_n >= (uint32)ceil(60.0 *
           cal_MCVPosDiffDelayTime * 10.0)) {
        ME11_ARID_DEF.is_c8_ME11Lib = ME11_IN_StepUp;
        ME11_ARID_DEF.Flag_o = true;
      } else if (!rtb_FixPtRelationalOperator_mk) {
        ME11_ARID_DEF.is_c8_ME11Lib = ME11_IN_Init_i;
        ME11_ARID_DEF.Flag_o = false;
      }
      break;
    }
  }

  /* End of Chart: '<S661>/Delay' */

  /* Logic: '<S642>/AND2' */
  ACTCtl_bMCVlearnFlg = (ME11_ARID_DEF.Flag_a || ME11_ARID_DEF.Flag_o);

  /* SignalConversion: '<S24>/Signal Copy51' incorporates:
   *  Inport: '<Root>/C3WV_Mode'
   *
   * Block description for '<Root>/C3WV_Mode':
   *  C3WV status.
   */
  MCV_Mode = Rte_IRead_Task_100ms_C3WV_Mode_C3WV_Mode();

  /* Switch: '<S642>/Switch2' incorporates:
   *  Constant: '<S642>/Constant4'
   *  Constant: '<S659>/Constant'
   *  Delay: '<S642>/Delay1'
   *  RelationalOperator: '<S659>/Compare'
   *  Switch: '<S642>/Switch'
   */
  if (MCV_Mode == 2) {
    ME11_ARID_DEF.Delay1_DSTATE_og = 0U;
  } else if (ACTCtl_bMCVlearnFlg) {
    /* Switch: '<S642>/Switch' incorporates:
     *  Constant: '<S642>/Constant'
     *  Delay: '<S642>/Delay1'
     */
    ME11_ARID_DEF.Delay1_DSTATE_og = 1U;
  }

  /* End of Switch: '<S642>/Switch2' */

  /* Switch: '<S660>/Switch' incorporates:
   *  Constant: '<S660>/Constant1'
   */
  if (cal_C3WVSLStsDataEnb) {
    /* Switch: '<S660>/Switch' incorporates:
     *  Constant: '<S660>/Constant'
     */
    ACTCtl_eC3WVSLSts = cal_C3WVSLStsData;
  } else {
    /* Switch: '<S660>/Switch' incorporates:
     *  Delay: '<S642>/Delay1'
     */
    ACTCtl_eC3WVSLSts = ME11_ARID_DEF.Delay1_DSTATE_og;
  }

  /* End of Switch: '<S660>/Switch' */

  /* SignalConversion: '<S17>/Signal Copy66' incorporates:
   *  Inport: '<Root>/C5WVFltSts'
   *
   * Block description for '<Root>/C5WVFltSts':
   *  C5WVelectric error
   */
  BCV_FltSts = Rte_IRead_Task_100ms_C5WVFltSts_C5WVFltSts();

  /* Chart: '<S664>/Chart' incorporates:
   *  Constant: '<S664>/Constant5'
   *  Constant: '<S664>/Constant6'
   *  Constant: '<S668>/Constant'
   *  Logic: '<S664>/AND1'
   *  Product: '<S664>/Divide1'
   *  RelationalOperator: '<S668>/Compare'
   */
  ME11_Chart((BCV_FltSts == 1) || (BCV_FltSts == 2), (uint16)
             (cal_BCVFltStsDelayTime * 10U), &ME11_ARID_DEF.Flag_d,
             &ME11_ARID_DEF.ARID_DEF_Chart_n);

  /* Switch: '<S664>/Switch1' */
  rtb_FixPtRelationalOperator_mk = ((ACTCtl_eC5WVSLSts <= 0) &&
    rtb_FixPtRelationalOperator_a0);

  /* Chart: '<S671>/Delay' incorporates:
   *  Constant: '<S664>/Constant2'
   *  Constant: '<S664>/Constant3'
   *  Product: '<S664>/Divide'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_o < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i1_o++;
  }

  if (ME11_ARID_DEF.is_active_c8_sxEHvlxA06GOIGuoBfehAHF_ME11Lib == 0U) {
    ME11_ARID_DEF.is_active_c8_sxEHvlxA06GOIGuoBfehAHF_ME11Lib = 1U;
    ME11_ARID_DEF.is_c8_sxEHvlxA06GOIGuoBfehAHF_ME11Lib = ME11_IN_Init_i;
    ME11_ARID_DEF.Flag = false;
  } else {
    switch (ME11_ARID_DEF.is_c8_sxEHvlxA06GOIGuoBfehAHF_ME11Lib) {
     case ME11_IN_Init_i:
      ME11_ARID_DEF.Flag = false;
      if (rtb_FixPtRelationalOperator_mk) {
        ME11_ARID_DEF.is_c8_sxEHvlxA06GOIGuoBfehAHF_ME11Lib = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_o = 0U;
      }
      break;

     case ME11_IN_StepUp:
      ME11_ARID_DEF.Flag = true;
      if (!rtb_FixPtRelationalOperator_mk) {
        ME11_ARID_DEF.is_c8_sxEHvlxA06GOIGuoBfehAHF_ME11Lib = ME11_IN_Init_i;
        ME11_ARID_DEF.Flag = false;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_o >= (float32)(60.0 *
           cal_BCVPosDiffDelayTime) * 10.0F) {
        ME11_ARID_DEF.is_c8_sxEHvlxA06GOIGuoBfehAHF_ME11Lib = ME11_IN_StepUp;
        ME11_ARID_DEF.Flag = true;
      } else if (!rtb_FixPtRelationalOperator_mk) {
        ME11_ARID_DEF.is_c8_sxEHvlxA06GOIGuoBfehAHF_ME11Lib = ME11_IN_Init_i;
        ME11_ARID_DEF.Flag = false;
      }
      break;
    }
  }

  /* End of Chart: '<S671>/Delay' */

  /* Logic: '<S664>/AND2' */
  ACTCtl_bBCVlearnFlg = (ME11_ARID_DEF.Flag_d || ME11_ARID_DEF.Flag);

  /* SignalConversion: '<S17>/Signal Copy67' incorporates:
   *  Inport: '<Root>/C5WVMode'
   *
   * Block description for '<Root>/C5WVMode':
   *  C5WVstatus.
   */
  BCV_Mode = Rte_IRead_Task_100ms_C5WVMode_C5WVMode();

  /* Switch: '<S664>/Switch2' incorporates:
   *  Constant: '<S664>/Constant4'
   *  Constant: '<S669>/Constant'
   *  Delay: '<S664>/Delay1'
   *  RelationalOperator: '<S669>/Compare'
   *  Switch: '<S664>/Switch'
   */
  if (BCV_Mode == 2) {
    ME11_ARID_DEF.Delay1_DSTATE_ob = 0U;
  } else if (ACTCtl_bBCVlearnFlg) {
    /* Switch: '<S664>/Switch' incorporates:
     *  Constant: '<S664>/Constant'
     *  Delay: '<S664>/Delay1'
     */
    ME11_ARID_DEF.Delay1_DSTATE_ob = 1U;
  }

  /* End of Switch: '<S664>/Switch2' */

  /* Switch: '<S670>/Switch' incorporates:
   *  Constant: '<S670>/Constant1'
   */
  if (cal_C5WVSLStsDataEnb) {
    /* Switch: '<S670>/Switch' incorporates:
     *  Constant: '<S670>/Constant'
     */
    ACTCtl_eC5WVSLSts = cal_C5WVSLStsData;
  } else {
    /* Switch: '<S670>/Switch' incorporates:
     *  Delay: '<S664>/Delay1'
     */
    ACTCtl_eC5WVSLSts = ME11_ARID_DEF.Delay1_DSTATE_ob;
  }

  /* End of Switch: '<S670>/Switch' */

  /* Switch: '<S639>/Switch' incorporates:
   *  Constant: '<S639>/Constant1'
   */
  if (cal_eC3WVValueEnb) {
    /* Switch: '<S639>/Switch' incorporates:
     *  Constant: '<S639>/Constant'
     */
    ACTCtl_eC3WVValue = cal_eC3WVValueData;
  } else {
    /* Switch: '<S639>/Switch' */
    ACTCtl_eC3WVValue = rtb_Add3_do;
  }

  /* End of Switch: '<S639>/Switch' */

  /* Switch: '<S640>/Switch' incorporates:
   *  Constant: '<S640>/Constant1'
   */
  if (cal_eC5WVValueEnb) {
    /* Switch: '<S640>/Switch' incorporates:
     *  Constant: '<S640>/Constant'
     */
    ACTCtl_eC5WVValue = cal_eC5WVValueData;
  } else {
    /* Switch: '<S640>/Switch' */
    ACTCtl_eC5WVValue = rtb_Switch3_l;
  }

  /* End of Switch: '<S640>/Switch' */

  /* Switch: '<S679>/Switch' incorporates:
   *  Constant: '<S679>/Constant'
   *  Constant: '<S691>/Constant'
   *  Constant: '<S692>/Constant'
   *  Constant: '<S693>/Constant'
   *  Constant: '<S694>/Constant'
   *  Delay: '<S679>/Delay'
   *  Delay: '<S679>/Delay1'
   *  Logic: '<S679>/AND1'
   *  RelationalOperator: '<S691>/Compare'
   *  RelationalOperator: '<S692>/Compare'
   *  RelationalOperator: '<S693>/Compare'
   *  RelationalOperator: '<S694>/Compare'
   *  Switch: '<S679>/Switch1'
   *  Switch: '<S679>/Switch2'
   */
  if ((ME11_ARID_DEF.Delay1_DSTATE_hw < 2) && (ME11_ARID_DEF.DataTypeConversion1
       >= 2)) {
    ME11_ARID_DEF.Delay_DSTATE_ax = 1U;
  } else if (EXV_CurrentInitState == 2) {
    /* Delay: '<S679>/Delay' incorporates:
     *  Constant: '<S679>/Constant1'
     *  Switch: '<S679>/Switch1'
     */
    ME11_ARID_DEF.Delay_DSTATE_ax = 0U;
  } else if (EXV_CurrentInitState == 1) {
    /* Switch: '<S679>/Switch2' incorporates:
     *  Constant: '<S679>/Constant2'
     *  Delay: '<S679>/Delay'
     *  Switch: '<S679>/Switch1'
     */
    ME11_ARID_DEF.Delay_DSTATE_ax = 2U;
  }

  /* End of Switch: '<S679>/Switch' */

  /* Switch: '<S696>/Switch' incorporates:
   *  Constant: '<S696>/Constant1'
   */
  if (cal_AEXVInitReqDataeEnb) {
    /* Switch: '<S696>/Switch' incorporates:
     *  Constant: '<S696>/Constant'
     */
    ACTCtl_bAEXVInitReq = cal_AEXVInitReqData;
  } else {
    /* Switch: '<S696>/Switch' incorporates:
     *  Delay: '<S679>/Delay'
     */
    ACTCtl_bAEXVInitReq = ME11_ARID_DEF.Delay_DSTATE_ax;
  }

  /* End of Switch: '<S696>/Switch' */

  /* Lookup_n-D: '<S715>/cal_AEXVCtrlBFF_CUR' incorporates:
   *  Switch: '<S451>/Switch2'
   */
  ACTCtl_sAEXVCtrlBFF = look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
    &cal_AEXVCtrlBFF_1X[0], (const float32 *)&cal_AEXVCtrlBFF_CUR[0], 4U);

  /* Gain: '<S8>/Gain8' incorporates:
   *  Lookup_n-D: '<S676>/cal_CondDep_CUR'
   *  Switch: '<S1864>/Switch'
   */
  rtb_Delay1_ie = look1_iflf_binlca(ACSen_sHiPressFilter, (const float32 *)
    &cal_CondDep_1X[0], (const float32 *)&cal_CondDep_CUR[0], 27U);

  /* Sum: '<S676>/Add3' */
  ACTCtl_sCoolCondDep = rtb_Delay1_ie - ACSen_sOHXTempFilter;

  /* Switch: '<S904>/Init' incorporates:
   *  Constant: '<S896>/Constant1'
   *  Constant: '<S903>/Constant'
   *  Product: '<S903>/Product'
   *  Product: '<S903>/Product1'
   *  Sum: '<S903>/Sum'
   *  Sum: '<S903>/Sum1'
   *  UnitDelay: '<S904>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_f != 0) {
    ACTCtl_sCoolCondDepAvg1 = ACTCtl_sCoolCondDep;
  }

  ACTCtl_sCoolCondDepAvg1 = (1.0F - cal_SuperHeatFilter) *
    ACTCtl_sCoolCondDepAvg1 + ACTCtl_sCoolCondDep * cal_SuperHeatFilter;

  /* End of Switch: '<S904>/Init' */

  /* Product: '<S896>/Divide' incorporates:
   *  Constant: '<S896>/Constant'
   *  Delay: '<S896>/Delay'
   *  Delay: '<S896>/Delay1'
   *  Delay: '<S896>/Delay2'
   *  Delay: '<S896>/Delay3'
   *  Sum: '<S896>/Add'
   */
  ACTCtl_sCoolCondDepAvg = ((((ACTCtl_sCoolCondDep +
    ME11_ARID_DEF.Delay1_DSTATE_h) + ME11_ARID_DEF.Delay_DSTATE_i[0]) +
    ME11_ARID_DEF.Delay2_DSTATE_h[0]) + ME11_ARID_DEF.Delay3_DSTATE_i[0]) / 5.0F;

  /* Switch: '<S676>/Switch3' incorporates:
   *  Constant: '<S676>/Constant4'
   */
  if (cal_AvgSwitch) {
    /* Switch: '<S676>/Switch3' */
    rtb_ACFanLevel5EnvCor = ACTCtl_sCoolCondDepAvg1;
  } else {
    /* Switch: '<S676>/Switch3' */
    rtb_ACFanLevel5EnvCor = ACTCtl_sCoolCondDepAvg;
  }

  /* End of Switch: '<S676>/Switch3' */

  /* Switch: '<S715>/Switch' incorporates:
   *  Constant: '<S720>/Constant'
   *  RelationalOperator: '<S720>/Compare'
   */
  if (rtb_Add_b1 == 1) {
    /* Switch: '<S715>/Switch' incorporates:
     *  Lookup_n-D: '<S715>/cal_AEXVCtrlBTrgSubCoolCOMPSpd_CUR'
     *  SignalConversion: '<S2>/Signal Copy122'
     */
    rtb_PI_Cor_n = look1_iflf_binlca(COMP_EcompActSpd, (const float32 *)
      &cal_AEXVCtrlBTrgSubCoolCOMPSpd_1X[0], (const float32 *)
      &cal_AEXVCtrlBTrgSubCoolCOMPSpd_CUR[0], 8U);
  } else {
    /* Switch: '<S715>/Switch' incorporates:
     *  Lookup_n-D: '<S715>/cal_AEXVCtrlBTrgSubCool_CUR'
     *  Switch: '<S1085>/Switch'
     */
    rtb_PI_Cor_n = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_AEXVCtrlBTrgSubCool_1X[0], (const float32 *)
      &cal_AEXVCtrlBTrgSubCool_CUR[0], 8U);
  }

  /* End of Switch: '<S715>/Switch' */

  /* Outputs for Enabled SubSystem: '<S715>/Descending_filter' */
  /* Logic: '<S715>/OR' incorporates:
   *  Constant: '<S715>/Constant9'
   *  Constant: '<S719>/Constant'
   *  RelationalOperator: '<S719>/Compare'
   */
  ME11_Descending_filter((rtb_Add_b1 == 1) || (rtb_Add_b1 == 3) || (rtb_Add_b1 ==
    12) || (rtb_Add_b1 == 14), rtb_ACFanLevel5EnvCor, rtb_PI_Cor_n,
    cal_AEXVSubCoolflt, COMP_EcompActSpd, &ME11_ARID_DEF.Init_m,
    &ME11_ARID_DEF.ARID_DEF_Descending_filter_b);

  /* End of Outputs for SubSystem: '<S715>/Descending_filter' */

  /* Sum: '<S715>/Add' */
  ACTCtl_sCondDepDiff = ME11_ARID_DEF.Init_m - rtb_ACFanLevel5EnvCor;

  /* Lookup_n-D: '<S676>/cal_SuperHeat_CUR' incorporates:
   *  Switch: '<S1788>/Switch'
   */
  rtb_Delay = look1_iflf_binlca(ACSen_sLoPressFilter, (const float32 *)
    &cal_SuperHeat_1X[0], (const float32 *)&cal_SuperHeat_CUR[0], 27U);

  /* Sum: '<S676>/Add4' */
  ACTCtl_sEvapSuperHeat = ACSen_sEvapTempFilter - rtb_Delay;

  /* Switch: '<S906>/Init' incorporates:
   *  Constant: '<S897>/Constant1'
   *  Constant: '<S905>/Constant'
   *  Product: '<S905>/Product'
   *  Product: '<S905>/Product1'
   *  Sum: '<S905>/Sum'
   *  Sum: '<S905>/Sum1'
   *  UnitDelay: '<S906>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_li != 0) {
    ACTCtl_sEvapSuperHeatAvg1 = ACTCtl_sEvapSuperHeat;
  }

  ACTCtl_sEvapSuperHeatAvg1 = (1.0F - cal_SuperHeatFilter) *
    ACTCtl_sEvapSuperHeatAvg1 + ACTCtl_sEvapSuperHeat * cal_SuperHeatFilter;

  /* End of Switch: '<S906>/Init' */

  /* Product: '<S897>/Divide' incorporates:
   *  Constant: '<S897>/Constant'
   *  Delay: '<S897>/Delay'
   *  Delay: '<S897>/Delay1'
   *  Delay: '<S897>/Delay2'
   *  Delay: '<S897>/Delay3'
   *  Sum: '<S897>/Add'
   */
  ACTCtl_sEvapSuperHeatAvg = ((((ACTCtl_sEvapSuperHeat +
    ME11_ARID_DEF.Delay1_DSTATE_l) + ME11_ARID_DEF.Delay_DSTATE_bm[0]) +
    ME11_ARID_DEF.Delay2_DSTATE_a[0]) + ME11_ARID_DEF.Delay3_DSTATE_k[0]) / 5.0F;

  /* Switch: '<S676>/Switch4' incorporates:
   *  Constant: '<S676>/Constant5'
   */
  if (cal_AvgSwitch) {
    /* Switch: '<S676>/Switch4' */
    ACTCtl_sAEXVActure = ACTCtl_sEvapSuperHeatAvg1;
  } else {
    /* Switch: '<S676>/Switch4' */
    ACTCtl_sAEXVActure = ACTCtl_sEvapSuperHeatAvg;
  }

  /* End of Switch: '<S676>/Switch4' */

  /* Outputs for Enabled SubSystem: '<S716>/Descending_filter' */
  /* RelationalOperator: '<S727>/Compare' incorporates:
   *  Constant: '<S716>/Constant9'
   *  Constant: '<S727>/Constant'
   *  Lookup_n-D: '<S716>/cal_AEXVCtrlCTrgtSuperHeat_CUR'
   *  Switch: '<S1085>/Switch'
   */
  ME11_Descending_filter(rtb_Add_b1 == 7, ACTCtl_sAEXVActure, look1_iflf_binlca
    (ACSen_sEnvTempCor, (const float32 *)&cal_AEXVCtrlCTrgtSuperHeat_1X[0], (
    const float32 *)&cal_AEXVCtrlCTrgtSuperHeat_CUR[0], 6U), cal_AEXVCtrlCTrgflt,
    COMP_EcompActSpd, &ME11_ARID_DEF.Init_n,
    &ME11_ARID_DEF.ARID_DEF_Descending_filter_o);

  /* End of Outputs for SubSystem: '<S716>/Descending_filter' */

  /* MultiPortSwitch: '<S681>/Multiport Switch' */
  switch (rtb_Add_b1) {
   case 2:
   case 4:
   case 5:
   case 6:
   case 13:
    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S714>/Constant'
     */
    rtb_Merge = 0.0F;
    ACTCtl_sHPEXVCtrlFF = 0.0F;
    rtb_Merge1 = 0.0F;

    /* SignalConversion: '<S673>/Signal Copy' incorporates:
     *  Constant: '<S714>/Constant'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVSetPoint = 0.0F;

    /* SignalConversion: '<S673>/Signal Copy1' incorporates:
     *  Constant: '<S714>/Constant'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVActure = 0.0F;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S714>/Constant'
     */
    rtb_PI_Cor_n = 0.0F;

    /* SignalConversion: '<S673>/Signal Copy2' incorporates:
     *  Constant: '<S714>/Constant'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVCtrlKp = 0.0F;

    /* SignalConversion: '<S673>/Signal Copy3' incorporates:
     *  Constant: '<S714>/Constant'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVCtrlKi = 0.0F;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S714>/Constant'
     *  Constant: '<S714>/Constant1'
     */
    rtb_Gain6 = 0.0F;
    rtb_Add_ok = 0.0F;
    b_previousEvent = 0;
    break;

   case 1:
   case 3:
   case 12:
   case 14:
    /* MultiPortSwitch: '<S715>/Multiport Switch' */
    switch (rtb_Add_b1) {
     case 1:
      /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
       *  Lookup_n-D: '<S715>/cal_AEXVCtrlBCabinCoolPIMin_CUR'
       *  MultiPortSwitch: '<S715>/Multiport Switch'
       *  SignalConversion: '<S2>/Signal Copy122'
       */
      rtb_Add_ok = look1_iflf_binlca(COMP_EcompActSpd, (const float32 *)
        &cal_AEXVCtrlBCabinCoolPIMin_1X[0], (const float32 *)
        &cal_AEXVCtrlBCabinCoolPIMin_CUR[0], 5U);
      break;

     case 3:
      /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
       *  Lookup_n-D: '<S715>/cal_AEXVCtrlBDCoolPIMin_CUR'
       *  MultiPortSwitch: '<S715>/Multiport Switch'
       *  SignalConversion: '<S2>/Signal Copy122'
       */
      rtb_Add_ok = look1_iflf_binlca(COMP_EcompActSpd, (const float32 *)
        &cal_AEXVCtrlBDCoolPIMin_1X[0], (const float32 *)
        &cal_AEXVCtrlBDCoolPIMin_CUR[0], 5U);
      break;

     default:
      /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
       *  Constant: '<S715>/Constant7'
       *  MultiPortSwitch: '<S715>/Multiport Switch'
       */
      rtb_Add_ok = cal_AEXVCtrlBPIMin;
      break;
    }

    /* End of MultiPortSwitch: '<S715>/Multiport Switch' */

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S715>/Constant'
     *  Constant: '<S715>/Constant1'
     */
    rtb_Merge = cal_AEXVCtrlBDelayTime;
    ACTCtl_sHPEXVCtrlFF = cal_AEXVCtrlBOpenVal;
    rtb_Merge1 = ACTCtl_sAEXVCtrlBFF;

    /* SignalConversion: '<S673>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVSetPoint = ME11_ARID_DEF.Init_m;

    /* SignalConversion: '<S673>/Signal Copy1' incorporates:
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVActure = rtb_ACFanLevel5EnvCor;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S715>/Constant3'
     */
    rtb_PI_Cor_n = cal_AEXVCtrlBDeadzone;

    /* SignalConversion: '<S673>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S715>/cal_AEXVCtrlBKp_CUR'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     *  Sum: '<S715>/Add'
     */
    ACTCtl_sAEXVCtrlKp = look1_iflf_binlca(ACTCtl_sCondDepDiff, (const float32 *)
      &cal_AEXVCtrlBKp_1X[0], (const float32 *)&cal_AEXVCtrlBKp_CUR[0], 7U);

    /* SignalConversion: '<S673>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S715>/cal_AEXVCtrlBKi_CUR'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     *  Sum: '<S715>/Add'
     */
    ACTCtl_sAEXVCtrlKi = look1_iflf_binlca(ACTCtl_sCondDepDiff, (const float32 *)
      &cal_AEXVCtrlBKi_1X[0], (const float32 *)&cal_AEXVCtrlBKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S715>/Constant6'
     *  Constant: '<S715>/Constant8'
     */
    rtb_Gain6 = cal_AEXVCtrlBPIMax;
    b_previousEvent = 1;
    break;

   case 7:
    /* Sum: '<S716>/Add' */
    rtb_Add_ok = ME11_ARID_DEF.Init_n - ACTCtl_sAEXVActure;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S716>/Constant'
     *  Constant: '<S716>/Constant1'
     *  Lookup_n-D: '<S716>/cal_AEXVCtrlCFF_CUR'
     *  Switch: '<S451>/Switch2'
     */
    rtb_Merge = cal_AEXVCtrlCDelayTime;
    ACTCtl_sHPEXVCtrlFF = cal_AEXVCtrlCOpenVal;
    rtb_Merge1 = look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
      &cal_AEXVCtrlCFF_1X[0], (const float32 *)&cal_AEXVCtrlCFF_CUR[0], 4U);

    /* SignalConversion: '<S673>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVSetPoint = ME11_ARID_DEF.Init_n;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S716>/Constant3'
     */
    rtb_PI_Cor_n = cal_AEXVCtrlCDeadzone;

    /* SignalConversion: '<S673>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S716>/cal_AEXVCtrlCKp_CUR'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     *  Sum: '<S716>/Add'
     */
    ACTCtl_sAEXVCtrlKp = look1_iflf_binlca(rtb_Add_ok, (const float32 *)
      &cal_AEXVCtrlCKp_1X[0], (const float32 *)&cal_AEXVCtrlCKp_CUR[0], 6U);

    /* SignalConversion: '<S673>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S716>/cal_AEXVCtrlCKi_CUR'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     *  Sum: '<S716>/Add'
     */
    ACTCtl_sAEXVCtrlKi = look1_iflf_binlca(rtb_Add_ok, (const float32 *)
      &cal_AEXVCtrlCKi_1X[0], (const float32 *)&cal_AEXVCtrlCKi_CUR[0], 6U);

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S716>/Constant6'
     *  Constant: '<S716>/Constant7'
     *  Constant: '<S716>/Constant8'
     */
    rtb_Gain6 = cal_AEXVCtrlCPIMax;
    rtb_Add_ok = cal_AEXVCtrlCPIMin;
    b_previousEvent = 1;
    break;

   case 8:
    /* Lookup_n-D: '<S717>/cal_AEXVCtrlDTrg_CUR' incorporates:
     *  Switch: '<S1085>/Switch'
     */
    ACTCtl_sAEXVSetPoint = look1_iflf_binlca(ACSen_sEnvTempCor, (const float32 *)
      &cal_AEXVCtrlDTrg_1X[0], (const float32 *)&cal_AEXVCtrlDTrg_CUR[0], 2U);

    /* Sum: '<S717>/Add' */
    rtb_Add_ok = ACTCtl_sAEXVSetPoint - ACSen_sEvapSurTemp;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S717>/Constant'
     *  Constant: '<S717>/Constant1'
     *  Lookup_n-D: '<S717>/cal_AEXVCtrlDFF_CUR'
     *  Switch: '<S451>/Switch2'
     */
    rtb_Merge = cal_AEXVCtrlDDelayTime;
    ACTCtl_sHPEXVCtrlFF = cal_AEXVCtrlDOpenVal;
    rtb_Merge1 = look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
      &cal_AEXVCtrlDFF_1X[0], (const float32 *)&cal_AEXVCtrlDFF_CUR[0], 4U);

    /* SignalConversion: '<S673>/Signal Copy1' incorporates:
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVActure = ACSen_sEvapSurTemp;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S717>/Constant3'
     */
    rtb_PI_Cor_n = cal_AEXVCtrlDDeadzone;

    /* SignalConversion: '<S673>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S717>/cal_AEXVCtrlDKp_CUR'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     *  Sum: '<S717>/Add'
     */
    ACTCtl_sAEXVCtrlKp = look1_iflf_binlca(rtb_Add_ok, (const float32 *)
      &cal_AEXVCtrlDKp_1X[0], (const float32 *)&cal_AEXVCtrlDKp_CUR[0], 7U);

    /* SignalConversion: '<S673>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S717>/cal_AEXVCtrlDKi_CUR'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     *  Sum: '<S717>/Add'
     */
    ACTCtl_sAEXVCtrlKi = look1_iflf_binlca(rtb_Add_ok, (const float32 *)
      &cal_AEXVCtrlDKi_1X[0], (const float32 *)&cal_AEXVCtrlDKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S717>/Constant2'
     *  Constant: '<S717>/Constant6'
     *  Constant: '<S717>/Constant7'
     */
    rtb_Gain6 = cal_AEXVCtrlDPIMax;
    rtb_Add_ok = cal_AEXVCtrlDPIMin;
    b_previousEvent = 1;
    break;

   default:
    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S718>/Constant1'
     */
    rtb_Merge = cal_AEXVCtrlDefaultPos;
    ACTCtl_sHPEXVCtrlFF = cal_AEXVCtrlDefaultPos;
    rtb_Merge1 = cal_AEXVCtrlDefaultPos;

    /* SignalConversion: '<S673>/Signal Copy' incorporates:
     *  Constant: '<S718>/Constant1'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVSetPoint = cal_AEXVCtrlDefaultPos;

    /* SignalConversion: '<S673>/Signal Copy1' incorporates:
     *  Constant: '<S718>/Constant1'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVActure = cal_AEXVCtrlDefaultPos;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S718>/Constant1'
     */
    rtb_PI_Cor_n = cal_AEXVCtrlDefaultPos;

    /* SignalConversion: '<S673>/Signal Copy2' incorporates:
     *  Constant: '<S718>/Constant1'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVCtrlKp = cal_AEXVCtrlDefaultPos;

    /* SignalConversion: '<S673>/Signal Copy3' incorporates:
     *  Constant: '<S718>/Constant1'
     *  MultiPortSwitch: '<S681>/Multiport Switch'
     */
    ACTCtl_sAEXVCtrlKi = cal_AEXVCtrlDefaultPos;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S718>/Constant1'
     *  Constant: '<S718>/Constant2'
     */
    rtb_Gain6 = cal_AEXVCtrlDefaultPos;
    rtb_Add_ok = cal_AEXVCtrlDefaultPos;
    b_previousEvent = 0;
    break;
  }

  /* End of MultiPortSwitch: '<S681>/Multiport Switch' */

  /* Chart: '<S677>/FFCal' incorporates:
   *  Delay: '<S503>/Delay'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_ao < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i1_ao++;
  }

  if (ME11_ARID_DEF.is_active_c47_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c47_ME11 = 1U;
    ME11_ARID_DEF.is_c47_ME11 = ME11_IN_Init_i;
    ME11_ARID_DEF.PID_Enble_i = false;
    ACTCtl_sAEXVCtrlFF = ACTCtl_sHPEXVCtrlFF;
    ME11_ARID_DEF.AEXVCtrlEnb = true;
  } else if (ME11_ARID_DEF.is_c47_ME11 == ME11_IN_Init_i) {
    ME11_ARID_DEF.PID_Enble_i = false;
    ME11_ARID_DEF.AEXVCtrlEnb = true;
    if (ME11_ARID_DEF.Delay_DSTATE_kf) {
      ME11_ARID_DEF.is_c47_ME11 = ME11_IN_On_li;
      ME11_ARID_DEF.is_On_n = ME11_IN_OpenCtrl;
      ME11_ARID_DEF.temporalCounter_i1_ao = 0U;
      ACTCtl_sAEXVCtrlFF = ACTCtl_sHPEXVCtrlFF;
      ME11_ARID_DEF.AEXVCtrlEnb = true;
    } else {
      ACTCtl_sAEXVCtrlFF = ACTCtl_sHPEXVCtrlFF;
    }

    /* case IN_On: */
  } else if (!ME11_ARID_DEF.Delay_DSTATE_kf) {
    ME11_ARID_DEF.is_On_n = ME11_IN_NO_ACTIVE_CHILD_gl;
    ME11_ARID_DEF.is_c47_ME11 = ME11_IN_Init_i;
    ME11_ARID_DEF.PID_Enble_i = false;
    ACTCtl_sAEXVCtrlFF = ACTCtl_sHPEXVCtrlFF;
    ME11_ARID_DEF.AEXVCtrlEnb = true;
  } else if (ME11_ARID_DEF.is_On_n == ME11_IN_CloseCtrl) {
    ME11_ARID_DEF.PID_Enble_i = true;
    ACTCtl_sAEXVCtrlFF = rtb_Merge1;
  } else {
    /* case IN_OpenCtrl: */
    ME11_ARID_DEF.AEXVCtrlEnb = true;
    if (ME11_ARID_DEF.temporalCounter_i1_ao >= rtb_Merge * 10.0F) {
      ME11_ARID_DEF.is_On_n = ME11_IN_CloseCtrl;
      ME11_ARID_DEF.PID_Enble_i = true;
      ACTCtl_sAEXVCtrlFF = rtb_Merge1;
    } else {
      ACTCtl_sAEXVCtrlFF = ACTCtl_sHPEXVCtrlFF;
    }
  }

  /* End of Chart: '<S677>/FFCal' */

  /* Switch: '<S686>/Switch' incorporates:
   *  Constant: '<S686>/Constant1'
   */
  if (cal_AEXVEnbDataEnb) {
    /* Switch: '<S686>/Switch' incorporates:
     *  Constant: '<S686>/Constant'
     */
    ACTCtl_bAEXVEnb = cal_AEXVEnbData;
  } else {
    /* Switch: '<S686>/Switch' incorporates:
     *  Constant: '<S684>/Constant'
     *  RelationalOperator: '<S684>/Compare'
     *  Switch: '<S677>/Switch'
     */
    ACTCtl_bAEXVEnb = ((ACTCtl_bAEXVInitReq >= 1) || ME11_ARID_DEF.AEXVCtrlEnb);
  }

  /* End of Switch: '<S686>/Switch' */

  /* RelationalOperator: '<S695>/Compare' incorporates:
   *  Constant: '<S695>/Constant'
   *  Delay: '<S679>/Delay2'
   */
  ACTCtl_bAEXVInitFinishFlg = (ME11_ARID_DEF.Delay2_DSTATE_pj < 1);

  /* Sum: '<S682>/Sum' */
  ACTCtl_sAEXVDvt = ACTCtl_sAEXVSetPoint - ACTCtl_sAEXVActure;

  /* Chart: '<S682>/deadzone' */
  ME11_deadzone_h1(ACTCtl_sAEXVDvt, rtb_PI_Cor_n, &rtb_flag_c);

  /* RelationalOperator: '<S682>/Relational Operator' */
  rtb_FixPtRelationalOperator_mk = (ACTCtl_sAEXVSetPoint >= ACTCtl_sAEXVActure);

  /* Switch: '<S682>/Switch1' incorporates:
   *  Switch: '<S682>/Switch'
   */
  if (rtb_flag_c) {
    /* Switch: '<S682>/Switch1' incorporates:
     *  Constant: '<S682>/Constant'
     */
    ACTCtl_sAEXVDvt = 0.0F;
  } else if (!rtb_FixPtRelationalOperator_mk) {
    /* Switch: '<S682>/Switch1' incorporates:
     *  Sum: '<S682>/Sum1'
     *  Switch: '<S682>/Switch'
     */
    ACTCtl_sAEXVDvt = ACTCtl_sAEXVActure - ACTCtl_sAEXVSetPoint;
  }

  /* End of Switch: '<S682>/Switch1' */

  /* Logic: '<S682>/NOT' */
  ACTCtl_bAEXVDvtFlg = !rtb_FixPtRelationalOperator_mk;

  /* Outputs for Enabled SubSystem: '<S700>/P_NEG' */
  /* Logic: '<S700>/Logical Operator' incorporates:
   *  Constant: '<S680>/Constant11'
   */
  ME11_P_NEG(!ACTCtl_bAEXVDvtFlg, ACTCtl_sAEXVDvt, rtb_PI_Cor_n,
             ACTCtl_sAEXVCtrlKi, cal_AEXVCtlKi, (float32 *)&ACTCtl_sAEXVI_Cor);

  /* End of Outputs for SubSystem: '<S700>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S700>/P_POS' */
  /* Constant: '<S680>/Constant11' */
  ME11_P_POS(ACTCtl_bAEXVDvtFlg, ACTCtl_sAEXVDvt, rtb_PI_Cor_n,
             ACTCtl_sAEXVCtrlKi, cal_AEXVCtlKi, (float32 *)&ACTCtl_sAEXVI_Cor);

  /* End of Outputs for SubSystem: '<S700>/P_POS' */

  /* Logic: '<S673>/AND' */
  ACTCtl_bAEXVPIEnble = (ME11_ARID_DEF.PID_Enble_i && (b_previousEvent != 0));

  /* Switch: '<S697>/Switch1' */
  if (ACTCtl_bAEXVPIEnble) {
    /* MultiPortSwitch: '<S700>/Multiport Switch' incorporates:
     *  Delay: '<S700>/Delay'
     */
    switch (ME11_ARID_DEF.Delay_DSTATE_op) {
     case 0:
      /* Switch: '<S704>/Switch' */
      if (ACTCtl_bAEXVDvtFlg) {
        /* Switch: '<S701>/Switch2' incorporates:
         *  Delay: '<S697>/Delay'
         *  Sum: '<S704>/Add'
         *  Switch: '<S704>/Switch'
         */
        ACTCtl_sAEXVI_Sum = ACTCtl_sAEXVI_Sum + ACTCtl_sAEXVI_Cor;
      } else {
        /* Switch: '<S701>/Switch2' incorporates:
         *  Delay: '<S697>/Delay'
         *  Sum: '<S704>/Add1'
         *  Switch: '<S704>/Switch'
         */
        ACTCtl_sAEXVI_Sum = ACTCtl_sAEXVI_Sum - ACTCtl_sAEXVI_Cor;
      }

      /* End of Switch: '<S704>/Switch' */
      break;

     case 1:
      /* Switch: '<S705>/Switch' */
      if (!ACTCtl_bAEXVDvtFlg) {
        /* Switch: '<S701>/Switch2' incorporates:
         *  Delay: '<S697>/Delay'
         *  Sum: '<S705>/Add1'
         *  Switch: '<S705>/Switch'
         */
        ACTCtl_sAEXVI_Sum = ACTCtl_sAEXVI_Sum - ACTCtl_sAEXVI_Cor;
      }

      /* End of Switch: '<S705>/Switch' */
      break;

     case 2:
      /* Switch: '<S702>/Switch' */
      if (ACTCtl_bAEXVDvtFlg) {
        /* Switch: '<S701>/Switch2' incorporates:
         *  Delay: '<S697>/Delay'
         *  Sum: '<S702>/Add'
         *  Switch: '<S702>/Switch'
         */
        ACTCtl_sAEXVI_Sum = ACTCtl_sAEXVI_Sum + ACTCtl_sAEXVI_Cor;
      }

      /* End of Switch: '<S702>/Switch' */
      break;

     case 3:
      break;
    }

    /* End of MultiPortSwitch: '<S700>/Multiport Switch' */

    /* Switch: '<S701>/Switch2' incorporates:
     *  Constant: '<S680>/Constant8'
     *  Constant: '<S680>/Constant9'
     *  RelationalOperator: '<S701>/LowerRelop1'
     *  RelationalOperator: '<S701>/UpperRelop'
     *  Sum: '<S697>/Add'
     *  Switch: '<S701>/Switch'
     */
    if (ACTCtl_sAEXVI_Sum > cal_AEXVCtlKisumMax) {
      /* Switch: '<S697>/Switch1' incorporates:
       *  Switch: '<S701>/Switch2'
       */
      ACTCtl_sAEXVI_Sum = cal_AEXVCtlKisumMax;
    } else if (ACTCtl_sAEXVI_Sum < cal_AEXVCtlKisumMin) {
      /* Switch: '<S701>/Switch' incorporates:
       *  Constant: '<S680>/Constant9'
       *  Switch: '<S697>/Switch1'
       *  Switch: '<S701>/Switch2'
       */
      ACTCtl_sAEXVI_Sum = cal_AEXVCtlKisumMin;
    }

    /* End of Switch: '<S701>/Switch2' */
  } else {
    /* Switch: '<S697>/Switch1' incorporates:
     *  Constant: '<S680>/Constant'
     */
    ACTCtl_sAEXVI_Sum = 0.0F;
  }

  /* End of Switch: '<S697>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S698>/PI_Controller1' */
  /* Logic: '<S698>/Logical Operator' */
  ME11_PI_Controller1(!ACTCtl_bAEXVPIEnble, ACTCtl_sAEXVCtrlFF, (float32 *)
                      &ACTCtl_sAEXVPI_Cor, &rtb_IFreezFlag_o);

  /* End of Outputs for SubSystem: '<S698>/PI_Controller1' */

  /* Outputs for Enabled SubSystem: '<S699>/P_NEG' */
  /* Logic: '<S699>/Logical Operator' incorporates:
   *  Constant: '<S680>/Constant10'
   */
  ME11_P_NEG_h(!ACTCtl_bAEXVDvtFlg, ACTCtl_sAEXVDvt, rtb_PI_Cor_n,
               ACTCtl_sAEXVCtrlKp, cal_AEXVCtlKp, (float32 *)&ACTCtl_sAEXVP_Cor);

  /* End of Outputs for SubSystem: '<S699>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S699>/P_POS' */
  /* Constant: '<S680>/Constant10' */
  ME11_P_POS_c(ACTCtl_bAEXVDvtFlg, ACTCtl_sAEXVDvt, rtb_PI_Cor_n,
               ACTCtl_sAEXVCtrlKp, cal_AEXVCtlKp, (float32 *)&ACTCtl_sAEXVP_Cor);

  /* End of Outputs for SubSystem: '<S699>/P_POS' */

  /* Outputs for Enabled SubSystem: '<S698>/PI_Controller' */
  ME11_PI_Controller(ACTCtl_bAEXVPIEnble, ACTCtl_bAEXVDvtFlg, ACTCtl_sAEXVCtrlFF,
                     ACTCtl_sAEXVP_Cor, ACTCtl_sAEXVI_Sum, rtb_Gain6, rtb_Add_ok,
                     (float32 *)&ACTCtl_sAEXVPI_Cor, &rtb_IFreezFlag_o);

  /* End of Outputs for SubSystem: '<S698>/PI_Controller' */

  /* Switch: '<S743>/Switch1' incorporates:
   *  Constant: '<S739>/Constant6'
   *  Constant: '<S739>/Constant8'
   *  RelationalOperator: '<S743>/Relational Operator'
   *  RelationalOperator: '<S743>/Relational Operator1'
   *  Sum: '<S743>/Add2'
   *  Sum: '<S743>/Add3'
   *  Switch: '<S743>/Switch3'
   */
  if (cal_AEXVDiffUp <= ACTCtl_sAEXVPI_Cor - rtb_PI_Cor_d) {
    /* Switch: '<S743>/Switch1' incorporates:
     *  Constant: '<S739>/Constant5'
     *  Sum: '<S743>/Add1'
     */
    rtb_PI_Cor_n = cal_AEXVDiffUpRate + rtb_PI_Cor_d;
  } else if (rtb_PI_Cor_d - ACTCtl_sAEXVPI_Cor >= cal_AEXVDiffDown) {
    /* Switch: '<S743>/Switch3' incorporates:
     *  Constant: '<S739>/Constant7'
     *  Sum: '<S743>/Add4'
     *  Switch: '<S743>/Switch1'
     */
    rtb_PI_Cor_n = rtb_PI_Cor_d - cal_AEXVDiffDownRate;
  } else {
    /* Switch: '<S743>/Switch1' incorporates:
     *  Switch: '<S743>/Switch3'
     */
    rtb_PI_Cor_n = ACTCtl_sAEXVPI_Cor;
  }

  /* End of Switch: '<S743>/Switch1' */

  /* Chart: '<S744>/PwrOn' */
  ME11_PwrOn(&rtb_flg_f, &ME11_ARID_DEF.ARID_DEF_PwrOn_l);

  /* Switch: '<S739>/Switch1' incorporates:
   *  Constant: '<S739>/Constant3'
   *  Constant: '<S739>/Constant4'
   *  Logic: '<S739>/AND1'
   *  Logic: '<S739>/AND2'
   *  RelationalOperator: '<S739>/Relational Operator2'
   *  RelationalOperator: '<S739>/Relational Operator3'
   */
  if (((ACSen_sLoPressFilter <= cal_AEXVLowPressLmtOn) || (ACSen_sHiPressFilter >=
        cal_AEXVHighPressLmtOn)) && rtb_Delay1_ag) {
    /* MinMax: '<S739>/Max' */
    if (rtb_PI_Cor_d >= rtb_PI_Cor_n) {
      /* Switch: '<S739>/Switch1' */
      rtb_PI_Cor_n = rtb_PI_Cor_d;
    }

    /* End of MinMax: '<S739>/Max' */
  }

  /* End of Switch: '<S739>/Switch1' */

  /* Switch: '<S744>/Switch2' incorporates:
   *  Constant: '<S744>/DownLmt1'
   *  Constant: '<S744>/UpLmt2'
   *  Delay: '<S744>/Delay'
   *  RelationalOperator: '<S744>/Relational Operator'
   *  RelationalOperator: '<S744>/Relational Operator1'
   *  Sum: '<S744>/Add2'
   *  Sum: '<S744>/Add3'
   *  Switch: '<S744>/Switch'
   *  Switch: '<S744>/Switch1'
   */
  if (rtb_flg_f) {
    ME11_ARID_DEF.Delay_DSTATE_g = rtb_PI_Cor_n;
  } else if (rtb_PI_Cor_n > ME11_ARID_DEF.Delay_DSTATE_g + cal_AEXVUpSpdLmt) {
    /* Switch: '<S744>/Switch' incorporates:
     *  Constant: '<S744>/UpLmt'
     *  Delay: '<S744>/Delay'
     *  Sum: '<S744>/Add'
     */
    ME11_ARID_DEF.Delay_DSTATE_g += cal_AEXVUpSpdLmt;
  } else if (rtb_PI_Cor_n < ME11_ARID_DEF.Delay_DSTATE_g - cal_AEXVDownSpdLmt) {
    /* Switch: '<S744>/Switch1' incorporates:
     *  Constant: '<S744>/DownLmt'
     *  Delay: '<S744>/Delay'
     *  Sum: '<S744>/Add1'
     *  Switch: '<S744>/Switch'
     */
    ME11_ARID_DEF.Delay_DSTATE_g -= cal_AEXVDownSpdLmt;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_g = rtb_PI_Cor_n;
  }

  /* End of Switch: '<S744>/Switch2' */

  /* Chart: '<S745>/PwrOn' */
  ME11_PwrOn(&rtb_flg_dg, &ME11_ARID_DEF.ARID_DEF_PwrOn_dy);

  /* Switch: '<S745>/Switch2' incorporates:
   *  Constant: '<S745>/DownLmt1'
   *  Constant: '<S745>/UpLmt2'
   *  Delay: '<S745>/Delay'
   *  RelationalOperator: '<S745>/Relational Operator'
   *  RelationalOperator: '<S745>/Relational Operator1'
   *  Sum: '<S745>/Add2'
   *  Sum: '<S745>/Add3'
   *  Switch: '<S745>/Switch'
   *  Switch: '<S745>/Switch1'
   */
  if (rtb_flg_dg) {
    ME11_ARID_DEF.Delay_DSTATE_iw = ACTCtl_sAEXVPI_Cor;
  } else if (ACTCtl_sAEXVPI_Cor > ME11_ARID_DEF.Delay_DSTATE_iw +
             cal_AEXVOpenCtrlUpSpdLmt) {
    /* Switch: '<S745>/Switch' incorporates:
     *  Constant: '<S745>/UpLmt'
     *  Delay: '<S745>/Delay'
     *  Sum: '<S745>/Add'
     */
    ME11_ARID_DEF.Delay_DSTATE_iw += cal_AEXVOpenCtrlUpSpdLmt;
  } else if (ACTCtl_sAEXVPI_Cor < ME11_ARID_DEF.Delay_DSTATE_iw -
             cal_AEXVOpenCtrlDownSpdLmt) {
    /* Switch: '<S745>/Switch1' incorporates:
     *  Constant: '<S745>/DownLmt'
     *  Delay: '<S745>/Delay'
     *  Sum: '<S745>/Add1'
     *  Switch: '<S745>/Switch'
     */
    ME11_ARID_DEF.Delay_DSTATE_iw -= cal_AEXVOpenCtrlDownSpdLmt;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_iw = ACTCtl_sAEXVPI_Cor;
  }

  /* End of Switch: '<S745>/Switch2' */

  /* Switch: '<S683>/Switch3' incorporates:
   *  Constant: '<S683>/Constant'
   *  Constant: '<S683>/Constant2'
   *  Constant: '<S735>/Constant'
   *  Constant: '<S736>/Constant'
   *  Logic: '<S683>/AND'
   *  Logic: '<S683>/AND1'
   *  RelationalOperator: '<S683>/Relational Operator'
   *  RelationalOperator: '<S683>/Relational Operator1'
   *  RelationalOperator: '<S735>/Compare'
   *  RelationalOperator: '<S736>/Compare'
   *  Switch: '<S683>/Switch'
   *  Switch: '<S683>/Switch2'
   *  Switch: '<S739>/Switch5'
   */
  if (rtb_IFreezFlag_bd >= 3) {
    /* Sum: '<S683>/Add1' incorporates:
     *  Delay: '<S683>/Delay'
     */
    ME11_ARID_DEF.Delay_DSTATE_k3 = ME11_ARID_DEF.ACTCtl_sAEXVVal;
  } else if (rtb_IFreezFlag_bd >= 1) {
    /* Sum: '<S683>/Add1' incorporates:
     *  Constant: '<S683>/Constant7'
     *  Switch: '<S683>/Switch2'
     */
    ME11_ARID_DEF.Delay_DSTATE_k3 = rtb_PI_Cor_d - cal_AEXVFltClsSpd;

    /* MinMax: '<S683>/Max' incorporates:
     *  Constant: '<S683>/Constant3'
     *  Switch: '<S683>/Switch2'
     */
    if (cal_AEXVClsValEvapPrt >= ME11_ARID_DEF.Delay_DSTATE_k3) {
      /* Sum: '<S683>/Add1' incorporates:
       *  Delay: '<S683>/Delay'
       *  Switch: '<S683>/Switch2'
       */
      ME11_ARID_DEF.Delay_DSTATE_k3 = cal_AEXVClsValEvapPrt;
    }

    /* End of MinMax: '<S683>/Max' */
  } else if (((ACSen_sHiPressFilter >= cal_AEXVHighPressProhOn) ||
              (ACSen_sLoPressFilter <= cal_AEXVLowPressProhOn)) && rtb_Delay1_ag)
  {
    /* Sum: '<S683>/Add1' incorporates:
     *  Constant: '<S683>/Constant1'
     *  Delay: '<S683>/Delay'
     *  Sum: '<S683>/Add'
     *  Switch: '<S683>/Switch'
     *  Switch: '<S683>/Switch2'
     */
    ME11_ARID_DEF.Delay_DSTATE_k3 = rtb_PI_Cor_d + cal_AEXVOpenValveSpd;
  } else if (ACTCtl_bAEXVPIEnble) {
    /* Sum: '<S683>/Add1' incorporates:
     *  Delay: '<S683>/Delay'
     *  Delay: '<S744>/Delay'
     *  Switch: '<S683>/Switch'
     *  Switch: '<S683>/Switch2'
     *  Switch: '<S739>/Switch5'
     */
    ME11_ARID_DEF.Delay_DSTATE_k3 = ME11_ARID_DEF.Delay_DSTATE_g;
  } else {
    /* Sum: '<S683>/Add1' incorporates:
     *  Delay: '<S683>/Delay'
     *  Delay: '<S745>/Delay'
     *  Switch: '<S683>/Switch'
     *  Switch: '<S683>/Switch2'
     *  Switch: '<S739>/Switch5'
     */
    ME11_ARID_DEF.Delay_DSTATE_k3 = ME11_ARID_DEF.Delay_DSTATE_iw;
  }

  /* End of Switch: '<S683>/Switch3' */

  /* Switch: '<S740>/Switch' incorporates:
   *  Constant: '<S740>/Constant1'
   */
  if (cal_AEXVPosDataEnb) {
    /* Switch: '<S740>/Switch' incorporates:
     *  Constant: '<S740>/Constant'
     */
    ACTCtl_sAEXVPos = cal_AEXVPosData;
  } else {
    /* Rounding: '<S742>/Floor' incorporates:
     *  Delay: '<S683>/Delay'
     */
    ACTCtl_sAEXVPos = (float32)floor(ME11_ARID_DEF.Delay_DSTATE_k3);

    /* Sum: '<S742>/Add' incorporates:
     *  Delay: '<S683>/Delay'
     */
    rtb_PI_Cor_n = ME11_ARID_DEF.Delay_DSTATE_k3 - ACTCtl_sAEXVPos;

    /* Switch: '<S742>/Switch' incorporates:
     *  Constant: '<S742>/Constant'
     *  Constant: '<S742>/Constant1'
     *  RelationalOperator: '<S742>/Relational Operator'
     *  RelationalOperator: '<S742>/Relational Operator1'
     *  Switch: '<S742>/Switch1'
     */
    if (cal_AEXVFloorDiff2 < rtb_PI_Cor_n) {
      /* Switch: '<S740>/Switch' incorporates:
       *  Constant: '<S742>/Constant2'
       *  Sum: '<S742>/Add1'
       *  Switch: '<S742>/Switch'
       */
      ACTCtl_sAEXVPos = ACTCtl_sAEXVPos + 1.0F;
    } else if (cal_AEXVFloorDiff1 < rtb_PI_Cor_n) {
      /* Switch: '<S742>/Switch1' incorporates:
       *  Constant: '<S742>/Constant3'
       *  Sum: '<S742>/Add2'
       *  Switch: '<S740>/Switch'
       */
      ACTCtl_sAEXVPos = ACTCtl_sAEXVPos + 0.5F;
    }

    /* End of Switch: '<S742>/Switch' */
  }

  /* End of Switch: '<S740>/Switch' */

  /* Switch: '<S741>/Switch2' incorporates:
   *  Constant: '<S683>/Constant5'
   *  Constant: '<S683>/Constant6'
   *  RelationalOperator: '<S741>/LowerRelop1'
   *  RelationalOperator: '<S741>/UpperRelop'
   *  Switch: '<S741>/Switch'
   */
  if (ACTCtl_sAEXVPos > 100.0F) {
    /* Switch: '<S741>/Switch2' */
    ACTCtl_sAEXVPos = 100.0F;
  } else if (ACTCtl_sAEXVPos < 0.0F) {
    /* Switch: '<S741>/Switch' incorporates:
     *  Constant: '<S683>/Constant6'
     *  Switch: '<S741>/Switch2'
     */
    ACTCtl_sAEXVPos = 0.0F;
  }

  /* End of Switch: '<S741>/Switch2' */

  /* Lookup_n-D: '<S783>/cal_BEXVCtrlBFF_CUR' incorporates:
   *  Switch: '<S451>/Switch2'
   */
  ACTCtl_sBEXVCtrlBFF = look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
    &cal_BEXVCtrlBFF_1X[0], (const float32 *)&cal_BEXVCtrlBFF_CUR[0], 4U);

  /* Sum: '<S676>/Add5' */
  ACTCtl_sChiSuperHeat = ACSen_sChiTempFilter - rtb_Delay;

  /* Switch: '<S908>/Init' incorporates:
   *  Constant: '<S898>/Constant1'
   *  Constant: '<S907>/Constant'
   *  Product: '<S907>/Product'
   *  Product: '<S907>/Product1'
   *  Sum: '<S907>/Sum'
   *  Sum: '<S907>/Sum1'
   *  UnitDelay: '<S908>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_h != 0) {
    ACTCtl_sChiSuperHeatAvg1 = ACTCtl_sChiSuperHeat;
  }

  ACTCtl_sChiSuperHeatAvg1 = (1.0F - cal_SuperHeatFilter) *
    ACTCtl_sChiSuperHeatAvg1 + ACTCtl_sChiSuperHeat * cal_SuperHeatFilter;

  /* End of Switch: '<S908>/Init' */

  /* Product: '<S898>/Divide' incorporates:
   *  Constant: '<S898>/Constant'
   *  Delay: '<S898>/Delay'
   *  Delay: '<S898>/Delay1'
   *  Delay: '<S898>/Delay2'
   *  Delay: '<S898>/Delay3'
   *  Sum: '<S898>/Add'
   */
  ACTCtl_sChiSuperHeatAvg = ((((ACTCtl_sChiSuperHeat +
    ME11_ARID_DEF.Delay1_DSTATE_e) + ME11_ARID_DEF.Delay_DSTATE_c[0]) +
    ME11_ARID_DEF.Delay2_DSTATE_k[0]) + ME11_ARID_DEF.Delay3_DSTATE_b[0]) / 5.0F;

  /* Switch: '<S676>/Switch5' incorporates:
   *  Constant: '<S676>/Constant6'
   */
  if (cal_AvgSwitch) {
    /* Switch: '<S676>/Switch5' */
    ACTCtl_sBEXVActure = ACTCtl_sChiSuperHeatAvg1;
  } else {
    /* Switch: '<S676>/Switch5' */
    ACTCtl_sBEXVActure = ACTCtl_sChiSuperHeatAvg;
  }

  /* End of Switch: '<S676>/Switch5' */

  /* Switch: '<S783>/Switch' incorporates:
   *  Constant: '<S786>/Constant'
   *  RelationalOperator: '<S786>/Compare'
   */
  if (ME11_ARID_DEF.DataTypeConversion1 == 4) {
    /* Gain: '<S8>/Gain6' incorporates:
     *  Constant: '<S783>/Constant10'
     */
    rtb_Gain6 = 0.0F;
  } else {
    /* Gain: '<S8>/Gain6' incorporates:
     *  Lookup_n-D: '<S783>/cal_BEXVCtrlBTrgCabinComp_CUR'
     *  Sum: '<S783>/Add3'
     *  UnitDelay: '<S225>/FixPt Unit Delay1'
     */
    rtb_Gain6 = look1_iflf_binlca(ACCtl_tLeftDuct -
      ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_dn, (const float32 *)
      &cal_BEXVCtrlBTrgCabinComp_1X[0], (const float32 *)
      &cal_BEXVCtrlBTrgCabinComp_CUR[0], 4U);
  }

  /* End of Switch: '<S783>/Switch' */

  /* Outputs for Enabled SubSystem: '<S783>/Descending_filter' */
  /* Logic: '<S783>/OR' incorporates:
   *  Constant: '<S783>/Constant11'
   *  Constant: '<S783>/Constant12'
   *  Constant: '<S787>/Constant'
   *  Lookup_n-D: '<S783>/cal_BEXVCtrlBTrgWtrTempDiff_CUR'
   *  RelationalOperator: '<S787>/Compare'
   *  Sum: '<S783>/Add'
   *  Sum: '<S783>/Add2'
   */
  ME11_Descending_filter((rtb_Add_b1 == 3) || (rtb_Add_b1 == 14),
    ACTCtl_sBEXVActure, look1_iflf_binlca(BMS_InletCooltActlTemp -
    cal_BatCoolInletTrgTemp, (const float32 *)&cal_BEXVCtrlBTrgWtrTempDiff_1X[0],
    (const float32 *)&cal_BEXVCtrlBTrgWtrTempDiff_CUR[0], 5U) + rtb_Gain6,
    cal_BEXVSubHeatflt, COMP_EcompActSpd, &ME11_ARID_DEF.Init_b,
    &ME11_ARID_DEF.ARID_DEF_Descending_filter_d);

  /* End of Outputs for SubSystem: '<S783>/Descending_filter' */

  /* Outputs for Enabled SubSystem: '<S784>/Descending_filter' */
  /* RelationalOperator: '<S795>/Compare' incorporates:
   *  Constant: '<S784>/Constant10'
   *  Constant: '<S795>/Constant'
   *  Lookup_n-D: '<S784>/cal_BEXVCtrlCTrg_CUR'
   *  Switch: '<S451>/Switch2'
   */
  ME11_Descending_filter(rtb_Add_b1 == 2, rtb_ACFanLevel5EnvCor,
    look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)&cal_BEXVCtrlCTrg_1X
                      [0], (const float32 *)&cal_BEXVCtrlCTrg_CUR[0], 4U),
    cal_BEXVSubCoolflt, COMP_EcompActSpd, &ME11_ARID_DEF.Init_e,
    &ME11_ARID_DEF.ARID_DEF_Descending_filter_ld);

  /* End of Outputs for SubSystem: '<S784>/Descending_filter' */

  /* MultiPortSwitch: '<S751>/Multiport Switch' */
  switch (rtb_Add_b1) {
   case 1:
   case 4:
   case 5:
   case 6:
   case 7:
   case 8:
   case 12:
    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S782>/Constant'
     */
    rtb_Merge = 0.0F;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S782>/Constant'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlFF = 0.0F;

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S782>/Constant'
     */
    rtb_Merge1 = 0.0F;

    /* SignalConversion: '<S674>/Signal Copy' incorporates:
     *  Constant: '<S782>/Constant'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVSetPoint = 0.0F;

    /* SignalConversion: '<S674>/Signal Copy1' incorporates:
     *  Constant: '<S782>/Constant'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVActure = 0.0F;

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S782>/Constant'
     */
    rtb_PI_Cor_n = 0.0F;

    /* SignalConversion: '<S674>/Signal Copy2' incorporates:
     *  Constant: '<S782>/Constant'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVCtrlKp = 0.0F;

    /* SignalConversion: '<S674>/Signal Copy3' incorporates:
     *  Constant: '<S782>/Constant'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVCtrlKi = 0.0F;

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S782>/Constant'
     *  Constant: '<S782>/Constant1'
     */
    rtb_Gain6 = 0.0F;
    rtb_Add_ok = 0.0F;
    b_previousEvent = 0;
    break;

   case 3:
   case 14:
    /* Sum: '<S783>/Add1' */
    rtb_PI_Cor_d = ME11_ARID_DEF.Init_b - ACTCtl_sBEXVActure;

    /* Switch: '<S783>/Switch1' incorporates:
     *  Constant: '<S788>/Constant'
     *  RelationalOperator: '<S788>/Compare'
     */
    if (rtb_Add_b1 == 3) {
      /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
       *  Lookup_n-D: '<S783>/cal_BEXVCtrlBDCoolPIMin_CUR'
       *  SignalConversion: '<S2>/Signal Copy122'
       *  Switch: '<S783>/Switch1'
       */
      rtb_Add_ok = look1_iflf_binlca(COMP_EcompActSpd, (const float32 *)
        &cal_BEXVCtrlBDCoolPIMin_1X[0], (const float32 *)
        &cal_BEXVCtrlBDCoolPIMin_CUR[0], 5U);
    } else {
      /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
       *  Constant: '<S783>/Constant7'
       *  Switch: '<S783>/Switch1'
       */
      rtb_Add_ok = cal_BEXVCtrlBPIDown;
    }

    /* End of Switch: '<S783>/Switch1' */

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S783>/Constant'
     */
    rtb_Merge = cal_BEXVCtrlBDelayTime;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S783>/Constant1'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlFF = cal_BEXVCtrlBOpenVal;

    /* MultiPortSwitch: '<S751>/Multiport Switch' */
    rtb_Merge1 = ACTCtl_sBEXVCtrlBFF;

    /* SignalConversion: '<S674>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVSetPoint = ME11_ARID_DEF.Init_b;

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S783>/Constant3'
     */
    rtb_PI_Cor_n = cal_BEXVCtrlBDeadzone;

    /* SignalConversion: '<S674>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S783>/cal_BEXVCtrlBKp_CUR'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     *  Sum: '<S783>/Add1'
     */
    ACTCtl_sBEXVCtrlKp = look1_iflf_binlca(rtb_PI_Cor_d, (const float32 *)
      &cal_BEXVCtrlBKp_1X[0], (const float32 *)&cal_BEXVCtrlBKp_CUR[0], 6U);

    /* SignalConversion: '<S674>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S783>/cal_BEXVCtrlBKi_CUR'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     *  Sum: '<S783>/Add1'
     */
    ACTCtl_sBEXVCtrlKi = look1_iflf_binlca(rtb_PI_Cor_d, (const float32 *)
      &cal_BEXVCtrlBKi_1X[0], (const float32 *)&cal_BEXVCtrlBKi_CUR[0], 6U);

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S783>/Constant2'
     *  Constant: '<S783>/Constant6'
     */
    rtb_Gain6 = cal_BEXVCtrlBPIUp;
    b_previousEvent = 1;
    break;

   case 2:
   case 13:
    /* Sum: '<S784>/Add' */
    rtb_PI_Cor_d = ME11_ARID_DEF.Init_e - rtb_ACFanLevel5EnvCor;

    /* Switch: '<S784>/Switch' incorporates:
     *  Constant: '<S796>/Constant'
     *  RelationalOperator: '<S796>/Compare'
     */
    if (rtb_Add_b1 == 2) {
      /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
       *  Lookup_n-D: '<S784>/cal_BEXVCtrlCBatCoolPIMin_CUR'
       *  SignalConversion: '<S2>/Signal Copy122'
       *  Switch: '<S784>/Switch'
       */
      rtb_Add_ok = look1_iflf_binlca(COMP_EcompActSpd, (const float32 *)
        &cal_BEXVCtrlCBatCoolPIMin_1X[0], (const float32 *)
        &cal_BEXVCtrlCBatCoolPIMin_CUR[0], 5U);
    } else {
      /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
       *  Constant: '<S784>/Constant7'
       *  Switch: '<S784>/Switch'
       */
      rtb_Add_ok = cal_BEXVCtrlCPIMin;
    }

    /* End of Switch: '<S784>/Switch' */

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S784>/Constant'
     */
    rtb_Merge = cal_BEXVCtrlCDelayTime;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S784>/Constant1'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlFF = cal_BEXVCtrlCOpenVal;

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Lookup_n-D: '<S784>/cal_BEXVCtrlCFF_CUR'
     *  Switch: '<S451>/Switch2'
     */
    rtb_Merge1 = look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
      &cal_BEXVCtrlCFF_1X[0], (const float32 *)&cal_BEXVCtrlCFF_CUR[0], 4U);

    /* SignalConversion: '<S674>/Signal Copy' incorporates:
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVSetPoint = ME11_ARID_DEF.Init_e;

    /* SignalConversion: '<S674>/Signal Copy1' incorporates:
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVActure = rtb_ACFanLevel5EnvCor;

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S784>/Constant3'
     */
    rtb_PI_Cor_n = cal_BEXVCtrlCDeadzone;

    /* SignalConversion: '<S674>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S784>/cal_BEXVCtrlCKp_CUR'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     *  Sum: '<S784>/Add'
     */
    ACTCtl_sBEXVCtrlKp = look1_iflf_binlca(rtb_PI_Cor_d, (const float32 *)
      &cal_BEXVCtrlCKp_1X[0], (const float32 *)&cal_BEXVCtrlCKp_CUR[0], 7U);

    /* SignalConversion: '<S674>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S784>/cal_BEXVCtrlCKi_CUR'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     *  Sum: '<S784>/Add'
     */
    ACTCtl_sBEXVCtrlKi = look1_iflf_binlca(rtb_PI_Cor_d, (const float32 *)
      &cal_BEXVCtrlCKi_1X[0], (const float32 *)&cal_BEXVCtrlCKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S784>/Constant6'
     *  Constant: '<S784>/Constant8'
     */
    rtb_Gain6 = cal_BEXVCtrlCPIMax;
    b_previousEvent = 1;
    break;

   default:
    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S785>/Constant1'
     */
    rtb_Merge = 50.0F;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S785>/Constant1'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlFF = 50.0F;

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S785>/Constant1'
     */
    rtb_Merge1 = 50.0F;

    /* SignalConversion: '<S674>/Signal Copy' incorporates:
     *  Constant: '<S785>/Constant1'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVSetPoint = 50.0F;

    /* SignalConversion: '<S674>/Signal Copy1' incorporates:
     *  Constant: '<S785>/Constant1'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVActure = 50.0F;

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S785>/Constant1'
     */
    rtb_PI_Cor_n = 50.0F;

    /* SignalConversion: '<S674>/Signal Copy2' incorporates:
     *  Constant: '<S785>/Constant1'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVCtrlKp = 50.0F;

    /* SignalConversion: '<S674>/Signal Copy3' incorporates:
     *  Constant: '<S785>/Constant1'
     *  MultiPortSwitch: '<S751>/Multiport Switch'
     */
    ACTCtl_sBEXVCtrlKi = 50.0F;

    /* MultiPortSwitch: '<S751>/Multiport Switch' incorporates:
     *  Constant: '<S785>/Constant1'
     *  Constant: '<S785>/Constant2'
     */
    rtb_Gain6 = 50.0F;
    rtb_Add_ok = 50.0F;
    b_previousEvent = 0;
    break;
  }

  /* End of MultiPortSwitch: '<S751>/Multiport Switch' */

  /* Chart: '<S752>/FFCal' incorporates:
   *  Delay: '<S503>/Delay'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_l2 < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i1_l2++;
  }

  if (ME11_ARID_DEF.is_active_c48_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c48_ME11 = 1U;
    ME11_ARID_DEF.is_c48_ME11 = ME11_IN_Init_i;
    ME11_ARID_DEF.PID_Enble_b = false;
    ACTCtl_sBEXVCtrlFF = ACTCtl_sHPEXVCtrlFF;
    ME11_ARID_DEF.BEXVCtrlEnb = true;
  } else if (ME11_ARID_DEF.is_c48_ME11 == ME11_IN_Init_i) {
    ME11_ARID_DEF.PID_Enble_b = false;
    ME11_ARID_DEF.BEXVCtrlEnb = true;
    if (ME11_ARID_DEF.Delay_DSTATE_kf) {
      ME11_ARID_DEF.is_c48_ME11 = ME11_IN_On_li;
      ME11_ARID_DEF.is_On_b = ME11_IN_OpenCtrl;
      ME11_ARID_DEF.temporalCounter_i1_l2 = 0U;
      ACTCtl_sBEXVCtrlFF = ACTCtl_sHPEXVCtrlFF;
      ME11_ARID_DEF.BEXVCtrlEnb = true;
    } else {
      ACTCtl_sBEXVCtrlFF = ACTCtl_sHPEXVCtrlFF;
    }

    /* case IN_On: */
  } else if (!ME11_ARID_DEF.Delay_DSTATE_kf) {
    ME11_ARID_DEF.is_On_b = ME11_IN_NO_ACTIVE_CHILD_gl;
    ME11_ARID_DEF.is_c48_ME11 = ME11_IN_Init_i;
    ME11_ARID_DEF.PID_Enble_b = false;
    ACTCtl_sBEXVCtrlFF = ACTCtl_sHPEXVCtrlFF;
    ME11_ARID_DEF.BEXVCtrlEnb = true;
  } else if (ME11_ARID_DEF.is_On_b == ME11_IN_CloseCtrl) {
    ME11_ARID_DEF.PID_Enble_b = true;
    ACTCtl_sBEXVCtrlFF = rtb_Merge1;
  } else {
    /* case IN_OpenCtrl: */
    ME11_ARID_DEF.BEXVCtrlEnb = true;
    if (ME11_ARID_DEF.temporalCounter_i1_l2 >= rtb_Merge * 10.0F) {
      ME11_ARID_DEF.is_On_b = ME11_IN_CloseCtrl;
      ME11_ARID_DEF.PID_Enble_b = true;
      ACTCtl_sBEXVCtrlFF = rtb_Merge1;
    } else {
      ACTCtl_sBEXVCtrlFF = ACTCtl_sHPEXVCtrlFF;
    }
  }

  /* End of Chart: '<S752>/FFCal' */

  /* Logic: '<S674>/AND' */
  ACTCtl_bBEXVPIEnble = (ME11_ARID_DEF.PID_Enble_b && (b_previousEvent != 0));

  /* RelationalOperator: '<S763>/Compare' incorporates:
   *  Constant: '<S763>/Constant'
   */
  ACTCtl_bBEXVInitFinishFlg = (ACTCtl_bBEXVInitReq < 1);

  /* Switch: '<S749>/Switch' incorporates:
   *  Constant: '<S749>/Constant'
   *  Constant: '<S759>/Constant'
   *  Constant: '<S760>/Constant'
   *  Constant: '<S761>/Constant'
   *  Constant: '<S762>/Constant'
   *  Delay: '<S749>/Delay'
   *  Delay: '<S749>/Delay1'
   *  Logic: '<S749>/AND1'
   *  RelationalOperator: '<S759>/Compare'
   *  RelationalOperator: '<S760>/Compare'
   *  RelationalOperator: '<S761>/Compare'
   *  RelationalOperator: '<S762>/Compare'
   *  Switch: '<S749>/Switch1'
   *  Switch: '<S749>/Switch2'
   */
  if ((ME11_ARID_DEF.Delay1_DSTATE_a < 2) && (ME11_ARID_DEF.DataTypeConversion1 >=
       2)) {
    ME11_ARID_DEF.Delay_DSTATE_hqw = 1U;
  } else if (BAT_EXV_CurrentInitState_B == 2) {
    /* Delay: '<S749>/Delay' incorporates:
     *  Constant: '<S749>/Constant1'
     *  Switch: '<S749>/Switch1'
     */
    ME11_ARID_DEF.Delay_DSTATE_hqw = 0U;
  } else if (BAT_EXV_CurrentInitState_B == 1) {
    /* Switch: '<S749>/Switch2' incorporates:
     *  Constant: '<S749>/Constant2'
     *  Delay: '<S749>/Delay'
     *  Switch: '<S749>/Switch1'
     */
    ME11_ARID_DEF.Delay_DSTATE_hqw = 2U;
  }

  /* End of Switch: '<S749>/Switch' */

  /* Switch: '<S764>/Switch' incorporates:
   *  Constant: '<S764>/Constant1'
   */
  if (cal_BEXVInitReqDataeEnb) {
    /* Switch: '<S764>/Switch' incorporates:
     *  Constant: '<S764>/Constant'
     */
    ACTCtl_bBEXVInitReq = cal_BEXVInitReqData;
  } else {
    /* Switch: '<S764>/Switch' incorporates:
     *  Delay: '<S749>/Delay'
     */
    ACTCtl_bBEXVInitReq = ME11_ARID_DEF.Delay_DSTATE_hqw;
  }

  /* End of Switch: '<S764>/Switch' */

  /* Sum: '<S753>/Sum' */
  ACTCtl_sBEXVDvt = ACTCtl_sBEXVSetPoint - ACTCtl_sBEXVActure;

  /* Chart: '<S753>/deadzone' */
  ME11_deadzone_h1(ACTCtl_sBEXVDvt, rtb_PI_Cor_n, &rtb_flag_l);

  /* RelationalOperator: '<S753>/Relational Operator' */
  rtb_Delay1_ag = (ACTCtl_sBEXVSetPoint >= ACTCtl_sBEXVActure);

  /* Switch: '<S753>/Switch1' incorporates:
   *  Switch: '<S753>/Switch'
   */
  if (rtb_flag_l) {
    /* Switch: '<S753>/Switch1' incorporates:
     *  Constant: '<S753>/Constant'
     */
    ACTCtl_sBEXVDvt = 0.0F;
  } else if (!rtb_Delay1_ag) {
    /* Switch: '<S753>/Switch1' incorporates:
     *  Sum: '<S753>/Sum1'
     *  Switch: '<S753>/Switch'
     */
    ACTCtl_sBEXVDvt = ACTCtl_sBEXVActure - ACTCtl_sBEXVSetPoint;
  }

  /* End of Switch: '<S753>/Switch1' */

  /* Logic: '<S753>/NOT' */
  ACTCtl_bBEXVDvtFlg = !rtb_Delay1_ag;

  /* Outputs for Enabled SubSystem: '<S768>/P_NEG' */
  /* Logic: '<S768>/Logical Operator' incorporates:
   *  Constant: '<S750>/Constant11'
   */
  ME11_P_NEG(!ACTCtl_bBEXVDvtFlg, ACTCtl_sBEXVDvt, rtb_PI_Cor_n,
             ACTCtl_sBEXVCtrlKi, cal_BEXVCtlKi, (float32 *)&ACTCtl_sBEXVI_Cor);

  /* End of Outputs for SubSystem: '<S768>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S768>/P_POS' */
  /* Constant: '<S750>/Constant11' */
  ME11_P_POS(ACTCtl_bBEXVDvtFlg, ACTCtl_sBEXVDvt, rtb_PI_Cor_n,
             ACTCtl_sBEXVCtrlKi, cal_BEXVCtlKi, (float32 *)&ACTCtl_sBEXVI_Cor);

  /* End of Outputs for SubSystem: '<S768>/P_POS' */

  /* Switch: '<S765>/Switch1' */
  if (ACTCtl_bBEXVPIEnble) {
    /* MultiPortSwitch: '<S768>/Multiport Switch' incorporates:
     *  Delay: '<S768>/Delay'
     */
    switch (ME11_ARID_DEF.Delay_DSTATE_bmz) {
     case 0:
      /* Switch: '<S772>/Switch' */
      if (ACTCtl_bBEXVDvtFlg) {
        /* Switch: '<S769>/Switch2' incorporates:
         *  Delay: '<S765>/Delay'
         *  Sum: '<S772>/Add'
         *  Switch: '<S772>/Switch'
         */
        ACTCtl_sBEXVI_Sum = ACTCtl_sBEXVI_Sum + ACTCtl_sBEXVI_Cor;
      } else {
        /* Switch: '<S769>/Switch2' incorporates:
         *  Delay: '<S765>/Delay'
         *  Sum: '<S772>/Add1'
         *  Switch: '<S772>/Switch'
         */
        ACTCtl_sBEXVI_Sum = ACTCtl_sBEXVI_Sum - ACTCtl_sBEXVI_Cor;
      }

      /* End of Switch: '<S772>/Switch' */
      break;

     case 1:
      /* Switch: '<S773>/Switch' */
      if (!ACTCtl_bBEXVDvtFlg) {
        /* Switch: '<S769>/Switch2' incorporates:
         *  Delay: '<S765>/Delay'
         *  Sum: '<S773>/Add1'
         *  Switch: '<S773>/Switch'
         */
        ACTCtl_sBEXVI_Sum = ACTCtl_sBEXVI_Sum - ACTCtl_sBEXVI_Cor;
      }

      /* End of Switch: '<S773>/Switch' */
      break;

     case 2:
      /* Switch: '<S770>/Switch' */
      if (ACTCtl_bBEXVDvtFlg) {
        /* Switch: '<S769>/Switch2' incorporates:
         *  Delay: '<S765>/Delay'
         *  Sum: '<S770>/Add'
         *  Switch: '<S770>/Switch'
         */
        ACTCtl_sBEXVI_Sum = ACTCtl_sBEXVI_Sum + ACTCtl_sBEXVI_Cor;
      }

      /* End of Switch: '<S770>/Switch' */
      break;

     case 3:
      break;
    }

    /* End of MultiPortSwitch: '<S768>/Multiport Switch' */

    /* Switch: '<S769>/Switch2' incorporates:
     *  Constant: '<S750>/Constant8'
     *  Constant: '<S750>/Constant9'
     *  RelationalOperator: '<S769>/LowerRelop1'
     *  RelationalOperator: '<S769>/UpperRelop'
     *  Sum: '<S765>/Add'
     *  Switch: '<S769>/Switch'
     */
    if (ACTCtl_sBEXVI_Sum > cal_BEXVCtlKisumMax) {
      /* Switch: '<S765>/Switch1' incorporates:
       *  Switch: '<S769>/Switch2'
       */
      ACTCtl_sBEXVI_Sum = cal_BEXVCtlKisumMax;
    } else if (ACTCtl_sBEXVI_Sum < cal_BEXVCtlKisumMin) {
      /* Switch: '<S769>/Switch' incorporates:
       *  Constant: '<S750>/Constant9'
       *  Switch: '<S765>/Switch1'
       *  Switch: '<S769>/Switch2'
       */
      ACTCtl_sBEXVI_Sum = cal_BEXVCtlKisumMin;
    }

    /* End of Switch: '<S769>/Switch2' */
  } else {
    /* Switch: '<S765>/Switch1' incorporates:
     *  Constant: '<S750>/Constant'
     */
    ACTCtl_sBEXVI_Sum = 0.0F;
  }

  /* End of Switch: '<S765>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S766>/PI_Controller1' */
  /* Logic: '<S766>/Logical Operator' */
  ME11_PI_Controller1(!ACTCtl_bBEXVPIEnble, ACTCtl_sBEXVCtrlFF, (float32 *)
                      &ACTCtl_sBEXVPI_Cor, &rtb_IFreezFlag_m);

  /* End of Outputs for SubSystem: '<S766>/PI_Controller1' */

  /* Outputs for Enabled SubSystem: '<S767>/P_NEG' */
  /* Logic: '<S767>/Logical Operator' incorporates:
   *  Constant: '<S750>/Constant10'
   */
  ME11_P_NEG_h(!ACTCtl_bBEXVDvtFlg, ACTCtl_sBEXVDvt, rtb_PI_Cor_n,
               ACTCtl_sBEXVCtrlKp, cal_BEXVCtlKp, (float32 *)&ACTCtl_sBEXVP_Cor);

  /* End of Outputs for SubSystem: '<S767>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S767>/P_POS' */
  /* Constant: '<S750>/Constant10' */
  ME11_P_POS_c(ACTCtl_bBEXVDvtFlg, ACTCtl_sBEXVDvt, rtb_PI_Cor_n,
               ACTCtl_sBEXVCtrlKp, cal_BEXVCtlKp, (float32 *)&ACTCtl_sBEXVP_Cor);

  /* End of Outputs for SubSystem: '<S767>/P_POS' */

  /* Outputs for Enabled SubSystem: '<S766>/PI_Controller' */
  ME11_PI_Controller(ACTCtl_bBEXVPIEnble, ACTCtl_bBEXVDvtFlg, ACTCtl_sBEXVCtrlFF,
                     ACTCtl_sBEXVP_Cor, ACTCtl_sBEXVI_Sum, rtb_Gain6, rtb_Add_ok,
                     (float32 *)&ACTCtl_sBEXVPI_Cor, &rtb_IFreezFlag_m);

  /* End of Outputs for SubSystem: '<S766>/PI_Controller' */

  /* Switch: '<S805>/Switch' incorporates:
   *  Constant: '<S805>/Constant1'
   */
  if (cal_BEXVEnbDataEnb) {
    /* Switch: '<S805>/Switch' incorporates:
     *  Constant: '<S805>/Constant'
     */
    ACTCtl_bBEXVEnb = cal_BEXVEnbData;
  } else {
    /* Switch: '<S805>/Switch' incorporates:
     *  Constant: '<S803>/Constant'
     *  RelationalOperator: '<S803>/Compare'
     *  Switch: '<S752>/Switch'
     */
    ACTCtl_bBEXVEnb = ((ACTCtl_bBEXVInitReq >= 1) || ME11_ARID_DEF.BEXVCtrlEnb);
  }

  /* End of Switch: '<S805>/Switch' */

  /* Logic: '<S754>/AND2' incorporates:
   *  Constant: '<S808>/Constant'
   *  Delay: '<S503>/Delay'
   *  Logic: '<S754>/OR'
   *  RelationalOperator: '<S808>/Compare'
   */
  rtb_Delay1_ag = (ME11_ARID_DEF.Delay_DSTATE_kf && ((rtb_Add_b1 == 2) ||
    (rtb_Add_b1 == 3) || (rtb_Add_b1 == 14)));

  /* Switch: '<S813>/Switch1' incorporates:
   *  Constant: '<S809>/Constant6'
   *  Constant: '<S809>/Constant8'
   *  Delay: '<S754>/Delay'
   *  RelationalOperator: '<S813>/Relational Operator'
   *  RelationalOperator: '<S813>/Relational Operator1'
   *  Sum: '<S813>/Add2'
   *  Sum: '<S813>/Add3'
   *  Switch: '<S813>/Switch3'
   */
  if (cal_BEXVDiffUp <= ACTCtl_sBEXVPI_Cor - ME11_ARID_DEF.Delay_DSTATE_l) {
    /* Switch: '<S813>/Switch1' incorporates:
     *  Constant: '<S809>/Constant5'
     *  Sum: '<S813>/Add1'
     */
    rtb_PI_Cor_n = cal_BEXVDiffUpRate + ME11_ARID_DEF.Delay_DSTATE_l;
  } else if (ME11_ARID_DEF.Delay_DSTATE_l - ACTCtl_sBEXVPI_Cor >=
             cal_BEXVDiffDown) {
    /* Switch: '<S813>/Switch3' incorporates:
     *  Constant: '<S809>/Constant7'
     *  Sum: '<S813>/Add4'
     *  Switch: '<S813>/Switch1'
     */
    rtb_PI_Cor_n = ME11_ARID_DEF.Delay_DSTATE_l - cal_BEXVDiffDownRate;
  } else {
    /* Switch: '<S813>/Switch1' incorporates:
     *  Switch: '<S813>/Switch3'
     */
    rtb_PI_Cor_n = ACTCtl_sBEXVPI_Cor;
  }

  /* End of Switch: '<S813>/Switch1' */

  /* Switch: '<S809>/Switch1' incorporates:
   *  Constant: '<S809>/Constant3'
   *  Constant: '<S809>/Constant4'
   *  Logic: '<S809>/AND1'
   *  Logic: '<S809>/AND3'
   *  RelationalOperator: '<S809>/Relational Operator2'
   *  RelationalOperator: '<S809>/Relational Operator3'
   */
  if (((ACSen_sLoPressFilter <= cal_BEXVLowPressLmtOn) || (ACSen_sHiPressFilter >=
        cal_BEXVHighPressLmtOn)) && rtb_Delay1_ag) {
    /* MinMax: '<S809>/Max' incorporates:
     *  Delay: '<S754>/Delay'
     */
    if (ME11_ARID_DEF.Delay_DSTATE_l >= rtb_PI_Cor_n) {
      /* Switch: '<S809>/Switch1' */
      rtb_PI_Cor_d = ME11_ARID_DEF.Delay_DSTATE_l;
    } else {
      /* Switch: '<S809>/Switch1' */
      rtb_PI_Cor_d = rtb_PI_Cor_n;
    }

    /* End of MinMax: '<S809>/Max' */
  } else {
    /* Switch: '<S809>/Switch1' */
    rtb_PI_Cor_d = rtb_PI_Cor_n;
  }

  /* End of Switch: '<S809>/Switch1' */

  /* Chart: '<S814>/PwrOn' */
  ME11_PwrOn(&rtb_flg_o, &ME11_ARID_DEF.ARID_DEF_PwrOn_g);

  /* Switch: '<S814>/Switch2' incorporates:
   *  Constant: '<S814>/DownLmt1'
   *  Constant: '<S814>/UpLmt2'
   *  Delay: '<S814>/Delay'
   *  RelationalOperator: '<S814>/Relational Operator'
   *  RelationalOperator: '<S814>/Relational Operator1'
   *  Sum: '<S814>/Add2'
   *  Sum: '<S814>/Add3'
   *  Switch: '<S814>/Switch'
   *  Switch: '<S814>/Switch1'
   */
  if (rtb_flg_o) {
    ME11_ARID_DEF.Delay_DSTATE_c2 = rtb_PI_Cor_d;
  } else if (rtb_PI_Cor_d > ME11_ARID_DEF.Delay_DSTATE_c2 + cal_BEXVUpSpdLmt) {
    /* Switch: '<S814>/Switch' incorporates:
     *  Constant: '<S814>/UpLmt'
     *  Delay: '<S814>/Delay'
     *  Sum: '<S814>/Add'
     */
    ME11_ARID_DEF.Delay_DSTATE_c2 += cal_BEXVUpSpdLmt;
  } else if (rtb_PI_Cor_d < ME11_ARID_DEF.Delay_DSTATE_c2 - cal_BEXVDownSpdLmt)
  {
    /* Switch: '<S814>/Switch1' incorporates:
     *  Constant: '<S814>/DownLmt'
     *  Delay: '<S814>/Delay'
     *  Sum: '<S814>/Add1'
     *  Switch: '<S814>/Switch'
     */
    ME11_ARID_DEF.Delay_DSTATE_c2 -= cal_BEXVDownSpdLmt;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_c2 = rtb_PI_Cor_d;
  }

  /* End of Switch: '<S814>/Switch2' */

  /* Chart: '<S815>/PwrOn' */
  ME11_PwrOn(&rtb_flg_g, &ME11_ARID_DEF.ARID_DEF_PwrOn_d);

  /* Switch: '<S815>/Switch2' incorporates:
   *  Constant: '<S815>/DownLmt1'
   *  Constant: '<S815>/UpLmt2'
   *  Delay: '<S815>/Delay'
   *  RelationalOperator: '<S815>/Relational Operator'
   *  RelationalOperator: '<S815>/Relational Operator1'
   *  Sum: '<S815>/Add2'
   *  Sum: '<S815>/Add3'
   *  Switch: '<S815>/Switch'
   *  Switch: '<S815>/Switch1'
   */
  if (rtb_flg_g) {
    ME11_ARID_DEF.Delay_DSTATE_h0 = ACTCtl_sBEXVPI_Cor;
  } else if (ACTCtl_sBEXVPI_Cor > ME11_ARID_DEF.Delay_DSTATE_h0 +
             cal_BEXVOpenCtrlUpSpdLmt) {
    /* Switch: '<S815>/Switch' incorporates:
     *  Constant: '<S815>/UpLmt'
     *  Delay: '<S815>/Delay'
     *  Sum: '<S815>/Add'
     */
    ME11_ARID_DEF.Delay_DSTATE_h0 += cal_BEXVOpenCtrlUpSpdLmt;
  } else if (ACTCtl_sBEXVPI_Cor < ME11_ARID_DEF.Delay_DSTATE_h0 -
             cal_BEXVOpenCtrlDownSpdLmt) {
    /* Switch: '<S815>/Switch1' incorporates:
     *  Constant: '<S815>/DownLmt'
     *  Delay: '<S815>/Delay'
     *  Sum: '<S815>/Add1'
     *  Switch: '<S815>/Switch'
     */
    ME11_ARID_DEF.Delay_DSTATE_h0 -= cal_BEXVOpenCtrlDownSpdLmt;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_h0 = ACTCtl_sBEXVPI_Cor;
  }

  /* End of Switch: '<S815>/Switch2' */

  /* Switch: '<S754>/Switch' incorporates:
   *  Constant: '<S754>/Constant'
   *  Constant: '<S754>/Constant1'
   *  Constant: '<S754>/Constant2'
   *  Delay: '<S754>/Delay'
   *  Delay: '<S815>/Delay'
   *  Logic: '<S754>/AND'
   *  RelationalOperator: '<S754>/Relational Operator'
   *  RelationalOperator: '<S754>/Relational Operator1'
   *  Sum: '<S754>/Add'
   *  Switch: '<S809>/Switch2'
   */
  if ((ACSen_sHiPressFilter >= cal_BEXVHighPressProhOn) || (ACSen_sLoPressFilter
       <= cal_BEXVLowPressProhOn)) {
    ME11_ARID_DEF.Delay_DSTATE_l += cal_BEXVOpenValveSpd;
  } else if (ACTCtl_bBEXVPIEnble) {
    /* Switch: '<S809>/Switch2' incorporates:
     *  Delay: '<S754>/Delay'
     *  Delay: '<S814>/Delay'
     */
    ME11_ARID_DEF.Delay_DSTATE_l = ME11_ARID_DEF.Delay_DSTATE_c2;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_l = ME11_ARID_DEF.Delay_DSTATE_h0;
  }

  /* End of Switch: '<S754>/Switch' */

  /* Switch: '<S810>/Switch' incorporates:
   *  Constant: '<S810>/Constant1'
   *  Switch: '<S807>/Switch2'
   */
  if (cal_BEXVPosDataEnb) {
    /* Switch: '<S810>/Switch' incorporates:
     *  Constant: '<S810>/Constant'
     */
    ACTCtl_sBEXVPos = cal_BEXVPosData;
  } else {
    if (rtb_Delay1_ag) {
      /* Switch: '<S807>/Switch2' incorporates:
       *  Delay: '<S754>/Delay'
       */
      rtb_PI_Cor_n = ME11_ARID_DEF.Delay_DSTATE_l;
    }

    /* Rounding: '<S812>/Floor' */
    ACTCtl_sBEXVPos = (float32)floor(rtb_PI_Cor_n);

    /* Sum: '<S812>/Add' */
    rtb_PI_Cor_n -= ACTCtl_sBEXVPos;

    /* Switch: '<S812>/Switch' incorporates:
     *  Constant: '<S812>/Constant'
     *  Constant: '<S812>/Constant1'
     *  RelationalOperator: '<S812>/Relational Operator'
     *  RelationalOperator: '<S812>/Relational Operator1'
     *  Switch: '<S812>/Switch1'
     */
    if (cal_BEXVFloorDiff2 < rtb_PI_Cor_n) {
      /* Switch: '<S810>/Switch' incorporates:
       *  Constant: '<S812>/Constant2'
       *  Sum: '<S812>/Add1'
       *  Switch: '<S812>/Switch'
       */
      ACTCtl_sBEXVPos = ACTCtl_sBEXVPos + 1.0F;
    } else if (cal_BEXVFloorDiff1 < rtb_PI_Cor_n) {
      /* Switch: '<S812>/Switch1' incorporates:
       *  Constant: '<S812>/Constant3'
       *  Sum: '<S812>/Add2'
       *  Switch: '<S810>/Switch'
       */
      ACTCtl_sBEXVPos = ACTCtl_sBEXVPos + 0.5F;
    }

    /* End of Switch: '<S812>/Switch' */
  }

  /* End of Switch: '<S810>/Switch' */

  /* Switch: '<S811>/Switch2' incorporates:
   *  Constant: '<S807>/Constant5'
   *  Constant: '<S807>/Constant6'
   *  RelationalOperator: '<S811>/LowerRelop1'
   *  RelationalOperator: '<S811>/UpperRelop'
   *  Switch: '<S811>/Switch'
   */
  if (ACTCtl_sBEXVPos > 100.0F) {
    /* Switch: '<S811>/Switch2' */
    ACTCtl_sBEXVPos = 100.0F;
  } else if (ACTCtl_sBEXVPos < 0.0F) {
    /* Switch: '<S811>/Switch' incorporates:
     *  Constant: '<S807>/Constant6'
     *  Switch: '<S811>/Switch2'
     */
    ACTCtl_sBEXVPos = 0.0F;
  }

  /* End of Switch: '<S811>/Switch2' */

  /* Sum: '<S676>/Add' */
  ACTCtl_sCondDep = rtb_Delay1_ie - ACSen_sWCCHiTempFilter;

  /* Switch: '<S902>/Init' incorporates:
   *  Constant: '<S895>/Constant2'
   *  Constant: '<S901>/Constant'
   *  Product: '<S901>/Product'
   *  Product: '<S901>/Product1'
   *  Sum: '<S901>/Sum'
   *  Sum: '<S901>/Sum1'
   *  UnitDelay: '<S902>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_kg != 0) {
    ACTCtl_sCondDepAvg1 = ACTCtl_sCondDep;
  }

  ACTCtl_sCondDepAvg1 = (1.0F - cal_CondDepFilter) * ACTCtl_sCondDepAvg1 +
    ACTCtl_sCondDep * cal_CondDepFilter;

  /* End of Switch: '<S902>/Init' */

  /* Product: '<S895>/Divide' incorporates:
   *  Constant: '<S895>/Constant'
   *  Delay: '<S895>/Delay'
   *  Delay: '<S895>/Delay1'
   *  Delay: '<S895>/Delay2'
   *  Delay: '<S895>/Delay3'
   *  Sum: '<S895>/Add'
   */
  ACTCtl_sCondDepAvg = ((((ACTCtl_sCondDep + ME11_ARID_DEF.Delay1_DSTATE_gh) +
    ME11_ARID_DEF.Delay_DSTATE_hl[0]) + ME11_ARID_DEF.Delay2_DSTATE_n[0]) +
                        ME11_ARID_DEF.Delay3_DSTATE_ks[0]) / 5.0F;

  /* Switch: '<S676>/Switch' incorporates:
   *  Constant: '<S676>/Constant1'
   */
  if (cal_AvgSwitch) {
    /* Switch: '<S676>/Switch' */
    ACTCtl_sHPEXVActure = ACTCtl_sCondDepAvg1;
  } else {
    /* Switch: '<S676>/Switch' */
    ACTCtl_sHPEXVActure = ACTCtl_sCondDepAvg;
  }

  /* End of Switch: '<S676>/Switch' */

  /* Lookup_n-D: '<S858>/cal_HPEXVCtrlATrgtSubcool_CUR' incorporates:
   *  Switch: '<S451>/Switch2'
   */
  rtb_PI_Cor_n = look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
    &cal_HPEXVCtrlATrgtSubcool_1X[0], (const float32 *)
    &cal_HPEXVCtrlATrgtSubcool_CUR[0], 4U);

  /* Outputs for Enabled SubSystem: '<S858>/Descending_filter' incorporates:
   *  EnablePort: '<S866>/Enable'
   */
  /* Logic: '<S858>/OR' incorporates:
   *  Constant: '<S865>/Constant'
   *  RelationalOperator: '<S865>/Compare'
   */
  if ((rtb_Add_b1 == 4) || (rtb_Add_b1 == 5) || (rtb_Add_b1 == 6)) {
    /* Switch: '<S871>/Init' incorporates:
     *  UnitDelay: '<S871>/FixPt Unit Delay2'
     */
    if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_p != 0) {
      /* Switch: '<S871>/Init' */
      ME11_ARID_DEF.Init_p = ACTCtl_sHPEXVActure;
    } else {
      /* Switch: '<S871>/Init' incorporates:
       *  UnitDelay: '<S871>/FixPt Unit Delay1'
       */
      ME11_ARID_DEF.Init_p = ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_mk;
    }

    /* End of Switch: '<S871>/Init' */

    /* Switch: '<S866>/Switch2' incorporates:
     *  Constant: '<S869>/Constant'
     *  Constant: '<S870>/Constant'
     *  Delay: '<S866>/Delay'
     *  Logic: '<S866>/AND1'
     *  RelationalOperator: '<S869>/Compare'
     *  RelationalOperator: '<S870>/Compare'
     */
    if ((ME11_ARID_DEF.Delay_DSTATE_jt < 800.0F) && (COMP_EcompActSpd >= 800.0F))
    {
      /* Sum: '<S866>/Sum2' incorporates:
       *  UnitDelay: '<S871>/FixPt Unit Delay1'
       */
      ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_mk = ACTCtl_sHPEXVActure;
    } else {
      /* Sum: '<S866>/Sum2' incorporates:
       *  Constant: '<S858>/Constant11'
       *  Sum: '<S866>/Sum3'
       *  Switch: '<S866>/Switch'
       */
      ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_mk = ME11_ARID_DEF.Init_p -
        cal_HPEXVSubCoolflt;

      /* Switch: '<S866>/Switch' incorporates:
       *  Constant: '<S868>/Constant'
       *  RelationalOperator: '<S868>/Compare'
       *  Sum: '<S866>/Sum2'
       */
      if (ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_mk - rtb_PI_Cor_n <= 0.0F) {
        /* UnitDelay: '<S871>/FixPt Unit Delay1' incorporates:
         *  Switch: '<S866>/Switch'
         */
        ME11_ARID_DEF.FixPtUnitDelay1_DSTATE_mk = rtb_PI_Cor_n;
      }
    }

    /* End of Switch: '<S866>/Switch2' */

    /* Update for Delay: '<S866>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_jt = COMP_EcompActSpd;

    /* Update for UnitDelay: '<S871>/FixPt Unit Delay2' incorporates:
     *  Constant: '<S871>/FixPt Constant'
     */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_p = 0U;
  }

  /* End of Logic: '<S858>/OR' */
  /* End of Outputs for SubSystem: '<S858>/Descending_filter' */

  /* Sum: '<S858>/Add' */
  ACTCtl_sHPEXVCtrlADiff = ME11_ARID_DEF.Init_p - ACTCtl_sHPEXVActure;

  /* Outputs for Enabled SubSystem: '<S861>/Descending_filter' */
  /* RelationalOperator: '<S872>/Compare' incorporates:
   *  Constant: '<S861>/Constant11'
   *  Constant: '<S872>/Constant'
   *  Lookup_n-D: '<S861>/cal_HPEXVCtrlDTrgtSubcool_CUR'
   *  Switch: '<S451>/Switch2'
   */
  ME11_Descending_filter(rtb_Add_b1 == 8, ACTCtl_sHPEXVActure, look1_iflf_binlca
    (ACTCtl_sACCMCtlSpd, (const float32 *)&cal_HPEXVCtrlDTrgtSubcool_1X[0], (
    const float32 *)&cal_HPEXVCtrlDTrgtSubcool_CUR[0], 4U), cal_HPEXVSubCoolflt,
    COMP_EcompActSpd, &ME11_ARID_DEF.Init_h,
    &ME11_ARID_DEF.ARID_DEF_Descending_filter_l);

  /* End of Outputs for SubSystem: '<S861>/Descending_filter' */

  /* Outputs for Enabled SubSystem: '<S862>/Descending_filter' */
  /* RelationalOperator: '<S880>/Compare' incorporates:
   *  Constant: '<S862>/Constant11'
   *  Constant: '<S880>/Constant'
   *  Lookup_n-D: '<S862>/cal_HPEXVCtrlETrgtSubcool_CUR'
   *  Switch: '<S451>/Switch2'
   */
  ME11_Descending_filter(rtb_Add_b1 == 13, ACTCtl_sHPEXVActure,
    look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
                      &cal_HPEXVCtrlETrgtSubcool_1X[0], (const float32 *)
                      &cal_HPEXVCtrlETrgtSubcool_CUR[0], 4U),
    cal_HPEXVSubCoolflt, COMP_EcompActSpd, &ME11_ARID_DEF.Init,
    &ME11_ARID_DEF.ARID_DEF_Descending_filter);

  /* End of Outputs for SubSystem: '<S862>/Descending_filter' */

  /* MultiPortSwitch: '<S822>/Multiport Switch' */
  switch (rtb_Add_b1) {
   case 4:
   case 5:
   case 6:
    /* Lookup_n-D: '<S858>/cal_HPEXVCtrlAFF_CUR' incorporates:
     *  Switch: '<S451>/Switch2'
     */
    rtb_Merge1 = look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
      &cal_HPEXVCtrlAFF_1X[0], (const float32 *)&cal_HPEXVCtrlAFF_CUR[0], 4U);

    /* Abs: '<S858>/Abs' */
    rtb_PI_Cor_d = (float32)fabs(ACTCtl_sHPEXVCtrlADiff);

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S858>/Constant2'
     */
    rtb_Merge = cal_HPEXVCtrlADelayTime;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S858>/Constant3'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlFF = cal_HPEXVCtrlAOpenVal;

    /* Switch: '<S867>/Switch2' incorporates:
     *  Constant: '<S858>/Constant'
     *  Constant: '<S858>/Constant1'
     *  RelationalOperator: '<S867>/LowerRelop1'
     *  RelationalOperator: '<S867>/UpperRelop'
     *  Switch: '<S867>/Switch'
     */
    if (rtb_Merge1 > cal_HPEXVCtrlAFFUplmt) {
      /* MultiPortSwitch: '<S822>/Multiport Switch' */
      rtb_Merge1 = cal_HPEXVCtrlAFFUplmt;
    } else if (rtb_Merge1 < cal_HPEXVCtrlAFFLolmt) {
      /* Switch: '<S867>/Switch' incorporates:
       *  Constant: '<S858>/Constant1'
       *  MultiPortSwitch: '<S822>/Multiport Switch'
       */
      rtb_Merge1 = cal_HPEXVCtrlAFFLolmt;
    }

    /* End of Switch: '<S867>/Switch2' */

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVSetPoint = ME11_ARID_DEF.Init_p;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S858>/Constant6'
     */
    rtb_PI_Cor_n = cal_HPEXVCtrlADeadzone;

    /* SignalConversion: '<S675>/Signal Copy2' incorporates:
     *  Abs: '<S858>/Abs'
     *  Lookup_n-D: '<S858>/cal_HPEXVCtrlAKp_CUR'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlKp = look1_iflf_binlca(rtb_PI_Cor_d, (const float32 *)
      &cal_HPEXVCtrlAKp_1X[0], (const float32 *)&cal_HPEXVCtrlAKp_CUR[0], 5U);

    /* SignalConversion: '<S675>/Signal Copy3' incorporates:
     *  Abs: '<S858>/Abs'
     *  Lookup_n-D: '<S858>/cal_HPEXVCtrlAKi_CUR'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlKi = look1_iflf_binlca(rtb_PI_Cor_d, (const float32 *)
      &cal_HPEXVCtrlAKi_1X[0], (const float32 *)&cal_HPEXVCtrlAKi_CUR[0], 5U);

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S858>/Constant10'
     *  Constant: '<S858>/Constant8'
     *  Constant: '<S858>/Constant9'
     */
    rtb_Gain6 = cal_HPEXVCtrlAMax;
    rtb_Add_ok = cal_HPEXVCtrlAMin;
    b_previousEvent = 1;
    break;

   case 1:
   case 2:
   case 3:
   case 12:
   case 14:
    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S859>/Constant'
     */
    rtb_Merge = 100.0F;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S859>/Constant'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlFF = 100.0F;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S859>/Constant'
     */
    rtb_Merge1 = 100.0F;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S859>/Constant1'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVSetPoint = 0.0F;

    /* SignalConversion: '<S675>/Signal Copy1' incorporates:
     *  Constant: '<S859>/Constant1'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVActure = 0.0F;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S859>/Constant2'
     */
    rtb_PI_Cor_n = 1.0F;

    /* SignalConversion: '<S675>/Signal Copy2' incorporates:
     *  Constant: '<S859>/Constant1'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlKp = 0.0F;

    /* SignalConversion: '<S675>/Signal Copy3' incorporates:
     *  Constant: '<S859>/Constant1'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlKi = 0.0F;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S859>/Constant'
     *  Constant: '<S859>/Constant1'
     */
    rtb_Gain6 = 100.0F;
    rtb_Add_ok = 100.0F;
    b_previousEvent = 0;
    break;

   case 7:
    /* Sum: '<S860>/Add' */
    rtb_ACFanLevel5EnvCor = ACCtl_tSetPointPTC - rtb_Merge_g;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S860>/Constant2'
     */
    rtb_Merge = cal_HPEXVCtrlCDelayTime;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S860>/Constant3'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlFF = cal_HPEXVCtrlCOpenVal;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Lookup_n-D: '<S860>/cal_HPEXVCtrlCFF_CUR'
     *  Switch: '<S451>/Switch2'
     */
    rtb_Merge1 = look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
      &cal_HPEXVCtrlCFF_1X[0], (const float32 *)&cal_HPEXVCtrlCFF_CUR[0], 4U);

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVSetPoint = ACCtl_tSetPointPTC;

    /* SignalConversion: '<S675>/Signal Copy1' incorporates:
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVActure = rtb_Merge_g;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S860>/Constant6'
     */
    rtb_PI_Cor_n = cal_HPEXVCtrlCDeadzone;

    /* SignalConversion: '<S675>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S860>/cal_HPEXVCtrlCKp_CUR'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     *  Sum: '<S860>/Add'
     */
    ACTCtl_sHPEXVCtrlKp = look1_iflf_binlca(rtb_ACFanLevel5EnvCor, (const
      float32 *)&cal_HPEXVCtrlCKp_1X[0], (const float32 *)&cal_HPEXVCtrlCKp_CUR
      [0], 7U);

    /* SignalConversion: '<S675>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S860>/cal_HPEXVCtrlCKi_CUR'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     *  Sum: '<S860>/Add'
     */
    ACTCtl_sHPEXVCtrlKi = look1_iflf_binlca(rtb_ACFanLevel5EnvCor, (const
      float32 *)&cal_HPEXVCtrlCKi_1X[0], (const float32 *)&cal_HPEXVCtrlCKi_CUR
      [0], 7U);

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S860>/Constant7'
     *  Constant: '<S860>/Constant8'
     *  Constant: '<S860>/Constant9'
     */
    rtb_Gain6 = cal_HPEXVCtrlCMax;
    rtb_Add_ok = cal_HPEXVCtrlCMin;
    b_previousEvent = 1;
    break;

   case 8:
    /* Lookup_n-D: '<S861>/cal_HPEXVCtrlDFF_CUR' incorporates:
     *  Switch: '<S451>/Switch2'
     */
    rtb_Merge1 = look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
      &cal_HPEXVCtrlDFF_1X[0], (const float32 *)&cal_HPEXVCtrlDFF_CUR[0], 4U);

    /* Sum: '<S861>/Add' */
    rtb_PI_Cor_d = ME11_ARID_DEF.Init_h - ACTCtl_sHPEXVActure;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S861>/Constant2'
     */
    rtb_Merge = cal_HPEXVCtrlDDelayTime;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S861>/Constant3'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlFF = cal_HPEXVCtrlDOpenVal;

    /* Switch: '<S874>/Switch2' incorporates:
     *  Constant: '<S861>/Constant'
     *  Constant: '<S861>/Constant1'
     *  RelationalOperator: '<S874>/LowerRelop1'
     *  RelationalOperator: '<S874>/UpperRelop'
     *  Switch: '<S874>/Switch'
     */
    if (rtb_Merge1 > cal_HPEXVCtrlDFFUplmt) {
      /* MultiPortSwitch: '<S822>/Multiport Switch' */
      rtb_Merge1 = cal_HPEXVCtrlDFFUplmt;
    } else if (rtb_Merge1 < cal_HPEXVCtrlDFFLolmt) {
      /* Switch: '<S874>/Switch' incorporates:
       *  Constant: '<S861>/Constant1'
       *  MultiPortSwitch: '<S822>/Multiport Switch'
       */
      rtb_Merge1 = cal_HPEXVCtrlDFFLolmt;
    }

    /* End of Switch: '<S874>/Switch2' */

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVSetPoint = ME11_ARID_DEF.Init_h;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S861>/Constant6'
     */
    rtb_PI_Cor_n = cal_HPEXVCtrlDDeadzone;

    /* SignalConversion: '<S675>/Signal Copy2' incorporates:
     *  Lookup_n-D: '<S861>/cal_HPEXVCtrlDKp_CUR'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     *  Sum: '<S861>/Add'
     */
    ACTCtl_sHPEXVCtrlKp = look1_iflf_binlca(rtb_PI_Cor_d, (const float32 *)
      &cal_HPEXVCtrlDKp_1X[0], (const float32 *)&cal_HPEXVCtrlDKp_CUR[0], 7U);

    /* SignalConversion: '<S675>/Signal Copy3' incorporates:
     *  Lookup_n-D: '<S861>/cal_HPEXVCtrlDKi_CUR'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     *  Sum: '<S861>/Add'
     */
    ACTCtl_sHPEXVCtrlKi = look1_iflf_binlca(rtb_PI_Cor_d, (const float32 *)
      &cal_HPEXVCtrlDKi_1X[0], (const float32 *)&cal_HPEXVCtrlDKi_CUR[0], 7U);

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S861>/Constant10'
     *  Constant: '<S861>/Constant8'
     *  Constant: '<S861>/Constant9'
     */
    rtb_Gain6 = cal_HPEXVCtrlDMax;
    rtb_Add_ok = cal_HPEXVCtrlDMin;
    b_previousEvent = 1;
    break;

   case 13:
    /* Lookup_n-D: '<S862>/cal_HPEXVCtrlEFF_CUR' incorporates:
     *  Switch: '<S451>/Switch2'
     */
    rtb_Merge1 = look1_iflf_binlca(ACTCtl_sACCMCtlSpd, (const float32 *)
      &cal_HPEXVCtrlEFF_1X[0], (const float32 *)&cal_HPEXVCtrlEFF_CUR[0], 4U);

    /* Abs: '<S862>/Abs' incorporates:
     *  Sum: '<S862>/Add'
     */
    rtb_PI_Cor_d = (float32)fabs(ME11_ARID_DEF.Init - ACTCtl_sHPEXVActure);

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S862>/Constant2'
     */
    rtb_Merge = cal_HPEXVCtrlEDelayTime;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S862>/Constant3'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlFF = cal_HPEXVCtrlEOpenVal;

    /* Switch: '<S882>/Switch2' incorporates:
     *  Constant: '<S862>/Constant'
     *  Constant: '<S862>/Constant1'
     *  RelationalOperator: '<S882>/LowerRelop1'
     *  RelationalOperator: '<S882>/UpperRelop'
     *  Switch: '<S882>/Switch'
     */
    if (rtb_Merge1 > cal_HPEXVCtrlEFFUplmt) {
      /* MultiPortSwitch: '<S822>/Multiport Switch' */
      rtb_Merge1 = cal_HPEXVCtrlEFFUplmt;
    } else if (rtb_Merge1 < cal_HPEXVCtrlEFFLolmt) {
      /* Switch: '<S882>/Switch' incorporates:
       *  Constant: '<S862>/Constant1'
       *  MultiPortSwitch: '<S822>/Multiport Switch'
       */
      rtb_Merge1 = cal_HPEXVCtrlEFFLolmt;
    }

    /* End of Switch: '<S882>/Switch2' */

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVSetPoint = ME11_ARID_DEF.Init;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S862>/Constant6'
     */
    rtb_PI_Cor_n = cal_HPEXVCtrlEDeadzone;

    /* SignalConversion: '<S675>/Signal Copy2' incorporates:
     *  Abs: '<S862>/Abs'
     *  Lookup_n-D: '<S862>/cal_HPEXVCtrlEKp_CUR'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlKp = look1_iflf_binlca(rtb_PI_Cor_d, (const float32 *)
      &cal_HPEXVCtrlEKp_1X[0], (const float32 *)&cal_HPEXVCtrlEKp_CUR[0], 5U);

    /* SignalConversion: '<S675>/Signal Copy3' incorporates:
     *  Abs: '<S862>/Abs'
     *  Lookup_n-D: '<S862>/cal_HPEXVCtrlEKi_CUR'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlKi = look1_iflf_binlca(rtb_PI_Cor_d, (const float32 *)
      &cal_HPEXVCtrlEKi_1X[0], (const float32 *)&cal_HPEXVCtrlEKi_CUR[0], 5U);

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S862>/Constant10'
     *  Constant: '<S862>/Constant8'
     *  Constant: '<S862>/Constant9'
     */
    rtb_Gain6 = cal_HPEXVCtrlEMax;
    rtb_Add_ok = cal_HPEXVCtrlEMin;
    b_previousEvent = 1;
    break;

   default:
    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S863>/Constant1'
     */
    rtb_Merge = 0.0F;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S863>/Constant'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlFF = 50.0F;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S863>/Constant'
     */
    rtb_Merge1 = 50.0F;

    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S863>/Constant1'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVSetPoint = 0.0F;

    /* SignalConversion: '<S675>/Signal Copy1' incorporates:
     *  Constant: '<S863>/Constant1'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVActure = 0.0F;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S863>/Constant1'
     */
    rtb_PI_Cor_n = 0.0F;

    /* SignalConversion: '<S675>/Signal Copy2' incorporates:
     *  Constant: '<S863>/Constant1'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlKp = 0.0F;

    /* SignalConversion: '<S675>/Signal Copy3' incorporates:
     *  Constant: '<S863>/Constant1'
     *  MultiPortSwitch: '<S822>/Multiport Switch'
     */
    ACTCtl_sHPEXVCtrlKi = 0.0F;

    /* MultiPortSwitch: '<S822>/Multiport Switch' incorporates:
     *  Constant: '<S863>/Constant'
     *  Constant: '<S863>/Constant1'
     */
    rtb_Gain6 = 50.0F;
    rtb_Add_ok = 50.0F;
    b_previousEvent = 0;
    break;
  }

  /* End of MultiPortSwitch: '<S822>/Multiport Switch' */

  /* Chart: '<S819>/FFCal' incorporates:
   *  Delay: '<S503>/Delay'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_d < MAX_uint32_T) {
    ME11_ARID_DEF.temporalCounter_i1_d++;
  }

  if (ME11_ARID_DEF.is_active_c6_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c6_ME11 = 1U;
    ME11_ARID_DEF.is_c6_ME11 = ME11_IN_Init_i;
    ME11_ARID_DEF.PID_Enble = false;
    ME11_ARID_DEF.HPEXVCtrlEnb = true;
  } else if (ME11_ARID_DEF.is_c6_ME11 == ME11_IN_Init_i) {
    ME11_ARID_DEF.PID_Enble = false;
    ME11_ARID_DEF.HPEXVCtrlEnb = true;
    if (ME11_ARID_DEF.Delay_DSTATE_kf) {
      ME11_ARID_DEF.is_c6_ME11 = ME11_IN_On_li;
      ME11_ARID_DEF.is_On_i = ME11_IN_OpenCtrl;
      ME11_ARID_DEF.temporalCounter_i1_d = 0U;
      ME11_ARID_DEF.HPEXVCtrlEnb = true;
    }

    /* case IN_On: */
  } else if (!ME11_ARID_DEF.Delay_DSTATE_kf) {
    ME11_ARID_DEF.is_On_i = ME11_IN_NO_ACTIVE_CHILD_gl;
    ME11_ARID_DEF.is_c6_ME11 = ME11_IN_Init_i;
    ME11_ARID_DEF.PID_Enble = false;
    ME11_ARID_DEF.HPEXVCtrlEnb = true;
  } else if (ME11_ARID_DEF.is_On_i == ME11_IN_CloseCtrl) {
    ME11_ARID_DEF.PID_Enble = true;

    /* MultiPortSwitch: '<S681>/Multiport Switch' */
    ACTCtl_sHPEXVCtrlFF = rtb_Merge1;
  } else {
    /* case IN_OpenCtrl: */
    ME11_ARID_DEF.HPEXVCtrlEnb = true;
    if (ME11_ARID_DEF.temporalCounter_i1_d >= rtb_Merge * 10.0F) {
      ME11_ARID_DEF.is_On_i = ME11_IN_CloseCtrl;
      ME11_ARID_DEF.PID_Enble = true;

      /* MultiPortSwitch: '<S681>/Multiport Switch' */
      ACTCtl_sHPEXVCtrlFF = rtb_Merge1;
    }
  }

  /* End of Chart: '<S819>/FFCal' */

  /* Logic: '<S675>/AND' */
  ACTCtl_bHPEXVPIEnble = (ME11_ARID_DEF.PID_Enble && (b_previousEvent != 0));

  /* Relay: '<S825>/LowProRelay' */
  ME11_ARID_DEF.LowProRelay_Mode = ((ACSen_sLoPressFilter >=
    cal_HPEXVlowPressProhOff) || ((ACSen_sLoPressFilter >
    cal_HPEXVlowPressProhOn) && ME11_ARID_DEF.LowProRelay_Mode));

  /* Switch: '<S825>/Switch5' incorporates:
   *  Delay: '<S503>/Delay'
   *  Relay: '<S825>/LowProRelay'
   */
  ACTCtl_bLowPressProFlg = (ME11_ARID_DEF.Delay_DSTATE_kf &&
    (!ME11_ARID_DEF.LowProRelay_Mode));

  /* Relay: '<S825>/HiProRelay' */
  ME11_ARID_DEF.HiProRelay_Mode = ((ACSen_sHiPressFilter >=
    cal_HPEXVHiPressProhOn) || ((ACSen_sHiPressFilter > cal_HPEXVHiPressProhOff)
    && ME11_ARID_DEF.HiProRelay_Mode));

  /* Switch: '<S825>/Switch4' incorporates:
   *  Delay: '<S503>/Delay'
   *  Relay: '<S825>/HiProRelay'
   */
  ACTCtl_bHiPressProFlg = (ME11_ARID_DEF.Delay_DSTATE_kf &&
    ME11_ARID_DEF.HiProRelay_Mode);

  /* Outputs for Enabled SubSystem: '<S842>/PI_Controller1' */
  /* Logic: '<S842>/Logical Operator' */
  ME11_PI_Controller1(!ACTCtl_bHPEXVPIEnble, ACTCtl_sHPEXVCtrlFF, (float32 *)
                      &ACTCtl_sHPEXVPI_Cor, &rtb_IFreezFlag_c);

  /* End of Outputs for SubSystem: '<S842>/PI_Controller1' */

  /* Relay: '<S864>/HiPressLmt' */
  ME11_ARID_DEF.HiPressLmt_Mode = ((ACSen_sWCCHiTempFilter >=
    cal_HPEXVHiPressLmtOn) || ((ACSen_sWCCHiTempFilter > cal_HPEXVHiPressLmtOff)
    && ME11_ARID_DEF.HiPressLmt_Mode));

  /* Relay: '<S864>/LowPressLmt' */
  ME11_ARID_DEF.LowPressLmt_Mode = ((ACSen_sLoPressFilter >=
    cal_HPEXVLowPressLmtOff) || ((ACSen_sLoPressFilter > cal_HPEXVLowPressLmtOn)
    && ME11_ARID_DEF.LowPressLmt_Mode));

  /* Switch: '<S822>/Switch' incorporates:
   *  Logic: '<S864>/OR'
   *  Relay: '<S864>/HiPressLmt'
   *  Relay: '<S864>/LowPressLmt'
   */
  if (ME11_ARID_DEF.HiPressLmt_Mode && (!ME11_ARID_DEF.LowPressLmt_Mode)) {
    /* MultiPortSwitch: '<S681>/Multiport Switch' incorporates:
     *  Constant: '<S822>/Constant'
     *  Switch: '<S822>/Switch'
     */
    ACTCtl_sHPEXVSetPoint = cal_HPEXVlowPressLmtTrg;
  }

  /* End of Switch: '<S822>/Switch' */

  /* RelationalOperator: '<S824>/Relational Operator' */
  rtb_Delay1_ag = (ACTCtl_sHPEXVSetPoint >= ACTCtl_sHPEXVActure);

  /* Logic: '<S824>/NOT' */
  ACTCtl_bHPEXVDvtFlg = !rtb_Delay1_ag;

  /* Sum: '<S824>/Sum' */
  ACTCtl_sHPEXVDvt = ACTCtl_sHPEXVSetPoint - ACTCtl_sHPEXVActure;

  /* Chart: '<S824>/deadzone' */
  ME11_deadzone_h1(ACTCtl_sHPEXVDvt, rtb_PI_Cor_n, &rtb_flag);

  /* Switch: '<S824>/Switch1' incorporates:
   *  Switch: '<S824>/Switch'
   */
  if (rtb_flag) {
    /* Switch: '<S824>/Switch1' incorporates:
     *  Constant: '<S824>/Constant'
     */
    ACTCtl_sHPEXVDvt = 0.0F;
  } else if (!rtb_Delay1_ag) {
    /* Switch: '<S824>/Switch1' incorporates:
     *  Sum: '<S824>/Sum1'
     *  Switch: '<S824>/Switch'
     */
    ACTCtl_sHPEXVDvt = ACTCtl_sHPEXVActure - ACTCtl_sHPEXVSetPoint;
  }

  /* End of Switch: '<S824>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S843>/P_NEG' */
  /* Logic: '<S843>/Logical Operator' incorporates:
   *  Constant: '<S821>/Constant10'
   *  Constant: '<S821>/Constant5'
   */
  ME11_P_NEG_h(!ACTCtl_bHPEXVDvtFlg, ACTCtl_sHPEXVDvt, cal_HPEXVCtlKpDeadzoneNeg,
               ACTCtl_sHPEXVCtrlKp, cal_HPEXVCtlKp, (float32 *)
               &ACTCtl_sHPEXVP_Cor);

  /* End of Outputs for SubSystem: '<S843>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S843>/P_POS' */
  /* Constant: '<S821>/Constant4' incorporates:
   *  Constant: '<S821>/Constant10'
   */
  ME11_P_POS_c(ACTCtl_bHPEXVDvtFlg, ACTCtl_sHPEXVDvt, cal_HPEXVCtlKpDeadzonePos,
               ACTCtl_sHPEXVCtrlKp, cal_HPEXVCtlKp, (float32 *)
               &ACTCtl_sHPEXVP_Cor);

  /* End of Outputs for SubSystem: '<S843>/P_POS' */

  /* Outputs for Enabled SubSystem: '<S844>/P_NEG' */
  /* Logic: '<S844>/Logical Operator' incorporates:
   *  Constant: '<S821>/Constant11'
   *  Constant: '<S821>/Constant7'
   */
  ME11_P_NEG(!ACTCtl_bHPEXVDvtFlg, ACTCtl_sHPEXVDvt, cal_HPEXVCtlKiDeadzoneNeg,
             ACTCtl_sHPEXVCtrlKi, cal_HPEXVCtlKi, (float32 *)&ACTCtl_sHPEXVI_Cor);

  /* End of Outputs for SubSystem: '<S844>/P_NEG' */

  /* Outputs for Enabled SubSystem: '<S844>/P_POS' */
  /* Constant: '<S821>/Constant6' incorporates:
   *  Constant: '<S821>/Constant11'
   */
  ME11_P_POS(ACTCtl_bHPEXVDvtFlg, ACTCtl_sHPEXVDvt, cal_HPEXVCtlKiDeadzonePos,
             ACTCtl_sHPEXVCtrlKi, cal_HPEXVCtlKi, (float32 *)&ACTCtl_sHPEXVI_Cor);

  /* End of Outputs for SubSystem: '<S844>/P_POS' */

  /* Switch: '<S841>/Switch1' */
  if (ACTCtl_bHPEXVPIEnble) {
    /* MultiPortSwitch: '<S844>/Multiport Switch' incorporates:
     *  Delay: '<S844>/Delay'
     */
    switch (ME11_ARID_DEF.Delay_DSTATE_nb) {
     case 0:
      /* Switch: '<S848>/Switch' */
      if (ACTCtl_bHPEXVDvtFlg) {
        /* Switch: '<S845>/Switch2' incorporates:
         *  Delay: '<S841>/Delay'
         *  Sum: '<S848>/Add'
         *  Switch: '<S848>/Switch'
         */
        ACTCtl_sHPEXVI_Sum = ACTCtl_sHPEXVI_Sum + ACTCtl_sHPEXVI_Cor;
      } else {
        /* Switch: '<S845>/Switch2' incorporates:
         *  Delay: '<S841>/Delay'
         *  Sum: '<S848>/Add1'
         *  Switch: '<S848>/Switch'
         */
        ACTCtl_sHPEXVI_Sum = ACTCtl_sHPEXVI_Sum - ACTCtl_sHPEXVI_Cor;
      }

      /* End of Switch: '<S848>/Switch' */
      break;

     case 1:
      /* Switch: '<S849>/Switch' */
      if (!ACTCtl_bHPEXVDvtFlg) {
        /* Switch: '<S845>/Switch2' incorporates:
         *  Delay: '<S841>/Delay'
         *  Sum: '<S849>/Add1'
         *  Switch: '<S849>/Switch'
         */
        ACTCtl_sHPEXVI_Sum = ACTCtl_sHPEXVI_Sum - ACTCtl_sHPEXVI_Cor;
      }

      /* End of Switch: '<S849>/Switch' */
      break;

     case 2:
      /* Switch: '<S846>/Switch' */
      if (ACTCtl_bHPEXVDvtFlg) {
        /* Switch: '<S845>/Switch2' incorporates:
         *  Delay: '<S841>/Delay'
         *  Sum: '<S846>/Add'
         *  Switch: '<S846>/Switch'
         */
        ACTCtl_sHPEXVI_Sum = ACTCtl_sHPEXVI_Sum + ACTCtl_sHPEXVI_Cor;
      }

      /* End of Switch: '<S846>/Switch' */
      break;

     case 3:
      break;
    }

    /* End of MultiPortSwitch: '<S844>/Multiport Switch' */

    /* Switch: '<S845>/Switch2' incorporates:
     *  Constant: '<S821>/Constant8'
     *  Constant: '<S821>/Constant9'
     *  RelationalOperator: '<S845>/LowerRelop1'
     *  RelationalOperator: '<S845>/UpperRelop'
     *  Sum: '<S841>/Add'
     *  Switch: '<S845>/Switch'
     */
    if (ACTCtl_sHPEXVI_Sum > cal_HPEXVCtlKisumMax) {
      /* Switch: '<S841>/Switch1' incorporates:
       *  Switch: '<S845>/Switch2'
       */
      ACTCtl_sHPEXVI_Sum = cal_HPEXVCtlKisumMax;
    } else if (ACTCtl_sHPEXVI_Sum < cal_HPEXVCtlKisumMin) {
      /* Switch: '<S845>/Switch' incorporates:
       *  Constant: '<S821>/Constant9'
       *  Switch: '<S841>/Switch1'
       *  Switch: '<S845>/Switch2'
       */
      ACTCtl_sHPEXVI_Sum = cal_HPEXVCtlKisumMin;
    }

    /* End of Switch: '<S845>/Switch2' */
  } else {
    /* Switch: '<S841>/Switch1' incorporates:
     *  Constant: '<S821>/Constant'
     */
    ACTCtl_sHPEXVI_Sum = 0.0F;
  }

  /* End of Switch: '<S841>/Switch1' */

  /* Outputs for Enabled SubSystem: '<S842>/PI_Controller' */
  ME11_PI_Controller(ACTCtl_bHPEXVPIEnble, ACTCtl_bHPEXVDvtFlg,
                     ACTCtl_sHPEXVCtrlFF, ACTCtl_sHPEXVP_Cor, ACTCtl_sHPEXVI_Sum,
                     rtb_Gain6, rtb_Add_ok, (float32 *)&ACTCtl_sHPEXVPI_Cor,
                     &rtb_IFreezFlag_c);

  /* End of Outputs for SubSystem: '<S842>/PI_Controller' */

  /* Switch: '<S829>/Switch1' incorporates:
   *  Constant: '<S825>/Constant6'
   *  Constant: '<S825>/Constant8'
   *  Delay: '<S818>/Delay'
   *  RelationalOperator: '<S829>/Relational Operator'
   *  RelationalOperator: '<S829>/Relational Operator1'
   *  Sum: '<S829>/Add2'
   *  Sum: '<S829>/Add3'
   *  Switch: '<S829>/Switch3'
   */
  if (cal_HPEXVDiffUp <= ACTCtl_sHPEXVPI_Cor - ME11_ARID_DEF.Delay_DSTATE_ny) {
    /* Switch: '<S829>/Switch1' incorporates:
     *  Constant: '<S825>/Constant5'
     *  Sum: '<S829>/Add1'
     */
    rtb_PI_Cor_n = cal_HPEXVDiffUpRate + ME11_ARID_DEF.Delay_DSTATE_ny;
  } else if (ME11_ARID_DEF.Delay_DSTATE_ny - ACTCtl_sHPEXVPI_Cor >=
             cal_HPEXVDiffDown) {
    /* Switch: '<S829>/Switch3' incorporates:
     *  Constant: '<S825>/Constant7'
     *  Sum: '<S829>/Add4'
     *  Switch: '<S829>/Switch1'
     */
    rtb_PI_Cor_n = ME11_ARID_DEF.Delay_DSTATE_ny - cal_HPEXVDiffDownRate;
  } else {
    /* Switch: '<S829>/Switch1' incorporates:
     *  Switch: '<S829>/Switch3'
     */
    rtb_PI_Cor_n = ACTCtl_sHPEXVPI_Cor;
  }

  /* End of Switch: '<S829>/Switch1' */

  /* Chart: '<S830>/PwrOn' */
  ME11_PwrOn(&rtb_flg_d, &ME11_ARID_DEF.ARID_DEF_PwrOn_j);

  /* Switch: '<S830>/Switch2' incorporates:
   *  Constant: '<S830>/DownLmt1'
   *  Constant: '<S830>/UpLmt2'
   *  Delay: '<S830>/Delay'
   *  RelationalOperator: '<S830>/Relational Operator'
   *  RelationalOperator: '<S830>/Relational Operator1'
   *  Sum: '<S830>/Add2'
   *  Sum: '<S830>/Add3'
   *  Switch: '<S830>/Switch'
   *  Switch: '<S830>/Switch1'
   */
  if (rtb_flg_d) {
    ME11_ARID_DEF.Delay_DSTATE_hq = rtb_PI_Cor_n;
  } else if (rtb_PI_Cor_n > ME11_ARID_DEF.Delay_DSTATE_hq + cal_HPEXVUpSpdLmt) {
    /* Switch: '<S830>/Switch' incorporates:
     *  Constant: '<S830>/UpLmt'
     *  Delay: '<S830>/Delay'
     *  Sum: '<S830>/Add'
     */
    ME11_ARID_DEF.Delay_DSTATE_hq += cal_HPEXVUpSpdLmt;
  } else if (rtb_PI_Cor_n < ME11_ARID_DEF.Delay_DSTATE_hq - cal_HPEXVDownSpdLmt)
  {
    /* Switch: '<S830>/Switch1' incorporates:
     *  Constant: '<S830>/DownLmt'
     *  Delay: '<S830>/Delay'
     *  Sum: '<S830>/Add1'
     *  Switch: '<S830>/Switch'
     */
    ME11_ARID_DEF.Delay_DSTATE_hq -= cal_HPEXVDownSpdLmt;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_hq = rtb_PI_Cor_n;
  }

  /* End of Switch: '<S830>/Switch2' */

  /* Chart: '<S831>/PwrOn' */
  ME11_PwrOn(&rtb_flg, &ME11_ARID_DEF.ARID_DEF_PwrOn);

  /* Switch: '<S831>/Switch2' incorporates:
   *  Constant: '<S831>/DownLmt1'
   *  Constant: '<S831>/UpLmt2'
   *  Delay: '<S831>/Delay'
   *  RelationalOperator: '<S831>/Relational Operator'
   *  RelationalOperator: '<S831>/Relational Operator1'
   *  Sum: '<S831>/Add2'
   *  Sum: '<S831>/Add3'
   *  Switch: '<S831>/Switch'
   *  Switch: '<S831>/Switch1'
   */
  if (rtb_flg) {
    ME11_ARID_DEF.Delay_DSTATE_iy = ACTCtl_sHPEXVPI_Cor;
  } else if (ACTCtl_sHPEXVPI_Cor > ME11_ARID_DEF.Delay_DSTATE_iy +
             cal_HPEXVOpenCtrlUpSpdLmt) {
    /* Switch: '<S831>/Switch' incorporates:
     *  Constant: '<S831>/UpLmt'
     *  Delay: '<S831>/Delay'
     *  Sum: '<S831>/Add'
     */
    ME11_ARID_DEF.Delay_DSTATE_iy += cal_HPEXVOpenCtrlUpSpdLmt;
  } else if (ACTCtl_sHPEXVPI_Cor < ME11_ARID_DEF.Delay_DSTATE_iy -
             cal_HPEXVOpenCtrlDownSpdLmt) {
    /* Switch: '<S831>/Switch1' incorporates:
     *  Constant: '<S831>/DownLmt'
     *  Delay: '<S831>/Delay'
     *  Sum: '<S831>/Add1'
     *  Switch: '<S831>/Switch'
     */
    ME11_ARID_DEF.Delay_DSTATE_iy -= cal_HPEXVOpenCtrlDownSpdLmt;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_iy = ACTCtl_sHPEXVPI_Cor;
  }

  /* End of Switch: '<S831>/Switch2' */

  /* Switch: '<S825>/Switch' incorporates:
   *  Delay: '<S818>/Delay'
   *  Logic: '<S825>/AND'
   *  MinMax: '<S825>/Max'
   *  Sum: '<S825>/Add'
   *  Switch: '<S825>/Switch1'
   *  Switch: '<S825>/Switch2'
   *  Switch: '<S825>/Switch3'
   */
  if (ACTCtl_bLowPressProFlg && ACTCtl_bHiPressProFlg) {
    /* MinMax: '<S825>/Max' incorporates:
     *  Constant: '<S825>/Constant'
     *  Constant: '<S825>/Constant1'
     */
    if (cal_HPEXVLowPressProOpenSpd >= cal_HPEXVHiPressProOpenSpd) {
      rtb_Add_ok = cal_HPEXVLowPressProOpenSpd;
    } else {
      rtb_Add_ok = cal_HPEXVHiPressProOpenSpd;
    }

    ME11_ARID_DEF.Delay_DSTATE_ny += rtb_Add_ok;
  } else if (ACTCtl_bLowPressProFlg) {
    /* Switch: '<S825>/Switch1' incorporates:
     *  Constant: '<S825>/Constant2'
     *  Delay: '<S818>/Delay'
     *  Sum: '<S825>/Add1'
     */
    ME11_ARID_DEF.Delay_DSTATE_ny += cal_HPEXVLowPressProOpenSpd;
  } else if (ACTCtl_bHiPressProFlg) {
    /* Switch: '<S825>/Switch2' incorporates:
     *  Constant: '<S825>/Constant3'
     *  Delay: '<S818>/Delay'
     *  Sum: '<S825>/Add2'
     *  Switch: '<S825>/Switch1'
     */
    ME11_ARID_DEF.Delay_DSTATE_ny += cal_HPEXVHiPressProOpenSpd;
  } else if (ACTCtl_bHPEXVPIEnble) {
    /* Switch: '<S825>/Switch3' incorporates:
     *  Delay: '<S818>/Delay'
     *  Delay: '<S830>/Delay'
     *  Switch: '<S825>/Switch1'
     *  Switch: '<S825>/Switch2'
     */
    ME11_ARID_DEF.Delay_DSTATE_ny = ME11_ARID_DEF.Delay_DSTATE_hq;
  } else {
    /* Delay: '<S818>/Delay' incorporates:
     *  Delay: '<S831>/Delay'
     *  Switch: '<S825>/Switch1'
     *  Switch: '<S825>/Switch2'
     *  Switch: '<S825>/Switch3'
     */
    ME11_ARID_DEF.Delay_DSTATE_ny = ME11_ARID_DEF.Delay_DSTATE_iy;
  }

  /* End of Switch: '<S825>/Switch' */

  /* Rounding: '<S828>/Floor' incorporates:
   *  Delay: '<S818>/Delay'
   */
  ACTCtl_sHPEXVStepLmt = (float32)floor(ME11_ARID_DEF.Delay_DSTATE_ny);

  /* Sum: '<S828>/Add' incorporates:
   *  Delay: '<S818>/Delay'
   */
  rtb_PI_Cor_n = ME11_ARID_DEF.Delay_DSTATE_ny - ACTCtl_sHPEXVStepLmt;

  /* Switch: '<S828>/Switch' incorporates:
   *  Constant: '<S828>/Constant'
   *  Constant: '<S828>/Constant1'
   *  RelationalOperator: '<S828>/Relational Operator'
   *  RelationalOperator: '<S828>/Relational Operator1'
   *  Switch: '<S828>/Switch1'
   */
  if (cal_HPEXVFloorDiff2 < rtb_PI_Cor_n) {
    /* Switch: '<S828>/Switch' incorporates:
     *  Constant: '<S828>/Constant2'
     *  Sum: '<S828>/Add1'
     */
    ACTCtl_sHPEXVStepLmt = ACTCtl_sHPEXVStepLmt + 1.0F;
  } else if (cal_HPEXVFloorDiff1 < rtb_PI_Cor_n) {
    /* Switch: '<S828>/Switch1' incorporates:
     *  Constant: '<S828>/Constant3'
     *  Sum: '<S828>/Add2'
     *  Switch: '<S828>/Switch'
     */
    ACTCtl_sHPEXVStepLmt = ACTCtl_sHPEXVStepLmt + 0.5F;
  }

  /* End of Switch: '<S828>/Switch' */

  /* Switch: '<S826>/Switch' incorporates:
   *  Constant: '<S818>/Constant2'
   *  Constant: '<S826>/Constant1'
   *  Switch: '<S818>/Switch'
   */
  if (cal_HPEXVPosDataEnb) {
    /* Switch: '<S826>/Switch' incorporates:
     *  Constant: '<S826>/Constant'
     */
    ACTCtl_sHPEXVPos = cal_HPEXVPosData;
  } else if (cal_HPEXVStepLmtSw) {
    /* Switch: '<S818>/Switch' incorporates:
     *  Switch: '<S826>/Switch'
     */
    ACTCtl_sHPEXVPos = ACTCtl_sHPEXVStepLmt;
  } else {
    /* Switch: '<S826>/Switch' incorporates:
     *  Delay: '<S818>/Delay'
     *  Switch: '<S818>/Switch'
     */
    ACTCtl_sHPEXVPos = ME11_ARID_DEF.Delay_DSTATE_ny;
  }

  /* End of Switch: '<S826>/Switch' */

  /* Switch: '<S827>/Switch2' incorporates:
   *  Constant: '<S818>/Constant'
   *  Constant: '<S818>/Constant1'
   *  RelationalOperator: '<S827>/LowerRelop1'
   *  RelationalOperator: '<S827>/UpperRelop'
   *  Switch: '<S827>/Switch'
   */
  if (ACTCtl_sHPEXVPos > 100.0F) {
    /* Switch: '<S827>/Switch2' */
    ACTCtl_sHPEXVPos = 100.0F;
  } else if (ACTCtl_sHPEXVPos < 0.0F) {
    /* Switch: '<S827>/Switch' incorporates:
     *  Constant: '<S818>/Constant1'
     *  Switch: '<S827>/Switch2'
     */
    ACTCtl_sHPEXVPos = 0.0F;
  }

  /* End of Switch: '<S827>/Switch2' */

  /* Switch: '<S823>/Switch' incorporates:
   *  Constant: '<S823>/Constant'
   *  Constant: '<S888>/Constant'
   *  Constant: '<S889>/Constant'
   *  Constant: '<S890>/Constant'
   *  Constant: '<S891>/Constant'
   *  Delay: '<S823>/Delay'
   *  Delay: '<S823>/Delay1'
   *  Logic: '<S823>/AND'
   *  RelationalOperator: '<S888>/Compare'
   *  RelationalOperator: '<S889>/Compare'
   *  RelationalOperator: '<S890>/Compare'
   *  RelationalOperator: '<S891>/Compare'
   *  Switch: '<S823>/Switch1'
   *  Switch: '<S823>/Switch2'
   */
  if ((ME11_ARID_DEF.Delay1_DSTATE_gf < 2) && (ME11_ARID_DEF.DataTypeConversion1
       >= 2)) {
    ME11_ARID_DEF.Delay_DSTATE_kr = 1U;
  } else if (HP_EXV_initialize_status == 2) {
    /* Delay: '<S823>/Delay' incorporates:
     *  Constant: '<S823>/Constant1'
     *  Switch: '<S823>/Switch1'
     */
    ME11_ARID_DEF.Delay_DSTATE_kr = 0U;
  } else if (HP_EXV_initialize_status == 1) {
    /* Switch: '<S823>/Switch2' incorporates:
     *  Constant: '<S823>/Constant2'
     *  Delay: '<S823>/Delay'
     *  Switch: '<S823>/Switch1'
     */
    ME11_ARID_DEF.Delay_DSTATE_kr = 2U;
  }

  /* End of Switch: '<S823>/Switch' */

  /* Switch: '<S893>/Switch' incorporates:
   *  Constant: '<S893>/Constant1'
   */
  if (cal_HPEXVInitReqDataeEnb) {
    /* Switch: '<S893>/Switch' incorporates:
     *  Constant: '<S893>/Constant'
     */
    ACTCtl_bHPEXVInitReq = cal_HPEXVInitReqData;
  } else {
    /* Switch: '<S893>/Switch' incorporates:
     *  Delay: '<S823>/Delay'
     */
    ACTCtl_bHPEXVInitReq = ME11_ARID_DEF.Delay_DSTATE_kr;
  }

  /* End of Switch: '<S893>/Switch' */

  /* Switch: '<S836>/Switch' incorporates:
   *  Constant: '<S836>/Constant1'
   */
  if (cal_HPEXVEnbDataEnb) {
    /* Switch: '<S836>/Switch' incorporates:
     *  Constant: '<S836>/Constant'
     */
    ACTCtl_bHPEXVEnb = cal_HPEXVEnbData;
  } else {
    /* Switch: '<S836>/Switch' incorporates:
     *  Constant: '<S834>/Constant'
     *  RelationalOperator: '<S834>/Compare'
     *  Switch: '<S819>/Switch'
     */
    ACTCtl_bHPEXVEnb = ((ACTCtl_bHPEXVInitReq >= 1) ||
                        ME11_ARID_DEF.HPEXVCtrlEnb);
  }

  /* End of Switch: '<S836>/Switch' */

  /* RelationalOperator: '<S892>/Compare' incorporates:
   *  Constant: '<S892>/Constant'
   *  Delay: '<S823>/Delay2'
   */
  ACTCtl_bHPEXVInitFinishFlg = (ME11_ARID_DEF.Delay2_DSTATE_pl < 1);

  /* Sum: '<S676>/Add1' */
  ACTCtl_sSuperHeat = ACSen_sOHXTempFilter - rtb_Delay;

  /* Sum: '<S676>/Add2' */
  ACTCtl_sExhSuperHeat = ACSen_sACCMHiTempFilter - rtb_Delay1_ie;

  /* Product: '<S899>/Divide' incorporates:
   *  Constant: '<S899>/Constant'
   *  Delay: '<S899>/Delay'
   *  Delay: '<S899>/Delay1'
   *  Delay: '<S899>/Delay2'
   *  Delay: '<S899>/Delay3'
   *  Sum: '<S899>/Add'
   */
  ACTCtl_sExhSuperHeatAvg = ((((ACTCtl_sExhSuperHeat +
    ME11_ARID_DEF.Delay1_DSTATE_c) + ME11_ARID_DEF.Delay_DSTATE_l3[0]) +
    ME11_ARID_DEF.Delay2_DSTATE_p[0]) + ME11_ARID_DEF.Delay3_DSTATE_ij[0]) /
    5.0F;

  /* Switch: '<S910>/Init' incorporates:
   *  Constant: '<S899>/Constant1'
   *  Constant: '<S909>/Constant'
   *  Product: '<S909>/Product'
   *  Product: '<S909>/Product1'
   *  Sum: '<S909>/Sum'
   *  Sum: '<S909>/Sum1'
   *  UnitDelay: '<S910>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_nk != 0) {
    ACTCtl_sExhSuperHeatAvg1 = ACTCtl_sExhSuperHeat;
  }

  ACTCtl_sExhSuperHeatAvg1 = (1.0F - cal_ExhSuperHeatFilter) *
    ACTCtl_sExhSuperHeatAvg1 + ACTCtl_sExhSuperHeat * cal_ExhSuperHeatFilter;

  /* End of Switch: '<S910>/Init' */

  /* Product: '<S900>/Divide' incorporates:
   *  Constant: '<S900>/Constant'
   *  Delay: '<S900>/Delay'
   *  Delay: '<S900>/Delay1'
   *  Delay: '<S900>/Delay2'
   *  Delay: '<S900>/Delay3'
   *  Sum: '<S900>/Add'
   */
  ACTCtl_sSuperHeatAvg = ((((ACTCtl_sSuperHeat + ME11_ARID_DEF.Delay1_DSTATE_lt)
    + ME11_ARID_DEF.Delay_DSTATE_aj[0]) + ME11_ARID_DEF.Delay2_DSTATE_f[0]) +
    ME11_ARID_DEF.Delay3_DSTATE_kc[0]) / 5.0F;

  /* Switch: '<S912>/Init' incorporates:
   *  Constant: '<S900>/Constant1'
   *  Constant: '<S911>/Constant'
   *  Product: '<S911>/Product'
   *  Product: '<S911>/Product1'
   *  Sum: '<S911>/Sum'
   *  Sum: '<S911>/Sum1'
   *  UnitDelay: '<S912>/FixPt Unit Delay2'
   */
  if (ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_a != 0) {
    ACTCtl_sSuperHeatAvg1 = ACTCtl_sSuperHeat;
  }

  ACTCtl_sSuperHeatAvg1 = (1.0F - cal_SuperHeatFilter) * ACTCtl_sSuperHeatAvg1 +
    ACTCtl_sSuperHeat * cal_SuperHeatFilter;

  /* End of Switch: '<S912>/Init' */

  /* Switch: '<S1013>/Switch' incorporates:
   *  Constant: '<S1012>/Constant'
   *  Constant: '<S1013>/Constant1'
   *  Logic: '<S945>/NOT'
   *  Logic: '<S945>/NOT1'
   *  Logic: '<S945>/OR'
   *  Logic: '<S945>/OR1'
   *  Logic: '<S945>/OR2'
   *  Logic: '<S945>/OR3'
   *  RelationalOperator: '<S1012>/Compare'
   *  Switch: '<S945>/Switch'
   */
  if (cal_PTCEnableDataEnb) {
    /* Switch: '<S1013>/Switch' incorporates:
     *  Constant: '<S1013>/Constant'
     */
    ACTCtl_sPTCEnable = cal_PTCEnableData;
  } else if ((!ACTCtl_bBatPMPSpdFlt) && (!ACTCtl_bAcPMPSpdFlt) &&
             ((!ACTCtl_bAcPMPFaultFlg) && (!ACTCtl_bBatPMPFaultFlg)) &&
             (ACTCtl_sPTCRequestTemp > 0.0F) &&
             ME11_ARID_DEF.ACTCtl_bAcPMPRunFFForPTC) {
    /* Switch: '<S945>/Switch' incorporates:
     *  Constant: '<S945>/Constant'
     *  Switch: '<S1013>/Switch'
     */
    ACTCtl_sPTCEnable = 3U;
  } else {
    /* Switch: '<S1013>/Switch' incorporates:
     *  Constant: '<S945>/Constant1'
     *  Switch: '<S945>/Switch'
     */
    ACTCtl_sPTCEnable = 0U;
  }

  /* End of Switch: '<S1013>/Switch' */

  /* Chart: '<S947>/PowerOffDelay' incorporates:
   *  Constant: '<S947>/Constant11'
   *  Constant: '<S947>/Constant12'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_pz < 4095U) {
    ME11_ARID_DEF.temporalCounter_i1_pz++;
  }

  if (ME11_ARID_DEF.is_active_c122_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c122_ME11 = 1U;
    ME11_ARID_DEF.is_c122_ME11 = ME11_IN_Init_o;
    ME11_ARID_DEF.ACTCtl_sPTCPwrDeal = ACTCtl_sPTCReqPower;
  } else if (ME11_ARID_DEF.is_c122_ME11 == ME11_IN_Dec) {
    if (ACTCtl_sPTCEnable == 1) {
      ME11_ARID_DEF.is_Dec_g = ME11_IN_NO_ACTIVE_CHILD_gl;
      ME11_ARID_DEF.is_c122_ME11 = ME11_IN_Init_o;
      ME11_ARID_DEF.ACTCtl_sPTCPwrDeal = ACTCtl_sPTCReqPower;
    } else if (ME11_ARID_DEF.is_Dec_g == ME11_IN_Act) {
      if (ME11_ARID_DEF.temporalCounter_i1_pz >= cal_PTCDelOffTime * 10) {
        ME11_ARID_DEF.is_Dec_g = ME11_IN_wait_pz;
      }
    } else {
      /* case IN_wait: */
      ME11_ARID_DEF.is_Dec_g = ME11_IN_Act;
      ME11_ARID_DEF.temporalCounter_i1_pz = 0U;
      ME11_ARID_DEF.ACTCtl_sPTCPwrDeal = ACTCtl_sPTCReqPower - cal_PTCPwrOffFlt;
    }

    /* case IN_Init: */
  } else if (ACTCtl_sPTCEnable == 0) {
    ME11_ARID_DEF.is_c122_ME11 = ME11_IN_Dec;
    ME11_ARID_DEF.is_Dec_g = ME11_IN_Act;
    ME11_ARID_DEF.temporalCounter_i1_pz = 0U;
    ME11_ARID_DEF.ACTCtl_sPTCPwrDeal = ACTCtl_sPTCReqPower - cal_PTCPwrOffFlt;
  } else {
    ME11_ARID_DEF.ACTCtl_sPTCPwrDeal = ACTCtl_sPTCReqPower;
  }

  /* End of Chart: '<S947>/PowerOffDelay' */

  /* Lookup_n-D: '<S947>/cal_SOCHighPTCPwrLmt_CUR' incorporates:
   *  Switch: '<S1165>/Switch'
   */
  ACTCtl_sSOCHighPTCPwrLmt = look1_iflf_binlca(HMICtl_sLeftSetPoint, (const
    float32 *)&cal_SOCHighPTCPwrLmt_1X[0], (const float32 *)
    &cal_SOCHighPTCPwrLmt_CUR[0], 5U);

  /* Relay: '<S947>/Relay' */
  ME11_ARID_DEF.Relay_Mode_h = ((BMS_BatSOCAct_pct >= cal_SOCHighPTCPwrLmtOn) ||
    ((BMS_BatSOCAct_pct > cal_SOCHighPTCPwrLmtOff) && ME11_ARID_DEF.Relay_Mode_h));

  /* Lookup_n-D: '<S947>/cal_PTCBatHeatPwrLmt_CUR' incorporates:
   *  Constant: '<S947>/Constant5'
   *  Sum: '<S947>/Add'
   */
  ACTCtl_sPTCBatHeatPwrLmt = look1_iflf_binlca(cal_BatHeatTrgTemp -
    BMS_InletCooltActlTemp, (const float32 *)&cal_PTCBatHeatPwrLmt_1X[0], (const
    float32 *)&cal_PTCBatHeatPwrLmt_CUR[0], 8U);

  /* SignalConversion: '<S2>/Signal Copy124' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_High_Voltage = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPHiVolt_V;

  /* SignalConversion: '<S2>/Signal Copy127' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_InputCurrent = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPInCurr_A;

  /* Product: '<S31>/Divide1' incorporates:
   *  Constant: '<S31>/Constant'
   *  Product: '<S31>/Divide'
   */
  PWRCtl_sCOMPActlPwr = COMP_High_Voltage * COMP_InputCurrent / 1000.0F;

  /* Switch: '<S31>/Switch3' */
  if (SOMCtl_bExtDefFlg) {
    /* Switch: '<S31>/Switch3' incorporates:
     *  Inport: '<Root>/Vcu2BcmTms_outputs'
     */
    ACPwr_sPTCLmtPwrVal =
      (Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs())
      ->VEMS_HeatCoolMaxPwrCmsp_kW;
  } else {
    /* Switch: '<S31>/Switch3' incorporates:
     *  Constant: '<S31>/Constant5'
     *  Inport: '<Root>/Vcu2BcmTms_outputs'
     *  Sum: '<S31>/Add2'
     */
    ACPwr_sPTCLmtPwrVal =
      ((Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs())
       ->VEMS_HeatCoolMaxPwrCmsp_kW - PWRCtl_sCOMPActlPwr) - cal_PwrOffsetVal;
  }

  /* End of Switch: '<S31>/Switch3' */

  /* Switch: '<S1020>/Switch' incorporates:
   *  Constant: '<S1020>/Constant1'
   *  Constant: '<S947>/Constant3'
   *  Switch: '<S947>/Switch4'
   *  Switch: '<S947>/Switch9'
   */
  if (cal_PTCReqtPowerDataEnb) {
    /* Switch: '<S947>/Switch2' incorporates:
     *  Constant: '<S1020>/Constant'
     *  Switch: '<S1020>/Switch'
     */
    ACTCtl_sPTCReqPower = cal_PTCReqtPowerData;
  } else {
    if (HMICtl_bACDefrost) {
      /* Switch: '<S947>/Switch2' incorporates:
       *  Constant: '<S947>/Constant9'
       *  Switch: '<S947>/Switch9'
       */
      ACTCtl_sPTCReqPower = 7.0F;
    } else if (cal_ACCMForbidCtrl) {
      /* Switch: '<S947>/Switch7' incorporates:
       *  Constant: '<S1015>/Constant'
       *  Constant: '<S1016>/Constant'
       *  Constant: '<S1017>/Constant'
       *  Constant: '<S1018>/Constant'
       *  RelationalOperator: '<S1015>/Compare'
       *  RelationalOperator: '<S1016>/Compare'
       *  RelationalOperator: '<S1017>/Compare'
       *  RelationalOperator: '<S1018>/Compare'
       *  Switch: '<S947>/Switch1'
       *  Switch: '<S947>/Switch3'
       *  Switch: '<S947>/Switch4'
       *  Switch: '<S947>/Switch5'
       *  Switch: '<S947>/Switch6'
       *  Switch: '<S947>/Switch9'
       */
      if (rtb_Add_b1 == 8) {
        /* Switch: '<S587>/Switch' */
        if (ACTCtl_bCtrlFPTCOnOrOffPwrDiff) {
          /* Switch: '<S947>/Switch2' incorporates:
           *  Switch: '<S947>/Switch7'
           *  Switch: '<S947>/Switch9'
           */
          ACTCtl_sPTCReqPower = ACTCtl_sCtrlFPTCAuxHeatPwr;
        } else {
          /* Switch: '<S947>/Switch2' incorporates:
           *  Constant: '<S587>/Constant5'
           *  Switch: '<S947>/Switch7'
           *  Switch: '<S947>/Switch9'
           */
          ACTCtl_sPTCReqPower = 0.0F;
        }

        /* End of Switch: '<S587>/Switch' */
      } else if (rtb_Add_b1 == 4) {
        /* Switch: '<S947>/Switch8' incorporates:
         *  Constant: '<S1019>/Constant'
         *  Constant: '<S947>/Constant8'
         *  Logic: '<S947>/AND'
         *  RelationalOperator: '<S1019>/Compare'
         *  Relay: '<S947>/Relay'
         *  Switch: '<S947>/Switch3'
         */
        if (ME11_ARID_DEF.Relay_Mode_h && (ME11_ARID_DEF.DataTypeConversion1 ==
             4)) {
          rtb_Delay1_ie = ACTCtl_sSOCHighPTCPwrLmt;
        } else {
          rtb_Delay1_ie = 7.0F;
        }

        /* Switch: '<S947>/Switch2' incorporates:
         *  Constant: '<S947>/Constant6'
         *  Delay: '<S503>/Delay'
         *  Switch: '<S947>/Switch3'
         */
        if (ME11_ARID_DEF.Delay_DSTATE_kf) {
          /* Switch: '<S582>/Switch' incorporates:
           *  Constant: '<S582>/Constant5'
           */
          if (ACTCtl_bPTCOnOrOffPwrDiff) {
            ACTCtl_sPTCReqPower = ACTCtl_sPTCAuxHeatPwr;
          } else {
            ACTCtl_sPTCReqPower = 0.0F;
          }
        } else {
          ACTCtl_sPTCReqPower = 7.0F;
        }

        /* MinMax: '<S947>/Min1' incorporates:
         *  Switch: '<S947>/Switch2'
         *  Switch: '<S947>/Switch3'
         *  Switch: '<S947>/Switch8'
         */
        if (rtb_Delay1_ie <= ACTCtl_sPTCReqPower) {
          /* Switch: '<S947>/Switch9' incorporates:
           *  Switch: '<S947>/Switch3'
           *  Switch: '<S947>/Switch7'
           */
          ACTCtl_sPTCReqPower = rtb_Delay1_ie;
        }

        /* End of MinMax: '<S947>/Min1' */
      } else if (rtb_Add_b1 == 5) {
        /* Switch: '<S947>/Switch2' incorporates:
         *  Switch: '<S947>/Switch3'
         *  Switch: '<S947>/Switch5'
         *  Switch: '<S947>/Switch9'
         */
        ACTCtl_sPTCReqPower = ACTCtl_sPTCBatHeatPwrLmt;
      } else if (rtb_Add_b1 == 6) {
        /* Switch: '<S582>/Switch' incorporates:
         *  Constant: '<S582>/Constant5'
         */
        if (ACTCtl_bPTCOnOrOffPwrDiff) {
          rtb_Add_ok = ACTCtl_sPTCAuxHeatPwr;
        } else {
          rtb_Add_ok = 0.0F;
        }

        /* Switch: '<S947>/Switch2' incorporates:
         *  Sum: '<S947>/Add1'
         *  Switch: '<S582>/Switch'
         *  Switch: '<S947>/Switch3'
         *  Switch: '<S947>/Switch5'
         *  Switch: '<S947>/Switch6'
         *  Switch: '<S947>/Switch9'
         */
        ACTCtl_sPTCReqPower = rtb_Add_ok + ACTCtl_sPTCBatHeatPwrLmt;
      } else if (rtb_FixPtRelationalOperator_fk) {
        /* Switch: '<S947>/Switch2' incorporates:
         *  Constant: '<S947>/Constant2'
         *  Switch: '<S947>/Switch1'
         *  Switch: '<S947>/Switch3'
         *  Switch: '<S947>/Switch5'
         *  Switch: '<S947>/Switch6'
         *  Switch: '<S947>/Switch9'
         */
        ACTCtl_sPTCReqPower = 7.0F;
      } else {
        /* Switch: '<S947>/Switch2' incorporates:
         *  Constant: '<S947>/Constant1'
         *  Switch: '<S947>/Switch1'
         *  Switch: '<S947>/Switch3'
         *  Switch: '<S947>/Switch5'
         *  Switch: '<S947>/Switch6'
         *  Switch: '<S947>/Switch9'
         */
        ACTCtl_sPTCReqPower = 0.0F;
      }

      /* End of Switch: '<S947>/Switch7' */
    } else {
      /* Switch: '<S947>/Switch2' incorporates:
       *  Constant: '<S947>/Constant4'
       *  Switch: '<S947>/Switch4'
       *  Switch: '<S947>/Switch9'
       */
      ACTCtl_sPTCReqPower = 7.0F;
    }

    /* MinMax: '<S947>/Min' incorporates:
     *  Constant: '<S947>/Constant3'
     *  Switch: '<S947>/Switch4'
     *  Switch: '<S947>/Switch9'
     */
    if (ACTCtl_sPTCReqPower > ACPwr_sPTCLmtPwrVal) {
      /* Switch: '<S947>/Switch2' incorporates:
       *  MinMax: '<S947>/Min'
       */
      ACTCtl_sPTCReqPower = ACPwr_sPTCLmtPwrVal;
    }

    /* End of MinMax: '<S947>/Min' */

    /* Switch: '<S947>/Switch13' incorporates:
     *  Constant: '<S1014>/Constant'
     *  RelationalOperator: '<S1014>/Compare'
     */
    if (ACTCtl_sPTCReqPower == 0.0F) {
      /* MinMax: '<S947>/Max' */
      if (ME11_ARID_DEF.ACTCtl_sPTCPwrDeal >= ACTCtl_sPTCReqPower) {
        /* Switch: '<S947>/Switch2' incorporates:
         *  Switch: '<S1020>/Switch'
         *  Switch: '<S947>/Switch13'
         */
        ACTCtl_sPTCReqPower = ME11_ARID_DEF.ACTCtl_sPTCPwrDeal;
      }

      /* End of MinMax: '<S947>/Max' */
    }

    /* End of Switch: '<S947>/Switch13' */
  }

  /* End of Switch: '<S1020>/Switch' */

  /* RelationalOperator: '<S937>/Compare' incorporates:
   *  Constant: '<S937>/Constant'
   *  Delay: '<S444>/Delay'
   */
  ME11_ARID_DEF.Delay_DSTATE_en = (ACTCtl_sPTCReqPower > 0.5F);

  /* DataTypeConversion: '<S24>/Data Type Conversion' incorporates:
   *  Constant: '<S444>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status1_BOD'
   *  Sum: '<S444>/Add'
   */
  rtb_Add3_do = (uint8)
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status1_BOD_IPM_HVCH_Status1_BOD())
     ->VIPM_HVCHPCBTemp_C + 40.0F);

  /* CCaller: '<S444>/C Caller1' incorporates:
   *  Constant: '<S444>/Constant5'
   */
  Rte_DIDReadData(rtb_Add3_do, ((uint8)DID_0xF275));

  /* CCaller: '<S444>/C Caller2' incorporates:
   *  Constant: '<S444>/Constant4'
   *  Constant: '<S444>/Constant8'
   *  Sum: '<S444>/Add1'
   */
  Rte_DIDReadData((uint8)(rtb_Merge_g + 40.0F), ((uint8)DID_0xF276));

  /* DataTypeConversion: '<S24>/Data Type Conversion' incorporates:
   *  Constant: '<S943>/Constant4'
   *  Inport: '<Root>/IPM_HVCH_Status1_BOD'
   *  Sum: '<S943>/Add1'
   */
  rtb_Add3_do = (uint8)
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status1_BOD_IPM_HVCH_Status1_BOD())
     ->VIPM_HVCHInletTemp_C + 40.0F);

  /* CCaller: '<S943>/C Caller1' incorporates:
   *  Constant: '<S943>/Constant5'
   */
  Rte_DIDReadData(rtb_Add3_do, ((uint8)DID_0xF277));

  /* RelationalOperator: '<S991>/Compare' incorporates:
   *  Constant: '<S991>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 8);

  /* Chart: '<S943>/Internal_Voltage_Fault' */
  ME11_External_Com_Fault(rtb_Delay1_ag, &ME11_ARID_DEF.ErrSts_iw,
    &ME11_ARID_DEF.ARID_DEF_Internal_Voltage_Fault);

  /* CCaller: '<S943>/C Caller10' incorporates:
   *  Constant: '<S943>/Constant11'
   *  RelationalOperator: '<S973>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942629),
                     ME11_ARID_DEF.ErrSts_iw);

  /* RelationalOperator: '<S992>/Compare' incorporates:
   *  Constant: '<S992>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 9);

  /* Chart: '<S943>/Over_Current_Fault' */
  if (ME11_ARID_DEF.temporalCounter_i1_h1 < 15U) {
    ME11_ARID_DEF.temporalCounter_i1_h1++;
  }

  if (ME11_ARID_DEF.is_active_c108_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c108_ME11 = 1U;
    ME11_ARID_DEF.is_c108_ME11 = ME11_IN_Default_k;
    ME11_ARID_DEF.ErrSts_o = false;
  } else {
    switch (ME11_ARID_DEF.is_c108_ME11) {
     case ME11_IN_Default_k:
      ME11_ARID_DEF.ErrSts_o = false;
      if (rtb_Delay1_ag) {
        ME11_ARID_DEF.is_c108_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_h1 = 0U;
      }
      break;

     case ME11_IN_Err_e:
      ME11_ARID_DEF.ErrSts_o = true;
      if (!rtb_Delay1_ag) {
        ME11_ARID_DEF.is_c108_ME11 = ME11_IN_wait1_o;
        ME11_ARID_DEF.temporalCounter_i1_h1 = 0U;
      }
      break;

     case ME11_IN_wait_k:
      if (!rtb_Delay1_ag) {
        ME11_ARID_DEF.is_c108_ME11 = ME11_IN_Default_k;
        ME11_ARID_DEF.ErrSts_o = false;
      } else if (ME11_ARID_DEF.temporalCounter_i1_h1 >= 10U) {
        ME11_ARID_DEF.is_c108_ME11 = ME11_IN_Err_e;
        ME11_ARID_DEF.ErrSts_o = true;
      }
      break;

     default:
      /* case IN_wait1: */
      if (rtb_Delay1_ag) {
        ME11_ARID_DEF.is_c108_ME11 = ME11_IN_Err_e;
        ME11_ARID_DEF.ErrSts_o = true;
      } else if (ME11_ARID_DEF.temporalCounter_i1_h1 >= 10U) {
        ME11_ARID_DEF.is_c108_ME11 = ME11_IN_Default_k;
        ME11_ARID_DEF.ErrSts_o = false;
      }
      break;
    }
  }

  /* End of Chart: '<S943>/Over_Current_Fault' */

  /* CCaller: '<S943>/C Caller11' incorporates:
   *  Constant: '<S943>/Constant12'
   *  RelationalOperator: '<S974>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942719), ME11_ARID_DEF.ErrSts_o);

  /* RelationalOperator: '<S993>/Compare' incorporates:
   *  Constant: '<S993>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 10);

  /* Chart: '<S943>/Power_Target_Fault' */
  ME11_External_Com_Fault(rtb_Delay1_ag, &ME11_ARID_DEF.ErrSts,
    &ME11_ARID_DEF.ARID_DEF_Power_Target_Fault);

  /* CCaller: '<S943>/C Caller12' incorporates:
   *  Constant: '<S943>/Constant13'
   *  RelationalOperator: '<S976>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942803), ME11_ARID_DEF.ErrSts);

  /* RelationalOperator: '<S954>/Compare' incorporates:
   *  Constant: '<S954>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 11);

  /* Chart: '<S943>/PCB_Temp_Sensor_Fault' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_m, &ME11_ARID_DEF.ARID_DEF_PCB_Temp_Sensor_Fault);

  /* CCaller: '<S943>/C Caller13' incorporates:
   *  Constant: '<S943>/Constant14'
   *  RelationalOperator: '<S977>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942929), ME11_ARID_DEF.ErrSts_m);

  /* RelationalOperator: '<S955>/Compare' incorporates:
   *  Constant: '<S955>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 12);

  /* Chart: '<S943>/Core_Temp_Sensor_Fault' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_h, &ME11_ARID_DEF.ARID_DEF_Core_Temp_Sensor_Fault);

  /* CCaller: '<S943>/C Caller14' incorporates:
   *  Constant: '<S943>/Constant15'
   *  RelationalOperator: '<S978>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942A29), ME11_ARID_DEF.ErrSts_h);

  /* CCaller: '<S943>/C Caller15' incorporates:
   *  Constant: '<S943>/Constant16'
   *  RelationalOperator: '<S979>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942B29),
                     ME11_ARID_DEF.ErrSts_oi);

  /* CCaller: '<S943>/C Caller16' incorporates:
   *  Constant: '<S943>/Constant17'
   *  RelationalOperator: '<S980>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942C29), ME11_ARID_DEF.ErrSts_e);

  /* RelationalOperator: '<S958>/Compare' incorporates:
   *  Constant: '<S958>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 15);

  /* Chart: '<S943>/PCB_Temp_High' */
  ME11_External_Com_Fault(rtb_Delay1_ag, &ME11_ARID_DEF.ErrSts_i,
    &ME11_ARID_DEF.ARID_DEF_PCB_Temp_High);

  /* CCaller: '<S943>/C Caller17' incorporates:
   *  Constant: '<S943>/Constant18'
   *  RelationalOperator: '<S981>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942D98), ME11_ARID_DEF.ErrSts_i);

  /* RelationalOperator: '<S959>/Compare' incorporates:
   *  Constant: '<S959>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 16);

  /* Chart: '<S943>/Core_Temp_High' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_oe, &ME11_ARID_DEF.ARID_DEF_Core_Temp_High);

  /* CCaller: '<S943>/C Caller18' incorporates:
   *  Constant: '<S943>/Constant19'
   *  RelationalOperator: '<S982>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942E98),
                     ME11_ARID_DEF.ErrSts_oe);

  /* RelationalOperator: '<S960>/Compare' incorporates:
   *  Constant: '<S960>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 17);

  /* Chart: '<S943>/Inlet_Temp_High' */
  ME11_External_Com_Fault(rtb_Delay1_ag, &ME11_ARID_DEF.ErrSts_l,
    &ME11_ARID_DEF.ARID_DEF_Inlet_Temp_High);

  /* CCaller: '<S943>/C Caller19' incorporates:
   *  Constant: '<S943>/Constant20'
   *  RelationalOperator: '<S983>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942B98), ME11_ARID_DEF.ErrSts_l);

  /* DataTypeConversion: '<S24>/Data Type Conversion' incorporates:
   *  DataTypeConversion: '<S943>/Data Type Conversion'
   *  Inport: '<Root>/IPM_HVCH_Status1_BOD'
   */
  rtb_Add3_do = (Rte_IRead_Task_100ms_IPM_HVCH_Status1_BOD_IPM_HVCH_Status1_BOD())
    ->VIPM_HVCHHVSt_flg;

  /* CCaller: '<S943>/C Caller2' incorporates:
   *  Constant: '<S943>/Constant1'
   */
  Rte_DIDReadData(rtb_Add3_do, ((uint8)DID_0xF278));

  /* RelationalOperator: '<S961>/Compare' incorporates:
   *  Constant: '<S961>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 18);

  /* Chart: '<S943>/ Outlet_Temp_High' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_nf, &ME11_ARID_DEF.ARID_DEF_Outlet_Temp_High);

  /* CCaller: '<S943>/C Caller20' incorporates:
   *  Constant: '<S943>/Constant21'
   *  RelationalOperator: '<S984>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942C98),
                     ME11_ARID_DEF.ErrSts_nf);

  /* RelationalOperator: '<S962>/Compare' incorporates:
   *  Constant: '<S962>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 19);

  /* Chart: '<S943>/Current_Sensor_Fault' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_li, &ME11_ARID_DEF.ARID_DEF_Current_Sensor_Fault);

  /* CCaller: '<S943>/C Caller21' incorporates:
   *  Constant: '<S943>/Constant22'
   *  RelationalOperator: '<S985>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942F1D),
                     ME11_ARID_DEF.ErrSts_li);

  /* RelationalOperator: '<S963>/Compare' incorporates:
   *  Constant: '<S963>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 20);

  /* Chart: '<S943>/ Abnormal_Over_temperatura_via _software_monitoring' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_nq,
    &ME11_ARID_DEF.ARID_DEF_Abnormal_Over_temperatura_via_software_monitoring);

  /* CCaller: '<S943>/C Caller22' incorporates:
   *  Constant: '<S943>/Constant23'
   *  RelationalOperator: '<S987>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942098),
                     ME11_ARID_DEF.ErrSts_nq);

  /* RelationalOperator: '<S965>/Compare' incorporates:
   *  Constant: '<S965>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 21);

  /* Chart: '<S943>/Abnormal_Over_temperatura_via _hardware_monitoring' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_oel,
    &ME11_ARID_DEF.ARID_DEF_Abnormal_Over_temperatura_via_hardware_monitoring);

  /* CCaller: '<S943>/C Caller23' incorporates:
   *  Constant: '<S943>/Constant24'
   *  RelationalOperator: '<S988>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x943198),
                     ME11_ARID_DEF.ErrSts_oel);

  /* RelationalOperator: '<S952>/Compare' incorporates:
   *  Constant: '<S952>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 1);

  /* Chart: '<S943>/External_Com_Fault' */
  ME11_External_Com_Fault(rtb_Delay1_ag, &ME11_ARID_DEF.ErrSts_d,
    &ME11_ARID_DEF.ARID_DEF_External_Com_Fault);

  /* CCaller: '<S943>/C Caller3' incorporates:
   *  Constant: '<S943>/Constant2'
   *  RelationalOperator: '<S966>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942386), ME11_ARID_DEF.ErrSts_d);

  /* RelationalOperator: '<S953>/Compare' incorporates:
   *  Constant: '<S953>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 2);

  /* Chart: '<S943>/HVIL_Fault' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_n, &ME11_ARID_DEF.ARID_DEF_HVIL_Fault);

  /* CCaller: '<S943>/C Caller4' incorporates:
   *  Constant: '<S943>/Constant3'
   *  RelationalOperator: '<S967>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942229), ME11_ARID_DEF.ErrSts_n);

  /* RelationalOperator: '<S964>/Compare' incorporates:
   *  Constant: '<S964>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 3);

  /* Chart: '<S943>/HV_Over_Voltage' */
  ME11_External_Com_Fault(rtb_Delay1_ag, &ME11_ARID_DEF.ErrSts_cu,
    &ME11_ARID_DEF.ARID_DEF_HV_Over_Voltage);

  /* CCaller: '<S943>/C Caller5' incorporates:
   *  Constant: '<S943>/Constant6'
   *  RelationalOperator: '<S968>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942416),
                     ME11_ARID_DEF.ErrSts_cu);

  /* RelationalOperator: '<S975>/Compare' incorporates:
   *  Constant: '<S975>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 4);

  /* Chart: '<S943>/HV_Under_Voltage' */
  ME11_External_Com_Fault(rtb_Delay1_ag, &ME11_ARID_DEF.ErrSts_b,
    &ME11_ARID_DEF.ARID_DEF_HV_Under_Voltage);

  /* CCaller: '<S943>/C Caller6' incorporates:
   *  Constant: '<S943>/Constant7'
   *  RelationalOperator: '<S969>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942417), ME11_ARID_DEF.ErrSts_b);

  /* RelationalOperator: '<S986>/Compare' incorporates:
   *  Constant: '<S986>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 5);

  /* Chart: '<S943>/LV_Over_Voltage' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_a, &ME11_ARID_DEF.ARID_DEF_LV_Over_Voltage);

  /* CCaller: '<S943>/C Caller7' incorporates:
   *  Constant: '<S943>/Constant8'
   *  RelationalOperator: '<S970>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942516), ME11_ARID_DEF.ErrSts_a);

  /* RelationalOperator: '<S989>/Compare' incorporates:
   *  Constant: '<S989>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 6);

  /* Chart: '<S943>/LV_Under_Voltage' */
  ME11_Abnormal_Over_temperatura_via_software_monitoring(rtb_Delay1_ag,
    &ME11_ARID_DEF.ErrSts_e5, &ME11_ARID_DEF.ARID_DEF_LV_Under_Voltage);

  /* CCaller: '<S943>/C Caller8' incorporates:
   *  Constant: '<S943>/Constant9'
   *  RelationalOperator: '<S971>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942517),
                     ME11_ARID_DEF.ErrSts_e5);

  /* RelationalOperator: '<S990>/Compare' incorporates:
   *  Constant: '<S990>/Constant'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   */
  rtb_Delay1_ag =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum == 7);

  /* Chart: '<S943>/Internal_Com_Fault' */
  ME11_External_Com_Fault(rtb_Delay1_ag, &ME11_ARID_DEF.ErrSts_c,
    &ME11_ARID_DEF.ARID_DEF_Internal_Com_Fault);

  /* CCaller: '<S943>/C Caller9' incorporates:
   *  Constant: '<S943>/Constant10'
   *  RelationalOperator: '<S972>/Compare'
   */
  Dem_SetEventStatus(((uint8)DemEventParameter_0x942604), ME11_ARID_DEF.ErrSts_c);

  /* Product: '<S1022>/Divide' incorporates:
   *  Constant: '<S1022>/Constant3'
   */
  ACTCtl_eAcPMPSpdSet = (uint8)((float32)rtb_Add6_d * 2.5F);

  /* Product: '<S1023>/Divide' incorporates:
   *  Constant: '<S1023>/Constant3'
   */
  ACTCtl_eBatPMPSpdSet = (uint8)((float32)rtb_MultiportSwitch1 * 2.5F);

  /* Gain: '<S1287>/Gain' incorporates:
   *  Inport: '<Root>/MotPMP_RealRPM'
   *
   * Block description for '<Root>/MotPMP_RealRPM':
   *  
   */
  MotPMP_RealRPM = 0.400390625F * (float32)
    Rte_IRead_Task_100ms_MotPMP_RealRPM_MotPMP_RealRPM();

  /* Switch: '<S1065>/Switch' incorporates:
   *  Constant: '<S1065>/Constant1'
   *  Switch: '<S1024>/Switch5'
   */
  if (cal_MotPMPSpdSetDataEnb) {
    /* Switch: '<S1065>/Switch' incorporates:
     *  Constant: '<S1065>/Constant'
     */
    rtb_IFreezFlag_bd = cal_MotPMPSpdSetData;
  } else if (rtb_Compare_mgx) {
    /* Switch: '<S1024>/Switch7' incorporates:
     *  Constant: '<S1061>/Constant'
     *  RelationalOperator: '<S1061>/Compare'
     *  Switch: '<S1024>/Switch2'
     *  Switch: '<S1024>/Switch5'
     */
    if (ACCtl_bExhFlg) {
      /* Switch: '<S1065>/Switch' incorporates:
       *  Constant: '<S1024>/Constant19'
       *  Switch: '<S1024>/Switch7'
       */
      rtb_IFreezFlag_bd = 50U;
    } else if (rtb_Add_b1 == 10) {
      /* Switch: '<S1065>/Switch' incorporates:
       *  Constant: '<S1024>/Constant6'
       *  Switch: '<S1024>/Switch2'
       *  Switch: '<S1024>/Switch7'
       */
      rtb_IFreezFlag_bd = 100U;
    } else {
      /* MultiPortSwitch: '<S1024>/Multiport Switch' incorporates:
       *  Switch: '<S1024>/Switch2'
       */
      switch (rtb_DataTypeConversion1_j0) {
       case 1:
       case 4:
       case 2:
        break;

       case 5:
        /* MultiPortSwitch: '<S1024>/Multiport Switch' incorporates:
         *  Constant: '<S1024>/Constant11'
         */
        rtb_Add5_d = cal_MotPMPMotHeatBatSpd;
        break;

       case 3:
        /* MultiPortSwitch: '<S1024>/Multiport Switch' incorporates:
         *  Constant: '<S1024>/Constant12'
         */
        rtb_Add5_d = cal_MotPMPThStoSpd;
        break;
      }

      /* End of MultiPortSwitch: '<S1024>/Multiport Switch' */

      /* Switch: '<S1024>/Switch4' incorporates:
       *  Constant: '<S1024>/Constant10'
       *  Constant: '<S1024>/Constant4'
       *  Constant: '<S1062>/Constant'
       *  RelationalOperator: '<S1062>/Compare'
       *  Switch: '<S1024>/Switch2'
       */
      if (ME11_ARID_DEF.DataTypeConversion1 >= 2) {
        rtb_IFreezFlag_bd = cal_MotPMPDefaultSpd;
      } else {
        rtb_IFreezFlag_bd = 10U;
      }

      /* MinMax: '<S1024>/Max' incorporates:
       *  Switch: '<S1024>/Switch2'
       *  Switch: '<S1024>/Switch4'
       */
      if (rtb_Add5_d >= rtb_IFreezFlag_bd) {
        /* Switch: '<S1065>/Switch' incorporates:
         *  Switch: '<S1024>/Switch2'
         *  Switch: '<S1024>/Switch7'
         */
        rtb_IFreezFlag_bd = rtb_Add5_d;
      }

      /* End of MinMax: '<S1024>/Max' */
    }

    /* End of Switch: '<S1024>/Switch7' */
  } else {
    /* Switch: '<S1065>/Switch' incorporates:
     *  Constant: '<S1024>/Constant16'
     *  Switch: '<S1024>/Switch5'
     */
    rtb_IFreezFlag_bd = 10U;
  }

  /* End of Switch: '<S1065>/Switch' */

  /* Switch: '<S1068>/Switch2' incorporates:
   *  Constant: '<S1024>/Constant7'
   *  Constant: '<S1024>/Constant8'
   *  RelationalOperator: '<S1068>/LowerRelop1'
   *  RelationalOperator: '<S1068>/UpperRelop'
   *  Switch: '<S1068>/Switch'
   */
  if (rtb_IFreezFlag_bd > 100) {
    /* Switch: '<S1068>/Switch2' */
    rtb_IFreezFlag_bd = 100U;
  } else if (rtb_IFreezFlag_bd < 10) {
    /* Switch: '<S1068>/Switch' incorporates:
     *  Constant: '<S1024>/Constant8'
     *  Switch: '<S1068>/Switch2'
     */
    rtb_IFreezFlag_bd = 10U;
  }

  /* End of Switch: '<S1068>/Switch2' */

  /* Chart: '<S1024>/Chart' incorporates:
   *  Constant: '<S1024>/Constant'
   */
  if (ME11_ARID_DEF.temporalCounter_i1_fp < 63U) {
    ME11_ARID_DEF.temporalCounter_i1_fp++;
  }

  if (ME11_ARID_DEF.is_active_c127_ME11 == 0U) {
    ME11_ARID_DEF.is_active_c127_ME11 = 1U;
    ME11_ARID_DEF.is_c127_ME11 = ME11_IN_Default_k;
    ACTCtl_bMotPMPSpdFlt = false;
  } else {
    switch (ME11_ARID_DEF.is_c127_ME11) {
     case ME11_IN_Default_k:
      ACTCtl_bMotPMPSpdFlt = false;
      if (rtb_IFreezFlag_bd > MotPMP_RealRPM + (float32)cal_MotPMPSpdDiffVal) {
        ME11_ARID_DEF.is_c127_ME11 = ME11_IN_wait_k;
        ME11_ARID_DEF.temporalCounter_i1_fp = 0U;
      }
      break;

     case ME11_IN_Fault_b:
      ACTCtl_bMotPMPSpdFlt = true;
      if ((rtb_IFreezFlag_bd < MotPMP_RealRPM + (float32)cal_MotPMPSpdDiffVal) &&
          (rtb_IFreezFlag_bd > MotPMP_RealRPM - (float32)cal_MotPMPSpdDiffVal))
      {
        ME11_ARID_DEF.is_c127_ME11 = ME11_IN_Default_k;
        ACTCtl_bMotPMPSpdFlt = false;
      }
      break;

     default:
      /* case IN_wait: */
      if (ME11_ARID_DEF.temporalCounter_i1_fp >= 50U) {
        ME11_ARID_DEF.is_c127_ME11 = ME11_IN_Fault_b;
        ACTCtl_bMotPMPSpdFlt = true;
      } else if ((rtb_IFreezFlag_bd < MotPMP_RealRPM + (float32)
                  cal_MotPMPSpdDiffVal) && (rtb_IFreezFlag_bd > MotPMP_RealRPM -
                  (float32)cal_MotPMPSpdDiffVal)) {
        ME11_ARID_DEF.is_c127_ME11 = ME11_IN_Default_k;
        ACTCtl_bMotPMPSpdFlt = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1024>/Chart' */

  /* Product: '<S1024>/Divide' incorporates:
   *  Constant: '<S1024>/Constant5'
   */
  ACTCtl_eMotPMPSpdSet = (uint8)((float32)rtb_IFreezFlag_bd * 2.5F);

  /* Logic: '<S8>/AND' incorporates:
   *  Constant: '<S1071>/Constant'
   *  Delay: '<S503>/Delay'
   *  RelationalOperator: '<S1070>/Compare'
   *  RelationalOperator: '<S1071>/Compare'
   */
  rtb_BusCreator.TMS_HVReq_flg = (ME11_ARID_DEF.Delay_DSTATE_kf ||
    (ACTCtl_sPTCReqPower >= 0.5F));

  /* BusCreator: '<S8>/Bus Creator' */
  rtb_BusCreator.AppSwcTmsVersion = 22U;
  rtb_BusCreator.TMS_NMReq_flg = IOCtl_PwrNmReqFlg;

  /* Switch: '<S31>/Switch2' */
  if (SOMCtl_bExtDefFlg) {
    /* Gain: '<S8>/Gain6' incorporates:
     *  Constant: '<S31>/Constant4'
     *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
     *  Inport: '<Root>/Vcu2BcmTms_outputs'
     *  Sum: '<S31>/Add1'
     */
    rtb_Gain6 = ((Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs()
                 )->VEMS_HeatCoolMaxPwrCmsp_kW -
                 (Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD
                  ())->VIPM_HVCHPwr_kW) - cal_PwrOffsetVal;
  } else {
    /* Gain: '<S8>/Gain6' incorporates:
     *  Inport: '<Root>/Vcu2BcmTms_outputs'
     */
    rtb_Gain6 = (Rte_IRead_Task_100ms_Vcu2BcmTms_outputs_Vcu2BcmTms_outputs())
      ->VEMS_HeatCoolMaxPwrCmsp_kW;
  }

  /* End of Switch: '<S31>/Switch2' */

  /* MinMax: '<S31>/Min' incorporates:
   *  Constant: '<S31>/Constant3'
   */
  if (rtb_Gain6 <= cal_COMPPwrMaxLmt) {
    /* MinMax: '<S31>/Min' */
    PWRCtl_sLmtPwrCOMP = rtb_Gain6;
  } else {
    /* MinMax: '<S31>/Min' */
    PWRCtl_sLmtPwrCOMP = cal_COMPPwrMaxLmt;
  }

  /* End of MinMax: '<S31>/Min' */

  /* Switch: '<S31>/Switch' incorporates:
   *  Constant: '<S1310>/Constant'
   *  RelationalOperator: '<S1310>/Compare'
   */
  if (ME11_ARID_DEF.DataTypeConversion1 < 2) {
    /* Gain: '<S8>/Gain6' incorporates:
     *  Constant: '<S31>/Constant1'
     */
    rtb_Gain6 = 0.0F;
  } else {
    /* Gain: '<S8>/Gain6' incorporates:
     *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
     *  Sum: '<S31>/Add'
     */
    rtb_Gain6 = PWRCtl_sCOMPActlPwr +
      (Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
      ->VIPM_HVCHPwr_kW;
  }

  /* End of Switch: '<S31>/Switch' */

  /* BusCreator: '<S8>/Bus Creator1' incorporates:
   *  Constant: '<S2>/Constant7'
   *  Constant: '<S8>/Constant'
   *  DataTypeConversion: '<S8>/Data Type Conversion9'
   *  Delay: '<S503>/Delay'
   *  Logic: '<S8>/NOT'
   */
  rtb_BusCreator1.AC_1_Chksum = 0U;
  rtb_BusCreator1.AC_1_AliveCnt = 0U;
  rtb_BusCreator1.AC_CompFailModeOprtSta = false;
  rtb_BusCreator1.AC_CompOprtReq = ME11_ARID_DEF.Delay_DSTATE_kf;
  rtb_BusCreator1.AC_CompOprtEnaCmd = ME11_ARID_DEF.Delay_DSTATE_kf;
  rtb_BusCreator1.AC_CompTgtSpd = (uint16)ACTCtl_sACCMCtlSpd;
  rtb_BusCreator1.AC_CompMaxAllowPwrCmsp = PWRCtl_sLmtPwrCOMP;
  rtb_BusCreator1.AC_PumpActlSpdDuty = ACTCtl_eAcPMPSpdSet;
  rtb_BusCreator1.AC_HighVolDCTolalPwr = rtb_Gain6;
  rtb_BusCreator1.AC_PumpActlSpdDutyV = !ACTCtl_bAcPMPFaultFlg;

  /* BusCreator: '<S8>/Bus Creator10' incorporates:
   *  Gain: '<S8>/Gain5'
   */
  rtb_BusCreator10.TMS_HPEXVCurrentPosition = (uint16)(6.4F *
    HP_EXV_CurrentPosition_B);
  rtb_BusCreator10.TMS_C5WVBPosSetReq = ACTCtl_eC5WVValue;
  rtb_BusCreator10.TMS_C3WVBPosSetReq = ACTCtl_eC3WVValue;
  rtb_BusCreator10.TMS_HPEXVEnableCmd = ACTCtl_bHPEXVEnb;
  rtb_BusCreator10.TMS_BEXVEnableCmd = ACTCtl_bBEXVEnb;
  rtb_BusCreator10.TMS_AEXVEnableReq = ACTCtl_bAEXVEnb;
  rtb_BusCreator10.TMS_C5WVPosRec = BCV_PosRec;
  rtb_BusCreator10.TMS_C3WVPosRec = MCV_PosRec;
  rtb_BusCreator10.TMS_C5WVMode = BCV_Mode;
  rtb_BusCreator10.TMS_C3WVMode = MCV_Mode;

  /* BusCreator: '<S8>/Bus Creator2' incorporates:
   *  Constant: '<S10>/Constant'
   *  Constant: '<S8>/Constant3'
   *  DataTypeConversion: '<S8>/Data Type Conversion13'
   *  DataTypeConversion: '<S8>/Data Type Conversion15'
   *  DataTypeConversion: '<S8>/Data Type Conversion16'
   *  DataTypeConversion: '<S8>/Data Type Conversion21'
   *  Gain: '<S8>/Gain9'
   *  Inport: '<Root>/IPM_HVCH_Status1_BOD'
   *  Inport: '<Root>/IPM_HVCH_Status2_BOD'
   *  RelationalOperator: '<S10>/Compare'
   */
  rtb_BusCreator2.AC_HVHDeviceInternTemp_HVAC = (sint8)(float32)floor
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status1_BOD_IPM_HVCH_Status1_BOD())
     ->VIPM_HVCHInletTemp_C);
  rtb_BusCreator2.AC_HVHFailSta_HVAC =
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
     ->VIPM_HVCHFltCod_enum >= 1);
  rtb_BusCreator2.AC_2_Chksum = 0U;
  rtb_BusCreator2.AC_2_AliveCnt = 0U;
  rtb_BusCreator2.AC_HVHActlPwr_HVAC =
    (Rte_IRead_Task_100ms_IPM_HVCH_Status2_BOD_IPM_HVCH_Status2_BOD())
    ->VIPM_HVCHPwr_kW;
  rtb_BusCreator2.TMS_PTPressure = 1000.0F * ACSen_sHiPressFilter;
  rtb_BusCreator2.AC_ActTotalPower = rtb_Gain6;
  rtb_BusCreator2.AC_FailSta = false;
  rtb_BusCreator2.TMSR_BattTempCtrlRmnSwtFb = false;
  rtb_BusCreator2.AC_BatPumpFailSta = false;
  rtb_BusCreator2.AC_HVHActlOprtMode_HVAC =
    (Rte_IRead_Task_100ms_IPM_HVCH_Status1_BOD_IPM_HVCH_Status1_BOD())
    ->VIPM_HVCHWorkMode_enum;
  rtb_BusCreator2.AC_ActlOprtMode = HMICtl_eACSts;
  rtb_BusCreator2.TMS_PTTemp = (sint8)(float32)floor(ACSen_sWCCHiTempFilter);

  /* BusCreator: '<S8>/Bus Creator6' incorporates:
   *  DataTypeConversion: '<S8>/Data Type Conversion10'
   *  DataTypeConversion: '<S8>/Data Type Conversion17'
   *  Delay: '<S503>/Delay'
   *  Gain: '<S8>/Gain10'
   */
  rtb_BusCreator6.AC_Checksum = 0U;
  rtb_BusCreator6.AC_RollingCounter = 0U;
  rtb_BusCreator6.COMP_EcompSpeedCtrl = ACTCtl_sACCMCtlSpd;
  rtb_BusCreator6.COMP_EcompEnable = ME11_ARID_DEF.Delay_DSTATE_kf;
  rtb_BusCreator6.COMP_CompInputPowerLimit = PWRCtl_sLmtPwrCOMP;
  rtb_BusCreator6.TMS_ACPExhaustTmp = (sint8)(float32)floor
    (ACSen_sACCMHiTempFilter);
  rtb_BusCreator6.TMS_ACPInletPressure = 1000.0F * ACSen_sLoPressFilter;

  /* BusCreator: '<S8>/Bus Creator7' incorporates:
   *  DataTypeConversion: '<S8>/Data Type Conversion2'
   */
  rtb_BusCreator7.HVCHCmd_Checksum = 0U;
  rtb_BusCreator7.HVCHCmd_RollingCounter = 0U;
  rtb_BusCreator7.HVCH_RequestTemp = (sint8)(float32)floor
    (ACTCtl_sPTCRequestTemp);
  rtb_BusCreator7.HVCH_RequestPower = ACTCtl_sPTCReqPower;
  rtb_BusCreator7.HVCH_Enabled = ACTCtl_sPTCEnable;

  /* BusCreator: '<S8>/Bus Creator8' incorporates:
   *  Gain: '<S8>/Gain'
   *  Gain: '<S8>/Gain6'
   *  Gain: '<S8>/Gain7'
   *  Gain: '<S8>/Gain8'
   */
  rtb_BusCreator8.TMS_AcPMPSpdSet = 0.400390625F * (float32)ACTCtl_eAcPMPSpdSet;
  rtb_BusCreator8.TMS_BatPMPSpdSet = 0.400390625F * (float32)
    ACTCtl_eBatPMPSpdSet;
  rtb_BusCreator8.TMS_MotPMPSpdSet = 0.400390625F * (float32)
    ACTCtl_eMotPMPSpdSet;
  rtb_BusCreator8.TMS_MotPMPRealRPM = MotPMP_RealRPM;
  rtb_BusCreator8.TMS_BatPMPRealRPM = BatPMP_RealRPM;
  rtb_BusCreator8.TMS_AcPMPRealRPM = AcPMP_RealRPM;
  rtb_BusCreator8.TMS_HPEXVPositionCmd = (uint16)(6.4F * ACTCtl_sHPEXVPos);

  /* Gain: '<S8>/Gain3' */
  rtb_BusCreator9.TMS_BEXVCurrentPosition = (uint16)(6.4F *
    BAT_EXV_CurrentPosition_B);

  /* Gain: '<S8>/Gain1' */
  rtb_BusCreator9.TMS_AEXVPositionReq = (uint16)(6.4F * ACTCtl_sAEXVPos);

  /* BusCreator: '<S8>/Bus Creator9' incorporates:
   *  Gain: '<S8>/Gain2'
   *  Gain: '<S8>/Gain4'
   */
  rtb_BusCreator9.TMS_BEXVPositionCmd = (uint16)(6.4F * ACTCtl_sBEXVPos);
  rtb_BusCreator9.TMS_AEXVCurrentPosition = (uint16)(6.4F * EXV_CurrentPosition);

  /* DataTypeConversion: '<S8>/Data Type Conversion11' */
  rtb_BusCreator3.TMS_EvapOutTmp = (sint8)(float32)floor(ACSen_sEvapTempFilter);

  /* BusCreator: '<S8>/Bus Creator3' incorporates:
   *  Constant: '<S8>/Constant8'
   *  DataTypeConversion: '<S8>/Data Type Conversion12'
   *  DataTypeConversion: '<S8>/Data Type Conversion13'
   *  DataTypeConversion: '<S8>/Data Type Conversion14'
   *  Logic: '<S8>/NOT1'
   */
  rtb_BusCreator3.AC_3_Chksum = 0U;
  rtb_BusCreator3.AC_3_AliveCnt = 0U;
  rtb_BusCreator3.AC_ExtdDefrostActvReq = SOMCtl_bExtDefFlg;
  rtb_BusCreator3.AC_EnvirTempV = !rtb_AND2_of;
  rtb_BusCreator3.AC_IndoorTemp = ACSen_sCabinTempFilter;
  rtb_BusCreator3.AC_EnvirTemp = ACSen_sEnvTempCor;
  rtb_BusCreator3.TMS_OHXOutTmp = (sint8)(float32)floor(ACSen_sOHXTempFilter);
  rtb_BusCreator3.TMS_EvapTmp = (sint8)(float32)floor(ACSen_sEvapSurTemp);
  rtb_BusCreator3.TMS_ChillerOutTmp = (sint8)(float32)floor(ACSen_sChiTempFilter);

  /* BusCreator: '<S8>/Bus Creator4' incorporates:
   *  DataTypeConversion: '<S8>/Data Type Conversion20'
   *  Inport: '<Root>/IPM_HVCH_Status1_BOD'
   *  Logic: '<S8>/NOT2'
   */
  rtb_BusCreator4.AC_HV_PTC_InternalPCBTemp = (sint8)(float32)floor
    ((Rte_IRead_Task_100ms_IPM_HVCH_Status1_BOD_IPM_HVCH_Status1_BOD())
     ->VIPM_HVCHPCBTemp_C);
  rtb_BusCreator4.AC_8_Checksum = 0U;
  rtb_BusCreator4.AC_8_RollingCounter = 0U;
  rtb_BusCreator4.AC_RefrgLoPressureV =
    !ME11_TMSADCSampleFunc_ARID_DEF.Compare_n;
  rtb_BusCreator4.AC_RefrgLoPressure = ACSen_sLoPressFilter;
  rtb_BusCreator4.AC_L_Currt_Slct_Frg_Dirct = false;
  rtb_BusCreator4.AC_HV_PTC_heating_rq = ACTCtl_sPTCEnable;
  rtb_BusCreator4.AC_HV_PTC_MediumTemp = 0;
  rtb_BusCreator4.AC_EvapTgtTemp = ACCtl_tSetPointEvap;
  rtb_BusCreator4.AC_HV_PTC_On_Rq = ACTCtl_sPTCEnable;
  rtb_BusCreator4.AC_Auto_FrontFanSpd = AC_FanLeVel;

  /* BusCreator: '<S8>/Bus Creator5' incorporates:
   *  DataTypeConversion: '<S8>/Data Type Conversion16'
   *  Delay: '<S1119>/Delay1'
   *  Inport: '<Root>/Bcm2VcuTms_outputs'
   */
  rtb_BusCreator5.BCM_RearViewMirrHeatingSts =
    ((Rte_IRead_Task_100ms_Bcm2VcuTms_outputs_Bcm2VcuTms_outputs())
     ->BCM_RearMirrorHeatSts != 0);
  rtb_BusCreator5.AC_ACStatus_Chksum = 0U;
  rtb_BusCreator5.AC_ACStatus_AliveCnt = 0U;
  rtb_BusCreator5.AC_leftTempValue = ME11_ARID_DEF.Delay1_DSTATE_fq;
  rtb_BusCreator5.AC_ManualDefrostFb = HMICtl_bACDefrost;
  rtb_BusCreator5.AC_ACAutoFb = HMICtl_bACAuto;
  rtb_BusCreator5.AC_BlowerModeSta = ME11_ARID_DEF.DataTypeConversion1_b;

  /* Switch: '<S8>/Switch' */
  if (HMICtl_bACAuto) {
    /* BusCreator: '<S8>/Bus Creator5' */
    rtb_BusCreator5.AC_FrontFanSpdValue = AC_FanLeVel;
  } else {
    /* BusCreator: '<S8>/Bus Creator5' */
    rtb_BusCreator5.AC_FrontFanSpdValue = ME11_ARID_DEF.Switch1_n;
  }

  /* End of Switch: '<S8>/Switch' */

  /* BusCreator: '<S8>/Bus Creator5' */
  rtb_BusCreator5.AC_ACPowerFb = ME11_ARID_DEF.Switch_c;
  rtb_BusCreator5.AC_AutoBlowerModeSta = ME11_ARID_DEF.DataTypeConversion1_b;
  rtb_BusCreator5.AC_HybridEcoModeSta = HMICtl_eACSts;
  rtb_BusCreator5.AC_AirInletModeSta = HMICtl_eInner;

  /* BusCreator: '<S8>/Bus Creator11' */
  rtb_BusCreator11.TMS_MotInletCooltTemp = 0;
  rtb_BusCreator11.TMS_PwrCoolFanSpdDuty = 0.0F;
  rtb_BusCreator11.TMS_BATThermalMod = rtb_SOMCtl_eBatModeSts_l;
  rtb_BusCreator11.TMS_CabThermalMod = rtb_Add2_j5;
  rtb_BusCreator11.AC_ACUnlockVentSetFB = 0U;
  rtb_BusCreator11.CCU_RemoteLockFb = 0U;
  rtb_BusCreator11.CCU_RemoteCarSearchFb = 0U;
  rtb_BusCreator11.CCU_OpenVentilationFb = 0U;
  rtb_BusCreator11.AC_RemtCtrlFb = 0U;
  rtb_BusCreator11.AC_TempSetFb = 0U;
  rtb_BusCreator11.AC_RemoteDefrostCtlFb = 0U;

  /* SignalConversion: '<S16>/Signal Copy108' incorporates:
   *  Inport: '<Root>/AcPMP_PumpInputVolt'
   *
   * Block description for '<Root>/AcPMP_PumpInputVolt':
   *  
   */
  AcPMP_PumpInputVolt =
    Rte_IRead_Task_100ms_AcPMP_PumpInputVolt_AcPMP_PumpInputVolt();

  /* SignalConversion: '<S16>/Signal Copy110' incorporates:
   *  Inport: '<Root>/AcPMP_ProjectCode1'
   *
   * Block description for '<Root>/AcPMP_ProjectCode1':
   *  1
   */
  AcPMP_ProjectCode1 =
    Rte_IRead_Task_100ms_AcPMP_ProjectCode1_AcPMP_ProjectCode1();

  /* SignalConversion: '<S16>/Signal Copy111' incorporates:
   *  Inport: '<Root>/AcPMP_ProjectCode2'
   *
   * Block description for '<Root>/AcPMP_ProjectCode2':
   *  1
   */
  AcPMP_ProjectCode2 =
    Rte_IRead_Task_100ms_AcPMP_ProjectCode2_AcPMP_ProjectCode2();

  /* SignalConversion: '<S16>/Signal Copy112' incorporates:
   *  Inport: '<Root>/AcPMP_SupplierNumber'
   *
   * Block description for '<Root>/AcPMP_SupplierNumber':
   *  
   */
  AcPMP_SupplierNumber =
    Rte_IRead_Task_100ms_AcPMP_SupplierNumber_AcPMP_SupplierNumber();

  /* SignalConversion: '<S16>/Signal Copy113' incorporates:
   *  Inport: '<Root>/AcPMP_PartNumber'
   *
   * Block description for '<Root>/AcPMP_PartNumber':
   *  
   */
  AcPMP_PartNumber = Rte_IRead_Task_100ms_AcPMP_PartNumber_AcPMP_PartNumber();

  /* SignalConversion: '<S16>/Signal Copy114' incorporates:
   *  Inport: '<Root>/AcPMP_HWVersion'
   *
   * Block description for '<Root>/AcPMP_HWVersion':
   *  
   */
  AcPMP_HWVersion = Rte_IRead_Task_100ms_AcPMP_HWVersion_AcPMP_HWVersion();

  /* SignalConversion: '<S16>/Signal Copy115' incorporates:
   *  Inport: '<Root>/AcPMP_SWVersion_Main'
   *
   * Block description for '<Root>/AcPMP_SWVersion_Main':
   *  -
   */
  AcPMP_SWVersion_Main =
    Rte_IRead_Task_100ms_AcPMP_SWVersion_Main_AcPMP_SWVersion_Main();

  /* SignalConversion: '<S16>/Signal Copy116' incorporates:
   *  Inport: '<Root>/AcPMP_SWVersion_Sub'
   *
   * Block description for '<Root>/AcPMP_SWVersion_Sub':
   *  -
   */
  AcPMP_SWVersion_Sub =
    Rte_IRead_Task_100ms_AcPMP_SWVersion_Sub_AcPMP_SWVersion_Sub();

  /* SignalConversion: '<S16>/Signal Copy117' incorporates:
   *  Inport: '<Root>/AcPMP_SWVersion_Patch'
   *
   * Block description for '<Root>/AcPMP_SWVersion_Patch':
   *  -
   */
  AcPMP_SWVersion_Patch =
    Rte_IRead_Task_100ms_AcPMP_SWVersion_Patch_AcPMP_SWVersion_Patch();

  /* CCaller: '<S17>/C Caller1' incorporates:
   *  Constant: '<S17>/Constant5'
   *  DataTypeConversion: '<S17>/Data Type Conversion'
   *  Inport: '<Root>/C5WVPosRec'
   *
   * Block description for '<Root>/C5WVPosRec':
   *  C5WVPosRec
   */
  Rte_DIDReadData((uint8)Rte_IRead_Task_100ms_C5WVPosRec_C5WVPosRec(), ((uint8)
    DID_0xF27B));

  /* SignalConversion: '<S17>/Signal Copy69' incorporates:
   *  Inport: '<Root>/C5WVRunSts'
   *
   * Block description for '<Root>/C5WVRunSts':
   *  C5WV motor status.
   */
  BCV_RunSts = Rte_IRead_Task_100ms_C5WVRunSts_C5WVRunSts();

  /* SignalConversion: '<S17>/Signal Copy70' incorporates:
   *  Inport: '<Root>/C5WVSpdLvl'
   *
   * Block description for '<Root>/C5WVSpdLvl':
   *  C5WV motor speed level.
   */
  BCV_SpdLvl = Rte_IRead_Task_100ms_C5WVSpdLvl_C5WVSpdLvl();

  /* SignalConversion: '<S17>/Signal Copy71' incorporates:
   *  Inport: '<Root>/C5WVTempSts'
   *
   * Block description for '<Root>/C5WVTempSts':
   *  C5WV over temperature warning
   */
  BCV_TempSts = Rte_IRead_Task_100ms_C5WVTempSts_C5WVTempSts();

  /* SignalConversion: '<S17>/Signal Copy72' incorporates:
   *  Inport: '<Root>/C5WVVoltSts'
   *
   * Block description for '<Root>/C5WVVoltSts':
   *  C5WV over voltage or under voltage
   *  warning.
   */
  BCV_VoltSts = Rte_IRead_Task_100ms_C5WVVoltSts_C5WVVoltSts();

  /* SignalConversion: '<S17>/Signal Copy73' incorporates:
   *  Inport: '<Root>/ErrRespC5WV'
   *
   * Block description for '<Root>/ErrRespC5WV':
   *  Communication error occurred.
   */
  BCV_ErrResp = Rte_IRead_Task_100ms_ErrRespC5WV_ErrRespC5WV();

  /* CCaller: '<S19>/C Caller1' incorporates:
   *  Constant: '<S19>/Constant4'
   *  Constant: '<S19>/Constant5'
   *  Sum: '<S19>/Add1'
   */
  Rte_DIDReadData((uint8)(BMS_InletCooltActlTemp + 40.0F), ((uint8)DID_0xF279));

  /* SignalConversion: '<S20>/Signal Copy94' incorporates:
   *  Inport: '<Root>/BatPMP_PumpInputVolt'
   *
   * Block description for '<Root>/BatPMP_PumpInputVolt':
   *  
   */
  BatPMP_PumpInputVolt =
    Rte_IRead_Task_100ms_BatPMP_PumpInputVolt_BatPMP_PumpInputVolt();

  /* CCaller: '<S24>/C Caller1' incorporates:
   *  Constant: '<S24>/Constant5'
   *  DataTypeConversion: '<S24>/Data Type Conversion'
   *  Inport: '<Root>/C3WV_PosRec'
   *
   * Block description for '<Root>/C3WV_PosRec':
   *  C3WVPosRec
   */
  Rte_DIDReadData((uint8)Rte_IRead_Task_100ms_C3WV_PosRec_C3WV_PosRec(), ((uint8)
    DID_0xF27A));

  /* SignalConversion: '<S24>/Signal Copy53' incorporates:
   *  Inport: '<Root>/C3WV_RunSts'
   *
   * Block description for '<Root>/C3WV_RunSts':
   *  C3WV motor status.
   */
  MCV_RunSts = Rte_IRead_Task_100ms_C3WV_RunSts_C3WV_RunSts();

  /* SignalConversion: '<S24>/Signal Copy54' incorporates:
   *  Inport: '<Root>/C3WV_SpdLvl'
   *
   * Block description for '<Root>/C3WV_SpdLvl':
   *  C3WV motor speed level.
   */
  MCV_SpdLvl = Rte_IRead_Task_100ms_C3WV_SpdLvl_C3WV_SpdLvl();

  /* SignalConversion: '<S24>/Signal Copy55' incorporates:
   *  Inport: '<Root>/C3WV_TempSts'
   *
   * Block description for '<Root>/C3WV_TempSts':
   *  C3WV over temperature warning
   */
  MCV_TempSts = Rte_IRead_Task_100ms_C3WV_TempSts_C3WV_TempSts();

  /* SignalConversion: '<S24>/Signal Copy56' incorporates:
   *  Inport: '<Root>/C3WV_VoltSts'
   *
   * Block description for '<Root>/C3WV_VoltSts':
   *  C3WV over voltage or under voltage
   *  warning.
   */
  MCV_VoltSts = Rte_IRead_Task_100ms_C3WV_VoltSts_C3WV_VoltSts();

  /* SignalConversion: '<S24>/Signal Copy57' incorporates:
   *  Inport: '<Root>/C3WV_ErrResp'
   *
   * Block description for '<Root>/C3WV_ErrResp':
   *  Communication error occurred.
   */
  MCV_ErrResp = Rte_IRead_Task_100ms_C3WV_ErrResp_C3WV_ErrResp();

  /* SignalConversion: '<S25>/Signal Copy87' incorporates:
   *  Inport: '<Root>/MotPMP_PumpInputVolt'
   *
   * Block description for '<Root>/MotPMP_PumpInputVolt':
   *  
   */
  MotPMP_PumpInputVolt =
    Rte_IRead_Task_100ms_MotPMP_PumpInputVolt_MotPMP_PumpInputVolt();

  /* Gain: '<S28>/Gain' */
  rtb_Divide_ox = (uint16)(6.4F * ACTCtl_sHPEXVPos);

  /* SignalConversion: '<S28>/Signal Copy1' */
  rtb_Delay1_ag = ACTCtl_bHPEXVEnb;

  /* SignalConversion: '<S28>/Signal Copy2' */
  rtb_IFreezFlag_bd = ACTCtl_bHPEXVInitReq;

  /* Gain: '<S28>/Gain2' */
  rtb_Add_ei_0 = (uint16)(6.4F * ACTCtl_sBEXVPos);

  /* SignalConversion: '<S28>/Signal Copy4' */
  rtb_FixPtRelationalOperator_mk = ACTCtl_bBEXVEnb;

  /* SignalConversion: '<S28>/Signal Copy5' */
  rtb_IFreezFlag_jz = ACTCtl_bBEXVInitReq;

  /* Gain: '<S28>/Gain1' */
  rtb_Gain1_j_0 = (uint16)(6.4F * ACTCtl_sAEXVPos);

  /* SignalConversion: '<S28>/Signal Copy7' */
  rtb_Compare_mgx = ACTCtl_bAEXVEnb;

  /* SignalConversion: '<S28>/Signal Copy8' */
  rtb_SOMCtl_eBatModeSts_l = ACTCtl_bAEXVInitReq;

  /* SignalConversion: '<S28>/Signal Copy9' */
  rtb_Add7_i = ACTCtl_eC3WVValue;

  /* SignalConversion: '<S28>/Signal Copy10' */
  rtb_Add2_j5 = ACTCtl_eC3WVSLSts;

  /* SignalConversion: '<S28>/Signal Copy12' */
  rtb_Add3_do = ACTCtl_eC5WVValue;

  /* SignalConversion: '<S28>/Signal Copy13' */
  rtb_Add6_d = ACTCtl_eC5WVSLSts;

  /* SignalConversion: '<S28>/Signal Copy15' */
  rtb_Add5_d = ACTCtl_eAcPMPSpdSet;

  /* SignalConversion: '<S28>/Signal Copy16' */
  rtb_Add4_ox = ACTCtl_eBatPMPSpdSet;

  /* SignalConversion: '<S28>/Signal Copy17' */
  rtb_Gain_gr = ACTCtl_eMotPMPSpdSet;

  /* Switch: '<S1438>/Switch' incorporates:
   *  Constant: '<S1438>/Constant'
   *  Delay: '<S1438>/Delay'
   *  Switch: '<S1438>/Switch1'
   */
  if (rtb_AND_b3z) {
    ME11_ARID_DEF.Delay_DSTATE_ha = true;
  } else {
    ME11_ARID_DEF.Delay_DSTATE_ha = ((!FixPtRelationalOperator) &&
      SOMCtrl_bBatLTRDelayFlg);
  }

  /* End of Switch: '<S1438>/Switch' */

  /* DataTypeConversion: '<S1683>/Data Type Conversion2' */
  SOMCtl_eCabinModePre = rtb_IndexVector8_j;

  /* SignalConversion: '<S2>/Signal Copy118' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_CANBusOff = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPCANBusOff_flg;

  /* SignalConversion: '<S2>/Signal Copy120' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_Commu_Error = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPCommuError_flg;

  /* SignalConversion: '<S2>/Signal Copy123' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_EcompST = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPEcompST_enum;

  /* SignalConversion: '<S2>/Signal Copy125' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_HvError = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPHvErr_enum;

  /* SignalConversion: '<S2>/Signal Copy128' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_LoseStep = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPLoseStep_flg;

  /* SignalConversion: '<S2>/Signal Copy129' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_LvError = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPLvErr_enum;

  /* SignalConversion: '<S2>/Signal Copy135' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_TempError = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPTempErr_flg;

  /* SignalConversion: '<S2>/Signal Copy136' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  COMP_Temperature = (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_COMPTemp_C;

  /* SignalConversion: '<S2>/Signal Copy137' incorporates:
   *  Inport: '<Root>/IPM_COMP_AC_BOD'
   */
  ECUHighVoltInterlockSignal =
    (Rte_IRead_Task_100ms_IPM_COMP_AC_BOD_IPM_COMP_AC_BOD())
    ->VIPM_ECUHiVoltInterlockSig_flg;

  /* DataStoreRead: '<S29>/Data Store Read1' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[0] = ME11_ARID_DEF.EEWrite_bACOnOff;

  /* DataStoreRead: '<S29>/Data Store Read2' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[1] = ME11_ARID_DEF.EEWrite_bACAutoSts;

  /* DataStoreRead: '<S29>/Data Store Read3' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[2] = ME11_ARID_DEF.EEWrite_CabinSetTemp;

  /* DataStoreRead: '<S29>/Data Store Read' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[3] = ME11_ARID_DEF.EEWrite_AmbienceTemp;

  /* DataStoreRead: '<S29>/Data Store Read4' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[4] = ME11_ARID_DEF.EEWrite_CabinMode;

  /* DataStoreRead: '<S29>/Data Store Read5' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[5] = ME11_ARID_DEF.EEWrite_CabinBlower;

  /* DataStoreRead: '<S29>/Data Store Read6' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[6] = ME11_ARID_DEF.EEWrite_PCUInletTemp;

  /* DataStoreRead: '<S29>/Data Store Read8' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[7] = ME11_ARID_DEF.EEWrite_TimeHour;

  /* DataStoreRead: '<S29>/Data Store Read7' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[8] = ME11_ARID_DEF.EEWrite_TimeMin;

  /* DataStoreRead: '<S29>/Data Store Read9' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[9] = ME11_ARID_DEF.EEWrite_TimeDay;

  /* DataStoreRead: '<S29>/Data Store Read10' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[10] = ME11_ARID_DEF.EEWrite_CabinRecDoor;

  /* DataStoreRead: '<S29>/Data Store Read11' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   */
  rtb_VectorConcatenate[11] = ME11_ARID_DEF.EEWrite_CabinModeDoor;

  /* CCaller: '<S29>/C Caller' incorporates:
   *  Concatenate: '<S29>/Vector Concatenate'
   *  Constant: '<S29>/Constant'
   */
  NvmTmsBlockWriteData(&rtb_VectorConcatenate[0], 12U);

  /* Update for UnitDelay: '<S211>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S211>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE = 0U;

  /* Update for Delay: '<S1081>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE = ME11_ARID_DEF.OutData;

  /* Update for UnitDelay: '<S1097>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1097>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_l = 0U;

  /* Update for Delay: '<S1072>/Delay' incorporates:
   *  Constant: '<S1072>/AC_swtEnvTempEquip_C2'
   */
  ME11_ARID_DEF.Delay_DSTATE_px = true;

  /* Update for UnitDelay: '<S1101>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S1101>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_n = 0U;

  /* Update for Delay: '<S1072>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE = ME11_ARID_DEF.OutData;

  /* Update for UnitDelay: '<S270>/Delay Input1'
   *
   * Block description for '<S270>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE = HMICtl_sLeftSetPoint;

  /* Update for UnitDelay: '<S271>/Delay Input1'
   *
   * Block description for '<S271>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_j = HMICtl_sLeftSetPoint;

  /* Update for UnitDelay: '<S272>/Delay Input1'
   *
   * Block description for '<S272>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_gyl = rtb_Delay_mz3;

  /* Update for UnitDelay: '<S176>/Unit Delay2' incorporates:
   *  UnitDelay: '<S176>/Unit Delay3'
   */
  ME11_ARID_DEF.UnitDelay2_DSTATE = ME11_ARID_DEF.UnitDelay3_DSTATE;

  /* Update for UnitDelay: '<S273>/Delay Input1' incorporates:
   *  UnitDelay: '<S176>/Unit Delay3'
   *
   * Block description for '<S273>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_d = ME11_ARID_DEF.UnitDelay3_DSTATE;

  /* Update for UnitDelay: '<S274>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S274>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_j = 0U;

  /* Update for Delay: '<S4>/Delay' incorporates:
   *  Merge: '<S43>/Merge'
   */
  ME11_ARID_DEF.Delay_DSTATE_fl = ACCtl_BlowerMode;

  /* Update for UnitDelay: '<S220>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S220>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_e = 0U;

  /* Update for UnitDelay: '<S223>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S223>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_k = 0U;

  /* Update for UnitDelay: '<S225>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S225>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_kj = 0U;

  /* Update for Delay: '<S228>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_hx = rtb_IFreezFlag;

  /* Update for Delay: '<S235>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_o3 = rtb_Switch2_ip;

  /* Update for Delay: '<S230>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_e0 = rtb_IFreezFlag_d;

  /* Update for Delay: '<S254>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_bf = rtb_Switch1_l2;

  /* Update for Delay: '<S178>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_n = ME11_ARID_DEF.RecordInitialEvapTemp_o;

  /* Update for Delay: '<S35>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_hr = AC_FanLevelAct;

  /* Update for Delay: '<S179>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_e = ME11_ARID_DEF.RecordInitialEvapTemp;

  /* Update for Delay: '<S179>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_o = ACCtl_BloweFanSpeed;

  /* Update for Delay: '<S340>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_f = rtb_Merge1_m;

  /* Update for Delay: '<S340>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_k[0] = ME11_ARID_DEF.Delay_DSTATE_k[1];
  ME11_ARID_DEF.Delay_DSTATE_k[1] = rtb_Merge1_m;

  /* Update for Delay: '<S340>/Delay2' */
  ME11_ARID_DEF.Delay2_DSTATE[0] = ME11_ARID_DEF.Delay2_DSTATE[1];
  ME11_ARID_DEF.Delay2_DSTATE[1] = ME11_ARID_DEF.Delay2_DSTATE[2];
  ME11_ARID_DEF.Delay2_DSTATE[2] = rtb_Merge1_m;

  /* Update for Delay: '<S340>/Delay3' */
  ME11_ARID_DEF.Delay3_DSTATE[0] = ME11_ARID_DEF.Delay3_DSTATE[1];
  ME11_ARID_DEF.Delay3_DSTATE[1] = ME11_ARID_DEF.Delay3_DSTATE[2];
  ME11_ARID_DEF.Delay3_DSTATE[2] = ME11_ARID_DEF.Delay3_DSTATE[3];
  ME11_ARID_DEF.Delay3_DSTATE[3] = rtb_Merge1_m;

  /* Update for UnitDelay: '<S385>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S385>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_g = 0U;

  /* Update for Delay: '<S42>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_fk = HMICtl_bACDefrost;

  /* Update for Delay: '<S38>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_dt = ACCtl_IntakeRatio;

  /* Update for Delay: '<S1419>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_h0r = ME11_ARID_DEF.DataTypeConversion1;

  /* Update for Delay: '<S1419>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_gb = ME11_ARID_DEF.DataTypeConversion1;

  /* Update for Delay: '<S1324>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_me = SOMCtl_bBatHeatFlg;

  /* Update for Delay: '<S1506>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_nl = ME11_ARID_DEF.DataTypeConversion1;

  /* Update for Delay: '<S1322>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_mq = SOMCtl_bBatHeatFlg;

  /* Update for Delay: '<S1326>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_ma = SOMCtl_bBatHeatFlg;

  /* Update for Delay: '<S1320>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_c0 = SOMCtl_bBatHeatFlg;

  /* Update for Delay: '<S1325>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_ef = SOMCtl_bBatHeatFlg;

  /* Update for UnitDelay: '<S156>/Delay Input1'
   *
   * Block description for '<S156>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_lk = HMICtl_bACDefrost;

  /* Update for UnitDelay: '<S124>/Delay Input1'
   *
   * Block description for '<S124>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_ne = HMICtl_bACDefrost;

  /* Update for Delay: '<S1676>/Delay1' incorporates:
   *  Delay: '<S1679>/Delay'
   */
  ME11_ARID_DEF.Delay1_DSTATE_b = ME11_ARID_DEF.Delay_DSTATE_d2;

  /* Update for Delay: '<S1676>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_he = rtb_Delay_j3;

  /* Update for UnitDelay: '<S1724>/Delay Input1'
   *
   * Block description for '<S1724>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_h = rtb_IndexVector8_j;

  /* Update for Delay: '<S32>/Delay1' incorporates:
   *  Delay: '<S503>/Delay'
   */
  ME11_ARID_DEF.Delay1_DSTATE_bs = ME11_ARID_DEF.Delay_DSTATE_kf;

  /* Update for Delay: '<S451>/Delay2' */
  ME11_ARID_DEF.Delay2_DSTATE_lz = ACTCtl_bCOMPSpdDiffFlt;

  /* Update for UnitDelay: '<S523>/Delay Input1'
   *
   * Block description for '<S523>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_ln = rtb_AND1_hh;

  /* Update for UnitDelay: '<S1034>/Delay Input1'
   *
   * Block description for '<S1034>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_kp = rtb_FixPtRelationalOperator_i1;

  /* Update for Delay: '<S1023>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_lv = rtb_IFreezFlag_k;

  /* Update for UnitDelay: '<S1050>/Delay Input1'
   *
   * Block description for '<S1050>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_ju = rtb_IFreezFlag_k;

  /* Update for Atomic SubSystem: '<S2>/IODriver' */
  ME11_TMSIODriverFunc_Update();

  /* End of Update for SubSystem: '<S2>/IODriver' */

  /* Update for UnitDelay: '<S75>/Delay Input1' incorporates:
   *  DataTypeConversion: '<S50>/Data Type Conversion'
   *
   * Block description for '<S75>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_hd = rtb_DataTypeConversion_ks;

  /* Update for Delay: '<S30>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_kx = ACSen_sMotTempFilter;

  /* Update for Delay: '<S483>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_cv = ACTCtl_bCOMPIFreeFlag;

  /* Update for Delay: '<S456>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_af = rtb_Add_b1;

  /* Update for UnitDelay: '<S556>/Delay Input1'
   *
   * Block description for '<S556>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_e = ACSen_sHiPressFilter;

  /* Update for UnitDelay: '<S557>/Delay Input1'
   *
   * Block description for '<S557>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_o = ACSen_sLoPressFilter;

  /* Update for UnitDelay: '<S558>/Delay Input1'
   *
   * Block description for '<S558>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_i = ACSen_sHiPressFilter;

  /* Update for UnitDelay: '<S559>/Delay Input1'
   *
   * Block description for '<S559>/Delay Input1':
   *
   *  Store in Global RAM
   */
  ME11_ARID_DEF.DelayInput1_DSTATE_g = ACSen_sLoPressFilter;

  /* Update for Delay: '<S679>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_hw = ME11_ARID_DEF.DataTypeConversion1;

  /* Update for UnitDelay: '<S904>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S904>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_f = 0U;

  /* Update for Delay: '<S896>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_h = ACTCtl_sCoolCondDep;

  /* Update for Delay: '<S896>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_i[0] = ME11_ARID_DEF.Delay_DSTATE_i[1];
  ME11_ARID_DEF.Delay_DSTATE_i[1] = ACTCtl_sCoolCondDep;

  /* Update for Delay: '<S896>/Delay2' */
  ME11_ARID_DEF.Delay2_DSTATE_h[0] = ME11_ARID_DEF.Delay2_DSTATE_h[1];
  ME11_ARID_DEF.Delay2_DSTATE_h[1] = ME11_ARID_DEF.Delay2_DSTATE_h[2];
  ME11_ARID_DEF.Delay2_DSTATE_h[2] = ACTCtl_sCoolCondDep;

  /* Update for Delay: '<S896>/Delay3' */
  ME11_ARID_DEF.Delay3_DSTATE_i[0] = ME11_ARID_DEF.Delay3_DSTATE_i[1];
  ME11_ARID_DEF.Delay3_DSTATE_i[1] = ME11_ARID_DEF.Delay3_DSTATE_i[2];
  ME11_ARID_DEF.Delay3_DSTATE_i[2] = ME11_ARID_DEF.Delay3_DSTATE_i[3];
  ME11_ARID_DEF.Delay3_DSTATE_i[3] = ACTCtl_sCoolCondDep;

  /* Update for UnitDelay: '<S906>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S906>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_li = 0U;

  /* Update for Delay: '<S897>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_l = ACTCtl_sEvapSuperHeat;

  /* Update for Delay: '<S897>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_bm[0] = ME11_ARID_DEF.Delay_DSTATE_bm[1];
  ME11_ARID_DEF.Delay_DSTATE_bm[1] = ACTCtl_sEvapSuperHeat;

  /* Update for Delay: '<S897>/Delay2' */
  ME11_ARID_DEF.Delay2_DSTATE_a[0] = ME11_ARID_DEF.Delay2_DSTATE_a[1];
  ME11_ARID_DEF.Delay2_DSTATE_a[1] = ME11_ARID_DEF.Delay2_DSTATE_a[2];
  ME11_ARID_DEF.Delay2_DSTATE_a[2] = ACTCtl_sEvapSuperHeat;

  /* Update for Delay: '<S897>/Delay3' */
  ME11_ARID_DEF.Delay3_DSTATE_k[0] = ME11_ARID_DEF.Delay3_DSTATE_k[1];
  ME11_ARID_DEF.Delay3_DSTATE_k[1] = ME11_ARID_DEF.Delay3_DSTATE_k[2];
  ME11_ARID_DEF.Delay3_DSTATE_k[2] = ME11_ARID_DEF.Delay3_DSTATE_k[3];
  ME11_ARID_DEF.Delay3_DSTATE_k[3] = ACTCtl_sEvapSuperHeat;

  /* Update for Delay: '<S679>/Delay2' */
  ME11_ARID_DEF.Delay2_DSTATE_pj = ACTCtl_bAEXVInitReq;

  /* Update for Delay: '<S700>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_op = rtb_IFreezFlag_o;

  /* Update for UnitDelay: '<S908>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S908>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_h = 0U;

  /* Update for Delay: '<S898>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_e = ACTCtl_sChiSuperHeat;

  /* Update for Delay: '<S898>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_c[0] = ME11_ARID_DEF.Delay_DSTATE_c[1];
  ME11_ARID_DEF.Delay_DSTATE_c[1] = ACTCtl_sChiSuperHeat;

  /* Update for Delay: '<S898>/Delay2' */
  ME11_ARID_DEF.Delay2_DSTATE_k[0] = ME11_ARID_DEF.Delay2_DSTATE_k[1];
  ME11_ARID_DEF.Delay2_DSTATE_k[1] = ME11_ARID_DEF.Delay2_DSTATE_k[2];
  ME11_ARID_DEF.Delay2_DSTATE_k[2] = ACTCtl_sChiSuperHeat;

  /* Update for Delay: '<S898>/Delay3' */
  ME11_ARID_DEF.Delay3_DSTATE_b[0] = ME11_ARID_DEF.Delay3_DSTATE_b[1];
  ME11_ARID_DEF.Delay3_DSTATE_b[1] = ME11_ARID_DEF.Delay3_DSTATE_b[2];
  ME11_ARID_DEF.Delay3_DSTATE_b[2] = ME11_ARID_DEF.Delay3_DSTATE_b[3];
  ME11_ARID_DEF.Delay3_DSTATE_b[3] = ACTCtl_sChiSuperHeat;

  /* Update for Delay: '<S749>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_a = ME11_ARID_DEF.DataTypeConversion1;

  /* Update for Delay: '<S768>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_bmz = rtb_IFreezFlag_m;

  /* Update for UnitDelay: '<S902>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S902>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_kg = 0U;

  /* Update for Delay: '<S895>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_gh = ACTCtl_sCondDep;

  /* Update for Delay: '<S895>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_hl[0] = ME11_ARID_DEF.Delay_DSTATE_hl[1];
  ME11_ARID_DEF.Delay_DSTATE_hl[1] = ACTCtl_sCondDep;

  /* Update for Delay: '<S895>/Delay2' */
  ME11_ARID_DEF.Delay2_DSTATE_n[0] = ME11_ARID_DEF.Delay2_DSTATE_n[1];
  ME11_ARID_DEF.Delay2_DSTATE_n[1] = ME11_ARID_DEF.Delay2_DSTATE_n[2];
  ME11_ARID_DEF.Delay2_DSTATE_n[2] = ACTCtl_sCondDep;

  /* Update for Delay: '<S895>/Delay3' */
  ME11_ARID_DEF.Delay3_DSTATE_ks[0] = ME11_ARID_DEF.Delay3_DSTATE_ks[1];
  ME11_ARID_DEF.Delay3_DSTATE_ks[1] = ME11_ARID_DEF.Delay3_DSTATE_ks[2];
  ME11_ARID_DEF.Delay3_DSTATE_ks[2] = ME11_ARID_DEF.Delay3_DSTATE_ks[3];
  ME11_ARID_DEF.Delay3_DSTATE_ks[3] = ACTCtl_sCondDep;

  /* Update for Delay: '<S844>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_nb = rtb_IFreezFlag_c;

  /* Update for Delay: '<S823>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_gf = ME11_ARID_DEF.DataTypeConversion1;

  /* Update for Delay: '<S823>/Delay2' */
  ME11_ARID_DEF.Delay2_DSTATE_pl = ACTCtl_bHPEXVInitReq;

  /* Update for Delay: '<S899>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_c = ACTCtl_sExhSuperHeat;

  /* Update for Delay: '<S899>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_l3[0] = ME11_ARID_DEF.Delay_DSTATE_l3[1];
  ME11_ARID_DEF.Delay_DSTATE_l3[1] = ACTCtl_sExhSuperHeat;

  /* Update for Delay: '<S899>/Delay2' */
  ME11_ARID_DEF.Delay2_DSTATE_p[0] = ME11_ARID_DEF.Delay2_DSTATE_p[1];
  ME11_ARID_DEF.Delay2_DSTATE_p[1] = ME11_ARID_DEF.Delay2_DSTATE_p[2];
  ME11_ARID_DEF.Delay2_DSTATE_p[2] = ACTCtl_sExhSuperHeat;

  /* Update for Delay: '<S899>/Delay3' */
  ME11_ARID_DEF.Delay3_DSTATE_ij[0] = ME11_ARID_DEF.Delay3_DSTATE_ij[1];
  ME11_ARID_DEF.Delay3_DSTATE_ij[1] = ME11_ARID_DEF.Delay3_DSTATE_ij[2];
  ME11_ARID_DEF.Delay3_DSTATE_ij[2] = ME11_ARID_DEF.Delay3_DSTATE_ij[3];
  ME11_ARID_DEF.Delay3_DSTATE_ij[3] = ACTCtl_sExhSuperHeat;

  /* Update for UnitDelay: '<S910>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S910>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_nk = 0U;

  /* Update for Delay: '<S900>/Delay1' */
  ME11_ARID_DEF.Delay1_DSTATE_lt = ACTCtl_sSuperHeat;

  /* Update for Delay: '<S900>/Delay' */
  ME11_ARID_DEF.Delay_DSTATE_aj[0] = ME11_ARID_DEF.Delay_DSTATE_aj[1];
  ME11_ARID_DEF.Delay_DSTATE_aj[1] = ACTCtl_sSuperHeat;

  /* Update for Delay: '<S900>/Delay2' */
  ME11_ARID_DEF.Delay2_DSTATE_f[0] = ME11_ARID_DEF.Delay2_DSTATE_f[1];
  ME11_ARID_DEF.Delay2_DSTATE_f[1] = ME11_ARID_DEF.Delay2_DSTATE_f[2];
  ME11_ARID_DEF.Delay2_DSTATE_f[2] = ACTCtl_sSuperHeat;

  /* Update for Delay: '<S900>/Delay3' */
  ME11_ARID_DEF.Delay3_DSTATE_kc[0] = ME11_ARID_DEF.Delay3_DSTATE_kc[1];
  ME11_ARID_DEF.Delay3_DSTATE_kc[1] = ME11_ARID_DEF.Delay3_DSTATE_kc[2];
  ME11_ARID_DEF.Delay3_DSTATE_kc[2] = ME11_ARID_DEF.Delay3_DSTATE_kc[3];
  ME11_ARID_DEF.Delay3_DSTATE_kc[3] = ACTCtl_sSuperHeat;

  /* Update for UnitDelay: '<S912>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S912>/FixPt Constant'
   */
  ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_a = 0U;

  /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' */

  /* Outport: '<Root>/TMS2VCU_AC_1_Command_Outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_AC_1_Command_Outputs_TMS2VCU_AC_1_Command_Outputs
    (&rtb_BusCreator1);

  /* Outport: '<Root>/TMS2VCU_AC_2_State_Outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_AC_2_State_Outputs_TMS2VCU_AC_2_State_Outputs
    (&rtb_BusCreator2);

  /* Outport: '<Root>/TMS2VCU_AC_3_State_Outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_AC_3_State_Outputs_TMS2VCU_AC_3_State_Outputs
    (&rtb_BusCreator3);

  /* Outport: '<Root>/TMS2VCU_AC_8_status_Outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_AC_8_status_Outputs_TMS2VCU_AC_8_status_Outputs(
    &rtb_BusCreator4);

  /* Outport: '<Root>/TMS2VCU_AC_ACStatuts_Outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_AC_ACStatuts_Outputs_TMS2VCU_AC_ACStatuts_Outputs
    (&rtb_BusCreator5);

  /* Outport: '<Root>/TMS2VCU_AC_COMP_Outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_AC_COMP_Outputs_TMS2VCU_AC_COMP_Outputs
    (&rtb_BusCreator6);

  /* Outport: '<Root>/TMS2VCU_HVCH_Command_Outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_HVCH_Command_Outputs_TMS2VCU_HVCH_Command_Outputs
    (&rtb_BusCreator7);

  /* Outport: '<Root>/TMS2VCU_TMS_LINTestData1_Outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_TMS_LINTestData1_Outputs_TMS2VCU_TMS_LINTestData1_Outputs
    (&rtb_BusCreator8);

  /* Outport: '<Root>/TMS2VCU_TMS_LINTestData2_Outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_TMS_LINTestData2_Outputs_TMS2VCU_TMS_LINTestData2_Outputs
    (&rtb_BusCreator9);

  /* Outport: '<Root>/TMS2VCU_TMS_LINTestData3_Outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_TMS_LINTestData3_Outputs_TMS2VCU_TMS_LINTestData3_Outputs
    (&rtb_BusCreator10);

  /* Outport: '<Root>/Tms2Vcu_Info' */
  Rte_IWrite_Task_100ms_Tms2Vcu_Info_Tms2Vcu_Info(&rtb_BusCreator);

  /* Outport: '<Root>/TMS2VCU_PPV_outputs' */
  Rte_IWrite_Task_100ms_TMS2VCU_PPV_outputs_TMS2VCU_PPV_outputs
    (&rtb_BusCreator11);

  /* RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' incorporates:
   *  SubSystem: '<Root>/ME11_TMS'
   */
  /* Outport: '<Root>/TMM_EXV_PositionRequest' incorporates:
   *  Gain: '<S28>/Gain1'
   *
   * Block description for '<Root>/TMM_EXV_PositionRequest':
   *  EXV Position RequestEXV 
   */
  Rte_IWrite_Task_100ms_TMM_EXV_PositionRequest_TMM_EXV_PositionRequest
    (rtb_Gain1_j_0);

  /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' */

  /* Outport: '<Root>/TMM_EXV_EnableRequest'
   *
   * Block description for '<Root>/TMM_EXV_EnableRequest':
   *  EXV Enable RequestEXV 
   */
  Rte_IWrite_Task_100ms_TMM_EXV_EnableRequest_TMM_EXV_EnableRequest
    (rtb_Compare_mgx);

  /* Outport: '<Root>/TMM_EXV_initRequest'
   *
   * Block description for '<Root>/TMM_EXV_initRequest':
   *  EXV Init RequestEXV 
   */
  Rte_IWrite_Task_100ms_TMM_EXV_initRequest_TMM_EXV_initRequest
    (rtb_SOMCtl_eBatModeSts_l);

  /* RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' incorporates:
   *  SubSystem: '<Root>/ME11_TMS'
   */
  /* Outport: '<Root>/BAT_EXV_position_command_B' incorporates:
   *  Gain: '<S28>/Gain2'
   *
   * Block description for '<Root>/BAT_EXV_position_command_B':
   *  EXV pulse request
   */
  Rte_IWrite_Task_100ms_BAT_EXV_position_command_B_BAT_EXV_position_command_B
    (rtb_Add_ei_0);

  /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' */

  /* Outport: '<Root>/BAT_EXV_movenable_command_B'
   *
   * Block description for '<Root>/BAT_EXV_movenable_command_B':
   *  EXV move enable request.
   */
  Rte_IWrite_Task_100ms_BAT_EXV_movenable_command_B_BAT_EXV_movenable_command_B
    (rtb_FixPtRelationalOperator_mk);

  /* Outport: '<Root>/BAT_EXV_initialize_command_B'
   *
   * Block description for '<Root>/BAT_EXV_initialize_command_B':
   *  Initialization status of EXV.
   */
  Rte_IWrite_Task_100ms_BAT_EXV_initialize_command_B_BAT_EXV_initialize_command_B
    (rtb_IFreezFlag_jz);

  /* Outport: '<Root>/C3WV_BPosSetReq'
   *
   * Block description for '<Root>/C3WV_BPosSetReq':
   *  C3WV pulse request
   */
  Rte_IWrite_Task_100ms_C3WV_BPosSetReq_C3WV_BPosSetReq(rtb_Add7_i);

  /* Outport: '<Root>/C3WV_RefDrvReq'
   *
   * Block description for '<Root>/C3WV_RefDrvReq':
   *  Initialization status of C3WV
   */
  Rte_IWrite_Task_100ms_C3WV_RefDrvReq_C3WV_RefDrvReq(rtb_Add2_j5);

  /* Outport: '<Root>/C3WV_SpdLvlReq'
   *
   * Block description for '<Root>/C3WV_SpdLvlReq':
   *  motor speed level.
   */
  Rte_IWrite_Task_100ms_C3WV_SpdLvlReq_C3WV_SpdLvlReq(0U);

  /* Outport: '<Root>/C5WV_BPosSetReq'
   *
   * Block description for '<Root>/C5WV_BPosSetReq':
   *  pulse request
   */
  Rte_IWrite_Task_100ms_C5WV_BPosSetReq_C5WV_BPosSetReq(rtb_Add3_do);

  /* Outport: '<Root>/C5WV_RefDrvReq'
   *
   * Block description for '<Root>/C5WV_RefDrvReq':
   *  Initialization status of C5WV
   */
  Rte_IWrite_Task_100ms_C5WV_RefDrvReq_C5WV_RefDrvReq(rtb_Add6_d);

  /* Outport: '<Root>/C5WV_SpdLvlReq'
   *
   * Block description for '<Root>/C5WV_SpdLvlReq':
   *  motor speed level.
   */
  Rte_IWrite_Task_100ms_C5WV_SpdLvlReq_C5WV_SpdLvlReq(0U);

  /* RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' incorporates:
   *  SubSystem: '<Root>/ME11_TMS'
   */
  /* Outport: '<Root>/HP_EXV_position_command_B' incorporates:
   *  Gain: '<S28>/Gain'
   *
   * Block description for '<Root>/HP_EXV_position_command_B':
   *  EXV pulse request
   */
  Rte_IWrite_Task_100ms_HP_EXV_position_command_B_HP_EXV_position_command_B
    (rtb_Divide_ox);

  /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' */

  /* Outport: '<Root>/HP_EXV_movenable_command_B'
   *
   * Block description for '<Root>/HP_EXV_movenable_command_B':
   *  EXV move enable request.
   */
  Rte_IWrite_Task_100ms_HP_EXV_movenable_command_B_HP_EXV_movenable_command_B
    (rtb_Delay1_ag);

  /* Outport: '<Root>/HP_EXV_initialize_command_B'
   *
   * Block description for '<Root>/HP_EXV_initialize_command_B':
   *  Initialization status of EXV.
   */
  Rte_IWrite_Task_100ms_HP_EXV_initialize_command_B_HP_EXV_initialize_command_B
    (rtb_IFreezFlag_bd);

  /* Outport: '<Root>/AcPMP_SpdSet'
   *
   * Block description for '<Root>/AcPMP_SpdSet':
   *  ,
   */
  Rte_IWrite_Task_100ms_AcPMP_SpdSet_AcPMP_SpdSet(rtb_Add5_d);

  /* Outport: '<Root>/BatPMP_SpdSet'
   *
   * Block description for '<Root>/BatPMP_SpdSet':
   *  ,
   */
  Rte_IWrite_Task_100ms_BatPMP_SpdSet_BatPMP_SpdSet(rtb_Add4_ox);

  /* Outport: '<Root>/MotPMP_SpdSet'
   *
   * Block description for '<Root>/MotPMP_SpdSet':
   *  ,
   */
  Rte_IWrite_Task_100ms_MotPMP_SpdSet_MotPMP_SpdSet(rtb_Gain_gr);
}

/* Model initialize function */
void ME11_Init(void)
{
  {
    /* local block i/o variables */
    boolean rtb_SOMCtl_bBatHeatB3tB1Flg;
    boolean rtb_SOMCtl_bBatHeatB3tB1Flg_e;
    boolean rtb_SOMCtl_bBatLTRFlg_k;
    boolean rtb_SOMCtl_bBatLTRFlg_b;
    boolean rtb_flag;
    boolean rtb_flg;
    boolean rtb_flg_d;
    boolean rtb_flg_g;
    boolean rtb_flg_o;
    boolean rtb_flag_l;
    boolean rtb_flg_dg;
    boolean rtb_flg_f;
    boolean rtb_flag_c;
    boolean rtb_flag_k;
    boolean rtb_flg_n;
    boolean rtb_flg_m;
    boolean rtb_ACTCtl_eCOMPFlg3Cal;
    boolean rtb_ACTCtl_eCOMPFlg3Cal_c;
    boolean rtb_flag_f;
    boolean rtb_flag_g;
    boolean rtb_flag_n;
    boolean rtb_flag_nk;
    boolean rtb_flag_d;
    boolean rtb_flag_a;
    boolean rtb_flag_g4;
    boolean rtb_flag_de;
    boolean rtb_flag_ko;
    uint8 rtb_CCaller[12];
    uint8 rtb_Divide1_ae;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F266H' */
    Buffer_DcmDspData_F266H[0] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F267H' */
    Buffer_DcmDspData_F267H[0] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F268H' */
    Buffer_DcmDspData_F268H[0] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F26CH' */
    Buffer_DcmDspData_F26CH[0] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F271H' */
    Buffer_DcmDspData_F271H[0] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F272H' */
    Buffer_DcmDspData_F272H[0] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F27CH' */
    Buffer_DcmDspData_F27CH[0] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F27DH' */
    Buffer_DcmDspData_F27DH[0] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F27EH' */
    Buffer_DcmDspData_F27EH[0] = 32U;

    /* Start for DataStoreMemory: '<Root>/Data Store Memory' */
    Buffer_DcmDspData_F270H[0] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F266H' */
    Buffer_DcmDspData_F266H[1] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F267H' */
    Buffer_DcmDspData_F267H[1] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F268H' */
    Buffer_DcmDspData_F268H[1] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F26CH' */
    Buffer_DcmDspData_F26CH[1] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F271H' */
    Buffer_DcmDspData_F271H[1] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F272H' */
    Buffer_DcmDspData_F272H[1] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F27CH' */
    Buffer_DcmDspData_F27CH[1] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F27DH' */
    Buffer_DcmDspData_F27DH[1] = 32U;

    /* Start for DataStoreMemory: '<Root>/Buffer_DcmDspData_F27EH' */
    Buffer_DcmDspData_F27EH[1] = 32U;

    /* Start for DataStoreMemory: '<Root>/Data Store Memory' */
    Buffer_DcmDspData_F270H[1] = 32U;

    /* Start for DataStoreMemory: '<Root>/EERead_AmbienceTemp' */
    ME11_ARID_DEF.EERead_AmbienceTemp = 25.0F;

    /* Start for DataStoreMemory: '<Root>/EERead_CabinSetTemp' */
    ME11_ARID_DEF.EERead_CabinSetTemp = 16U;

    /* Start for DataStoreMemory: '<Root>/EEWrite_AmbienceTemp' */
    ME11_ARID_DEF.EEWrite_AmbienceTemp = 65U;

    /* Start for DataStoreMemory: '<Root>/EEWrite_CabinSetTemp' */
    ME11_ARID_DEF.EEWrite_CabinSetTemp = 16U;

    /* Start for DataStoreMemory: '<Root>/EEWrite_PCUInletTemp' */
    ME11_ARID_DEF.EEWrite_PCUInletTemp = 25U;
    ME11_ARID_DEF.Delay1_Reset_ZCE = POS_ZCSIG;
    ME11_ARID_DEF.Delay1_Reset_ZCE_a = POS_ZCSIG;

    /* SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' incorporates:
     *  SubSystem: '<Root>/ME11_TMS'
     */
    /* InitializeConditions for UnitDelay: '<S211>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE = 1U;

    /* InitializeConditions for UnitDelay: '<S1097>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_l = 1U;

    /* InitializeConditions for UnitDelay: '<S1101>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_n = 1U;

    /* InitializeConditions for UnitDelay: '<S274>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_j = 1U;

    /* InitializeConditions for Delay: '<S4>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_fl = BlowerModes_OffMode;

    /* InitializeConditions for UnitDelay: '<S220>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_e = 1U;

    /* InitializeConditions for UnitDelay: '<S223>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_k = 1U;

    /* InitializeConditions for UnitDelay: '<S225>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_kj = 1U;

    /* InitializeConditions for UnitDelay: '<S385>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_g = 1U;

    /* InitializeConditions for UnitDelay: '<S904>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_f = 1U;

    /* InitializeConditions for UnitDelay: '<S906>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_li = 1U;

    /* InitializeConditions for UnitDelay: '<S908>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_h = 1U;

    /* InitializeConditions for UnitDelay: '<S902>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_kg = 1U;

    /* InitializeConditions for UnitDelay: '<S910>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_nk = 1U;

    /* InitializeConditions for UnitDelay: '<S912>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_a = 1U;

    /* SystemInitialize for Enabled SubSystem: '<S184>/PID_CalDVT_FIX' */
    /* SystemInitialize for Chart: '<S189>/deadzone' */
    ME11_deadzone_Init(&rtb_flag_ko);

    /* End of SystemInitialize for SubSystem: '<S184>/PID_CalDVT_FIX' */

    /* SystemInitialize for Chart: '<S232>/deadzone' */
    ME11_deadzone_a_Init(&rtb_flag_de);

    /* SystemInitialize for Chart: '<S251>/deadzone' */
    ME11_deadzone_a_Init(&rtb_flag_g4);

    /* SystemInitialize for Enabled SubSystem: '<S275>/CalAirCondEvapAimTemp_FIXPID' */
    /* InitializeConditions for UnitDelay: '<S302>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_ar = 1U;

    /* SystemInitialize for Chart: '<S285>/deadzone' */
    ME11_deadzone_Init(&rtb_flag_a);

    /* End of SystemInitialize for SubSystem: '<S275>/CalAirCondEvapAimTemp_FIXPID' */

    /* SystemInitialize for Enabled SubSystem: '<S276>/CalAirCondEvapAimTemp_RightDes' */
    /* InitializeConditions for UnitDelay: '<S314>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_i = 1U;

    /* SystemInitialize for Chart: '<S311>/deadzone' */
    ME11_deadzone_Init(&rtb_flag_d);

    /* End of SystemInitialize for SubSystem: '<S276>/CalAirCondEvapAimTemp_RightDes' */

    /* SystemInitialize for Enabled SubSystem: '<S335>/CalAirCondPTCAimTemp_FIXPID' */
    /* SystemInitialize for Chart: '<S345>/deadzone' */
    ME11_deadzone_a_Init(&rtb_flag_nk);

    /* End of SystemInitialize for SubSystem: '<S335>/CalAirCondPTCAimTemp_FIXPID' */

    /* SystemInitialize for Enabled SubSystem: '<S336>/CalAirCondPTCAimTemp_LeftDes' */
    /* SystemInitialize for Chart: '<S367>/deadzone' */
    ME11_deadzone_a_Init(&rtb_flag_n);

    /* End of SystemInitialize for SubSystem: '<S336>/CalAirCondPTCAimTemp_LeftDes' */

    /* SystemInitialize for Atomic SubSystem: '<S45>/PTC_PID' */
    ME11_PTC_PID_Init();

    /* End of SystemInitialize for SubSystem: '<S45>/PTC_PID' */

    /* SystemInitialize for Enabled SubSystem: '<S41>/CalDrMixDoorDesRatio' */
    /* SystemInitialize for Enabled SubSystem: '<S386>/CalDrMixDoorDesRatio_FIXPID' */
    /* SystemInitialize for Chart: '<S397>/deadzone' */
    ME11_deadzone_a_Init(&rtb_flag_g);

    /* End of SystemInitialize for SubSystem: '<S386>/CalDrMixDoorDesRatio_FIXPID' */
    /* End of SystemInitialize for SubSystem: '<S41>/CalDrMixDoorDesRatio' */

    /* SystemInitialize for Enabled SubSystem: '<S41>/CalPsMixDoorDesRatio' */
    /* SystemInitialize for Enabled SubSystem: '<S387>/CalPsMixDoorDesRatio' */
    /* SystemInitialize for Chart: '<S421>/deadzone' */
    ME11_deadzone_a_Init(&rtb_flag_f);

    /* End of SystemInitialize for SubSystem: '<S387>/CalPsMixDoorDesRatio' */
    /* End of SystemInitialize for SubSystem: '<S41>/CalPsMixDoorDesRatio' */

    /* SystemInitialize for Atomic SubSystem: '<S1074>/Env' */
    /* SystemInitialize for Chart: '<S1093>/Judge' */
    ME11_Judge_Init(&ME11_ARID_DEF.SenSts_a);

    /* End of SystemInitialize for SubSystem: '<S1074>/Env' */

    /* SystemInitialize for Atomic SubSystem: '<S1075>/motor' */
    /* SystemInitialize for Chart: '<S1103>/Judge' */
    ME11_Judge_Init(&ME11_ARID_DEF.SenSts);

    /* End of SystemInitialize for SubSystem: '<S1075>/motor' */

    /* SystemInitialize for Chart: '<S497>/OverDuty1' */
    ME11_OverDuty1_Init(&ME11_ARID_DEF.Sts_b, &ME11_ARID_DEF.ClearFlt_m);

    /* SystemInitialize for Chart: '<S497>/OverDuty2' */
    ME11_OverDuty1_Init(&ME11_ARID_DEF.Sts_a, &ME11_ARID_DEF.ClearFlt_k);

    /* SystemInitialize for Chart: '<S497>/OverDuty3' */
    ME11_OverDuty1_Init(&ME11_ARID_DEF.Sts_e, &ME11_ARID_DEF.ClearFlt_c);

    /* SystemInitialize for Chart: '<S497>/OverDuty4' */
    ME11_OverDuty1_Init(&ME11_ARID_DEF.Sts_d, &ME11_ARID_DEF.ClearFlt_f);

    /* SystemInitialize for Chart: '<S497>/OverDuty5' */
    ME11_OverDuty1_Init(&ME11_ARID_DEF.Sts, &ME11_ARID_DEF.ClearFlt);

    /* SystemInitialize for Chart: '<S526>/Flg3Cal' */
    ME11_Flg3Cal_Init(&rtb_ACTCtl_eCOMPFlg3Cal_c);

    /* SystemInitialize for Chart: '<S527>/Flg3Cal' */
    ME11_Flg3Cal_Init(&rtb_ACTCtl_eCOMPFlg3Cal);

    /* SystemInitialize for Chart: '<S572>/PwrOn' */
    ME11_PwrOn_Init(&rtb_flg_m);

    /* SystemInitialize for Chart: '<S573>/PwrOn' */
    ME11_PwrOn_Init(&rtb_flg_n);

    /* SystemInitialize for Chart: '<S453>/deadzone' */
    ME11_deadzone_p_Init(&rtb_flag_k);

    /* SystemInitialize for Enabled SubSystem: '<S583>/Descending_filter' */
    ME11_Descending_filter_Init(&ME11_ARID_DEF.ARID_DEF_Descending_filter_h);

    /* End of SystemInitialize for SubSystem: '<S583>/Descending_filter' */

    /* SystemInitialize for Enabled SubSystem: '<S586>/Descending_filter' */
    ME11_Descending_filter_Init(&ME11_ARID_DEF.ARID_DEF_Descending_filter_ln);

    /* End of SystemInitialize for SubSystem: '<S586>/Descending_filter' */

    /* SystemInitialize for Chart: '<S642>/Chart' */
    ME11_Chart_Init(&ME11_ARID_DEF.Flag_a);

    /* SystemInitialize for Chart: '<S664>/Chart' */
    ME11_Chart_Init(&ME11_ARID_DEF.Flag_d);

    /* SystemInitialize for Enabled SubSystem: '<S715>/Descending_filter' */
    ME11_Descending_filter_Init(&ME11_ARID_DEF.ARID_DEF_Descending_filter_b);

    /* End of SystemInitialize for SubSystem: '<S715>/Descending_filter' */

    /* SystemInitialize for Enabled SubSystem: '<S716>/Descending_filter' */
    ME11_Descending_filter_Init(&ME11_ARID_DEF.ARID_DEF_Descending_filter_o);

    /* End of SystemInitialize for SubSystem: '<S716>/Descending_filter' */

    /* SystemInitialize for Chart: '<S682>/deadzone' */
    ME11_deadzone_p_Init(&rtb_flag_c);

    /* SystemInitialize for Chart: '<S744>/PwrOn' */
    ME11_PwrOn_Init(&rtb_flg_f);

    /* SystemInitialize for Chart: '<S745>/PwrOn' */
    ME11_PwrOn_Init(&rtb_flg_dg);

    /* SystemInitialize for Enabled SubSystem: '<S783>/Descending_filter' */
    ME11_Descending_filter_Init(&ME11_ARID_DEF.ARID_DEF_Descending_filter_d);

    /* End of SystemInitialize for SubSystem: '<S783>/Descending_filter' */

    /* SystemInitialize for Enabled SubSystem: '<S784>/Descending_filter' */
    ME11_Descending_filter_Init(&ME11_ARID_DEF.ARID_DEF_Descending_filter_ld);

    /* End of SystemInitialize for SubSystem: '<S784>/Descending_filter' */

    /* SystemInitialize for Chart: '<S753>/deadzone' */
    ME11_deadzone_p_Init(&rtb_flag_l);

    /* SystemInitialize for Chart: '<S814>/PwrOn' */
    ME11_PwrOn_Init(&rtb_flg_o);

    /* SystemInitialize for Chart: '<S815>/PwrOn' */
    ME11_PwrOn_Init(&rtb_flg_g);

    /* SystemInitialize for Chart: '<S830>/PwrOn' */
    ME11_PwrOn_Init(&rtb_flg_d);

    /* SystemInitialize for Chart: '<S831>/PwrOn' */
    ME11_PwrOn_Init(&rtb_flg);

    /* SystemInitialize for Enabled SubSystem: '<S858>/Descending_filter' */
    /* InitializeConditions for UnitDelay: '<S871>/FixPt Unit Delay2' */
    ME11_ARID_DEF.FixPtUnitDelay2_DSTATE_p = 1U;

    /* End of SystemInitialize for SubSystem: '<S858>/Descending_filter' */

    /* SystemInitialize for Enabled SubSystem: '<S861>/Descending_filter' */
    ME11_Descending_filter_Init(&ME11_ARID_DEF.ARID_DEF_Descending_filter_l);

    /* End of SystemInitialize for SubSystem: '<S861>/Descending_filter' */

    /* SystemInitialize for Enabled SubSystem: '<S862>/Descending_filter' */
    ME11_Descending_filter_Init(&ME11_ARID_DEF.ARID_DEF_Descending_filter);

    /* End of SystemInitialize for SubSystem: '<S862>/Descending_filter' */

    /* SystemInitialize for Chart: '<S824>/deadzone' */
    ME11_deadzone_p_Init(&rtb_flag);

    /* SystemInitialize for Chart: '<S943>/ Abnormal_Over_temperatura_via _software_monitoring' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_nq);

    /* SystemInitialize for Chart: '<S943>/ Outlet_Temp_High' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_nf);

    /* SystemInitialize for Chart: '<S943>/Abnormal_Over_temperatura_via _hardware_monitoring' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_oel);

    /* SystemInitialize for Chart: '<S943>/Core_Temp_High' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_oe);

    /* SystemInitialize for Chart: '<S943>/Core_Temp_Sensor_Fault' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_h);

    /* SystemInitialize for Chart: '<S943>/Current_Sensor_Fault' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_li);

    /* SystemInitialize for Chart: '<S943>/External_Com_Fault' */
    ME11_External_Com_Fault_Init(&ME11_ARID_DEF.ErrSts_d);

    /* SystemInitialize for Chart: '<S943>/HVIL_Fault' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_n);

    /* SystemInitialize for Chart: '<S943>/HV_Over_Voltage' */
    ME11_External_Com_Fault_Init(&ME11_ARID_DEF.ErrSts_cu);

    /* SystemInitialize for Chart: '<S943>/HV_Under_Voltage' */
    ME11_External_Com_Fault_Init(&ME11_ARID_DEF.ErrSts_b);

    /* SystemInitialize for Chart: '<S943>/Inlet_Temp_High' */
    ME11_External_Com_Fault_Init(&ME11_ARID_DEF.ErrSts_l);

    /* SystemInitialize for Chart: '<S943>/Inlet_Temp_Sensor_Fault' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_oi);

    /* SystemInitialize for Chart: '<S943>/Internal_Com_Fault' */
    ME11_External_Com_Fault_Init(&ME11_ARID_DEF.ErrSts_c);

    /* SystemInitialize for Chart: '<S943>/Internal_Voltage_Fault' */
    ME11_External_Com_Fault_Init(&ME11_ARID_DEF.ErrSts_iw);

    /* SystemInitialize for Chart: '<S943>/LV_Over_Voltage' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_a);

    /* SystemInitialize for Chart: '<S943>/LV_Under_Voltage' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_e5);

    /* SystemInitialize for Chart: '<S943>/Outlet_Temp_Sensor_Fault' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_e);

    /* SystemInitialize for Chart: '<S943>/PCB_Temp_High' */
    ME11_External_Com_Fault_Init(&ME11_ARID_DEF.ErrSts_i);

    /* SystemInitialize for Chart: '<S943>/PCB_Temp_Sensor_Fault' */
    ME11_Abnormal_Over_temperatura_via_software_monitoring_Init
      (&ME11_ARID_DEF.ErrSts_m);

    /* SystemInitialize for Chart: '<S943>/Power_Target_Fault' */
    ME11_External_Com_Fault_Init(&ME11_ARID_DEF.ErrSts);

    /* SystemInitialize for Chart: '<S1022>/AcPMPFaultJudge' */
    ME11_AcPMPFaultJudge_Init(&ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_c);

    /* SystemInitialize for Chart: '<S1024>/AcPMPFaultJudge' */
    ME11_AcPMPFaultJudge_Init(&ME11_ARID_DEF.ACTCtl_bAcPMPFaultFlg_e);

    /* SystemInitialize for Enabled SubSystem: '<S2>/HMI' */
    /* InitializeConditions for Delay: '<S1170>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_cf = 2U;

    /* InitializeConditions for Delay: '<S1115>/Delay' */
    ME11_ARID_DEF.Delay_DSTATE_f = 2U;

    /* SystemInitialize for Chart: '<S1119>/SetTemp' */
    ME11_ARID_DEF.sfEvent = -1;

    /* End of SystemInitialize for SubSystem: '<S2>/HMI' */

    /* SystemInitialize for Atomic SubSystem: '<S2>/IODriver' */
    ME11_TMSIODriverFunc_Init();

    /* End of SystemInitialize for SubSystem: '<S2>/IODriver' */

    /* SystemInitialize for Chart: '<S1333>/Delay' */
    ME11_Delay_j_Init(&ME11_ARID_DEF.B_kg);

    /* SystemInitialize for Chart: '<S1373>/Chart' */
    ME11_Delay_j_Init(&ME11_ARID_DEF.B_ms);

    /* SystemInitialize for Chart: '<S1382>/Chart' */
    ME11_Delay_j_Init(&ME11_ARID_DEF.B_cv);

    /* SystemInitialize for Chart: '<S1320>/Chart' */
    ME11_Chart_c_Init(&rtb_SOMCtl_bBatLTRFlg_b);

    /* SystemInitialize for Chart: '<S1324>/Chart' */
    ME11_Chart_c_Init(&rtb_SOMCtl_bBatLTRFlg_k);

    /* SystemInitialize for Enabled SubSystem: '<S1325>/B1_B31_AC' */
    /* SystemInitialize for Chart: '<S1574>/Chart' */
    ME11_Chart_k_Init(&ME11_ARID_DEF.B_m);

    /* End of SystemInitialize for SubSystem: '<S1325>/B1_B31_AC' */

    /* SystemInitialize for Enabled SubSystem: '<S1325>/B1_B31_PT' */
    /* SystemInitialize for Chart: '<S1575>/Chart' */
    ME11_Chart_k_Init(&ME11_ARID_DEF.B_h);

    /* End of SystemInitialize for SubSystem: '<S1325>/B1_B31_PT' */

    /* SystemInitialize for Chart: '<S1576>/Chart1' */
    ME11_Delay_j_Init(&ME11_ARID_DEF.B_n);

    /* SystemInitialize for Chart: '<S1325>/Chart' */
    ME11_Chart_e_Init(&rtb_SOMCtl_bBatHeatB3tB1Flg_e);

    /* SystemInitialize for Chart: '<S1326>/Chart' */
    ME11_Chart_e_Init(&rtb_SOMCtl_bBatHeatB3tB1Flg);

    /* SystemInitialize for Enabled SubSystem: '<S1326>/Enter_AC' */
    /* SystemInitialize for Chart: '<S1610>/Chart' */
    ME11_Chart_k_Init(&ME11_ARID_DEF.B_e);

    /* End of SystemInitialize for SubSystem: '<S1326>/Enter_AC' */

    /* SystemInitialize for Enabled SubSystem: '<S1326>/Enter_PT' */
    /* SystemInitialize for Chart: '<S1611>/Chart' */
    ME11_Chart_k_Init(&ME11_ARID_DEF.B_p);

    /* End of SystemInitialize for SubSystem: '<S1326>/Enter_PT' */

    /* SystemInitialize for Chart: '<S1612>/Chart1' */
    ME11_Delay_j_Init(&ME11_ARID_DEF.B_k);

    /* SystemInitialize for Chart: '<S1612>/Chart2' */
    ME11_Delay_j_Init(&ME11_ARID_DEF.B_c);

    /* SystemInitialize for Chart: '<S1612>/Chart3' */
    ME11_Delay_j_Init(&ME11_ARID_DEF.B_o);

    /* SystemInitialize for Chart: '<S1612>/Chart4' */
    ME11_Delay_j_Init(&ME11_ARID_DEF.B_f);

    /* SystemInitialize for Chart: '<S1644>/Chart' */
    ME11_Delay_j_Init(&ME11_ARID_DEF.B_b);

    /* SystemInitialize for Atomic SubSystem: '<S2>/Sensor' */
    ME11_TMSADCSampleFunc_Init();

    /* End of SystemInitialize for SubSystem: '<S2>/Sensor' */
    /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' */

    /* Outputs for Atomic SubSystem: '<Root>/Init' */
    /* CCaller: '<S3>/C Caller' incorporates:
     *  Constant: '<S3>/Constant'
     */
    NvmTmsBlockReadData(&rtb_CCaller[0], 12U);

    /* Product: '<S3>/Divide1' incorporates:
     *  Constant: '<S3>/Constant2'
     *  MultiPortSwitch: '<S3>/Index Vector1'
     */
    rtb_Divide1_ae = rtb_CCaller[1];

    /* DataTypeConversion: '<S3>/Data Type Conversion1' */
    ACNvm_bACAutoSts = (rtb_Divide1_ae != 0);

    /* DataStoreWrite: '<S3>/Data Store Write' */
    ME11_ARID_DEF.EERead_bACAutoSts = ACNvm_bACAutoSts;

    /* Product: '<S3>/Divide1' incorporates:
     *  Constant: '<S3>/Constant1'
     *  MultiPortSwitch: '<S3>/Index Vector'
     */
    rtb_Divide1_ae = rtb_CCaller[0];

    /* DataTypeConversion: '<S3>/Data Type Conversion' */
    ACNvm_bACOnOff = (rtb_Divide1_ae != 0);

    /* DataStoreWrite: '<S3>/Data Store Write1' */
    ME11_ARID_DEF.EERead_bACOnOff = ACNvm_bACOnOff;

    /* MultiPortSwitch: '<S3>/Index Vector10' incorporates:
     *  Constant: '<S3>/Constant11'
     */
    ACNvm_eCainRecDoor = rtb_CCaller[10];

    /* DataStoreWrite: '<S3>/Data Store Write10' */
    ME11_ARID_DEF.EERead_CabinRecDoor = ACNvm_eCainRecDoor;

    /* MultiPortSwitch: '<S3>/Index Vector11' incorporates:
     *  Constant: '<S3>/Constant12'
     */
    ACNvm_eCainModeDoor = rtb_CCaller[11];

    /* DataStoreWrite: '<S3>/Data Store Write11' */
    ME11_ARID_DEF.EERead_CabinModeDoor = ACNvm_eCainModeDoor;

    /* Product: '<S3>/Divide1' incorporates:
     *  Constant: '<S3>/Constant4'
     *  MultiPortSwitch: '<S3>/Index Vector3'
     */
    rtb_Divide1_ae = rtb_CCaller[3];

    /* Sum: '<S3>/Add' incorporates:
     *  Constant: '<S3>/Constant13'
     *  Constant: '<S3>/Constant14'
     *  Product: '<S3>/Divide'
     */
    ACNvm_sACEnvTemp = (float32)(uint8)((float64)rtb_Divide1_ae / 2.0) - 40.0F;

    /* DataStoreWrite: '<S3>/Data Store Write2' */
    ME11_ARID_DEF.EERead_AmbienceTemp = ACNvm_sACEnvTemp;

    /* MultiPortSwitch: '<S3>/Index Vector2' incorporates:
     *  Constant: '<S3>/Constant3'
     */
    ACNvm_eCabinSetTemp = rtb_CCaller[2];

    /* DataStoreWrite: '<S3>/Data Store Write3' */
    ME11_ARID_DEF.EERead_CabinSetTemp = ACNvm_eCabinSetTemp;

    /* MultiPortSwitch: '<S3>/Index Vector4' incorporates:
     *  Constant: '<S3>/Constant5'
     */
    ACNvm_eACCabinMode = rtb_CCaller[4];

    /* DataStoreWrite: '<S3>/Data Store Write4' */
    ME11_ARID_DEF.EERead_CabinMode = ACNvm_eACCabinMode;

    /* MultiPortSwitch: '<S3>/Index Vector5' incorporates:
     *  Constant: '<S3>/Constant6'
     */
    ACNvm_eCabinBlower = rtb_CCaller[5];

    /* DataStoreWrite: '<S3>/Data Store Write5' */
    ME11_ARID_DEF.EERead_CabinBlower = ACNvm_eCabinBlower;

    /* MultiPortSwitch: '<S3>/Index Vector6' incorporates:
     *  Constant: '<S3>/Constant7'
     */
    rtb_Divide1_ae = rtb_CCaller[6];

    /* Sum: '<S3>/Add1' incorporates:
     *  Constant: '<S3>/Constant15'
     *  Constant: '<S3>/Constant16'
     *  Product: '<S3>/Divide1'
     */
    ACNvm_sPCUInletTemp = (float32)(uint8)((float64)rtb_Divide1_ae / 2.0) -
      40.0F;

    /* DataStoreWrite: '<S3>/Data Store Write6' */
    ME11_ARID_DEF.EERead_PCUInletTemp = ACNvm_sPCUInletTemp;

    /* MultiPortSwitch: '<S3>/Index Vector7' incorporates:
     *  Constant: '<S3>/Constant8'
     *  DataStoreWrite: '<S3>/Data Store Write7'
     */
    ME11_ARID_DEF.EERead_TimeHour = rtb_CCaller[7];

    /* MultiPortSwitch: '<S3>/Index Vector8' incorporates:
     *  Constant: '<S3>/Constant9'
     *  DataStoreWrite: '<S3>/Data Store Write8'
     */
    ME11_ARID_DEF.EERead_TimeMin = rtb_CCaller[8];

    /* MultiPortSwitch: '<S3>/Index Vector9' incorporates:
     *  Constant: '<S3>/Constant10'
     *  DataStoreWrite: '<S3>/Data Store Write9'
     */
    ME11_ARID_DEF.EERead_TimeDay = rtb_CCaller[9];

    /* CCaller: '<S1>/C Caller' incorporates:
     *  Constant: '<S1>/Constant3'
     */
    set_PwrFanAndPump(0U);

    /* CCaller: '<S1>/C Caller1' incorporates:
     *  Constant: '<S1>/Constant2'
     */
    set_PwrHVPart(0U);

    /* CCaller: '<S1>/C Caller2' incorporates:
     *  Constant: '<S1>/Constant1'
     */
    SetHw_PwrBlower(0U);

    /* CCaller: '<S1>/C Caller5' incorporates:
     *  Constant: '<S1>/Constant'
     */
    set_PwrHVPart(0U);

    /* CCaller: '<S1>/C Caller6' incorporates:
     *  Constant: '<S1>/Constant4'
     */
    set_PwrACPump(0U);

    /* CCaller: '<S1>/C Caller7' incorporates:
     *  Constant: '<S1>/Constant5'
     */
    set_PwrFanCabin(0U);

    /* CCaller: '<S1>/C Caller8' incorporates:
     *  Constant: '<S1>/Constant6'
     */
    set_PwrSensor(0U);

    /* End of Outputs for SubSystem: '<Root>/Init' */

    /* ConstCode for RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' incorporates:
     *  SubSystem: '<Root>/ME11_TMS'
     */
    /* ConstCode for Constant: '<S2>/Constant2' */
    GlbDa_uBat = 1200U;

    /* ConstCode for Constant: '<S8>/Constant1' */
    TMS_VersionNumber = 22U;

    /* End of ConstCode for RootInportFunctionCallGenerator generated from: '<Root>/TMS_Task' */
  }
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
