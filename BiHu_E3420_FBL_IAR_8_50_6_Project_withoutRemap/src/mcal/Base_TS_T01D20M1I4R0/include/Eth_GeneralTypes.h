/**
 *   @file    Eth_GeneralTypes.h
 *
 *   @brief   Eth (Eth Modulation) file.
 *   @details
 *            Compatible to "Specification of CDD Driver, CP, 4.3.1"
 */

/********************************************************
 *        Copyright(c) 2020    Semidrive                *
 *        All rights reserved.                          *
 ********************************************************/

#ifndef ETH_GENERALTYPES_H
#define ETH_GENERALTYPES_H

#include "arch.h"
#include "cdefs.h"
#include "Std_Types.h"


typedef enum
{
    /* Controller Disable */
    ETH_MODE_DOWN = 0,
    /* Controller Enable */
    ETH_MODE_ACTIVE,
} Eth_ModeType;

typedef enum
{
    /* Driver is not yet configured */
    ETH_STATE_UNINIT = 0,
    /* Driver is configured*/
    ETH_STATE_INIT,
} Eth_StateType;

/* */
typedef uint16 Eth_FrameType;
/* */
typedef uint8 Eth_DataType;
/* */
typedef uint32 Eth_BufIdxType;

typedef enum
{
    /* Ethernet frame has been received, no further frames available */
    ETH_RECEIVED = 0,
    /* Ethernet frame has not been received, no further frames available */
    ETH_NOT_RECEIVED,
    /* Ethernet frame has been received, more frames are available */
    ETH_RECEIVED_MORE_DATA_AVAILABLE,
} Eth_RxStatusType;

typedef enum
{
    /* add the MAC address to the filter, meaning allow reception */
    ETH_ADD_TO_FILTER = 0,
    /* remove the MAC address from the filter, meaning reception is blocked in the lower layer */
    ETH_REMOVE_FROM_FILTER,

} Eth_FilterActionType;

typedef enum
{
    ETH_VALID = 0,
    ETH_INVALID,
    ETH_UNCERTAIN,
} Eth_TimeStampQualType;

typedef struct
{
    uint32 nanoseconds;
    uint32 seconds;
    uint16 secondsHi;
} Eth_TimeStampType;

typedef struct
{
    /* time difference */
    Eth_TimeStampType diff;
    /* Positive (True) / negative (False) time */
    boolean sign;
} Eth_TimeIntDiffType;

typedef struct
{
    /* IngressTimeStampSync2 - IngressTimeStampSync1 */
    Eth_TimeIntDiffType IngressTimeStampDelta;
    /* OriginTimeStampSync2[FUP2] - OriginTimeStampSync1[FUP1] */
    Eth_TimeIntDiffType OriginTimeStampDelta;
} Eth_RateRatioType;

typedef struct
{
    /* Specifies the VLAN address  0..65535 */
    uint16 VlanId;
    /*
        Hash value that is generated by the Ethernet switch according the given MacAddr.
        If the HashValue is notavailable the value shall be set to 0b1111xxxxxxxxxxxx == 0xFxxx
        (invalid value). If the HashValue is available the value shall be set to 0b0000xxxxxxxxxxxx== 0x0xxx (valid value)
    */
    uint16 HashValue;
    /* AMC address */
    uint8 MacAddr[6];
    /* Port of the switch 0..255 */
    uint8 SwitchPort;
} Eth_MacVlanType;

typedef struct
{
    /* dropped packets due to buffer overrun */
    uint32 DropPktBufOverrun;
    /* dropped packets due to CRC errors */
    uint32 DropPktCrc;
    /*
        number of undersize packets which were less than 64 octets long (excluding framing bits,
        but including FCS octets) and were otherwise well formed. (see IETF RFC 1757)
    */
    uint32 UndersizePkt;
    /*
        number of oversize packets which are longer than 1518 octets (excluding
        framing bits, but including FCS octets) and were otherwise well formed. (see IETF RFC 1757)
    */
    uint32 OversizePkt;
    /*
        number of alignment errors, i.e. packets which are received and are not an integral number of
        octets in length and do not pass the CRC.
    */
    uint32 AlgnmtErr;
    /* SQE test error according to IETF RFC1643 dot3StatsSQETestErrors */
    uint32 SqeTestErr;
    /*
        The number of inbound packets which were chosen to be discarded even though no errors
        had been detected to prevent their being deliverable to a higher-layer protocol.
        One possible reason for discarding such a packet could be to free up buffer space. (see IETF RFC 2233 ifInDiscards)
    */
    uint32 DiscInbdPkt;
    /* total number of erroneous inbound packets */
    uint32 ErrInbdPkt;
    /*
        The number of outbound packets which were chosen to be discarded even though no errors had been detected to
        prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.
        (see IETF RFC 2233 ifOutDiscards)
    */
    uint32 DiscOtbdPkt;
    /* total number of erroneous outbound packets */
    uint32 ErrOtbdPkt;
    /*
        Single collision frames: A count of successfully transmitted frames on a particular interface for which
        transmission is inhibited by exactly one collision. (see IETF RFC1643 dot3StatsSingleCollisionFrames)
    */
    uint32 SnglCollPkt;
    /*
        Multiple collision frames: A count of successfully transmitted frames on a particular interface for which transmission
        is inhibited by more than one collision. (see IETF RFC1643 dot3StatsMultipleCollisionFrames)
        */
    uint32 MultCollPkt;
    /*
        Number of deferred transmission: A count of frames for which the first transmission attempt on a particular
        interface is delayed because the medium is busy. (see IETF RFC1643 dot3StatsDeferredTransmissions)
    */
    uint32 DfrdPkt;
    /*
        Number of late collisions: The number of times that a collision is detected on a particular interface later than
        512 bit-times into the transmission of a packet.(see IETF RFC1643 dot3StatsLateCollisions)
    */
    uint32 LatCollPkt;
    /* hardware dependent counter value */
    uint32 HwDepCtr0;
    uint32 HwDepCtr1;
    uint32 HwDepCtr2;
    uint32 HwDepCtr3;
} __attribute__((aligned(CACHE_LINE))) Eth_CounterType;

typedef struct
{
    /*
        The total number of events in which packets were dropped by the probe
        due to lack of resources. Also described in IETF RFC 2819 MIB etherStatsDropEvents.
    */
    uint32 RxStatsDropEvents;
    /*
        The total number of octets of data (including those in bad packets)
        received on the network (excluding framing bits but including FCS octets). Also described in IETF
        RFC 2819 MIB etherStatsOctets.
    */
    uint32 RxStatsOctets;
    /*
        The total number of packets (including bad packets, broadcast packets, and multicast packets)
        received. Also described in IETF RFC 2819 MIB etherStatsPkts
    */
    uint32 RxStatsPkts;
    /*
        The total number of good packets received that were directed to the
        broadcast address. Also described in IETF RFC 2819 MIB etherStatsBroadcastPkts
    */
    uint32 RxStatsBroadcastPkts;
    /*
        The total number of good packets received that were directed to a
        multicast address. Also described in IETF RFC 2819 MIB etherStatsMulticastPkts.
    */
    uint32 RxStatsMulticastPkts;
    /*
        The total number of packets received that had a length of
        bertween 64 and 1518 octets that had either a bad Frame Check Sequence (FCS) with an integral
        number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error).
        Also described in IETF RFC 2819 MIB etherStatsCRCAlignErrors
    */
    uint32 RxStatsCrcAlignErrors;
    /*
        The total number of packets received that were less than 64 octets long (excluding framing bits,
        but including FCS octets) and were otherwise well formed. Also described in IETF RFC 2819 MIB
        etherStatsUndersizePkts.
    */
    uint32 RxStatsUndersizePkts;
    /*
        The total number of packets received that were longer than
        1518 octets (excluding framing bits,but including FCS octets) and were
        otherwise well formed. Also described in IETF RFC 2819 MIB etherStatsOversizePkts
    */
    uint32 RxStatsOversizePkts;
    /*
        The total number of packets received that were less than 64
        octets in length (excluding framing bits but including FCS octets) and
        had either a bad Frame Check Sequence (FCS) with an integral
        number of octets (FCS Error) or a bad FCS with a non-integral
        number of octets (Alignment Error). Also described in IETF RFC 2819 MIB etherStatsFragments.
    */
    uint32 RxStatsFragments;
    /*
        The total number of packets received that were less than 64
        octets in length (excluding framing bits but including FCS octets) and
        had either a bad Frame Check Sequence (FCS) with an integral
        number of octets (FCS Error) or a bad FCS with a non-integral
        number of octets (Alignment Error). Also described in IETF RFC 2819 MIB etherStatsFragments.
    */
    uint32 RxStatsJabbers;
    /*
        The best estimate of the total number of collisions on this
        Ethernet segment. Also described in IETF RFC 2819 MIB etherStatsCollisions
    */
    uint32 RxStatsCollisions;
    /*
        The total number of packets (including bad packets) received
        that were 64 octets in length. Also described in IETF RFC 2819 MIB etherStatsPkts64Octets
    */
    uint32 RxStatsPkts64Octets;
    /*
        The total number of packets (including bad packets) received
        that were between 65 and 127 octets in length. Also described in
        IETF RFC 2819 MIB etherStatsPkts65to127Octets
    */
    uint32 RxStatsPkts65to127Octets;
    /*
        The total number of packets (including bad packets) received
        that were between 128 and 255 octets in length. Also described in
        IETF RFC 2819 MIB etherStatsPkts128to255Octets
    */
    uint32 RxStatsPkts128to255Octets;
    /*
        The total number of packets (including bad packets) received
        that were between 256 and 511 octets in length. Also described in
        IETF RFC 2819 MIB etherStatsPkts256to511Octets
    */
    uint32 RxStatsPkts256to511Octets;
    /*
        The total number of packets (including bad packets) received
        that were between 512 and 1023 octets in length. Also described in
        IETF RFC 2819 MIB etherStatsPkts512to1023Octets
    */
    uint32 RxStatsPkts512to1023Octets;
    /*
        The total number of packets (including bad packets) received
        that were between 1024 and 1518 octets in length. Also described in
        IETF RFC 2819 MIB etherStatsPkts1024to1518Octets
    */
    uint32 RxStatsPkts1024to1518Octets;
    /*
        The number of subnetwork-unicast packets delivered to a higher-layer
        protocol. Also described in IETF RFC1213 MIB ifInUcastPkts
    */
    uint32 RxUnicastFrames;

} __attribute__((aligned(CACHE_LINE))) Eth_RxStatsType;

typedef struct
{
    /*
        The total number of octets transmitted out of the interface, including framing
        characters. Also described in IETF RFC1213 MIB ifOutOctets.
    */
    uint32 TxNumberOfOctets;
    /*
        The total number of packets that higher-level protocols requested be transmitted
        to a non-unicast (i.e., a subnetwork-broadcast or subnetwork-multicast)
        address, including those that were discarded or not sent. Also described in IETF RFC1213 MIB ifOutNUcastPkts
    */
    uint32 TxNUcastPkts;
    /*
        The total number of packets that higher-level protocols requested be transmitted
        to a subnetwork-unicast address,including those that were discarded or
        not sent. Also described in IETF RFC1213 MIB ifOutUcastPkts.
    */
    uint32 TxUniCastPkts;

    uint32 Reserved[5];

} __attribute__((aligned(CACHE_LINE))) Eth_TxStatsType;

typedef struct
{
    /*
        The number of outbound packets which were chosen to be discarded
        even though no errors had been detected to prevent their being
        transmitted. One possible reason for discarding such a packet could be to
        free up buffer space. Also described in IETF RFC1213 MIB ifOutDiscards
    */
    uint32 TxDroppedNoErrorPkts;
    /* transmitted because of errors. Also described in IETF RFC1213 MIB ifOutErrors */
    uint32 TxDroppedErrorPkts;
    /*
        A count of frames for which the first transmission attempt on a particular
        interface is delayed because the medium is busy. The count
        represented by an instance of this object does not include frames
        involved in collisions. Also described in IETF RFC1643 MIB dot3StatsDeferredTransmissions
    */
    uint32 TxDeferredTrans;
    /*
        A count of successfully transmitted frames on a particular interface for
        which transmission is inhibited by exactly one collision. A frame that is
        counted by an instance of this object is also counted by the corresponding
        instance of either the TxUniCastPkts and TxNUcastPkts and is not counted
        by the corresponding instance of the TxMultipleCollision object. Also
        described in IETF RFC1643 MIB dot3StatsSingleCollisionFrames
    */
    uint32 TxSingleCollision;
    /*
        A count of successfully transmitted frames on a particular interface for
        which transmission is inhibited by more than one collision. A frame that
        is counted by an instance of this object is also counted by the corresponding
        instance of either the TxUniCastPkts and TxNUcastPkts and is not counted
        by the corresponding instance of the TxSingleCollision object. Also
        described in IETF RFC1643 MIB dot3StatsMultipleCollisionFrames.
    */
    uint32 TxMultipleCollision;
    /*
        The number of times that a collision is detected on a particular interface later than 512 bit-times into the
        transmission of a packet. Five hundred and twelve bit-times corresponds to 51.2 microseconds on a 10 Mbit/s
        system. A (late) collision included in a count represented by an instance of this object is also considered
        as a (generic) collision for purposes of other collision-related statistics. Also described in IETF RFC1643
        MIB dot3StatsLateCollisions
    */
    uint32 TxLateCollision;
    /*
        A count of frames for which transmission on a particular interface  fails due to excessive collisions. Also
        described in IETF RFC1643 MIB dot3StatsExcessiveCollisions
    */
    uint32 TxExcessiveCollison;

    uint32 Reserved;

} __attribute__((aligned(CACHE_LINE))) Eth_TxErrorCounterValuesType;

typedef enum {
    /* 10 MBit/s */
    TRCV_SPEED_10=0,
    /* 100 MBit/s */
    TRCV_SPEED_100,
    /* 1000 MBit/s */
    TRCV_SPEED_1000,
}EthTrcv_SpeedType;


typedef enum {
    /* Transceiver disabled */
    ETHTRCV_MODE_DOWN=0x00,
    /* transceiver enabled */
    ETHTRCV_MODE_ACTIVE
}EthTrcv_ModeType;

typedef enum {
    /* No physical Ethernet connection established */
    ETHTRCV_LINK_STATE_DOWN = 0x00,
    /* Physical Ethernet connection established */
    ETHTRCV_LINK_STATE_ACTIVE
}EthTrcv_LinkStateType;

typedef enum {
    /* Driver is not yet configured */
    ETHTRCV_STATE_UNINIT=0x00,
    /* 0x01  Driver is configured */
    ETHTRCV_STATE_INIT

}EthTrcv_StateType;


typedef enum {
    /* 10MBIT Ethernet connection */
    ETHTRCV_BAUD_RATE_10MBIT=0x00,
    /* 0x01 100MBIT Ethernet connection */
    ETHTRCV_BAUD_RATE_100MBIT,
    /* 0x02 1000MBIT Ethernet connection */
    ETHTRCV_BAUD_RATE_1000MBIT
}EthTrcv_BaudRateType;

typedef enum {
    /* Half duplex Ethernet connection */
    ETHTRCV_DUPLEX_MODE_HALF=0x00,
    /*  0x01 Full duplex Ethernet connection */
    ETHTRCV_DUPLEX_MODE_FULL
}EthTrcv_DuplexModeType;

typedef enum {
    /* Transceiver wake up disabled */
    ETHTRCV_WUM_DISABLE=0x00,
    /* 0x01 Transceiver wake up enabled */
    ETHTRCV_WUM_ENABLE,
    /* 0x02 Transceiver wake up reason cleared. */
    ETHTRCV_WUM_CLEAR
}EthTrcv_WakeupModeType;

typedef enum {
    /* No wake up reason detected. */
    ETHTRCV_WUR_NONE=0x00,
    /* 0x01 General wake up detected, no distinct reason supported by hardware. */
    ETHTRCV_WUR_GENERAL,
    /* 0x02 Bus wake up detected. Available if supported by hardware. */
    ETHTRCV_WUR_BUS,
    /* 0x03 Internal wake up detected. Available if supported by hardware. */
    ETHTRCV_WUR_INTERNAL,
    /* 0x04 Reset wake up detected. Available if supported by hardware. */
    ETHTRCV_WUR_RESET,
    /* 0x05 Power on wake up detected. Available if supported by hardware. */
    ETHTRCV_WUR_POWER_ON,
    /* 0x06 Pin wake up detected. Available if supported by hardware. */
    ETHTRCV_WUR_PIN,
    /* 0x07 System error wake up detected. Available if supported by hardware. */
    ETHTRCV_WUR_SYSERR
}EthTrcv_WakeupReasonType;

typedef enum {
    /* normal operation */
    ETHTRCV_PHYTESTMODE_NONE=0x00,
    /* 0x01 test transmitter droop */
    ETHTRCV_PHYTESTMODE_1,
    /* 0x02 test master timing jitter */
    ETHTRCV_PHYTESTMODE_2,
    /* 0x03 test slave timing jitter */
    ETHTRCV_PHYTESTMODE_3,
    /* 0x04 test transmitter distortion */
    ETHTRCV_PHYTESTMODE_4,
    /* 0x05 test power spectral density (PSD) mask */
    ETHTRCV_PHYTESTMODE_5
}EthTrcv_PhyTestModeType;

typedef enum {
    /* 0x00  normal operation */
    ETHTRCV_PHYLOOPBACK_NONE = 0,
    /* 0x01  internal loopback */
    ETHTRCV_PHYLOOPBACK_INTERNAL,
    /* external loopback */
    ETHTRCV_PHYLOOPBACK_EXTERNAL,
    /* remote loopback */
    ETHTRCV_PHYLOOPBACK_REMOTE
}EthTrcv_PhyLoopbackModeType;

typedef enum {
    /* normal operation */
    ETHTRCV_PHYTXMODE_NORMAL=0x00,
    /* 0x01 transmitter disabled */
    ETHTRCV_PHYTXMODE_TX_OFF,
    /* 0x02 scrambler disabled */
    ETHTRCV_PHYTXMODE_SCRAMBLER_OFF
}EthTrcv_PhyTxModeType;

typedef enum {
    /* Cable diagnostic ok */
    ETHTRCV_CABLEDIAG_OK=0x00,
    /* 0x01 Cable diagnostic failed */
    ETHTRCV_CABLEDIAG_ERROR,
    /* 0x02 Short circuit detected */
    ETHTRCV_CABLEDIAG_SHORT,
    /* 0x03 Open circuit detected */
    ETHTRCV_CABLEDIAG_OPEN,
    /* 0x04 cable diagnostic is still running */
    ETHTRCV_CABLEDIAG_PENDING,
    /*
    0x05 cable diagnostics has detected
    wrong polarity of the "Ethernet physical+" or "Ethernet physical-" lines
    */
    ETHTRCV_CABLEDIAG_WRONG_POLARITY

}EthTrcv_CableDiagResultType;




typedef enum {
    /* Automatic Negotiation */
    TRCV_CONN_NEG_AUTO=0,
    /* Master */
    TRCV_CONN_NEG_MASTER,
    /* Slave */
    TRCV_CONN_NEG_SLAVE
}EthTrcv_ConnNegModeType;

typedef enum {
    /*  physical layer interface 1000BASE-T (1Gbit/s, 4 pairs). Used for consumer electronic. */
    TRCV_PHYS_LAYER_TYPE_1000BASE_T=0,
    /* physical layer interface 1000BASE-T1 (1Gbit/s, 1 pair). Used for automotive. */
    TRCV_PHYS_LAYER_TYPE_1000BASE_T1,
    /* physical layer interface 100BASE-T1 (100Mbit/s, 1 pair). Used for automotive. */
    TRCV_PHYS_LAYER_TYPE_100BASE_T1,
    /* physical layer interface 100BASE-TX (100Mbit/s, 2 pairs). Used for consumer electronic. */
    TRCV_PHYS_LAYER_TYPE_100BASE_TX,
}PhysLayerType;


typedef enum {
    /* Driver is not yet configured */
    ETHSWT_STATE_UNINIT=0x00,
    /* 0x01  Driver is configured */
    ETHSWT_STATE_INIT,

    ETHSWT_STATE_ACTIVE,

}EthSwt_StateType;

typedef enum {
    ETHSWT_MACLEARNING_HWDISABLED,

    ETHSWT_MACLEARNING_HWENABLED,

    ETHSWT_MACLEARNING_SWENABLED

}EthSwt_MacLearningType;

typedef struct {
    uint8  SwitchIdx;
    uint8  SwitchPortIdx;
}EthSwt_MgmtInfoType;


typedef struct {
    uint8   srcMacAddrFilter[6];
    uint8   dstMacAddrFilter[6];
    uint16  VlanIdFilter;
    uint8   MirroringPacketDivider;
    uint8   MirroringMode;
    uint32  TrafficDirectionIngressBitMask ;
    uint32  TrafficDirectionEgressBitMask ;
    uint8   CapturePortIdx;
    uint8   DoubleTaggingVlanId;
}EthSwt_PortMirrorCfgType;


typedef enum {
    PORT_MIRRORING_DISABLED=0x00,
    PORT_MIRRORING_ENABLED,
}EthSwt_PortMirrorStateType;


typedef enum {
    ETHSWT_PORT_MIRRORING_CONFIGURATION_NOT_SUPPORTED=0x02,
}EthSwt_ReturnType;


typedef enum {
    ETHSWT_MGMT_OBJ_UNUSED=0x00,
    ETHSWT_MGMT_OBJ_OWNED_BY_ETHSWT,
    ETHSWT_MGMT_OBJ_OWNED_BY_UPPER_LAYER,
}EthSwt_MgmtOwner;

typedef struct {

    Std_ReturnType IngressTimestampValid;
    Std_ReturnType EgressTimestampValid;
    Std_ReturnType MgmtInfoValid;
}EthSwt_MgmtObjectValidType;

typedef struct {
    EthSwt_MgmtObjectValidType Validation;
    Eth_TimeStampType  IngressTimestamp;
    Eth_TimeStampType  EgressTimestamp;
    EthSwt_MgmtInfoType  MgmtInfo;
    EthSwt_MgmtOwner  Ownership ;
}EthSwt_Mgmt_ObjectType;




#endif
